// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DAS20200116_H_
#define ALIBABACLOUD_DAS20200116_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_DAS20200116 {
class DataResultValue : public Darabonba::Model {
public:
  shared_ptr<string> sqlId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> count{};

  DataResultValue() {}

  explicit DataResultValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sqlId) {
      res["sqlId"] = boost::any(*sqlId);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sqlId") != m.end() && !m["sqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["sqlId"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~DataResultValue() = default;
};
class DataSessionStatClientStatsValue : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<long> totalCount{};

  DataSessionStatClientStatsValue() {}

  explicit DataSessionStatClientStatsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DataSessionStatClientStatsValue() = default;
};
class DataSessionStatDbStatsValue : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<long> totalCount{};

  DataSessionStatDbStatsValue() {}

  explicit DataSessionStatDbStatsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DataSessionStatDbStatsValue() = default;
};
class DataValue : public Darabonba::Model {
public:
  shared_ptr<string> timestamp{};
  shared_ptr<boost::any> value{};

  DataValue() {}

  explicit DataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~DataValue() = default;
};
class AddHDMInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> flushAccount{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceArea{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> networkType{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> username{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> context{};

  AddHDMInstanceRequest() {}

  explicit AddHDMInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (flushAccount) {
      res["FlushAccount"] = boost::any(*flushAccount);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceArea) {
      res["InstanceArea"] = boost::any(*instanceArea);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("FlushAccount") != m.end() && !m["FlushAccount"].empty()) {
      flushAccount = make_shared<string>(boost::any_cast<string>(m["FlushAccount"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceArea") != m.end() && !m["InstanceArea"].empty()) {
      instanceArea = make_shared<string>(boost::any_cast<string>(m["InstanceArea"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
  }


  virtual ~AddHDMInstanceRequest() = default;
};
class AddHDMInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> callerUid{};
  shared_ptr<long> code{};
  shared_ptr<string> error{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> port{};
  shared_ptr<string> role{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> token{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcId{};

  AddHDMInstanceResponseBodyData() {}

  explicit AddHDMInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callerUid) {
      res["CallerUid"] = boost::any(*callerUid);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallerUid") != m.end() && !m["CallerUid"].empty()) {
      callerUid = make_shared<string>(boost::any_cast<string>(m["CallerUid"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddHDMInstanceResponseBodyData() = default;
};
class AddHDMInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AddHDMInstanceResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  AddHDMInstanceResponseBody() {}

  explicit AddHDMInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddHDMInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddHDMInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~AddHDMInstanceResponseBody() = default;
};
class AddHDMInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddHDMInstanceResponseBody> body{};

  AddHDMInstanceResponse() {}

  explicit AddHDMInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddHDMInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddHDMInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddHDMInstanceResponse() = default;
};
class CreateAdamBenchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dstInstanceId{};
  shared_ptr<string> dstSuperAccount{};
  shared_ptr<string> dstSuperPassword{};
  shared_ptr<long> rate{};
  shared_ptr<long> requestDuration{};
  shared_ptr<long> requestStartTime{};
  shared_ptr<string> srcEngine{};
  shared_ptr<string> srcEngineVersion{};
  shared_ptr<double> srcMaxQps{};
  shared_ptr<double> srcMeanQps{};
  shared_ptr<string> srcSqlOssAddr{};

  CreateAdamBenchTaskRequest() {}

  explicit CreateAdamBenchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstInstanceId) {
      res["DstInstanceId"] = boost::any(*dstInstanceId);
    }
    if (dstSuperAccount) {
      res["DstSuperAccount"] = boost::any(*dstSuperAccount);
    }
    if (dstSuperPassword) {
      res["DstSuperPassword"] = boost::any(*dstSuperPassword);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (requestDuration) {
      res["RequestDuration"] = boost::any(*requestDuration);
    }
    if (requestStartTime) {
      res["RequestStartTime"] = boost::any(*requestStartTime);
    }
    if (srcEngine) {
      res["SrcEngine"] = boost::any(*srcEngine);
    }
    if (srcEngineVersion) {
      res["SrcEngineVersion"] = boost::any(*srcEngineVersion);
    }
    if (srcMaxQps) {
      res["SrcMaxQps"] = boost::any(*srcMaxQps);
    }
    if (srcMeanQps) {
      res["SrcMeanQps"] = boost::any(*srcMeanQps);
    }
    if (srcSqlOssAddr) {
      res["SrcSqlOssAddr"] = boost::any(*srcSqlOssAddr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstInstanceId") != m.end() && !m["DstInstanceId"].empty()) {
      dstInstanceId = make_shared<string>(boost::any_cast<string>(m["DstInstanceId"]));
    }
    if (m.find("DstSuperAccount") != m.end() && !m["DstSuperAccount"].empty()) {
      dstSuperAccount = make_shared<string>(boost::any_cast<string>(m["DstSuperAccount"]));
    }
    if (m.find("DstSuperPassword") != m.end() && !m["DstSuperPassword"].empty()) {
      dstSuperPassword = make_shared<string>(boost::any_cast<string>(m["DstSuperPassword"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("RequestDuration") != m.end() && !m["RequestDuration"].empty()) {
      requestDuration = make_shared<long>(boost::any_cast<long>(m["RequestDuration"]));
    }
    if (m.find("RequestStartTime") != m.end() && !m["RequestStartTime"].empty()) {
      requestStartTime = make_shared<long>(boost::any_cast<long>(m["RequestStartTime"]));
    }
    if (m.find("SrcEngine") != m.end() && !m["SrcEngine"].empty()) {
      srcEngine = make_shared<string>(boost::any_cast<string>(m["SrcEngine"]));
    }
    if (m.find("SrcEngineVersion") != m.end() && !m["SrcEngineVersion"].empty()) {
      srcEngineVersion = make_shared<string>(boost::any_cast<string>(m["SrcEngineVersion"]));
    }
    if (m.find("SrcMaxQps") != m.end() && !m["SrcMaxQps"].empty()) {
      srcMaxQps = make_shared<double>(boost::any_cast<double>(m["SrcMaxQps"]));
    }
    if (m.find("SrcMeanQps") != m.end() && !m["SrcMeanQps"].empty()) {
      srcMeanQps = make_shared<double>(boost::any_cast<double>(m["SrcMeanQps"]));
    }
    if (m.find("SrcSqlOssAddr") != m.end() && !m["SrcSqlOssAddr"].empty()) {
      srcSqlOssAddr = make_shared<string>(boost::any_cast<string>(m["SrcSqlOssAddr"]));
    }
  }


  virtual ~CreateAdamBenchTaskRequest() = default;
};
class CreateAdamBenchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateAdamBenchTaskResponseBody() {}

  explicit CreateAdamBenchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateAdamBenchTaskResponseBody() = default;
};
class CreateAdamBenchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAdamBenchTaskResponseBody> body{};

  CreateAdamBenchTaskResponse() {}

  explicit CreateAdamBenchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAdamBenchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAdamBenchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAdamBenchTaskResponse() = default;
};
class CreateCacheAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> backupSetId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> separators{};

  CreateCacheAnalysisJobRequest() {}

  explicit CreateCacheAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (separators) {
      res["Separators"] = boost::any(*separators);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Separators") != m.end() && !m["Separators"].empty()) {
      separators = make_shared<string>(boost::any_cast<string>(m["Separators"]));
    }
  }


  virtual ~CreateCacheAnalysisJobRequest() = default;
};
class CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo() {}

  explicit CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo() = default;
};
class CreateCacheAnalysisJobResponseBodyDataBigKeys : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo>> keyInfo{};

  CreateCacheAnalysisJobResponseBodyDataBigKeys() {}

  explicit CreateCacheAnalysisJobResponseBodyDataBigKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<CreateCacheAnalysisJobResponseBodyDataBigKeysKeyInfo>>(expect1);
      }
    }
  }


  virtual ~CreateCacheAnalysisJobResponseBodyDataBigKeys() = default;
};
class CreateCacheAnalysisJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CreateCacheAnalysisJobResponseBodyDataBigKeys> bigKeys{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> taskState{};

  CreateCacheAnalysisJobResponseBodyData() {}

  explicit CreateCacheAnalysisJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKeys) {
      res["BigKeys"] = bigKeys ? boost::any(bigKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKeys") != m.end() && !m["BigKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["BigKeys"].type()) {
        CreateCacheAnalysisJobResponseBodyDataBigKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BigKeys"]));
        bigKeys = make_shared<CreateCacheAnalysisJobResponseBodyDataBigKeys>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
  }


  virtual ~CreateCacheAnalysisJobResponseBodyData() = default;
};
class CreateCacheAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateCacheAnalysisJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateCacheAnalysisJobResponseBody() {}

  explicit CreateCacheAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateCacheAnalysisJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateCacheAnalysisJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateCacheAnalysisJobResponseBody() = default;
};
class CreateCacheAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCacheAnalysisJobResponseBody> body{};

  CreateCacheAnalysisJobResponse() {}

  explicit CreateCacheAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCacheAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCacheAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCacheAnalysisJobResponse() = default;
};
class CreateCloudBenchTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> backupId{};
  shared_ptr<string> backupTime{};
  shared_ptr<string> clientType{};
  shared_ptr<string> description{};
  shared_ptr<string> dstConnectionString{};
  shared_ptr<string> dstInstanceId{};
  shared_ptr<string> dstPort{};
  shared_ptr<string> dstSuperAccount{};
  shared_ptr<string> dstSuperPassword{};
  shared_ptr<string> dstType{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> endState{};
  shared_ptr<string> gatewayVpcId{};
  shared_ptr<string> gatewayVpcIp{};
  shared_ptr<string> rate{};
  shared_ptr<string> requestDuration{};
  shared_ptr<string> requestEndTime{};
  shared_ptr<string> requestStartTime{};
  shared_ptr<string> smartPressureTime{};
  shared_ptr<string> srcInstanceId{};
  shared_ptr<string> srcPublicIp{};
  shared_ptr<string> srcSuperAccount{};
  shared_ptr<string> srcSuperPassword{};
  shared_ptr<string> taskType{};
  shared_ptr<string> workDir{};

  CreateCloudBenchTasksRequest() {}

  explicit CreateCloudBenchTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (backupTime) {
      res["BackupTime"] = boost::any(*backupTime);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstConnectionString) {
      res["DstConnectionString"] = boost::any(*dstConnectionString);
    }
    if (dstInstanceId) {
      res["DstInstanceId"] = boost::any(*dstInstanceId);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (dstSuperAccount) {
      res["DstSuperAccount"] = boost::any(*dstSuperAccount);
    }
    if (dstSuperPassword) {
      res["DstSuperPassword"] = boost::any(*dstSuperPassword);
    }
    if (dstType) {
      res["DstType"] = boost::any(*dstType);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endState) {
      res["EndState"] = boost::any(*endState);
    }
    if (gatewayVpcId) {
      res["GatewayVpcId"] = boost::any(*gatewayVpcId);
    }
    if (gatewayVpcIp) {
      res["GatewayVpcIp"] = boost::any(*gatewayVpcIp);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (requestDuration) {
      res["RequestDuration"] = boost::any(*requestDuration);
    }
    if (requestEndTime) {
      res["RequestEndTime"] = boost::any(*requestEndTime);
    }
    if (requestStartTime) {
      res["RequestStartTime"] = boost::any(*requestStartTime);
    }
    if (smartPressureTime) {
      res["SmartPressureTime"] = boost::any(*smartPressureTime);
    }
    if (srcInstanceId) {
      res["SrcInstanceId"] = boost::any(*srcInstanceId);
    }
    if (srcPublicIp) {
      res["SrcPublicIp"] = boost::any(*srcPublicIp);
    }
    if (srcSuperAccount) {
      res["SrcSuperAccount"] = boost::any(*srcSuperAccount);
    }
    if (srcSuperPassword) {
      res["SrcSuperPassword"] = boost::any(*srcSuperPassword);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (workDir) {
      res["WorkDir"] = boost::any(*workDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["Amount"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("BackupTime") != m.end() && !m["BackupTime"].empty()) {
      backupTime = make_shared<string>(boost::any_cast<string>(m["BackupTime"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstConnectionString") != m.end() && !m["DstConnectionString"].empty()) {
      dstConnectionString = make_shared<string>(boost::any_cast<string>(m["DstConnectionString"]));
    }
    if (m.find("DstInstanceId") != m.end() && !m["DstInstanceId"].empty()) {
      dstInstanceId = make_shared<string>(boost::any_cast<string>(m["DstInstanceId"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<string>(boost::any_cast<string>(m["DstPort"]));
    }
    if (m.find("DstSuperAccount") != m.end() && !m["DstSuperAccount"].empty()) {
      dstSuperAccount = make_shared<string>(boost::any_cast<string>(m["DstSuperAccount"]));
    }
    if (m.find("DstSuperPassword") != m.end() && !m["DstSuperPassword"].empty()) {
      dstSuperPassword = make_shared<string>(boost::any_cast<string>(m["DstSuperPassword"]));
    }
    if (m.find("DstType") != m.end() && !m["DstType"].empty()) {
      dstType = make_shared<string>(boost::any_cast<string>(m["DstType"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EndState") != m.end() && !m["EndState"].empty()) {
      endState = make_shared<string>(boost::any_cast<string>(m["EndState"]));
    }
    if (m.find("GatewayVpcId") != m.end() && !m["GatewayVpcId"].empty()) {
      gatewayVpcId = make_shared<string>(boost::any_cast<string>(m["GatewayVpcId"]));
    }
    if (m.find("GatewayVpcIp") != m.end() && !m["GatewayVpcIp"].empty()) {
      gatewayVpcIp = make_shared<string>(boost::any_cast<string>(m["GatewayVpcIp"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("RequestDuration") != m.end() && !m["RequestDuration"].empty()) {
      requestDuration = make_shared<string>(boost::any_cast<string>(m["RequestDuration"]));
    }
    if (m.find("RequestEndTime") != m.end() && !m["RequestEndTime"].empty()) {
      requestEndTime = make_shared<string>(boost::any_cast<string>(m["RequestEndTime"]));
    }
    if (m.find("RequestStartTime") != m.end() && !m["RequestStartTime"].empty()) {
      requestStartTime = make_shared<string>(boost::any_cast<string>(m["RequestStartTime"]));
    }
    if (m.find("SmartPressureTime") != m.end() && !m["SmartPressureTime"].empty()) {
      smartPressureTime = make_shared<string>(boost::any_cast<string>(m["SmartPressureTime"]));
    }
    if (m.find("SrcInstanceId") != m.end() && !m["SrcInstanceId"].empty()) {
      srcInstanceId = make_shared<string>(boost::any_cast<string>(m["SrcInstanceId"]));
    }
    if (m.find("SrcPublicIp") != m.end() && !m["SrcPublicIp"].empty()) {
      srcPublicIp = make_shared<string>(boost::any_cast<string>(m["SrcPublicIp"]));
    }
    if (m.find("SrcSuperAccount") != m.end() && !m["SrcSuperAccount"].empty()) {
      srcSuperAccount = make_shared<string>(boost::any_cast<string>(m["SrcSuperAccount"]));
    }
    if (m.find("SrcSuperPassword") != m.end() && !m["SrcSuperPassword"].empty()) {
      srcSuperPassword = make_shared<string>(boost::any_cast<string>(m["SrcSuperPassword"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("WorkDir") != m.end() && !m["WorkDir"].empty()) {
      workDir = make_shared<string>(boost::any_cast<string>(m["WorkDir"]));
    }
  }


  virtual ~CreateCloudBenchTasksRequest() = default;
};
class CreateCloudBenchTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> taskIds{};

  CreateCloudBenchTasksResponseBodyData() {}

  explicit CreateCloudBenchTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["taskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("taskIds") != m.end() && !m["taskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["taskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["taskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateCloudBenchTasksResponseBodyData() = default;
};
class CreateCloudBenchTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateCloudBenchTasksResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateCloudBenchTasksResponseBody() {}

  explicit CreateCloudBenchTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateCloudBenchTasksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateCloudBenchTasksResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateCloudBenchTasksResponseBody() = default;
};
class CreateCloudBenchTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudBenchTasksResponseBody> body{};

  CreateCloudBenchTasksResponse() {}

  explicit CreateCloudBenchTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudBenchTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudBenchTasksResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudBenchTasksResponse() = default;
};
class CreateDiagnosticReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  CreateDiagnosticReportRequest() {}

  explicit CreateDiagnosticReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateDiagnosticReportRequest() = default;
};
class CreateDiagnosticReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateDiagnosticReportResponseBody() {}

  explicit CreateDiagnosticReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateDiagnosticReportResponseBody() = default;
};
class CreateDiagnosticReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiagnosticReportResponseBody> body{};

  CreateDiagnosticReportResponse() {}

  explicit CreateDiagnosticReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnosticReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnosticReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnosticReportResponse() = default;
};
class CreateKillInstanceSessionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbUser{};
  shared_ptr<string> dbUserPassword{};
  shared_ptr<string> ignoredUsers{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> killAllSessions{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sessionIds{};

  CreateKillInstanceSessionTaskRequest() {}

  explicit CreateKillInstanceSessionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbUser) {
      res["DbUser"] = boost::any(*dbUser);
    }
    if (dbUserPassword) {
      res["DbUserPassword"] = boost::any(*dbUserPassword);
    }
    if (ignoredUsers) {
      res["IgnoredUsers"] = boost::any(*ignoredUsers);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (killAllSessions) {
      res["KillAllSessions"] = boost::any(*killAllSessions);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sessionIds) {
      res["SessionIds"] = boost::any(*sessionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbUser") != m.end() && !m["DbUser"].empty()) {
      dbUser = make_shared<string>(boost::any_cast<string>(m["DbUser"]));
    }
    if (m.find("DbUserPassword") != m.end() && !m["DbUserPassword"].empty()) {
      dbUserPassword = make_shared<string>(boost::any_cast<string>(m["DbUserPassword"]));
    }
    if (m.find("IgnoredUsers") != m.end() && !m["IgnoredUsers"].empty()) {
      ignoredUsers = make_shared<string>(boost::any_cast<string>(m["IgnoredUsers"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KillAllSessions") != m.end() && !m["KillAllSessions"].empty()) {
      killAllSessions = make_shared<bool>(boost::any_cast<bool>(m["KillAllSessions"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SessionIds") != m.end() && !m["SessionIds"].empty()) {
      sessionIds = make_shared<string>(boost::any_cast<string>(m["SessionIds"]));
    }
  }


  virtual ~CreateKillInstanceSessionTaskRequest() = default;
};
class CreateKillInstanceSessionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateKillInstanceSessionTaskResponseBody() {}

  explicit CreateKillInstanceSessionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateKillInstanceSessionTaskResponseBody() = default;
};
class CreateKillInstanceSessionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateKillInstanceSessionTaskResponseBody> body{};

  CreateKillInstanceSessionTaskResponse() {}

  explicit CreateKillInstanceSessionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKillInstanceSessionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKillInstanceSessionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKillInstanceSessionTaskResponse() = default;
};
class CreateKillInstanceSessionTaskWithMaintainUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ignoredUsers{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> killAllSessions{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sessionIds{};

  CreateKillInstanceSessionTaskWithMaintainUserRequest() {}

  explicit CreateKillInstanceSessionTaskWithMaintainUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredUsers) {
      res["IgnoredUsers"] = boost::any(*ignoredUsers);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (killAllSessions) {
      res["KillAllSessions"] = boost::any(*killAllSessions);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sessionIds) {
      res["SessionIds"] = boost::any(*sessionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredUsers") != m.end() && !m["IgnoredUsers"].empty()) {
      ignoredUsers = make_shared<string>(boost::any_cast<string>(m["IgnoredUsers"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KillAllSessions") != m.end() && !m["KillAllSessions"].empty()) {
      killAllSessions = make_shared<bool>(boost::any_cast<bool>(m["KillAllSessions"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SessionIds") != m.end() && !m["SessionIds"].empty()) {
      sessionIds = make_shared<string>(boost::any_cast<string>(m["SessionIds"]));
    }
  }


  virtual ~CreateKillInstanceSessionTaskWithMaintainUserRequest() = default;
};
class CreateKillInstanceSessionTaskWithMaintainUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateKillInstanceSessionTaskWithMaintainUserResponseBody() {}

  explicit CreateKillInstanceSessionTaskWithMaintainUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateKillInstanceSessionTaskWithMaintainUserResponseBody() = default;
};
class CreateKillInstanceSessionTaskWithMaintainUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateKillInstanceSessionTaskWithMaintainUserResponseBody> body{};

  CreateKillInstanceSessionTaskWithMaintainUserResponse() {}

  explicit CreateKillInstanceSessionTaskWithMaintainUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKillInstanceSessionTaskWithMaintainUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKillInstanceSessionTaskWithMaintainUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKillInstanceSessionTaskWithMaintainUserResponse() = default;
};
class CreateQueryOptimizeTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> comments{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlIds{};
  shared_ptr<long> status{};
  shared_ptr<string> tags{};

  CreateQueryOptimizeTagRequest() {}

  explicit CreateQueryOptimizeTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlIds) {
      res["SqlIds"] = boost::any(*sqlIds);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlIds") != m.end() && !m["SqlIds"].empty()) {
      sqlIds = make_shared<string>(boost::any_cast<string>(m["SqlIds"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateQueryOptimizeTagRequest() = default;
};
class CreateQueryOptimizeTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateQueryOptimizeTagResponseBody() {}

  explicit CreateQueryOptimizeTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateQueryOptimizeTagResponseBody() = default;
};
class CreateQueryOptimizeTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateQueryOptimizeTagResponseBody> body{};

  CreateQueryOptimizeTagResponse() {}

  explicit CreateQueryOptimizeTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQueryOptimizeTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQueryOptimizeTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQueryOptimizeTagResponse() = default;
};
class CreateRequestDiagnosisRequest : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sql{};

  CreateRequestDiagnosisRequest() {}

  explicit CreateRequestDiagnosisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
  }


  virtual ~CreateRequestDiagnosisRequest() = default;
};
class CreateRequestDiagnosisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateRequestDiagnosisResponseBody() {}

  explicit CreateRequestDiagnosisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateRequestDiagnosisResponseBody() = default;
};
class CreateRequestDiagnosisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRequestDiagnosisResponseBody> body{};

  CreateRequestDiagnosisResponse() {}

  explicit CreateRequestDiagnosisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRequestDiagnosisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRequestDiagnosisResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRequestDiagnosisResponse() = default;
};
class CreateSqlLogTaskRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSqlLogTaskRequestFilters() {}

  explicit CreateSqlLogTaskRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSqlLogTaskRequestFilters() = default;
};
class CreateSqlLogTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<CreateSqlLogTaskRequestFilters>> filters{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> role{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  CreateSqlLogTaskRequest() {}

  explicit CreateSqlLogTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<CreateSqlLogTaskRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSqlLogTaskRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<CreateSqlLogTaskRequestFilters>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateSqlLogTaskRequest() = default;
};
class CreateSqlLogTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> start{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  CreateSqlLogTaskResponseBodyData() {}

  explicit CreateSqlLogTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateSqlLogTaskResponseBodyData() = default;
};
class CreateSqlLogTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSqlLogTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateSqlLogTaskResponseBody() {}

  explicit CreateSqlLogTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSqlLogTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSqlLogTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSqlLogTaskResponseBody() = default;
};
class CreateSqlLogTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSqlLogTaskResponseBody> body{};

  CreateSqlLogTaskResponse() {}

  explicit CreateSqlLogTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSqlLogTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSqlLogTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSqlLogTaskResponse() = default;
};
class CreateStorageAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tableName{};

  CreateStorageAnalysisTaskRequest() {}

  explicit CreateStorageAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~CreateStorageAnalysisTaskRequest() = default;
};
class CreateStorageAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> createTaskSuccess{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};

  CreateStorageAnalysisTaskResponseBodyData() {}

  explicit CreateStorageAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTaskSuccess) {
      res["CreateTaskSuccess"] = boost::any(*createTaskSuccess);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTaskSuccess") != m.end() && !m["CreateTaskSuccess"].empty()) {
      createTaskSuccess = make_shared<bool>(boost::any_cast<bool>(m["CreateTaskSuccess"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateStorageAnalysisTaskResponseBodyData() = default;
};
class CreateStorageAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateStorageAnalysisTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateStorageAnalysisTaskResponseBody() {}

  explicit CreateStorageAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateStorageAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateStorageAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateStorageAnalysisTaskResponseBody() = default;
};
class CreateStorageAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStorageAnalysisTaskResponseBody> body{};

  CreateStorageAnalysisTaskResponse() {}

  explicit CreateStorageAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStorageAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStorageAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStorageAnalysisTaskResponse() = default;
};
class DeleteCloudBenchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DeleteCloudBenchTaskRequest() {}

  explicit DeleteCloudBenchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteCloudBenchTaskRequest() = default;
};
class DeleteCloudBenchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteCloudBenchTaskResponseBody() {}

  explicit DeleteCloudBenchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteCloudBenchTaskResponseBody() = default;
};
class DeleteCloudBenchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudBenchTaskResponseBody> body{};

  DeleteCloudBenchTaskResponse() {}

  explicit DeleteCloudBenchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudBenchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudBenchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudBenchTaskResponse() = default;
};
class DeleteStopGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> gatewayId{};

  DeleteStopGatewayRequest() {}

  explicit DeleteStopGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
  }


  virtual ~DeleteStopGatewayRequest() = default;
};
class DeleteStopGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteStopGatewayResponseBody() {}

  explicit DeleteStopGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteStopGatewayResponseBody() = default;
};
class DeleteStopGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStopGatewayResponseBody> body{};

  DeleteStopGatewayResponse() {}

  explicit DeleteStopGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStopGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStopGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStopGatewayResponse() = default;
};
class DescribeAutoScalingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeAutoScalingConfigRequest() {}

  explicit DescribeAutoScalingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeAutoScalingConfigRequest() = default;
};
class DescribeAutoScalingConfigResponseBodyDataBandwidth : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthUsageLowerThreshold{};
  shared_ptr<long> bandwidthUsageUpperThreshold{};
  shared_ptr<bool> downgrade{};
  shared_ptr<string> observationWindowSize{};
  shared_ptr<bool> upgrade{};

  DescribeAutoScalingConfigResponseBodyDataBandwidth() {}

  explicit DescribeAutoScalingConfigResponseBodyDataBandwidth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthUsageLowerThreshold) {
      res["BandwidthUsageLowerThreshold"] = boost::any(*bandwidthUsageLowerThreshold);
    }
    if (bandwidthUsageUpperThreshold) {
      res["BandwidthUsageUpperThreshold"] = boost::any(*bandwidthUsageUpperThreshold);
    }
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (observationWindowSize) {
      res["ObservationWindowSize"] = boost::any(*observationWindowSize);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthUsageLowerThreshold") != m.end() && !m["BandwidthUsageLowerThreshold"].empty()) {
      bandwidthUsageLowerThreshold = make_shared<long>(boost::any_cast<long>(m["BandwidthUsageLowerThreshold"]));
    }
    if (m.find("BandwidthUsageUpperThreshold") != m.end() && !m["BandwidthUsageUpperThreshold"].empty()) {
      bandwidthUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["BandwidthUsageUpperThreshold"]));
    }
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("ObservationWindowSize") != m.end() && !m["ObservationWindowSize"].empty()) {
      observationWindowSize = make_shared<string>(boost::any_cast<string>(m["ObservationWindowSize"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyDataBandwidth() = default;
};
class DescribeAutoScalingConfigResponseBodyDataResource : public Darabonba::Model {
public:
  shared_ptr<long> cpuStep{};
  shared_ptr<long> cpuUsageUpperThreshold{};
  shared_ptr<string> downgradeObservationWindowSize{};
  shared_ptr<bool> enable{};
  shared_ptr<string> upgradeObservationWindowSize{};

  DescribeAutoScalingConfigResponseBodyDataResource() {}

  explicit DescribeAutoScalingConfigResponseBodyDataResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuStep) {
      res["CpuStep"] = boost::any(*cpuStep);
    }
    if (cpuUsageUpperThreshold) {
      res["CpuUsageUpperThreshold"] = boost::any(*cpuUsageUpperThreshold);
    }
    if (downgradeObservationWindowSize) {
      res["DowngradeObservationWindowSize"] = boost::any(*downgradeObservationWindowSize);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (upgradeObservationWindowSize) {
      res["UpgradeObservationWindowSize"] = boost::any(*upgradeObservationWindowSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuStep") != m.end() && !m["CpuStep"].empty()) {
      cpuStep = make_shared<long>(boost::any_cast<long>(m["CpuStep"]));
    }
    if (m.find("CpuUsageUpperThreshold") != m.end() && !m["CpuUsageUpperThreshold"].empty()) {
      cpuUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["CpuUsageUpperThreshold"]));
    }
    if (m.find("DowngradeObservationWindowSize") != m.end() && !m["DowngradeObservationWindowSize"].empty()) {
      downgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["DowngradeObservationWindowSize"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("UpgradeObservationWindowSize") != m.end() && !m["UpgradeObservationWindowSize"].empty()) {
      upgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["UpgradeObservationWindowSize"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyDataResource() = default;
};
class DescribeAutoScalingConfigResponseBodyDataShard : public Darabonba::Model {
public:
  shared_ptr<bool> downgrade{};
  shared_ptr<string> downgradeObservationWindowSize{};
  shared_ptr<long> maxShards{};
  shared_ptr<long> memUsageLowerThreshold{};
  shared_ptr<long> memUsageUpperThreshold{};
  shared_ptr<long> minShards{};
  shared_ptr<bool> upgrade{};
  shared_ptr<string> upgradeObservationWindowSize{};

  DescribeAutoScalingConfigResponseBodyDataShard() {}

  explicit DescribeAutoScalingConfigResponseBodyDataShard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (downgradeObservationWindowSize) {
      res["DowngradeObservationWindowSize"] = boost::any(*downgradeObservationWindowSize);
    }
    if (maxShards) {
      res["MaxShards"] = boost::any(*maxShards);
    }
    if (memUsageLowerThreshold) {
      res["MemUsageLowerThreshold"] = boost::any(*memUsageLowerThreshold);
    }
    if (memUsageUpperThreshold) {
      res["MemUsageUpperThreshold"] = boost::any(*memUsageUpperThreshold);
    }
    if (minShards) {
      res["MinShards"] = boost::any(*minShards);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    if (upgradeObservationWindowSize) {
      res["UpgradeObservationWindowSize"] = boost::any(*upgradeObservationWindowSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("DowngradeObservationWindowSize") != m.end() && !m["DowngradeObservationWindowSize"].empty()) {
      downgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["DowngradeObservationWindowSize"]));
    }
    if (m.find("MaxShards") != m.end() && !m["MaxShards"].empty()) {
      maxShards = make_shared<long>(boost::any_cast<long>(m["MaxShards"]));
    }
    if (m.find("MemUsageLowerThreshold") != m.end() && !m["MemUsageLowerThreshold"].empty()) {
      memUsageLowerThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageLowerThreshold"]));
    }
    if (m.find("MemUsageUpperThreshold") != m.end() && !m["MemUsageUpperThreshold"].empty()) {
      memUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageUpperThreshold"]));
    }
    if (m.find("MinShards") != m.end() && !m["MinShards"].empty()) {
      minShards = make_shared<long>(boost::any_cast<long>(m["MinShards"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
    if (m.find("UpgradeObservationWindowSize") != m.end() && !m["UpgradeObservationWindowSize"].empty()) {
      upgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["UpgradeObservationWindowSize"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyDataShard() = default;
};
class DescribeAutoScalingConfigResponseBodyDataSpec : public Darabonba::Model {
public:
  shared_ptr<string> coolDownTime{};
  shared_ptr<long> cpuUsageUpperThreshold{};
  shared_ptr<bool> downgrade{};
  shared_ptr<long> maxReadOnlyNodes{};
  shared_ptr<string> maxSpec{};
  shared_ptr<long> memUsageUpperThreshold{};
  shared_ptr<string> observationWindowSize{};
  shared_ptr<bool> upgrade{};

  DescribeAutoScalingConfigResponseBodyDataSpec() {}

  explicit DescribeAutoScalingConfigResponseBodyDataSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coolDownTime) {
      res["CoolDownTime"] = boost::any(*coolDownTime);
    }
    if (cpuUsageUpperThreshold) {
      res["CpuUsageUpperThreshold"] = boost::any(*cpuUsageUpperThreshold);
    }
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (maxReadOnlyNodes) {
      res["MaxReadOnlyNodes"] = boost::any(*maxReadOnlyNodes);
    }
    if (maxSpec) {
      res["MaxSpec"] = boost::any(*maxSpec);
    }
    if (memUsageUpperThreshold) {
      res["MemUsageUpperThreshold"] = boost::any(*memUsageUpperThreshold);
    }
    if (observationWindowSize) {
      res["ObservationWindowSize"] = boost::any(*observationWindowSize);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoolDownTime") != m.end() && !m["CoolDownTime"].empty()) {
      coolDownTime = make_shared<string>(boost::any_cast<string>(m["CoolDownTime"]));
    }
    if (m.find("CpuUsageUpperThreshold") != m.end() && !m["CpuUsageUpperThreshold"].empty()) {
      cpuUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["CpuUsageUpperThreshold"]));
    }
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("MaxReadOnlyNodes") != m.end() && !m["MaxReadOnlyNodes"].empty()) {
      maxReadOnlyNodes = make_shared<long>(boost::any_cast<long>(m["MaxReadOnlyNodes"]));
    }
    if (m.find("MaxSpec") != m.end() && !m["MaxSpec"].empty()) {
      maxSpec = make_shared<string>(boost::any_cast<string>(m["MaxSpec"]));
    }
    if (m.find("MemUsageUpperThreshold") != m.end() && !m["MemUsageUpperThreshold"].empty()) {
      memUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageUpperThreshold"]));
    }
    if (m.find("ObservationWindowSize") != m.end() && !m["ObservationWindowSize"].empty()) {
      observationWindowSize = make_shared<string>(boost::any_cast<string>(m["ObservationWindowSize"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyDataSpec() = default;
};
class DescribeAutoScalingConfigResponseBodyDataStorage : public Darabonba::Model {
public:
  shared_ptr<long> diskUsageUpperThreshold{};
  shared_ptr<long> maxStorage{};
  shared_ptr<bool> upgrade{};

  DescribeAutoScalingConfigResponseBodyDataStorage() {}

  explicit DescribeAutoScalingConfigResponseBodyDataStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskUsageUpperThreshold) {
      res["DiskUsageUpperThreshold"] = boost::any(*diskUsageUpperThreshold);
    }
    if (maxStorage) {
      res["MaxStorage"] = boost::any(*maxStorage);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskUsageUpperThreshold") != m.end() && !m["DiskUsageUpperThreshold"].empty()) {
      diskUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["DiskUsageUpperThreshold"]));
    }
    if (m.find("MaxStorage") != m.end() && !m["MaxStorage"].empty()) {
      maxStorage = make_shared<long>(boost::any_cast<long>(m["MaxStorage"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyDataStorage() = default;
};
class DescribeAutoScalingConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeAutoScalingConfigResponseBodyDataBandwidth> bandwidth{};
  shared_ptr<DescribeAutoScalingConfigResponseBodyDataResource> resource{};
  shared_ptr<DescribeAutoScalingConfigResponseBodyDataShard> shard{};
  shared_ptr<DescribeAutoScalingConfigResponseBodyDataSpec> spec{};
  shared_ptr<DescribeAutoScalingConfigResponseBodyDataStorage> storage{};

  DescribeAutoScalingConfigResponseBodyData() {}

  explicit DescribeAutoScalingConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = bandwidth ? boost::any(bandwidth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shard) {
      res["Shard"] = shard ? boost::any(shard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storage) {
      res["Storage"] = storage ? boost::any(storage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      if (typeid(map<string, boost::any>) == m["Bandwidth"].type()) {
        DescribeAutoScalingConfigResponseBodyDataBandwidth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Bandwidth"]));
        bandwidth = make_shared<DescribeAutoScalingConfigResponseBodyDataBandwidth>(model1);
      }
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeAutoScalingConfigResponseBodyDataResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeAutoScalingConfigResponseBodyDataResource>(model1);
      }
    }
    if (m.find("Shard") != m.end() && !m["Shard"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shard"].type()) {
        DescribeAutoScalingConfigResponseBodyDataShard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shard"]));
        shard = make_shared<DescribeAutoScalingConfigResponseBodyDataShard>(model1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        DescribeAutoScalingConfigResponseBodyDataSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<DescribeAutoScalingConfigResponseBodyDataSpec>(model1);
      }
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Storage"].type()) {
        DescribeAutoScalingConfigResponseBodyDataStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Storage"]));
        storage = make_shared<DescribeAutoScalingConfigResponseBodyDataStorage>(model1);
      }
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBodyData() = default;
};
class DescribeAutoScalingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeAutoScalingConfigResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeAutoScalingConfigResponseBody() {}

  explicit DescribeAutoScalingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAutoScalingConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAutoScalingConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeAutoScalingConfigResponseBody() = default;
};
class DescribeAutoScalingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoScalingConfigResponseBody> body{};

  DescribeAutoScalingConfigResponse() {}

  explicit DescribeAutoScalingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoScalingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoScalingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoScalingConfigResponse() = default;
};
class DescribeAutoScalingHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoScalingTaskType{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  DescribeAutoScalingHistoryRequest() {}

  explicit DescribeAutoScalingHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScalingTaskType) {
      res["AutoScalingTaskType"] = boost::any(*autoScalingTaskType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoScalingTaskType") != m.end() && !m["AutoScalingTaskType"].empty()) {
      autoScalingTaskType = make_shared<string>(boost::any_cast<string>(m["AutoScalingTaskType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeAutoScalingHistoryRequest() = default;
};
class DescribeAutoScalingHistoryResponseBodyDataSpecHistory : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<long> originCore{};
  shared_ptr<string> originInstanceClass{};
  shared_ptr<double> originMemory{};
  shared_ptr<string> scaleType{};
  shared_ptr<long> targetCore{};
  shared_ptr<string> targetInstanceClass{};
  shared_ptr<double> targetMemory{};
  shared_ptr<bool> taskExcuteStatus{};
  shared_ptr<long> taskTime{};

  DescribeAutoScalingHistoryResponseBodyDataSpecHistory() {}

  explicit DescribeAutoScalingHistoryResponseBodyDataSpecHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (originCore) {
      res["OriginCore"] = boost::any(*originCore);
    }
    if (originInstanceClass) {
      res["OriginInstanceClass"] = boost::any(*originInstanceClass);
    }
    if (originMemory) {
      res["OriginMemory"] = boost::any(*originMemory);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (targetCore) {
      res["TargetCore"] = boost::any(*targetCore);
    }
    if (targetInstanceClass) {
      res["TargetInstanceClass"] = boost::any(*targetInstanceClass);
    }
    if (targetMemory) {
      res["TargetMemory"] = boost::any(*targetMemory);
    }
    if (taskExcuteStatus) {
      res["TaskExcuteStatus"] = boost::any(*taskExcuteStatus);
    }
    if (taskTime) {
      res["TaskTime"] = boost::any(*taskTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OriginCore") != m.end() && !m["OriginCore"].empty()) {
      originCore = make_shared<long>(boost::any_cast<long>(m["OriginCore"]));
    }
    if (m.find("OriginInstanceClass") != m.end() && !m["OriginInstanceClass"].empty()) {
      originInstanceClass = make_shared<string>(boost::any_cast<string>(m["OriginInstanceClass"]));
    }
    if (m.find("OriginMemory") != m.end() && !m["OriginMemory"].empty()) {
      originMemory = make_shared<double>(boost::any_cast<double>(m["OriginMemory"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("TargetCore") != m.end() && !m["TargetCore"].empty()) {
      targetCore = make_shared<long>(boost::any_cast<long>(m["TargetCore"]));
    }
    if (m.find("TargetInstanceClass") != m.end() && !m["TargetInstanceClass"].empty()) {
      targetInstanceClass = make_shared<string>(boost::any_cast<string>(m["TargetInstanceClass"]));
    }
    if (m.find("TargetMemory") != m.end() && !m["TargetMemory"].empty()) {
      targetMemory = make_shared<double>(boost::any_cast<double>(m["TargetMemory"]));
    }
    if (m.find("TaskExcuteStatus") != m.end() && !m["TaskExcuteStatus"].empty()) {
      taskExcuteStatus = make_shared<bool>(boost::any_cast<bool>(m["TaskExcuteStatus"]));
    }
    if (m.find("TaskTime") != m.end() && !m["TaskTime"].empty()) {
      taskTime = make_shared<long>(boost::any_cast<long>(m["TaskTime"]));
    }
  }


  virtual ~DescribeAutoScalingHistoryResponseBodyDataSpecHistory() = default;
};
class DescribeAutoScalingHistoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> bandwidth{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<map<string, boost::any>>> resource{};
  shared_ptr<vector<map<string, boost::any>>> shard{};
  shared_ptr<vector<DescribeAutoScalingHistoryResponseBodyDataSpecHistory>> specHistory{};
  shared_ptr<vector<map<string, boost::any>>> storage{};

  DescribeAutoScalingHistoryResponseBodyData() {}

  explicit DescribeAutoScalingHistoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (shard) {
      res["Shard"] = boost::any(*shard);
    }
    if (specHistory) {
      vector<boost::any> temp1;
      for(auto item1:*specHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecHistory"] = boost::any(temp1);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Bandwidth"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Bandwidth"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      bandwidth = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resource"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      resource = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Shard") != m.end() && !m["Shard"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Shard"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Shard"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      shard = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("SpecHistory") != m.end() && !m["SpecHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecHistory"].type()) {
        vector<DescribeAutoScalingHistoryResponseBodyDataSpecHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoScalingHistoryResponseBodyDataSpecHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specHistory = make_shared<vector<DescribeAutoScalingHistoryResponseBodyDataSpecHistory>>(expect1);
      }
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Storage"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Storage"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      storage = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAutoScalingHistoryResponseBodyData() = default;
};
class DescribeAutoScalingHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeAutoScalingHistoryResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeAutoScalingHistoryResponseBody() {}

  explicit DescribeAutoScalingHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAutoScalingHistoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAutoScalingHistoryResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeAutoScalingHistoryResponseBody() = default;
};
class DescribeAutoScalingHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoScalingHistoryResponseBody> body{};

  DescribeAutoScalingHistoryResponse() {}

  explicit DescribeAutoScalingHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoScalingHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoScalingHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoScalingHistoryResponse() = default;
};
class DescribeCacheAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  DescribeCacheAnalysisJobRequest() {}

  explicit DescribeCacheAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobRequest() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataBigKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo>> keyInfo{};

  DescribeCacheAnalysisJobResponseBodyDataBigKeys() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataBigKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysKeyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataBigKeys() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo>> keyInfo{};

  DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNumKeyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel : public Darabonba::Model {
public:
  shared_ptr<long> analysisTs{};
  shared_ptr<long> level{};
  shared_ptr<long> totalBytes{};
  shared_ptr<long> totalKeys{};

  DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisTs) {
      res["AnalysisTs"] = boost::any(*analysisTs);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalKeys) {
      res["TotalKeys"] = boost::any(*totalKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisTs") != m.end() && !m["AnalysisTs"].empty()) {
      analysisTs = make_shared<long>(boost::any_cast<long>(m["AnalysisTs"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<long>(boost::any_cast<long>(m["TotalBytes"]));
    }
    if (m.find("TotalKeys") != m.end() && !m["TotalKeys"].empty()) {
      totalKeys = make_shared<long>(boost::any_cast<long>(m["TotalKeys"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel>> expiryLevel{};

  DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiryLevel) {
      vector<boost::any> temp1;
      for(auto item1:*expiryLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExpiryLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiryLevel") != m.end() && !m["ExpiryLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["ExpiryLevel"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExpiryLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expiryLevel = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCountExpiryLevel>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> keyNum{};
  shared_ptr<string> prefix{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (keyNum) {
      res["KeyNum"] = boost::any(*keyNum);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("KeyNum") != m.end() && !m["KeyNum"].empty()) {
      keyNum = make_shared<long>(boost::any_cast<long>(m["KeyNum"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix>> prefix{};

  DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefix) {
      vector<boost::any> temp1;
      for(auto item1:*prefix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Prefix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      if (typeid(vector<boost::any>) == m["Prefix"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Prefix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefix = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataKeyPrefixesPrefix>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo>> keyInfo{};

  DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytesKeyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo() = default;
};
class DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo>> keyInfo{};

  DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum() {}

  explicit DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNumKeyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum() = default;
};
class DescribeCacheAnalysisJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataBigKeys> bigKeys{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum> bigKeysOfNum{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount> expiryKeysLevelCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes> keyPrefixes{};
  shared_ptr<string> message{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> taskState{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes> unexBigKeysOfBytes{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum> unexBigKeysOfNum{};

  DescribeCacheAnalysisJobResponseBodyData() {}

  explicit DescribeCacheAnalysisJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKeys) {
      res["BigKeys"] = bigKeys ? boost::any(bigKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bigKeysOfNum) {
      res["BigKeysOfNum"] = bigKeysOfNum ? boost::any(bigKeysOfNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expiryKeysLevelCount) {
      res["ExpiryKeysLevelCount"] = expiryKeysLevelCount ? boost::any(expiryKeysLevelCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (keyPrefixes) {
      res["KeyPrefixes"] = keyPrefixes ? boost::any(keyPrefixes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (unexBigKeysOfBytes) {
      res["UnexBigKeysOfBytes"] = unexBigKeysOfBytes ? boost::any(unexBigKeysOfBytes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unexBigKeysOfNum) {
      res["UnexBigKeysOfNum"] = unexBigKeysOfNum ? boost::any(unexBigKeysOfNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKeys") != m.end() && !m["BigKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["BigKeys"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataBigKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BigKeys"]));
        bigKeys = make_shared<DescribeCacheAnalysisJobResponseBodyDataBigKeys>(model1);
      }
    }
    if (m.find("BigKeysOfNum") != m.end() && !m["BigKeysOfNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["BigKeysOfNum"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BigKeysOfNum"]));
        bigKeysOfNum = make_shared<DescribeCacheAnalysisJobResponseBodyDataBigKeysOfNum>(model1);
      }
    }
    if (m.find("ExpiryKeysLevelCount") != m.end() && !m["ExpiryKeysLevelCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExpiryKeysLevelCount"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExpiryKeysLevelCount"]));
        expiryKeysLevelCount = make_shared<DescribeCacheAnalysisJobResponseBodyDataExpiryKeysLevelCount>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("KeyPrefixes") != m.end() && !m["KeyPrefixes"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPrefixes"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPrefixes"]));
        keyPrefixes = make_shared<DescribeCacheAnalysisJobResponseBodyDataKeyPrefixes>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("UnexBigKeysOfBytes") != m.end() && !m["UnexBigKeysOfBytes"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnexBigKeysOfBytes"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnexBigKeysOfBytes"]));
        unexBigKeysOfBytes = make_shared<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfBytes>(model1);
      }
    }
    if (m.find("UnexBigKeysOfNum") != m.end() && !m["UnexBigKeysOfNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnexBigKeysOfNum"].type()) {
        DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnexBigKeysOfNum"]));
        unexBigKeysOfNum = make_shared<DescribeCacheAnalysisJobResponseBodyDataUnexBigKeysOfNum>(model1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBodyData() = default;
};
class DescribeCacheAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCacheAnalysisJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCacheAnalysisJobResponseBody() {}

  explicit DescribeCacheAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeCacheAnalysisJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeCacheAnalysisJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobResponseBody() = default;
};
class DescribeCacheAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCacheAnalysisJobResponseBody> body{};

  DescribeCacheAnalysisJobResponse() {}

  explicit DescribeCacheAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCacheAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCacheAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobResponse() = default;
};
class DescribeCacheAnalysisJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};

  DescribeCacheAnalysisJobsRequest() {}

  explicit DescribeCacheAnalysisJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobsRequest() = default;
};
class DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo : public Darabonba::Model {
public:
  shared_ptr<long> bytes{};
  shared_ptr<long> count{};
  shared_ptr<long> db{};
  shared_ptr<string> encoding{};
  shared_ptr<long> expirationTimeMillis{};
  shared_ptr<string> key{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> type{};

  DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo() {}

  explicit DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytes) {
      res["Bytes"] = boost::any(*bytes);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (expirationTimeMillis) {
      res["ExpirationTimeMillis"] = boost::any(*expirationTimeMillis);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bytes") != m.end() && !m["Bytes"].empty()) {
      bytes = make_shared<long>(boost::any_cast<long>(m["Bytes"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ExpirationTimeMillis") != m.end() && !m["ExpirationTimeMillis"].empty()) {
      expirationTimeMillis = make_shared<long>(boost::any_cast<long>(m["ExpirationTimeMillis"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo() = default;
};
class DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo>> keyInfo{};

  DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys() {}

  explicit DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*keyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyInfo"].type()) {
        vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyInfo = make_shared<vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeysKeyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys() = default;
};
class DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys> bigKeys{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> taskState{};

  DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob() {}

  explicit DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKeys) {
      res["BigKeys"] = bigKeys ? boost::any(bigKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKeys") != m.end() && !m["BigKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["BigKeys"].type()) {
        DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BigKeys"]));
        bigKeys = make_shared<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJobBigKeys>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob() = default;
};
class DescribeCacheAnalysisJobsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob>> cacheAnalysisJob{};

  DescribeCacheAnalysisJobsResponseBodyDataList() {}

  explicit DescribeCacheAnalysisJobsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheAnalysisJob) {
      vector<boost::any> temp1;
      for(auto item1:*cacheAnalysisJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheAnalysisJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheAnalysisJob") != m.end() && !m["CacheAnalysisJob"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheAnalysisJob"].type()) {
        vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheAnalysisJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheAnalysisJob = make_shared<vector<DescribeCacheAnalysisJobsResponseBodyDataListCacheAnalysisJob>>(expect1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBodyDataList() = default;
};
class DescribeCacheAnalysisJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<DescribeCacheAnalysisJobsResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeCacheAnalysisJobsResponseBodyData() {}

  explicit DescribeCacheAnalysisJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        DescribeCacheAnalysisJobsResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<DescribeCacheAnalysisJobsResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBodyData() = default;
};
class DescribeCacheAnalysisJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCacheAnalysisJobsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCacheAnalysisJobsResponseBody() {}

  explicit DescribeCacheAnalysisJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeCacheAnalysisJobsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeCacheAnalysisJobsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponseBody() = default;
};
class DescribeCacheAnalysisJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCacheAnalysisJobsResponseBody> body{};

  DescribeCacheAnalysisJobsResponse() {}

  explicit DescribeCacheAnalysisJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCacheAnalysisJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCacheAnalysisJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCacheAnalysisJobsResponse() = default;
};
class DescribeCloudBenchTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskType{};

  DescribeCloudBenchTasksRequest() {}

  explicit DescribeCloudBenchTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeCloudBenchTasksRequest() = default;
};
class DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks : public Darabonba::Model {
public:
  shared_ptr<string> archiveJobId{};
  shared_ptr<string> archiveOssTableName{};
  shared_ptr<long> archiveState{};
  shared_ptr<string> backupId{};
  shared_ptr<string> backupType{};
  shared_ptr<string> benchStep{};
  shared_ptr<string> benchStepStatus{};
  shared_ptr<string> clientGatewayId{};
  shared_ptr<string> clientType{};
  shared_ptr<string> description{};
  shared_ptr<string> dstInstanceUuid{};
  shared_ptr<string> dstIp{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> dstType{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<long> dtsJobState{};
  shared_ptr<string> dtsJobStatus{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> endState{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> external{};
  shared_ptr<long> rate{};
  shared_ptr<long> requestDuration{};
  shared_ptr<long> smartPressureTime{};
  shared_ptr<string> source{};
  shared_ptr<string> sqlCompleteReuse{};
  shared_ptr<string> srcInstanceArea{};
  shared_ptr<string> srcInstanceUuid{};
  shared_ptr<string> srcPublicIp{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<string> tableSchema{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> topic{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};
  shared_ptr<string> workDir{};

  DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks() {}

  explicit DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveJobId) {
      res["ArchiveJobId"] = boost::any(*archiveJobId);
    }
    if (archiveOssTableName) {
      res["ArchiveOssTableName"] = boost::any(*archiveOssTableName);
    }
    if (archiveState) {
      res["ArchiveState"] = boost::any(*archiveState);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (benchStep) {
      res["BenchStep"] = boost::any(*benchStep);
    }
    if (benchStepStatus) {
      res["BenchStepStatus"] = boost::any(*benchStepStatus);
    }
    if (clientGatewayId) {
      res["ClientGatewayId"] = boost::any(*clientGatewayId);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstInstanceUuid) {
      res["DstInstanceUuid"] = boost::any(*dstInstanceUuid);
    }
    if (dstIp) {
      res["DstIp"] = boost::any(*dstIp);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (dstType) {
      res["DstType"] = boost::any(*dstType);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (dtsJobState) {
      res["DtsJobState"] = boost::any(*dtsJobState);
    }
    if (dtsJobStatus) {
      res["DtsJobStatus"] = boost::any(*dtsJobStatus);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (endState) {
      res["EndState"] = boost::any(*endState);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (external) {
      res["External"] = boost::any(*external);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (requestDuration) {
      res["RequestDuration"] = boost::any(*requestDuration);
    }
    if (smartPressureTime) {
      res["SmartPressureTime"] = boost::any(*smartPressureTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sqlCompleteReuse) {
      res["SqlCompleteReuse"] = boost::any(*sqlCompleteReuse);
    }
    if (srcInstanceArea) {
      res["SrcInstanceArea"] = boost::any(*srcInstanceArea);
    }
    if (srcInstanceUuid) {
      res["SrcInstanceUuid"] = boost::any(*srcInstanceUuid);
    }
    if (srcPublicIp) {
      res["SrcPublicIp"] = boost::any(*srcPublicIp);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableSchema) {
      res["TableSchema"] = boost::any(*tableSchema);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (workDir) {
      res["WorkDir"] = boost::any(*workDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveJobId") != m.end() && !m["ArchiveJobId"].empty()) {
      archiveJobId = make_shared<string>(boost::any_cast<string>(m["ArchiveJobId"]));
    }
    if (m.find("ArchiveOssTableName") != m.end() && !m["ArchiveOssTableName"].empty()) {
      archiveOssTableName = make_shared<string>(boost::any_cast<string>(m["ArchiveOssTableName"]));
    }
    if (m.find("ArchiveState") != m.end() && !m["ArchiveState"].empty()) {
      archiveState = make_shared<long>(boost::any_cast<long>(m["ArchiveState"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("BenchStep") != m.end() && !m["BenchStep"].empty()) {
      benchStep = make_shared<string>(boost::any_cast<string>(m["BenchStep"]));
    }
    if (m.find("BenchStepStatus") != m.end() && !m["BenchStepStatus"].empty()) {
      benchStepStatus = make_shared<string>(boost::any_cast<string>(m["BenchStepStatus"]));
    }
    if (m.find("ClientGatewayId") != m.end() && !m["ClientGatewayId"].empty()) {
      clientGatewayId = make_shared<string>(boost::any_cast<string>(m["ClientGatewayId"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstInstanceUuid") != m.end() && !m["DstInstanceUuid"].empty()) {
      dstInstanceUuid = make_shared<string>(boost::any_cast<string>(m["DstInstanceUuid"]));
    }
    if (m.find("DstIp") != m.end() && !m["DstIp"].empty()) {
      dstIp = make_shared<string>(boost::any_cast<string>(m["DstIp"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("DstType") != m.end() && !m["DstType"].empty()) {
      dstType = make_shared<string>(boost::any_cast<string>(m["DstType"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("DtsJobState") != m.end() && !m["DtsJobState"].empty()) {
      dtsJobState = make_shared<long>(boost::any_cast<long>(m["DtsJobState"]));
    }
    if (m.find("DtsJobStatus") != m.end() && !m["DtsJobStatus"].empty()) {
      dtsJobStatus = make_shared<string>(boost::any_cast<string>(m["DtsJobStatus"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EndState") != m.end() && !m["EndState"].empty()) {
      endState = make_shared<string>(boost::any_cast<string>(m["EndState"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("External") != m.end() && !m["External"].empty()) {
      external = make_shared<string>(boost::any_cast<string>(m["External"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("RequestDuration") != m.end() && !m["RequestDuration"].empty()) {
      requestDuration = make_shared<long>(boost::any_cast<long>(m["RequestDuration"]));
    }
    if (m.find("SmartPressureTime") != m.end() && !m["SmartPressureTime"].empty()) {
      smartPressureTime = make_shared<long>(boost::any_cast<long>(m["SmartPressureTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SqlCompleteReuse") != m.end() && !m["SqlCompleteReuse"].empty()) {
      sqlCompleteReuse = make_shared<string>(boost::any_cast<string>(m["SqlCompleteReuse"]));
    }
    if (m.find("SrcInstanceArea") != m.end() && !m["SrcInstanceArea"].empty()) {
      srcInstanceArea = make_shared<string>(boost::any_cast<string>(m["SrcInstanceArea"]));
    }
    if (m.find("SrcInstanceUuid") != m.end() && !m["SrcInstanceUuid"].empty()) {
      srcInstanceUuid = make_shared<string>(boost::any_cast<string>(m["SrcInstanceUuid"]));
    }
    if (m.find("SrcPublicIp") != m.end() && !m["SrcPublicIp"].empty()) {
      srcPublicIp = make_shared<string>(boost::any_cast<string>(m["SrcPublicIp"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableSchema") != m.end() && !m["TableSchema"].empty()) {
      tableSchema = make_shared<string>(boost::any_cast<string>(m["TableSchema"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("WorkDir") != m.end() && !m["WorkDir"].empty()) {
      workDir = make_shared<string>(boost::any_cast<string>(m["WorkDir"]));
    }
  }


  virtual ~DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks() = default;
};
class DescribeCloudBenchTasksResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks>> cloudbenchTasks{};

  DescribeCloudBenchTasksResponseBodyDataList() {}

  explicit DescribeCloudBenchTasksResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudbenchTasks) {
      vector<boost::any> temp1;
      for(auto item1:*cloudbenchTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cloudbenchTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cloudbenchTasks") != m.end() && !m["cloudbenchTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["cloudbenchTasks"].type()) {
        vector<DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cloudbenchTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudbenchTasks = make_shared<vector<DescribeCloudBenchTasksResponseBodyDataListCloudbenchTasks>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudBenchTasksResponseBodyDataList() = default;
};
class DescribeCloudBenchTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<DescribeCloudBenchTasksResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeCloudBenchTasksResponseBodyData() {}

  explicit DescribeCloudBenchTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        DescribeCloudBenchTasksResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<DescribeCloudBenchTasksResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCloudBenchTasksResponseBodyData() = default;
};
class DescribeCloudBenchTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCloudBenchTasksResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCloudBenchTasksResponseBody() {}

  explicit DescribeCloudBenchTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeCloudBenchTasksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeCloudBenchTasksResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCloudBenchTasksResponseBody() = default;
};
class DescribeCloudBenchTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudBenchTasksResponseBody> body{};

  DescribeCloudBenchTasksResponse() {}

  explicit DescribeCloudBenchTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudBenchTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudBenchTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudBenchTasksResponse() = default;
};
class DescribeCloudbenchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribeCloudbenchTaskRequest() {}

  explicit DescribeCloudbenchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeCloudbenchTaskRequest() = default;
};
class DescribeCloudbenchTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> archiveJobId{};
  shared_ptr<string> archiveOssTableName{};
  shared_ptr<long> archiveState{};
  shared_ptr<string> backupId{};
  shared_ptr<string> backupType{};
  shared_ptr<string> benchStep{};
  shared_ptr<string> benchStepStatus{};
  shared_ptr<string> clientGatewayId{};
  shared_ptr<string> clientType{};
  shared_ptr<string> description{};
  shared_ptr<string> dstInstanceUuid{};
  shared_ptr<string> dstIp{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> dstType{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<long> dtsJobState{};
  shared_ptr<string> dtsJobStatus{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> endState{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> external{};
  shared_ptr<long> rate{};
  shared_ptr<long> requestDuration{};
  shared_ptr<long> smartPressureTime{};
  shared_ptr<string> source{};
  shared_ptr<string> sqlCompleteReuse{};
  shared_ptr<string> srcInstanceArea{};
  shared_ptr<string> srcInstanceUuid{};
  shared_ptr<string> srcPublicIp{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<string> tableSchema{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> topic{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};
  shared_ptr<string> workDir{};

  DescribeCloudbenchTaskResponseBodyData() {}

  explicit DescribeCloudbenchTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveJobId) {
      res["ArchiveJobId"] = boost::any(*archiveJobId);
    }
    if (archiveOssTableName) {
      res["ArchiveOssTableName"] = boost::any(*archiveOssTableName);
    }
    if (archiveState) {
      res["ArchiveState"] = boost::any(*archiveState);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (benchStep) {
      res["BenchStep"] = boost::any(*benchStep);
    }
    if (benchStepStatus) {
      res["BenchStepStatus"] = boost::any(*benchStepStatus);
    }
    if (clientGatewayId) {
      res["ClientGatewayId"] = boost::any(*clientGatewayId);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstInstanceUuid) {
      res["DstInstanceUuid"] = boost::any(*dstInstanceUuid);
    }
    if (dstIp) {
      res["DstIp"] = boost::any(*dstIp);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (dstType) {
      res["DstType"] = boost::any(*dstType);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (dtsJobState) {
      res["DtsJobState"] = boost::any(*dtsJobState);
    }
    if (dtsJobStatus) {
      res["DtsJobStatus"] = boost::any(*dtsJobStatus);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (endState) {
      res["EndState"] = boost::any(*endState);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (external) {
      res["External"] = boost::any(*external);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (requestDuration) {
      res["RequestDuration"] = boost::any(*requestDuration);
    }
    if (smartPressureTime) {
      res["SmartPressureTime"] = boost::any(*smartPressureTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sqlCompleteReuse) {
      res["SqlCompleteReuse"] = boost::any(*sqlCompleteReuse);
    }
    if (srcInstanceArea) {
      res["SrcInstanceArea"] = boost::any(*srcInstanceArea);
    }
    if (srcInstanceUuid) {
      res["SrcInstanceUuid"] = boost::any(*srcInstanceUuid);
    }
    if (srcPublicIp) {
      res["SrcPublicIp"] = boost::any(*srcPublicIp);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableSchema) {
      res["TableSchema"] = boost::any(*tableSchema);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (workDir) {
      res["WorkDir"] = boost::any(*workDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveJobId") != m.end() && !m["ArchiveJobId"].empty()) {
      archiveJobId = make_shared<string>(boost::any_cast<string>(m["ArchiveJobId"]));
    }
    if (m.find("ArchiveOssTableName") != m.end() && !m["ArchiveOssTableName"].empty()) {
      archiveOssTableName = make_shared<string>(boost::any_cast<string>(m["ArchiveOssTableName"]));
    }
    if (m.find("ArchiveState") != m.end() && !m["ArchiveState"].empty()) {
      archiveState = make_shared<long>(boost::any_cast<long>(m["ArchiveState"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("BenchStep") != m.end() && !m["BenchStep"].empty()) {
      benchStep = make_shared<string>(boost::any_cast<string>(m["BenchStep"]));
    }
    if (m.find("BenchStepStatus") != m.end() && !m["BenchStepStatus"].empty()) {
      benchStepStatus = make_shared<string>(boost::any_cast<string>(m["BenchStepStatus"]));
    }
    if (m.find("ClientGatewayId") != m.end() && !m["ClientGatewayId"].empty()) {
      clientGatewayId = make_shared<string>(boost::any_cast<string>(m["ClientGatewayId"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstInstanceUuid") != m.end() && !m["DstInstanceUuid"].empty()) {
      dstInstanceUuid = make_shared<string>(boost::any_cast<string>(m["DstInstanceUuid"]));
    }
    if (m.find("DstIp") != m.end() && !m["DstIp"].empty()) {
      dstIp = make_shared<string>(boost::any_cast<string>(m["DstIp"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("DstType") != m.end() && !m["DstType"].empty()) {
      dstType = make_shared<string>(boost::any_cast<string>(m["DstType"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("DtsJobState") != m.end() && !m["DtsJobState"].empty()) {
      dtsJobState = make_shared<long>(boost::any_cast<long>(m["DtsJobState"]));
    }
    if (m.find("DtsJobStatus") != m.end() && !m["DtsJobStatus"].empty()) {
      dtsJobStatus = make_shared<string>(boost::any_cast<string>(m["DtsJobStatus"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EndState") != m.end() && !m["EndState"].empty()) {
      endState = make_shared<string>(boost::any_cast<string>(m["EndState"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("External") != m.end() && !m["External"].empty()) {
      external = make_shared<string>(boost::any_cast<string>(m["External"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("RequestDuration") != m.end() && !m["RequestDuration"].empty()) {
      requestDuration = make_shared<long>(boost::any_cast<long>(m["RequestDuration"]));
    }
    if (m.find("SmartPressureTime") != m.end() && !m["SmartPressureTime"].empty()) {
      smartPressureTime = make_shared<long>(boost::any_cast<long>(m["SmartPressureTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SqlCompleteReuse") != m.end() && !m["SqlCompleteReuse"].empty()) {
      sqlCompleteReuse = make_shared<string>(boost::any_cast<string>(m["SqlCompleteReuse"]));
    }
    if (m.find("SrcInstanceArea") != m.end() && !m["SrcInstanceArea"].empty()) {
      srcInstanceArea = make_shared<string>(boost::any_cast<string>(m["SrcInstanceArea"]));
    }
    if (m.find("SrcInstanceUuid") != m.end() && !m["SrcInstanceUuid"].empty()) {
      srcInstanceUuid = make_shared<string>(boost::any_cast<string>(m["SrcInstanceUuid"]));
    }
    if (m.find("SrcPublicIp") != m.end() && !m["SrcPublicIp"].empty()) {
      srcPublicIp = make_shared<string>(boost::any_cast<string>(m["SrcPublicIp"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableSchema") != m.end() && !m["TableSchema"].empty()) {
      tableSchema = make_shared<string>(boost::any_cast<string>(m["TableSchema"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("WorkDir") != m.end() && !m["WorkDir"].empty()) {
      workDir = make_shared<string>(boost::any_cast<string>(m["WorkDir"]));
    }
  }


  virtual ~DescribeCloudbenchTaskResponseBodyData() = default;
};
class DescribeCloudbenchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCloudbenchTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCloudbenchTaskResponseBody() {}

  explicit DescribeCloudbenchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeCloudbenchTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeCloudbenchTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCloudbenchTaskResponseBody() = default;
};
class DescribeCloudbenchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudbenchTaskResponseBody> body{};

  DescribeCloudbenchTaskResponse() {}

  explicit DescribeCloudbenchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudbenchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudbenchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudbenchTaskResponse() = default;
};
class DescribeCloudbenchTaskConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribeCloudbenchTaskConfigRequest() {}

  explicit DescribeCloudbenchTaskConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeCloudbenchTaskConfigRequest() = default;
};
class DescribeCloudbenchTaskConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> archiveFolder{};
  shared_ptr<string> benchCmd{};
  shared_ptr<string> clientJarPath{};
  shared_ptr<string> jarOnOss{};
  shared_ptr<string> loadCmd{};
  shared_ptr<string> metaFileName{};
  shared_ptr<string> metaFileOnOss{};
  shared_ptr<string> metaFilePath{};
  shared_ptr<string> parseCmd{};
  shared_ptr<string> parseFilePath{};
  shared_ptr<string> rocksDbPath{};
  shared_ptr<string> sqlFileName{};
  shared_ptr<string> sqlFileOnOss{};
  shared_ptr<string> sqlFilePath{};
  shared_ptr<string> taskId{};
  shared_ptr<string> userId{};
  shared_ptr<string> workDir{};

  DescribeCloudbenchTaskConfigResponseBodyData() {}

  explicit DescribeCloudbenchTaskConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveFolder) {
      res["ArchiveFolder"] = boost::any(*archiveFolder);
    }
    if (benchCmd) {
      res["BenchCmd"] = boost::any(*benchCmd);
    }
    if (clientJarPath) {
      res["ClientJarPath"] = boost::any(*clientJarPath);
    }
    if (jarOnOss) {
      res["JarOnOss"] = boost::any(*jarOnOss);
    }
    if (loadCmd) {
      res["LoadCmd"] = boost::any(*loadCmd);
    }
    if (metaFileName) {
      res["MetaFileName"] = boost::any(*metaFileName);
    }
    if (metaFileOnOss) {
      res["MetaFileOnOss"] = boost::any(*metaFileOnOss);
    }
    if (metaFilePath) {
      res["MetaFilePath"] = boost::any(*metaFilePath);
    }
    if (parseCmd) {
      res["ParseCmd"] = boost::any(*parseCmd);
    }
    if (parseFilePath) {
      res["ParseFilePath"] = boost::any(*parseFilePath);
    }
    if (rocksDbPath) {
      res["RocksDbPath"] = boost::any(*rocksDbPath);
    }
    if (sqlFileName) {
      res["SqlFileName"] = boost::any(*sqlFileName);
    }
    if (sqlFileOnOss) {
      res["SqlFileOnOss"] = boost::any(*sqlFileOnOss);
    }
    if (sqlFilePath) {
      res["SqlFilePath"] = boost::any(*sqlFilePath);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workDir) {
      res["WorkDir"] = boost::any(*workDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveFolder") != m.end() && !m["ArchiveFolder"].empty()) {
      archiveFolder = make_shared<string>(boost::any_cast<string>(m["ArchiveFolder"]));
    }
    if (m.find("BenchCmd") != m.end() && !m["BenchCmd"].empty()) {
      benchCmd = make_shared<string>(boost::any_cast<string>(m["BenchCmd"]));
    }
    if (m.find("ClientJarPath") != m.end() && !m["ClientJarPath"].empty()) {
      clientJarPath = make_shared<string>(boost::any_cast<string>(m["ClientJarPath"]));
    }
    if (m.find("JarOnOss") != m.end() && !m["JarOnOss"].empty()) {
      jarOnOss = make_shared<string>(boost::any_cast<string>(m["JarOnOss"]));
    }
    if (m.find("LoadCmd") != m.end() && !m["LoadCmd"].empty()) {
      loadCmd = make_shared<string>(boost::any_cast<string>(m["LoadCmd"]));
    }
    if (m.find("MetaFileName") != m.end() && !m["MetaFileName"].empty()) {
      metaFileName = make_shared<string>(boost::any_cast<string>(m["MetaFileName"]));
    }
    if (m.find("MetaFileOnOss") != m.end() && !m["MetaFileOnOss"].empty()) {
      metaFileOnOss = make_shared<string>(boost::any_cast<string>(m["MetaFileOnOss"]));
    }
    if (m.find("MetaFilePath") != m.end() && !m["MetaFilePath"].empty()) {
      metaFilePath = make_shared<string>(boost::any_cast<string>(m["MetaFilePath"]));
    }
    if (m.find("ParseCmd") != m.end() && !m["ParseCmd"].empty()) {
      parseCmd = make_shared<string>(boost::any_cast<string>(m["ParseCmd"]));
    }
    if (m.find("ParseFilePath") != m.end() && !m["ParseFilePath"].empty()) {
      parseFilePath = make_shared<string>(boost::any_cast<string>(m["ParseFilePath"]));
    }
    if (m.find("RocksDbPath") != m.end() && !m["RocksDbPath"].empty()) {
      rocksDbPath = make_shared<string>(boost::any_cast<string>(m["RocksDbPath"]));
    }
    if (m.find("SqlFileName") != m.end() && !m["SqlFileName"].empty()) {
      sqlFileName = make_shared<string>(boost::any_cast<string>(m["SqlFileName"]));
    }
    if (m.find("SqlFileOnOss") != m.end() && !m["SqlFileOnOss"].empty()) {
      sqlFileOnOss = make_shared<string>(boost::any_cast<string>(m["SqlFileOnOss"]));
    }
    if (m.find("SqlFilePath") != m.end() && !m["SqlFilePath"].empty()) {
      sqlFilePath = make_shared<string>(boost::any_cast<string>(m["SqlFilePath"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkDir") != m.end() && !m["WorkDir"].empty()) {
      workDir = make_shared<string>(boost::any_cast<string>(m["WorkDir"]));
    }
  }


  virtual ~DescribeCloudbenchTaskConfigResponseBodyData() = default;
};
class DescribeCloudbenchTaskConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCloudbenchTaskConfigResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCloudbenchTaskConfigResponseBody() {}

  explicit DescribeCloudbenchTaskConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeCloudbenchTaskConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeCloudbenchTaskConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCloudbenchTaskConfigResponseBody() = default;
};
class DescribeCloudbenchTaskConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudbenchTaskConfigResponseBody> body{};

  DescribeCloudbenchTaskConfigResponse() {}

  explicit DescribeCloudbenchTaskConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudbenchTaskConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudbenchTaskConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudbenchTaskConfigResponse() = default;
};
class DescribeDiagnosticReportListRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};

  DescribeDiagnosticReportListRequest() {}

  explicit DescribeDiagnosticReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDiagnosticReportListRequest() = default;
};
class DescribeDiagnosticReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  DescribeDiagnosticReportListResponseBody() {}

  explicit DescribeDiagnosticReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~DescribeDiagnosticReportListResponseBody() = default;
};
class DescribeDiagnosticReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnosticReportListResponseBody> body{};

  DescribeDiagnosticReportListResponse() {}

  explicit DescribeDiagnosticReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnosticReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnosticReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportListResponse() = default;
};
class DescribeHotBigKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};

  DescribeHotBigKeysRequest() {}

  explicit DescribeHotBigKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeHotBigKeysRequest() = default;
};
class DescribeHotBigKeysResponseBodyDataBigKeysBigKey : public Darabonba::Model {
public:
  shared_ptr<long> db{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> size{};

  DescribeHotBigKeysResponseBodyDataBigKeysBigKey() {}

  explicit DescribeHotBigKeysResponseBodyDataBigKeysBigKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeHotBigKeysResponseBodyDataBigKeysBigKey() = default;
};
class DescribeHotBigKeysResponseBodyDataBigKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHotBigKeysResponseBodyDataBigKeysBigKey>> bigKey{};

  DescribeHotBigKeysResponseBodyDataBigKeys() {}

  explicit DescribeHotBigKeysResponseBodyDataBigKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKey) {
      vector<boost::any> temp1;
      for(auto item1:*bigKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BigKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKey") != m.end() && !m["BigKey"].empty()) {
      if (typeid(vector<boost::any>) == m["BigKey"].type()) {
        vector<DescribeHotBigKeysResponseBodyDataBigKeysBigKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BigKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHotBigKeysResponseBodyDataBigKeysBigKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bigKey = make_shared<vector<DescribeHotBigKeysResponseBodyDataBigKeysBigKey>>(expect1);
      }
    }
  }


  virtual ~DescribeHotBigKeysResponseBodyDataBigKeys() = default;
};
class DescribeHotBigKeysResponseBodyDataHotKeysHotKey : public Darabonba::Model {
public:
  shared_ptr<long> db{};
  shared_ptr<string> hot{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<long> lfu{};
  shared_ptr<string> nodeId{};

  DescribeHotBigKeysResponseBodyDataHotKeysHotKey() {}

  explicit DescribeHotBigKeysResponseBodyDataHotKeysHotKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (hot) {
      res["Hot"] = boost::any(*hot);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (lfu) {
      res["Lfu"] = boost::any(*lfu);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Hot") != m.end() && !m["Hot"].empty()) {
      hot = make_shared<string>(boost::any_cast<string>(m["Hot"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Lfu") != m.end() && !m["Lfu"].empty()) {
      lfu = make_shared<long>(boost::any_cast<long>(m["Lfu"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeHotBigKeysResponseBodyDataHotKeysHotKey() = default;
};
class DescribeHotBigKeysResponseBodyDataHotKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHotBigKeysResponseBodyDataHotKeysHotKey>> hotKey{};

  DescribeHotBigKeysResponseBodyDataHotKeys() {}

  explicit DescribeHotBigKeysResponseBodyDataHotKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotKey) {
      vector<boost::any> temp1;
      for(auto item1:*hotKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HotKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotKey") != m.end() && !m["HotKey"].empty()) {
      if (typeid(vector<boost::any>) == m["HotKey"].type()) {
        vector<DescribeHotBigKeysResponseBodyDataHotKeysHotKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HotKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHotBigKeysResponseBodyDataHotKeysHotKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotKey = make_shared<vector<DescribeHotBigKeysResponseBodyDataHotKeysHotKey>>(expect1);
      }
    }
  }


  virtual ~DescribeHotBigKeysResponseBodyDataHotKeys() = default;
};
class DescribeHotBigKeysResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bigKeyMsg{};
  shared_ptr<DescribeHotBigKeysResponseBodyDataBigKeys> bigKeys{};
  shared_ptr<string> hotKeyMsg{};
  shared_ptr<DescribeHotBigKeysResponseBodyDataHotKeys> hotKeys{};

  DescribeHotBigKeysResponseBodyData() {}

  explicit DescribeHotBigKeysResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKeyMsg) {
      res["BigKeyMsg"] = boost::any(*bigKeyMsg);
    }
    if (bigKeys) {
      res["BigKeys"] = bigKeys ? boost::any(bigKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotKeyMsg) {
      res["HotKeyMsg"] = boost::any(*hotKeyMsg);
    }
    if (hotKeys) {
      res["HotKeys"] = hotKeys ? boost::any(hotKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKeyMsg") != m.end() && !m["BigKeyMsg"].empty()) {
      bigKeyMsg = make_shared<string>(boost::any_cast<string>(m["BigKeyMsg"]));
    }
    if (m.find("BigKeys") != m.end() && !m["BigKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["BigKeys"].type()) {
        DescribeHotBigKeysResponseBodyDataBigKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BigKeys"]));
        bigKeys = make_shared<DescribeHotBigKeysResponseBodyDataBigKeys>(model1);
      }
    }
    if (m.find("HotKeyMsg") != m.end() && !m["HotKeyMsg"].empty()) {
      hotKeyMsg = make_shared<string>(boost::any_cast<string>(m["HotKeyMsg"]));
    }
    if (m.find("HotKeys") != m.end() && !m["HotKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotKeys"].type()) {
        DescribeHotBigKeysResponseBodyDataHotKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotKeys"]));
        hotKeys = make_shared<DescribeHotBigKeysResponseBodyDataHotKeys>(model1);
      }
    }
  }


  virtual ~DescribeHotBigKeysResponseBodyData() = default;
};
class DescribeHotBigKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeHotBigKeysResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeHotBigKeysResponseBody() {}

  explicit DescribeHotBigKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeHotBigKeysResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeHotBigKeysResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeHotBigKeysResponseBody() = default;
};
class DescribeHotBigKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHotBigKeysResponseBody> body{};

  DescribeHotBigKeysResponse() {}

  explicit DescribeHotBigKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHotBigKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHotBigKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHotBigKeysResponse() = default;
};
class DescribeHotKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};

  DescribeHotKeysRequest() {}

  explicit DescribeHotKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeHotKeysRequest() = default;
};
class DescribeHotKeysResponseBodyDataHotKey : public Darabonba::Model {
public:
  shared_ptr<long> db{};
  shared_ptr<string> hot{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<long> size{};

  DescribeHotKeysResponseBodyDataHotKey() {}

  explicit DescribeHotKeysResponseBodyDataHotKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (hot) {
      res["Hot"] = boost::any(*hot);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Hot") != m.end() && !m["Hot"].empty()) {
      hot = make_shared<string>(boost::any_cast<string>(m["Hot"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeHotKeysResponseBodyDataHotKey() = default;
};
class DescribeHotKeysResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHotKeysResponseBodyDataHotKey>> hotKey{};

  DescribeHotKeysResponseBodyData() {}

  explicit DescribeHotKeysResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotKey) {
      vector<boost::any> temp1;
      for(auto item1:*hotKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HotKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotKey") != m.end() && !m["HotKey"].empty()) {
      if (typeid(vector<boost::any>) == m["HotKey"].type()) {
        vector<DescribeHotKeysResponseBodyDataHotKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HotKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHotKeysResponseBodyDataHotKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotKey = make_shared<vector<DescribeHotKeysResponseBodyDataHotKey>>(expect1);
      }
    }
  }


  virtual ~DescribeHotKeysResponseBodyData() = default;
};
class DescribeHotKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeHotKeysResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeHotKeysResponseBody() {}

  explicit DescribeHotKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeHotKeysResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeHotKeysResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeHotKeysResponseBody() = default;
};
class DescribeHotKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHotKeysResponseBody> body{};

  DescribeHotKeysResponse() {}

  explicit DescribeHotKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHotKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHotKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHotKeysResponse() = default;
};
class DescribeInstanceDasProRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceDasProRequest() {}

  explicit DescribeInstanceDasProRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceDasProRequest() = default;
};
class DescribeInstanceDasProResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeInstanceDasProResponseBody() {}

  explicit DescribeInstanceDasProResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeInstanceDasProResponseBody() = default;
};
class DescribeInstanceDasProResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceDasProResponseBody> body{};

  DescribeInstanceDasProResponse() {}

  explicit DescribeInstanceDasProResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceDasProResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceDasProResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceDasProResponse() = default;
};
class DescribeSqlLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeSqlLogConfigRequest() {}

  explicit DescribeSqlLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeSqlLogConfigRequest() = default;
};
class DescribeSqlLogConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> coldEnable{};
  shared_ptr<long> coldRetention{};
  shared_ptr<long> coldStartTime{};
  shared_ptr<string> collectorVersion{};
  shared_ptr<bool> hotEnable{};
  shared_ptr<long> hotRetention{};
  shared_ptr<long> hotStartTime{};
  shared_ptr<string> logFilter{};
  shared_ptr<bool> requestEnable{};
  shared_ptr<long> requestStartTime{};
  shared_ptr<long> requestStopTime{};
  shared_ptr<long> retention{};
  shared_ptr<bool> sqlLogEnable{};
  shared_ptr<string> sqlLogSource{};
  shared_ptr<string> sqlLogState{};
  shared_ptr<long> sqlLogVisibleTime{};
  shared_ptr<bool> supportMigration{};
  shared_ptr<string> supportVersion{};
  shared_ptr<string> version{};

  DescribeSqlLogConfigResponseBodyData() {}

  explicit DescribeSqlLogConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldEnable) {
      res["ColdEnable"] = boost::any(*coldEnable);
    }
    if (coldRetention) {
      res["ColdRetention"] = boost::any(*coldRetention);
    }
    if (coldStartTime) {
      res["ColdStartTime"] = boost::any(*coldStartTime);
    }
    if (collectorVersion) {
      res["CollectorVersion"] = boost::any(*collectorVersion);
    }
    if (hotEnable) {
      res["HotEnable"] = boost::any(*hotEnable);
    }
    if (hotRetention) {
      res["HotRetention"] = boost::any(*hotRetention);
    }
    if (hotStartTime) {
      res["HotStartTime"] = boost::any(*hotStartTime);
    }
    if (logFilter) {
      res["LogFilter"] = boost::any(*logFilter);
    }
    if (requestEnable) {
      res["RequestEnable"] = boost::any(*requestEnable);
    }
    if (requestStartTime) {
      res["RequestStartTime"] = boost::any(*requestStartTime);
    }
    if (requestStopTime) {
      res["RequestStopTime"] = boost::any(*requestStopTime);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (sqlLogEnable) {
      res["SqlLogEnable"] = boost::any(*sqlLogEnable);
    }
    if (sqlLogSource) {
      res["SqlLogSource"] = boost::any(*sqlLogSource);
    }
    if (sqlLogState) {
      res["SqlLogState"] = boost::any(*sqlLogState);
    }
    if (sqlLogVisibleTime) {
      res["SqlLogVisibleTime"] = boost::any(*sqlLogVisibleTime);
    }
    if (supportMigration) {
      res["SupportMigration"] = boost::any(*supportMigration);
    }
    if (supportVersion) {
      res["SupportVersion"] = boost::any(*supportVersion);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdEnable") != m.end() && !m["ColdEnable"].empty()) {
      coldEnable = make_shared<bool>(boost::any_cast<bool>(m["ColdEnable"]));
    }
    if (m.find("ColdRetention") != m.end() && !m["ColdRetention"].empty()) {
      coldRetention = make_shared<long>(boost::any_cast<long>(m["ColdRetention"]));
    }
    if (m.find("ColdStartTime") != m.end() && !m["ColdStartTime"].empty()) {
      coldStartTime = make_shared<long>(boost::any_cast<long>(m["ColdStartTime"]));
    }
    if (m.find("CollectorVersion") != m.end() && !m["CollectorVersion"].empty()) {
      collectorVersion = make_shared<string>(boost::any_cast<string>(m["CollectorVersion"]));
    }
    if (m.find("HotEnable") != m.end() && !m["HotEnable"].empty()) {
      hotEnable = make_shared<bool>(boost::any_cast<bool>(m["HotEnable"]));
    }
    if (m.find("HotRetention") != m.end() && !m["HotRetention"].empty()) {
      hotRetention = make_shared<long>(boost::any_cast<long>(m["HotRetention"]));
    }
    if (m.find("HotStartTime") != m.end() && !m["HotStartTime"].empty()) {
      hotStartTime = make_shared<long>(boost::any_cast<long>(m["HotStartTime"]));
    }
    if (m.find("LogFilter") != m.end() && !m["LogFilter"].empty()) {
      logFilter = make_shared<string>(boost::any_cast<string>(m["LogFilter"]));
    }
    if (m.find("RequestEnable") != m.end() && !m["RequestEnable"].empty()) {
      requestEnable = make_shared<bool>(boost::any_cast<bool>(m["RequestEnable"]));
    }
    if (m.find("RequestStartTime") != m.end() && !m["RequestStartTime"].empty()) {
      requestStartTime = make_shared<long>(boost::any_cast<long>(m["RequestStartTime"]));
    }
    if (m.find("RequestStopTime") != m.end() && !m["RequestStopTime"].empty()) {
      requestStopTime = make_shared<long>(boost::any_cast<long>(m["RequestStopTime"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SqlLogEnable") != m.end() && !m["SqlLogEnable"].empty()) {
      sqlLogEnable = make_shared<bool>(boost::any_cast<bool>(m["SqlLogEnable"]));
    }
    if (m.find("SqlLogSource") != m.end() && !m["SqlLogSource"].empty()) {
      sqlLogSource = make_shared<string>(boost::any_cast<string>(m["SqlLogSource"]));
    }
    if (m.find("SqlLogState") != m.end() && !m["SqlLogState"].empty()) {
      sqlLogState = make_shared<string>(boost::any_cast<string>(m["SqlLogState"]));
    }
    if (m.find("SqlLogVisibleTime") != m.end() && !m["SqlLogVisibleTime"].empty()) {
      sqlLogVisibleTime = make_shared<long>(boost::any_cast<long>(m["SqlLogVisibleTime"]));
    }
    if (m.find("SupportMigration") != m.end() && !m["SupportMigration"].empty()) {
      supportMigration = make_shared<bool>(boost::any_cast<bool>(m["SupportMigration"]));
    }
    if (m.find("SupportVersion") != m.end() && !m["SupportVersion"].empty()) {
      supportVersion = make_shared<string>(boost::any_cast<string>(m["SupportVersion"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeSqlLogConfigResponseBodyData() = default;
};
class DescribeSqlLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSqlLogConfigResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSqlLogConfigResponseBody() {}

  explicit DescribeSqlLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSqlLogConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSqlLogConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSqlLogConfigResponseBody() = default;
};
class DescribeSqlLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSqlLogConfigResponseBody> body{};

  DescribeSqlLogConfigResponse() {}

  explicit DescribeSqlLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSqlLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSqlLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSqlLogConfigResponse() = default;
};
class DescribeSqlLogRecordsRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSqlLogRecordsRequestFilters() {}

  explicit DescribeSqlLogRecordsRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSqlLogRecordsRequestFilters() = default;
};
class DescribeSqlLogRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<DescribeSqlLogRecordsRequestFilters>> filters{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> role{};
  shared_ptr<long> startTime{};

  DescribeSqlLogRecordsRequest() {}

  explicit DescribeSqlLogRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<DescribeSqlLogRecordsRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogRecordsRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<DescribeSqlLogRecordsRequestFilters>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSqlLogRecordsRequest() = default;
};
class DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> collection{};
  shared_ptr<long> consume{};
  shared_ptr<long> cpuTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> executeTime{};
  shared_ptr<string> ext{};
  shared_ptr<long> frows{};
  shared_ptr<string> hostAddress{};
  shared_ptr<long> lockTime{};
  shared_ptr<long> logicRead{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> originTime{};
  shared_ptr<string> parallelDegree{};
  shared_ptr<string> parallelQueueTime{};
  shared_ptr<long> physicAsyncRead{};
  shared_ptr<long> physicRead{};
  shared_ptr<long> physicSyncRead{};
  shared_ptr<long> returnRows{};
  shared_ptr<long> rows{};
  shared_ptr<long> scanRows{};
  shared_ptr<long> scnt{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> state{};
  shared_ptr<long> threadId{};
  shared_ptr<string> traceId{};
  shared_ptr<string> trxId{};
  shared_ptr<long> updateRows{};
  shared_ptr<string> useImciEngine{};
  shared_ptr<string> vip{};
  shared_ptr<long> writes{};

  DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord() {}

  explicit DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (collection) {
      res["Collection"] = boost::any(*collection);
    }
    if (consume) {
      res["Consume"] = boost::any(*consume);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (frows) {
      res["Frows"] = boost::any(*frows);
    }
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (lockTime) {
      res["LockTime"] = boost::any(*lockTime);
    }
    if (logicRead) {
      res["LogicRead"] = boost::any(*logicRead);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (originTime) {
      res["OriginTime"] = boost::any(*originTime);
    }
    if (parallelDegree) {
      res["ParallelDegree"] = boost::any(*parallelDegree);
    }
    if (parallelQueueTime) {
      res["ParallelQueueTime"] = boost::any(*parallelQueueTime);
    }
    if (physicAsyncRead) {
      res["PhysicAsyncRead"] = boost::any(*physicAsyncRead);
    }
    if (physicRead) {
      res["PhysicRead"] = boost::any(*physicRead);
    }
    if (physicSyncRead) {
      res["PhysicSyncRead"] = boost::any(*physicSyncRead);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (scanRows) {
      res["ScanRows"] = boost::any(*scanRows);
    }
    if (scnt) {
      res["Scnt"] = boost::any(*scnt);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (threadId) {
      res["ThreadId"] = boost::any(*threadId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (trxId) {
      res["TrxId"] = boost::any(*trxId);
    }
    if (updateRows) {
      res["UpdateRows"] = boost::any(*updateRows);
    }
    if (useImciEngine) {
      res["UseImciEngine"] = boost::any(*useImciEngine);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    if (writes) {
      res["Writes"] = boost::any(*writes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("Collection") != m.end() && !m["Collection"].empty()) {
      collection = make_shared<string>(boost::any_cast<string>(m["Collection"]));
    }
    if (m.find("Consume") != m.end() && !m["Consume"].empty()) {
      consume = make_shared<long>(boost::any_cast<long>(m["Consume"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<long>(boost::any_cast<long>(m["CpuTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<string>(boost::any_cast<string>(m["ExecuteTime"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("Frows") != m.end() && !m["Frows"].empty()) {
      frows = make_shared<long>(boost::any_cast<long>(m["Frows"]));
    }
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("LockTime") != m.end() && !m["LockTime"].empty()) {
      lockTime = make_shared<long>(boost::any_cast<long>(m["LockTime"]));
    }
    if (m.find("LogicRead") != m.end() && !m["LogicRead"].empty()) {
      logicRead = make_shared<long>(boost::any_cast<long>(m["LogicRead"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OriginTime") != m.end() && !m["OriginTime"].empty()) {
      originTime = make_shared<long>(boost::any_cast<long>(m["OriginTime"]));
    }
    if (m.find("ParallelDegree") != m.end() && !m["ParallelDegree"].empty()) {
      parallelDegree = make_shared<string>(boost::any_cast<string>(m["ParallelDegree"]));
    }
    if (m.find("ParallelQueueTime") != m.end() && !m["ParallelQueueTime"].empty()) {
      parallelQueueTime = make_shared<string>(boost::any_cast<string>(m["ParallelQueueTime"]));
    }
    if (m.find("PhysicAsyncRead") != m.end() && !m["PhysicAsyncRead"].empty()) {
      physicAsyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicAsyncRead"]));
    }
    if (m.find("PhysicRead") != m.end() && !m["PhysicRead"].empty()) {
      physicRead = make_shared<long>(boost::any_cast<long>(m["PhysicRead"]));
    }
    if (m.find("PhysicSyncRead") != m.end() && !m["PhysicSyncRead"].empty()) {
      physicSyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicSyncRead"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      rows = make_shared<long>(boost::any_cast<long>(m["Rows"]));
    }
    if (m.find("ScanRows") != m.end() && !m["ScanRows"].empty()) {
      scanRows = make_shared<long>(boost::any_cast<long>(m["ScanRows"]));
    }
    if (m.find("Scnt") != m.end() && !m["Scnt"].empty()) {
      scnt = make_shared<long>(boost::any_cast<long>(m["Scnt"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ThreadId") != m.end() && !m["ThreadId"].empty()) {
      threadId = make_shared<long>(boost::any_cast<long>(m["ThreadId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("TrxId") != m.end() && !m["TrxId"].empty()) {
      trxId = make_shared<string>(boost::any_cast<string>(m["TrxId"]));
    }
    if (m.find("UpdateRows") != m.end() && !m["UpdateRows"].empty()) {
      updateRows = make_shared<long>(boost::any_cast<long>(m["UpdateRows"]));
    }
    if (m.find("UseImciEngine") != m.end() && !m["UseImciEngine"].empty()) {
      useImciEngine = make_shared<string>(boost::any_cast<string>(m["UseImciEngine"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
    if (m.find("Writes") != m.end() && !m["Writes"].empty()) {
      writes = make_shared<long>(boost::any_cast<long>(m["Writes"]));
    }
  }


  virtual ~DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord() = default;
};
class DescribeSqlLogRecordsResponseBodyDataItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord>> SQLLogRecord{};

  DescribeSqlLogRecordsResponseBodyDataItems() {}

  explicit DescribeSqlLogRecordsResponseBodyDataItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLLogRecord) {
      vector<boost::any> temp1;
      for(auto item1:*SQLLogRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLLogRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLLogRecord") != m.end() && !m["SQLLogRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLLogRecord"].type()) {
        vector<DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLLogRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLLogRecord = make_shared<vector<DescribeSqlLogRecordsResponseBodyDataItemsSQLLogRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeSqlLogRecordsResponseBodyDataItems() = default;
};
class DescribeSqlLogRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> finish{};
  shared_ptr<DescribeSqlLogRecordsResponseBodyDataItems> items{};
  shared_ptr<string> jobId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> totalRecords{};

  DescribeSqlLogRecordsResponseBodyData() {}

  explicit DescribeSqlLogRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (finish) {
      res["Finish"] = boost::any(*finish);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalRecords) {
      res["TotalRecords"] = boost::any(*totalRecords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Finish") != m.end() && !m["Finish"].empty()) {
      finish = make_shared<string>(boost::any_cast<string>(m["Finish"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSqlLogRecordsResponseBodyDataItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSqlLogRecordsResponseBodyDataItems>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TotalRecords") != m.end() && !m["TotalRecords"].empty()) {
      totalRecords = make_shared<long>(boost::any_cast<long>(m["TotalRecords"]));
    }
  }


  virtual ~DescribeSqlLogRecordsResponseBodyData() = default;
};
class DescribeSqlLogRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSqlLogRecordsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSqlLogRecordsResponseBody() {}

  explicit DescribeSqlLogRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSqlLogRecordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSqlLogRecordsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSqlLogRecordsResponseBody() = default;
};
class DescribeSqlLogRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSqlLogRecordsResponseBody> body{};

  DescribeSqlLogRecordsResponse() {}

  explicit DescribeSqlLogRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSqlLogRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSqlLogRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSqlLogRecordsResponse() = default;
};
class DescribeSqlLogStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeSqlLogStatisticRequest() {}

  explicit DescribeSqlLogStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeSqlLogStatisticRequest() = default;
};
class DescribeSqlLogStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> coldSqlSize{};
  shared_ptr<long> freeColdSqlSize{};
  shared_ptr<long> freeHotSqlSize{};
  shared_ptr<long> hotSqlSize{};
  shared_ptr<long> importSqlSize{};
  shared_ptr<long> timestamp{};

  DescribeSqlLogStatisticResponseBodyData() {}

  explicit DescribeSqlLogStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldSqlSize) {
      res["ColdSqlSize"] = boost::any(*coldSqlSize);
    }
    if (freeColdSqlSize) {
      res["FreeColdSqlSize"] = boost::any(*freeColdSqlSize);
    }
    if (freeHotSqlSize) {
      res["FreeHotSqlSize"] = boost::any(*freeHotSqlSize);
    }
    if (hotSqlSize) {
      res["HotSqlSize"] = boost::any(*hotSqlSize);
    }
    if (importSqlSize) {
      res["ImportSqlSize"] = boost::any(*importSqlSize);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdSqlSize") != m.end() && !m["ColdSqlSize"].empty()) {
      coldSqlSize = make_shared<long>(boost::any_cast<long>(m["ColdSqlSize"]));
    }
    if (m.find("FreeColdSqlSize") != m.end() && !m["FreeColdSqlSize"].empty()) {
      freeColdSqlSize = make_shared<long>(boost::any_cast<long>(m["FreeColdSqlSize"]));
    }
    if (m.find("FreeHotSqlSize") != m.end() && !m["FreeHotSqlSize"].empty()) {
      freeHotSqlSize = make_shared<long>(boost::any_cast<long>(m["FreeHotSqlSize"]));
    }
    if (m.find("HotSqlSize") != m.end() && !m["HotSqlSize"].empty()) {
      hotSqlSize = make_shared<long>(boost::any_cast<long>(m["HotSqlSize"]));
    }
    if (m.find("ImportSqlSize") != m.end() && !m["ImportSqlSize"].empty()) {
      importSqlSize = make_shared<long>(boost::any_cast<long>(m["ImportSqlSize"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeSqlLogStatisticResponseBodyData() = default;
};
class DescribeSqlLogStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSqlLogStatisticResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSqlLogStatisticResponseBody() {}

  explicit DescribeSqlLogStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSqlLogStatisticResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSqlLogStatisticResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSqlLogStatisticResponseBody() = default;
};
class DescribeSqlLogStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSqlLogStatisticResponseBody> body{};

  DescribeSqlLogStatisticResponse() {}

  explicit DescribeSqlLogStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSqlLogStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSqlLogStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSqlLogStatisticResponse() = default;
};
class DescribeSqlLogTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskId{};

  DescribeSqlLogTaskRequest() {}

  explicit DescribeSqlLogTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeSqlLogTaskRequest() = default;
};
class DescribeSqlLogTaskResponseBodyDataFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<boost::any> value{};

  DescribeSqlLogTaskResponseBodyDataFilters() {}

  explicit DescribeSqlLogTaskResponseBodyDataFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~DescribeSqlLogTaskResponseBodyDataFilters() = default;
};
class DescribeSqlLogTaskResponseBodyDataQueries : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> collection{};
  shared_ptr<long> consume{};
  shared_ptr<long> cpuTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> executeTime{};
  shared_ptr<string> ext{};
  shared_ptr<long> frows{};
  shared_ptr<string> hostAddress{};
  shared_ptr<long> lockTime{};
  shared_ptr<long> logicRead{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> originTime{};
  shared_ptr<string> parallelDegree{};
  shared_ptr<string> parallelQueueTime{};
  shared_ptr<long> physicAsyncRead{};
  shared_ptr<long> physicRead{};
  shared_ptr<long> physicSyncRead{};
  shared_ptr<long> returnRows{};
  shared_ptr<long> rows{};
  shared_ptr<long> scanRows{};
  shared_ptr<long> scnt{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> state{};
  shared_ptr<long> threadId{};
  shared_ptr<string> traceId{};
  shared_ptr<string> trxId{};
  shared_ptr<long> updateRows{};
  shared_ptr<string> useImciEngine{};
  shared_ptr<string> vip{};
  shared_ptr<long> writes{};

  DescribeSqlLogTaskResponseBodyDataQueries() {}

  explicit DescribeSqlLogTaskResponseBodyDataQueries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (collection) {
      res["Collection"] = boost::any(*collection);
    }
    if (consume) {
      res["Consume"] = boost::any(*consume);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (frows) {
      res["Frows"] = boost::any(*frows);
    }
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (lockTime) {
      res["LockTime"] = boost::any(*lockTime);
    }
    if (logicRead) {
      res["LogicRead"] = boost::any(*logicRead);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (originTime) {
      res["OriginTime"] = boost::any(*originTime);
    }
    if (parallelDegree) {
      res["ParallelDegree"] = boost::any(*parallelDegree);
    }
    if (parallelQueueTime) {
      res["ParallelQueueTime"] = boost::any(*parallelQueueTime);
    }
    if (physicAsyncRead) {
      res["PhysicAsyncRead"] = boost::any(*physicAsyncRead);
    }
    if (physicRead) {
      res["PhysicRead"] = boost::any(*physicRead);
    }
    if (physicSyncRead) {
      res["PhysicSyncRead"] = boost::any(*physicSyncRead);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (scanRows) {
      res["ScanRows"] = boost::any(*scanRows);
    }
    if (scnt) {
      res["Scnt"] = boost::any(*scnt);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (threadId) {
      res["ThreadId"] = boost::any(*threadId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (trxId) {
      res["TrxId"] = boost::any(*trxId);
    }
    if (updateRows) {
      res["UpdateRows"] = boost::any(*updateRows);
    }
    if (useImciEngine) {
      res["UseImciEngine"] = boost::any(*useImciEngine);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    if (writes) {
      res["Writes"] = boost::any(*writes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("Collection") != m.end() && !m["Collection"].empty()) {
      collection = make_shared<string>(boost::any_cast<string>(m["Collection"]));
    }
    if (m.find("Consume") != m.end() && !m["Consume"].empty()) {
      consume = make_shared<long>(boost::any_cast<long>(m["Consume"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<long>(boost::any_cast<long>(m["CpuTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<string>(boost::any_cast<string>(m["ExecuteTime"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("Frows") != m.end() && !m["Frows"].empty()) {
      frows = make_shared<long>(boost::any_cast<long>(m["Frows"]));
    }
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("LockTime") != m.end() && !m["LockTime"].empty()) {
      lockTime = make_shared<long>(boost::any_cast<long>(m["LockTime"]));
    }
    if (m.find("LogicRead") != m.end() && !m["LogicRead"].empty()) {
      logicRead = make_shared<long>(boost::any_cast<long>(m["LogicRead"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OriginTime") != m.end() && !m["OriginTime"].empty()) {
      originTime = make_shared<long>(boost::any_cast<long>(m["OriginTime"]));
    }
    if (m.find("ParallelDegree") != m.end() && !m["ParallelDegree"].empty()) {
      parallelDegree = make_shared<string>(boost::any_cast<string>(m["ParallelDegree"]));
    }
    if (m.find("ParallelQueueTime") != m.end() && !m["ParallelQueueTime"].empty()) {
      parallelQueueTime = make_shared<string>(boost::any_cast<string>(m["ParallelQueueTime"]));
    }
    if (m.find("PhysicAsyncRead") != m.end() && !m["PhysicAsyncRead"].empty()) {
      physicAsyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicAsyncRead"]));
    }
    if (m.find("PhysicRead") != m.end() && !m["PhysicRead"].empty()) {
      physicRead = make_shared<long>(boost::any_cast<long>(m["PhysicRead"]));
    }
    if (m.find("PhysicSyncRead") != m.end() && !m["PhysicSyncRead"].empty()) {
      physicSyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicSyncRead"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      rows = make_shared<long>(boost::any_cast<long>(m["Rows"]));
    }
    if (m.find("ScanRows") != m.end() && !m["ScanRows"].empty()) {
      scanRows = make_shared<long>(boost::any_cast<long>(m["ScanRows"]));
    }
    if (m.find("Scnt") != m.end() && !m["Scnt"].empty()) {
      scnt = make_shared<long>(boost::any_cast<long>(m["Scnt"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ThreadId") != m.end() && !m["ThreadId"].empty()) {
      threadId = make_shared<long>(boost::any_cast<long>(m["ThreadId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("TrxId") != m.end() && !m["TrxId"].empty()) {
      trxId = make_shared<string>(boost::any_cast<string>(m["TrxId"]));
    }
    if (m.find("UpdateRows") != m.end() && !m["UpdateRows"].empty()) {
      updateRows = make_shared<long>(boost::any_cast<long>(m["UpdateRows"]));
    }
    if (m.find("UseImciEngine") != m.end() && !m["UseImciEngine"].empty()) {
      useImciEngine = make_shared<string>(boost::any_cast<string>(m["UseImciEngine"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
    if (m.find("Writes") != m.end() && !m["Writes"].empty()) {
      writes = make_shared<long>(boost::any_cast<long>(m["Writes"]));
    }
  }


  virtual ~DescribeSqlLogTaskResponseBodyDataQueries() = default;
};
class DescribeSqlLogTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> end{};
  shared_ptr<bool> expire{};
  shared_ptr<string> export_{};
  shared_ptr<vector<DescribeSqlLogTaskResponseBodyDataFilters>> filters{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeSqlLogTaskResponseBodyDataQueries>> queries{};
  shared_ptr<long> start{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> total{};

  DescribeSqlLogTaskResponseBodyData() {}

  explicit DescribeSqlLogTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (export_) {
      res["Export"] = boost::any(*export_);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (queries) {
      vector<boost::any> temp1;
      for(auto item1:*queries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Queries"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<bool>(boost::any_cast<bool>(m["Expire"]));
    }
    if (m.find("Export") != m.end() && !m["Export"].empty()) {
      export_ = make_shared<string>(boost::any_cast<string>(m["Export"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<DescribeSqlLogTaskResponseBodyDataFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogTaskResponseBodyDataFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<DescribeSqlLogTaskResponseBodyDataFilters>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Queries") != m.end() && !m["Queries"].empty()) {
      if (typeid(vector<boost::any>) == m["Queries"].type()) {
        vector<DescribeSqlLogTaskResponseBodyDataQueries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Queries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogTaskResponseBodyDataQueries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queries = make_shared<vector<DescribeSqlLogTaskResponseBodyDataQueries>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeSqlLogTaskResponseBodyData() = default;
};
class DescribeSqlLogTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSqlLogTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSqlLogTaskResponseBody() {}

  explicit DescribeSqlLogTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSqlLogTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSqlLogTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSqlLogTaskResponseBody() = default;
};
class DescribeSqlLogTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSqlLogTaskResponseBody> body{};

  DescribeSqlLogTaskResponse() {}

  explicit DescribeSqlLogTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSqlLogTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSqlLogTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSqlLogTaskResponse() = default;
};
class DescribeSqlLogTasksRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSqlLogTasksRequestFilters() {}

  explicit DescribeSqlLogTasksRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSqlLogTasksRequestFilters() = default;
};
class DescribeSqlLogTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<DescribeSqlLogTasksRequestFilters>> filters{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  DescribeSqlLogTasksRequest() {}

  explicit DescribeSqlLogTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<DescribeSqlLogTasksRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogTasksRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<DescribeSqlLogTasksRequestFilters>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSqlLogTasksRequest() = default;
};
class DescribeSqlLogTasksResponseBodyDataListFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSqlLogTasksResponseBodyDataListFilters() {}

  explicit DescribeSqlLogTasksResponseBodyDataListFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSqlLogTasksResponseBodyDataListFilters() = default;
};
class DescribeSqlLogTasksResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> analysisTaskFinishTime{};
  shared_ptr<string> analysisTaskStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<long> end{};
  shared_ptr<bool> expire{};
  shared_ptr<vector<DescribeSqlLogTasksResponseBodyDataListFilters>> filters{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> logCount{};
  shared_ptr<string> name{};
  shared_ptr<long> progress{};
  shared_ptr<string> result{};
  shared_ptr<long> scanFileSize{};
  shared_ptr<long> start{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  DescribeSqlLogTasksResponseBodyDataList() {}

  explicit DescribeSqlLogTasksResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisTaskFinishTime) {
      res["AnalysisTaskFinishTime"] = boost::any(*analysisTaskFinishTime);
    }
    if (analysisTaskStatus) {
      res["AnalysisTaskStatus"] = boost::any(*analysisTaskStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (scanFileSize) {
      res["ScanFileSize"] = boost::any(*scanFileSize);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisTaskFinishTime") != m.end() && !m["AnalysisTaskFinishTime"].empty()) {
      analysisTaskFinishTime = make_shared<long>(boost::any_cast<long>(m["AnalysisTaskFinishTime"]));
    }
    if (m.find("AnalysisTaskStatus") != m.end() && !m["AnalysisTaskStatus"].empty()) {
      analysisTaskStatus = make_shared<string>(boost::any_cast<string>(m["AnalysisTaskStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<bool>(boost::any_cast<bool>(m["Expire"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<DescribeSqlLogTasksResponseBodyDataListFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogTasksResponseBodyDataListFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<DescribeSqlLogTasksResponseBodyDataListFilters>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ScanFileSize") != m.end() && !m["ScanFileSize"].empty()) {
      scanFileSize = make_shared<long>(boost::any_cast<long>(m["ScanFileSize"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeSqlLogTasksResponseBodyDataList() = default;
};
class DescribeSqlLogTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSqlLogTasksResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeSqlLogTasksResponseBodyData() {}

  explicit DescribeSqlLogTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeSqlLogTasksResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSqlLogTasksResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeSqlLogTasksResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeSqlLogTasksResponseBodyData() = default;
};
class DescribeSqlLogTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSqlLogTasksResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSqlLogTasksResponseBody() {}

  explicit DescribeSqlLogTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSqlLogTasksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSqlLogTasksResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSqlLogTasksResponseBody() = default;
};
class DescribeSqlLogTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSqlLogTasksResponseBody> body{};

  DescribeSqlLogTasksResponse() {}

  explicit DescribeSqlLogTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSqlLogTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSqlLogTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSqlLogTasksResponse() = default;
};
class DescribeTopBigKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> startTime{};

  DescribeTopBigKeysRequest() {}

  explicit DescribeTopBigKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeTopBigKeysRequest() = default;
};
class DescribeTopBigKeysResponseBodyDataBigKey : public Darabonba::Model {
public:
  shared_ptr<long> db{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> size{};

  DescribeTopBigKeysResponseBodyDataBigKey() {}

  explicit DescribeTopBigKeysResponseBodyDataBigKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeTopBigKeysResponseBodyDataBigKey() = default;
};
class DescribeTopBigKeysResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTopBigKeysResponseBodyDataBigKey>> bigKey{};

  DescribeTopBigKeysResponseBodyData() {}

  explicit DescribeTopBigKeysResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bigKey) {
      vector<boost::any> temp1;
      for(auto item1:*bigKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BigKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BigKey") != m.end() && !m["BigKey"].empty()) {
      if (typeid(vector<boost::any>) == m["BigKey"].type()) {
        vector<DescribeTopBigKeysResponseBodyDataBigKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BigKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTopBigKeysResponseBodyDataBigKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bigKey = make_shared<vector<DescribeTopBigKeysResponseBodyDataBigKey>>(expect1);
      }
    }
  }


  virtual ~DescribeTopBigKeysResponseBodyData() = default;
};
class DescribeTopBigKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeTopBigKeysResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeTopBigKeysResponseBody() {}

  explicit DescribeTopBigKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeTopBigKeysResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeTopBigKeysResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeTopBigKeysResponseBody() = default;
};
class DescribeTopBigKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTopBigKeysResponseBody> body{};

  DescribeTopBigKeysResponse() {}

  explicit DescribeTopBigKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTopBigKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTopBigKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTopBigKeysResponse() = default;
};
class DescribeTopHotKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> startTime{};

  DescribeTopHotKeysRequest() {}

  explicit DescribeTopHotKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeTopHotKeysRequest() = default;
};
class DescribeTopHotKeysResponseBodyDataHotKey : public Darabonba::Model {
public:
  shared_ptr<long> db{};
  shared_ptr<string> hot{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<long> lfu{};
  shared_ptr<string> nodeId{};

  DescribeTopHotKeysResponseBodyDataHotKey() {}

  explicit DescribeTopHotKeysResponseBodyDataHotKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (hot) {
      res["Hot"] = boost::any(*hot);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (lfu) {
      res["Lfu"] = boost::any(*lfu);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Hot") != m.end() && !m["Hot"].empty()) {
      hot = make_shared<string>(boost::any_cast<string>(m["Hot"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Lfu") != m.end() && !m["Lfu"].empty()) {
      lfu = make_shared<long>(boost::any_cast<long>(m["Lfu"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeTopHotKeysResponseBodyDataHotKey() = default;
};
class DescribeTopHotKeysResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTopHotKeysResponseBodyDataHotKey>> hotKey{};

  DescribeTopHotKeysResponseBodyData() {}

  explicit DescribeTopHotKeysResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotKey) {
      vector<boost::any> temp1;
      for(auto item1:*hotKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HotKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotKey") != m.end() && !m["HotKey"].empty()) {
      if (typeid(vector<boost::any>) == m["HotKey"].type()) {
        vector<DescribeTopHotKeysResponseBodyDataHotKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HotKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTopHotKeysResponseBodyDataHotKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotKey = make_shared<vector<DescribeTopHotKeysResponseBodyDataHotKey>>(expect1);
      }
    }
  }


  virtual ~DescribeTopHotKeysResponseBodyData() = default;
};
class DescribeTopHotKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeTopHotKeysResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeTopHotKeysResponseBody() {}

  explicit DescribeTopHotKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeTopHotKeysResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeTopHotKeysResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeTopHotKeysResponseBody() = default;
};
class DescribeTopHotKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTopHotKeysResponseBody> body{};

  DescribeTopHotKeysResponse() {}

  explicit DescribeTopHotKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTopHotKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTopHotKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTopHotKeysResponse() = default;
};
class DisableAllSqlConcurrencyControlRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};

  DisableAllSqlConcurrencyControlRulesRequest() {}

  explicit DisableAllSqlConcurrencyControlRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableAllSqlConcurrencyControlRulesRequest() = default;
};
class DisableAllSqlConcurrencyControlRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DisableAllSqlConcurrencyControlRulesResponseBody() {}

  explicit DisableAllSqlConcurrencyControlRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DisableAllSqlConcurrencyControlRulesResponseBody() = default;
};
class DisableAllSqlConcurrencyControlRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableAllSqlConcurrencyControlRulesResponseBody> body{};

  DisableAllSqlConcurrencyControlRulesResponse() {}

  explicit DisableAllSqlConcurrencyControlRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableAllSqlConcurrencyControlRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableAllSqlConcurrencyControlRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DisableAllSqlConcurrencyControlRulesResponse() = default;
};
class DisableAutoResourceOptimizeRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceIds{};

  DisableAutoResourceOptimizeRulesRequest() {}

  explicit DisableAutoResourceOptimizeRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesRequest() = default;
};
class DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};

  DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList() {}

  explicit DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList() = default;
};
class DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> instanceId{};

  DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList() {}

  explicit DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList() = default;
};
class DisableAutoResourceOptimizeRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configFailInstanceCount{};
  shared_ptr<vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList>> configFailInstanceList{};
  shared_ptr<long> configSuccessInstanceCount{};
  shared_ptr<vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList>> configSuccessInstanceList{};
  shared_ptr<long> totalInstanceCount{};

  DisableAutoResourceOptimizeRulesResponseBodyData() {}

  explicit DisableAutoResourceOptimizeRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFailInstanceCount) {
      res["ConfigFailInstanceCount"] = boost::any(*configFailInstanceCount);
    }
    if (configFailInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configFailInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFailInstanceList"] = boost::any(temp1);
    }
    if (configSuccessInstanceCount) {
      res["ConfigSuccessInstanceCount"] = boost::any(*configSuccessInstanceCount);
    }
    if (configSuccessInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configSuccessInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigSuccessInstanceList"] = boost::any(temp1);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFailInstanceCount") != m.end() && !m["ConfigFailInstanceCount"].empty()) {
      configFailInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigFailInstanceCount"]));
    }
    if (m.find("ConfigFailInstanceList") != m.end() && !m["ConfigFailInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFailInstanceList"].type()) {
        vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFailInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFailInstanceList = make_shared<vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigFailInstanceList>>(expect1);
      }
    }
    if (m.find("ConfigSuccessInstanceCount") != m.end() && !m["ConfigSuccessInstanceCount"].empty()) {
      configSuccessInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigSuccessInstanceCount"]));
    }
    if (m.find("ConfigSuccessInstanceList") != m.end() && !m["ConfigSuccessInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigSuccessInstanceList"].type()) {
        vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigSuccessInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configSuccessInstanceList = make_shared<vector<DisableAutoResourceOptimizeRulesResponseBodyDataConfigSuccessInstanceList>>(expect1);
      }
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesResponseBodyData() = default;
};
class DisableAutoResourceOptimizeRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DisableAutoResourceOptimizeRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableAutoResourceOptimizeRulesResponseBody() {}

  explicit DisableAutoResourceOptimizeRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DisableAutoResourceOptimizeRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DisableAutoResourceOptimizeRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesResponseBody() = default;
};
class DisableAutoResourceOptimizeRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableAutoResourceOptimizeRulesResponseBody> body{};

  DisableAutoResourceOptimizeRulesResponse() {}

  explicit DisableAutoResourceOptimizeRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableAutoResourceOptimizeRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableAutoResourceOptimizeRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DisableAutoResourceOptimizeRulesResponse() = default;
};
class DisableAutoThrottleRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceIds{};

  DisableAutoThrottleRulesRequest() {}

  explicit DisableAutoThrottleRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DisableAutoThrottleRulesRequest() = default;
};
class DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};

  DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList() {}

  explicit DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList() = default;
};
class DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> instanceId{};

  DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList() {}

  explicit DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList() = default;
};
class DisableAutoThrottleRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configFailInstanceCount{};
  shared_ptr<vector<DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList>> configFailInstanceList{};
  shared_ptr<long> configSuccessInstanceCount{};
  shared_ptr<vector<DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList>> configSuccessInstanceList{};
  shared_ptr<long> totalInstanceCount{};

  DisableAutoThrottleRulesResponseBodyData() {}

  explicit DisableAutoThrottleRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFailInstanceCount) {
      res["ConfigFailInstanceCount"] = boost::any(*configFailInstanceCount);
    }
    if (configFailInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configFailInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFailInstanceList"] = boost::any(temp1);
    }
    if (configSuccessInstanceCount) {
      res["ConfigSuccessInstanceCount"] = boost::any(*configSuccessInstanceCount);
    }
    if (configSuccessInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configSuccessInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigSuccessInstanceList"] = boost::any(temp1);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFailInstanceCount") != m.end() && !m["ConfigFailInstanceCount"].empty()) {
      configFailInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigFailInstanceCount"]));
    }
    if (m.find("ConfigFailInstanceList") != m.end() && !m["ConfigFailInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFailInstanceList"].type()) {
        vector<DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFailInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFailInstanceList = make_shared<vector<DisableAutoThrottleRulesResponseBodyDataConfigFailInstanceList>>(expect1);
      }
    }
    if (m.find("ConfigSuccessInstanceCount") != m.end() && !m["ConfigSuccessInstanceCount"].empty()) {
      configSuccessInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigSuccessInstanceCount"]));
    }
    if (m.find("ConfigSuccessInstanceList") != m.end() && !m["ConfigSuccessInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigSuccessInstanceList"].type()) {
        vector<DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigSuccessInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configSuccessInstanceList = make_shared<vector<DisableAutoThrottleRulesResponseBodyDataConfigSuccessInstanceList>>(expect1);
      }
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
  }


  virtual ~DisableAutoThrottleRulesResponseBodyData() = default;
};
class DisableAutoThrottleRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DisableAutoThrottleRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableAutoThrottleRulesResponseBody() {}

  explicit DisableAutoThrottleRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DisableAutoThrottleRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DisableAutoThrottleRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableAutoThrottleRulesResponseBody() = default;
};
class DisableAutoThrottleRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableAutoThrottleRulesResponseBody> body{};

  DisableAutoThrottleRulesResponse() {}

  explicit DisableAutoThrottleRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableAutoThrottleRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableAutoThrottleRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DisableAutoThrottleRulesResponse() = default;
};
class DisableDasProRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  DisableDasProRequest() {}

  explicit DisableDasProRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DisableDasProRequest() = default;
};
class DisableDasProResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  DisableDasProResponseBody() {}

  explicit DisableDasProResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~DisableDasProResponseBody() = default;
};
class DisableDasProResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableDasProResponseBody> body{};

  DisableDasProResponse() {}

  explicit DisableDasProResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDasProResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDasProResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDasProResponse() = default;
};
class DisableInstanceDasConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scaleType{};

  DisableInstanceDasConfigRequest() {}

  explicit DisableInstanceDasConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
  }


  virtual ~DisableInstanceDasConfigRequest() = default;
};
class DisableInstanceDasConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DisableInstanceDasConfigResponseBody() {}

  explicit DisableInstanceDasConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DisableInstanceDasConfigResponseBody() = default;
};
class DisableInstanceDasConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableInstanceDasConfigResponseBody> body{};

  DisableInstanceDasConfigResponse() {}

  explicit DisableInstanceDasConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableInstanceDasConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableInstanceDasConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DisableInstanceDasConfigResponse() = default;
};
class DisableSqlConcurrencyControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> itemId{};

  DisableSqlConcurrencyControlRequest() {}

  explicit DisableSqlConcurrencyControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
  }


  virtual ~DisableSqlConcurrencyControlRequest() = default;
};
class DisableSqlConcurrencyControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DisableSqlConcurrencyControlResponseBody() {}

  explicit DisableSqlConcurrencyControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DisableSqlConcurrencyControlResponseBody() = default;
};
class DisableSqlConcurrencyControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSqlConcurrencyControlResponseBody> body{};

  DisableSqlConcurrencyControlResponse() {}

  explicit DisableSqlConcurrencyControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSqlConcurrencyControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSqlConcurrencyControlResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSqlConcurrencyControlResponse() = default;
};
class EnableDasProRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> sqlRetention{};
  shared_ptr<string> userId{};

  EnableDasProRequest() {}

  explicit EnableDasProRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlRetention) {
      res["SqlRetention"] = boost::any(*sqlRetention);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlRetention") != m.end() && !m["SqlRetention"].empty()) {
      sqlRetention = make_shared<long>(boost::any_cast<long>(m["SqlRetention"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EnableDasProRequest() = default;
};
class EnableDasProResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  EnableDasProResponseBody() {}

  explicit EnableDasProResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~EnableDasProResponseBody() = default;
};
class EnableDasProResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableDasProResponseBody> body{};

  EnableDasProResponse() {}

  explicit EnableDasProResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDasProResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDasProResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDasProResponse() = default;
};
class EnableSqlConcurrencyControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrencyControlTime{};
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxConcurrency{};
  shared_ptr<string> sqlKeywords{};
  shared_ptr<string> sqlType{};

  EnableSqlConcurrencyControlRequest() {}

  explicit EnableSqlConcurrencyControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrencyControlTime) {
      res["ConcurrencyControlTime"] = boost::any(*concurrencyControlTime);
    }
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxConcurrency) {
      res["MaxConcurrency"] = boost::any(*maxConcurrency);
    }
    if (sqlKeywords) {
      res["SqlKeywords"] = boost::any(*sqlKeywords);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrencyControlTime") != m.end() && !m["ConcurrencyControlTime"].empty()) {
      concurrencyControlTime = make_shared<long>(boost::any_cast<long>(m["ConcurrencyControlTime"]));
    }
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxConcurrency") != m.end() && !m["MaxConcurrency"].empty()) {
      maxConcurrency = make_shared<long>(boost::any_cast<long>(m["MaxConcurrency"]));
    }
    if (m.find("SqlKeywords") != m.end() && !m["SqlKeywords"].empty()) {
      sqlKeywords = make_shared<string>(boost::any_cast<string>(m["SqlKeywords"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
  }


  virtual ~EnableSqlConcurrencyControlRequest() = default;
};
class EnableSqlConcurrencyControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  EnableSqlConcurrencyControlResponseBody() {}

  explicit EnableSqlConcurrencyControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~EnableSqlConcurrencyControlResponseBody() = default;
};
class EnableSqlConcurrencyControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSqlConcurrencyControlResponseBody> body{};

  EnableSqlConcurrencyControlResponse() {}

  explicit EnableSqlConcurrencyControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSqlConcurrencyControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSqlConcurrencyControlResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSqlConcurrencyControlResponse() = default;
};
class GetAsyncErrorRequestListByCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> start{};

  GetAsyncErrorRequestListByCodeRequest() {}

  explicit GetAsyncErrorRequestListByCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~GetAsyncErrorRequestListByCodeRequest() = default;
};
class GetAsyncErrorRequestListByCodeResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};

  GetAsyncErrorRequestListByCodeResponseBodyDataResult() {}

  explicit GetAsyncErrorRequestListByCodeResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["sqlId"] = boost::any(*sqlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("sqlId") != m.end() && !m["sqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["sqlId"]));
    }
  }


  virtual ~GetAsyncErrorRequestListByCodeResponseBodyDataResult() = default;
};
class GetAsyncErrorRequestListByCodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<vector<GetAsyncErrorRequestListByCodeResponseBodyDataResult>> result{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  GetAsyncErrorRequestListByCodeResponseBodyData() {}

  explicit GetAsyncErrorRequestListByCodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["complete"] = boost::any(*complete);
    }
    if (fail) {
      res["fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["isFinish"] = boost::any(*isFinish);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (resultId) {
      res["resultId"] = boost::any(*resultId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("complete") != m.end() && !m["complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["complete"]));
    }
    if (m.find("fail") != m.end() && !m["fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["fail"]));
    }
    if (m.find("isFinish") != m.end() && !m["isFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["isFinish"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetAsyncErrorRequestListByCodeResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAsyncErrorRequestListByCodeResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetAsyncErrorRequestListByCodeResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("resultId") != m.end() && !m["resultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["resultId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~GetAsyncErrorRequestListByCodeResponseBodyData() = default;
};
class GetAsyncErrorRequestListByCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAsyncErrorRequestListByCodeResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAsyncErrorRequestListByCodeResponseBody() {}

  explicit GetAsyncErrorRequestListByCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAsyncErrorRequestListByCodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAsyncErrorRequestListByCodeResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAsyncErrorRequestListByCodeResponseBody() = default;
};
class GetAsyncErrorRequestListByCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAsyncErrorRequestListByCodeResponseBody> body{};

  GetAsyncErrorRequestListByCodeResponse() {}

  explicit GetAsyncErrorRequestListByCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAsyncErrorRequestListByCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAsyncErrorRequestListByCodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAsyncErrorRequestListByCodeResponse() = default;
};
class GetAsyncErrorRequestStatByCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> start{};

  GetAsyncErrorRequestStatByCodeRequest() {}

  explicit GetAsyncErrorRequestStatByCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatByCodeRequest() = default;
};
class GetAsyncErrorRequestStatByCodeResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceId{};

  GetAsyncErrorRequestStatByCodeResponseBodyDataResult() {}

  explicit GetAsyncErrorRequestStatByCodeResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatByCodeResponseBodyDataResult() = default;
};
class GetAsyncErrorRequestStatByCodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<vector<GetAsyncErrorRequestStatByCodeResponseBodyDataResult>> result{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  GetAsyncErrorRequestStatByCodeResponseBodyData() {}

  explicit GetAsyncErrorRequestStatByCodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["complete"] = boost::any(*complete);
    }
    if (fail) {
      res["fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["isFinish"] = boost::any(*isFinish);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (resultId) {
      res["resultId"] = boost::any(*resultId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("complete") != m.end() && !m["complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["complete"]));
    }
    if (m.find("fail") != m.end() && !m["fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["fail"]));
    }
    if (m.find("isFinish") != m.end() && !m["isFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["isFinish"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetAsyncErrorRequestStatByCodeResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAsyncErrorRequestStatByCodeResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetAsyncErrorRequestStatByCodeResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("resultId") != m.end() && !m["resultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["resultId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatByCodeResponseBodyData() = default;
};
class GetAsyncErrorRequestStatByCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAsyncErrorRequestStatByCodeResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAsyncErrorRequestStatByCodeResponseBody() {}

  explicit GetAsyncErrorRequestStatByCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAsyncErrorRequestStatByCodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAsyncErrorRequestStatByCodeResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatByCodeResponseBody() = default;
};
class GetAsyncErrorRequestStatByCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAsyncErrorRequestStatByCodeResponseBody> body{};

  GetAsyncErrorRequestStatByCodeResponse() {}

  explicit GetAsyncErrorRequestStatByCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAsyncErrorRequestStatByCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAsyncErrorRequestStatByCodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAsyncErrorRequestStatByCodeResponse() = default;
};
class GetAsyncErrorRequestStatResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sqlIdList{};
  shared_ptr<long> start{};

  GetAsyncErrorRequestStatResultRequest() {}

  explicit GetAsyncErrorRequestStatResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sqlIdList) {
      res["SqlIdList"] = boost::any(*sqlIdList);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SqlIdList") != m.end() && !m["SqlIdList"].empty()) {
      sqlIdList = make_shared<string>(boost::any_cast<string>(m["SqlIdList"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatResultRequest() = default;
};
class GetAsyncErrorRequestStatResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<vector<map<string, DataResultValue>>> result{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  GetAsyncErrorRequestStatResultResponseBodyData() {}

  explicit GetAsyncErrorRequestStatResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["complete"] = boost::any(*complete);
    }
    if (fail) {
      res["fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["isFinish"] = boost::any(*isFinish);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        map<string, boost::any> temp2;
        for(auto item2:item1){
          temp2[item2.first] = boost::any(item2.second.toMap());
        }
        temp1 = boost::any(temp2);
      }
      res["result"] = boost::any(temp1);
    }
    if (resultId) {
      res["resultId"] = boost::any(*resultId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("complete") != m.end() && !m["complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["complete"]));
    }
    if (m.find("fail") != m.end() && !m["fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["fail"]));
    }
    if (m.find("isFinish") != m.end() && !m["isFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["isFinish"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<map<string, DataResultValue>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            map<string, DataResultValue> expect2;
            for(auto item2:boost::any_cast<map<string, boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.second.type()) {
                DataResultValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2.second));
                expect2[item2.first] = model3;
              }
            }
            expect1.push_back(expect2);
          }
        }
        result = make_shared<vector<map<string, DataResultValue>>>(expect1);
      }
    }
    if (m.find("resultId") != m.end() && !m["resultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["resultId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatResultResponseBodyData() = default;
};
class GetAsyncErrorRequestStatResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAsyncErrorRequestStatResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAsyncErrorRequestStatResultResponseBody() {}

  explicit GetAsyncErrorRequestStatResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAsyncErrorRequestStatResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAsyncErrorRequestStatResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAsyncErrorRequestStatResultResponseBody() = default;
};
class GetAsyncErrorRequestStatResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAsyncErrorRequestStatResultResponseBody> body{};

  GetAsyncErrorRequestStatResultResponse() {}

  explicit GetAsyncErrorRequestStatResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAsyncErrorRequestStatResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAsyncErrorRequestStatResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetAsyncErrorRequestStatResultResponse() = default;
};
class GetAutoIncrementUsageStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> ratioFilter{};
  shared_ptr<bool> realTime{};

  GetAutoIncrementUsageStatisticRequest() {}

  explicit GetAutoIncrementUsageStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ratioFilter) {
      res["RatioFilter"] = boost::any(*ratioFilter);
    }
    if (realTime) {
      res["RealTime"] = boost::any(*realTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RatioFilter") != m.end() && !m["RatioFilter"].empty()) {
      ratioFilter = make_shared<double>(boost::any_cast<double>(m["RatioFilter"]));
    }
    if (m.find("RealTime") != m.end() && !m["RealTime"].empty()) {
      realTime = make_shared<bool>(boost::any_cast<bool>(m["RealTime"]));
    }
  }


  virtual ~GetAutoIncrementUsageStatisticRequest() = default;
};
class GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList : public Darabonba::Model {
public:
  shared_ptr<long> autoIncrementCurrentValue{};
  shared_ptr<double> autoIncrementRatio{};
  shared_ptr<string> columnName{};
  shared_ptr<string> dbName{};
  shared_ptr<long> maximumValue{};
  shared_ptr<string> tableName{};

  GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList() {}

  explicit GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIncrementCurrentValue) {
      res["AutoIncrementCurrentValue"] = boost::any(*autoIncrementCurrentValue);
    }
    if (autoIncrementRatio) {
      res["AutoIncrementRatio"] = boost::any(*autoIncrementRatio);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (maximumValue) {
      res["MaximumValue"] = boost::any(*maximumValue);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIncrementCurrentValue") != m.end() && !m["AutoIncrementCurrentValue"].empty()) {
      autoIncrementCurrentValue = make_shared<long>(boost::any_cast<long>(m["AutoIncrementCurrentValue"]));
    }
    if (m.find("AutoIncrementRatio") != m.end() && !m["AutoIncrementRatio"].empty()) {
      autoIncrementRatio = make_shared<double>(boost::any_cast<double>(m["AutoIncrementRatio"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("MaximumValue") != m.end() && !m["MaximumValue"].empty()) {
      maximumValue = make_shared<long>(boost::any_cast<long>(m["MaximumValue"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList() = default;
};
class GetAutoIncrementUsageStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList>> autoIncrementUsageList{};
  shared_ptr<string> errorInfo{};
  shared_ptr<bool> finish{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> timestamp{};

  GetAutoIncrementUsageStatisticResponseBodyData() {}

  explicit GetAutoIncrementUsageStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIncrementUsageList) {
      vector<boost::any> temp1;
      for(auto item1:*autoIncrementUsageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoIncrementUsageList"] = boost::any(temp1);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (finish) {
      res["Finish"] = boost::any(*finish);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIncrementUsageList") != m.end() && !m["AutoIncrementUsageList"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoIncrementUsageList"].type()) {
        vector<GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoIncrementUsageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoIncrementUsageList = make_shared<vector<GetAutoIncrementUsageStatisticResponseBodyDataAutoIncrementUsageList>>(expect1);
      }
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("Finish") != m.end() && !m["Finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["Finish"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetAutoIncrementUsageStatisticResponseBodyData() = default;
};
class GetAutoIncrementUsageStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAutoIncrementUsageStatisticResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAutoIncrementUsageStatisticResponseBody() {}

  explicit GetAutoIncrementUsageStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAutoIncrementUsageStatisticResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAutoIncrementUsageStatisticResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAutoIncrementUsageStatisticResponseBody() = default;
};
class GetAutoIncrementUsageStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutoIncrementUsageStatisticResponseBody> body{};

  GetAutoIncrementUsageStatisticResponse() {}

  explicit GetAutoIncrementUsageStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutoIncrementUsageStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutoIncrementUsageStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutoIncrementUsageStatisticResponse() = default;
};
class GetAutoResourceOptimizeRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceIds{};

  GetAutoResourceOptimizeRulesRequest() {}

  explicit GetAutoResourceOptimizeRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~GetAutoResourceOptimizeRulesRequest() = default;
};
class GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList : public Darabonba::Model {
public:
  shared_ptr<bool> autoDefragment{};
  shared_ptr<bool> dasProOn{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> tableFragmentationRatio{};
  shared_ptr<double> tableSpaceSize{};
  shared_ptr<string> userId{};

  GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList() {}

  explicit GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoDefragment) {
      res["AutoDefragment"] = boost::any(*autoDefragment);
    }
    if (dasProOn) {
      res["DasProOn"] = boost::any(*dasProOn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tableFragmentationRatio) {
      res["TableFragmentationRatio"] = boost::any(*tableFragmentationRatio);
    }
    if (tableSpaceSize) {
      res["TableSpaceSize"] = boost::any(*tableSpaceSize);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoDefragment") != m.end() && !m["AutoDefragment"].empty()) {
      autoDefragment = make_shared<bool>(boost::any_cast<bool>(m["AutoDefragment"]));
    }
    if (m.find("DasProOn") != m.end() && !m["DasProOn"].empty()) {
      dasProOn = make_shared<bool>(boost::any_cast<bool>(m["DasProOn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TableFragmentationRatio") != m.end() && !m["TableFragmentationRatio"].empty()) {
      tableFragmentationRatio = make_shared<double>(boost::any_cast<double>(m["TableFragmentationRatio"]));
    }
    if (m.find("TableSpaceSize") != m.end() && !m["TableSpaceSize"].empty()) {
      tableSpaceSize = make_shared<double>(boost::any_cast<double>(m["TableSpaceSize"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList() = default;
};
class GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList : public Darabonba::Model {
public:
  shared_ptr<bool> autoDefragment{};
  shared_ptr<bool> dasProOn{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> tableFragmentationRatio{};
  shared_ptr<double> tableSpaceSize{};
  shared_ptr<string> userId{};

  GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList() {}

  explicit GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoDefragment) {
      res["AutoDefragment"] = boost::any(*autoDefragment);
    }
    if (dasProOn) {
      res["DasProOn"] = boost::any(*dasProOn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tableFragmentationRatio) {
      res["TableFragmentationRatio"] = boost::any(*tableFragmentationRatio);
    }
    if (tableSpaceSize) {
      res["TableSpaceSize"] = boost::any(*tableSpaceSize);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoDefragment") != m.end() && !m["AutoDefragment"].empty()) {
      autoDefragment = make_shared<bool>(boost::any_cast<bool>(m["AutoDefragment"]));
    }
    if (m.find("DasProOn") != m.end() && !m["DasProOn"].empty()) {
      dasProOn = make_shared<bool>(boost::any_cast<bool>(m["DasProOn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TableFragmentationRatio") != m.end() && !m["TableFragmentationRatio"].empty()) {
      tableFragmentationRatio = make_shared<double>(boost::any_cast<double>(m["TableFragmentationRatio"]));
    }
    if (m.find("TableSpaceSize") != m.end() && !m["TableSpaceSize"].empty()) {
      tableSpaceSize = make_shared<double>(boost::any_cast<double>(m["TableSpaceSize"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList() = default;
};
class GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList : public Darabonba::Model {
public:
  shared_ptr<bool> autoDefragment{};
  shared_ptr<bool> dasProOn{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> tableFragmentationRatio{};
  shared_ptr<double> tableSpaceSize{};
  shared_ptr<string> userId{};

  GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList() {}

  explicit GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoDefragment) {
      res["AutoDefragment"] = boost::any(*autoDefragment);
    }
    if (dasProOn) {
      res["DasProOn"] = boost::any(*dasProOn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tableFragmentationRatio) {
      res["TableFragmentationRatio"] = boost::any(*tableFragmentationRatio);
    }
    if (tableSpaceSize) {
      res["TableSpaceSize"] = boost::any(*tableSpaceSize);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoDefragment") != m.end() && !m["AutoDefragment"].empty()) {
      autoDefragment = make_shared<bool>(boost::any_cast<bool>(m["AutoDefragment"]));
    }
    if (m.find("DasProOn") != m.end() && !m["DasProOn"].empty()) {
      dasProOn = make_shared<bool>(boost::any_cast<bool>(m["DasProOn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TableFragmentationRatio") != m.end() && !m["TableFragmentationRatio"].empty()) {
      tableFragmentationRatio = make_shared<double>(boost::any_cast<double>(m["TableFragmentationRatio"]));
    }
    if (m.find("TableSpaceSize") != m.end() && !m["TableSpaceSize"].empty()) {
      tableSpaceSize = make_shared<double>(boost::any_cast<double>(m["TableSpaceSize"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList() = default;
};
class GetAutoResourceOptimizeRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> enableAutoResourceOptimizeCount{};
  shared_ptr<vector<GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList>> enableAutoResourceOptimizeList{};
  shared_ptr<long> hasEnableRuleButNotDasProCount{};
  shared_ptr<vector<GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList>> hasEnableRuleButNotDasProList{};
  shared_ptr<long> neverEnableAutoResourceOptimizeOrReleasedInstanceCount{};
  shared_ptr<vector<string>> neverEnableAutoResourceOptimizeOrReleasedInstanceIdList{};
  shared_ptr<long> totalAutoResourceOptimizeRulesCount{};
  shared_ptr<long> turnOffAutoResourceOptimizeCount{};
  shared_ptr<vector<GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList>> turnOffAutoResourceOptimizeList{};

  GetAutoResourceOptimizeRulesResponseBodyData() {}

  explicit GetAutoResourceOptimizeRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableAutoResourceOptimizeCount) {
      res["EnableAutoResourceOptimizeCount"] = boost::any(*enableAutoResourceOptimizeCount);
    }
    if (enableAutoResourceOptimizeList) {
      vector<boost::any> temp1;
      for(auto item1:*enableAutoResourceOptimizeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnableAutoResourceOptimizeList"] = boost::any(temp1);
    }
    if (hasEnableRuleButNotDasProCount) {
      res["HasEnableRuleButNotDasProCount"] = boost::any(*hasEnableRuleButNotDasProCount);
    }
    if (hasEnableRuleButNotDasProList) {
      vector<boost::any> temp1;
      for(auto item1:*hasEnableRuleButNotDasProList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HasEnableRuleButNotDasProList"] = boost::any(temp1);
    }
    if (neverEnableAutoResourceOptimizeOrReleasedInstanceCount) {
      res["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"] = boost::any(*neverEnableAutoResourceOptimizeOrReleasedInstanceCount);
    }
    if (neverEnableAutoResourceOptimizeOrReleasedInstanceIdList) {
      res["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"] = boost::any(*neverEnableAutoResourceOptimizeOrReleasedInstanceIdList);
    }
    if (totalAutoResourceOptimizeRulesCount) {
      res["TotalAutoResourceOptimizeRulesCount"] = boost::any(*totalAutoResourceOptimizeRulesCount);
    }
    if (turnOffAutoResourceOptimizeCount) {
      res["TurnOffAutoResourceOptimizeCount"] = boost::any(*turnOffAutoResourceOptimizeCount);
    }
    if (turnOffAutoResourceOptimizeList) {
      vector<boost::any> temp1;
      for(auto item1:*turnOffAutoResourceOptimizeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TurnOffAutoResourceOptimizeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableAutoResourceOptimizeCount") != m.end() && !m["EnableAutoResourceOptimizeCount"].empty()) {
      enableAutoResourceOptimizeCount = make_shared<long>(boost::any_cast<long>(m["EnableAutoResourceOptimizeCount"]));
    }
    if (m.find("EnableAutoResourceOptimizeList") != m.end() && !m["EnableAutoResourceOptimizeList"].empty()) {
      if (typeid(vector<boost::any>) == m["EnableAutoResourceOptimizeList"].type()) {
        vector<GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnableAutoResourceOptimizeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enableAutoResourceOptimizeList = make_shared<vector<GetAutoResourceOptimizeRulesResponseBodyDataEnableAutoResourceOptimizeList>>(expect1);
      }
    }
    if (m.find("HasEnableRuleButNotDasProCount") != m.end() && !m["HasEnableRuleButNotDasProCount"].empty()) {
      hasEnableRuleButNotDasProCount = make_shared<long>(boost::any_cast<long>(m["HasEnableRuleButNotDasProCount"]));
    }
    if (m.find("HasEnableRuleButNotDasProList") != m.end() && !m["HasEnableRuleButNotDasProList"].empty()) {
      if (typeid(vector<boost::any>) == m["HasEnableRuleButNotDasProList"].type()) {
        vector<GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HasEnableRuleButNotDasProList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hasEnableRuleButNotDasProList = make_shared<vector<GetAutoResourceOptimizeRulesResponseBodyDataHasEnableRuleButNotDasProList>>(expect1);
      }
    }
    if (m.find("NeverEnableAutoResourceOptimizeOrReleasedInstanceCount") != m.end() && !m["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"].empty()) {
      neverEnableAutoResourceOptimizeOrReleasedInstanceCount = make_shared<long>(boost::any_cast<long>(m["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"]));
    }
    if (m.find("NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList") != m.end() && !m["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      neverEnableAutoResourceOptimizeOrReleasedInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalAutoResourceOptimizeRulesCount") != m.end() && !m["TotalAutoResourceOptimizeRulesCount"].empty()) {
      totalAutoResourceOptimizeRulesCount = make_shared<long>(boost::any_cast<long>(m["TotalAutoResourceOptimizeRulesCount"]));
    }
    if (m.find("TurnOffAutoResourceOptimizeCount") != m.end() && !m["TurnOffAutoResourceOptimizeCount"].empty()) {
      turnOffAutoResourceOptimizeCount = make_shared<long>(boost::any_cast<long>(m["TurnOffAutoResourceOptimizeCount"]));
    }
    if (m.find("TurnOffAutoResourceOptimizeList") != m.end() && !m["TurnOffAutoResourceOptimizeList"].empty()) {
      if (typeid(vector<boost::any>) == m["TurnOffAutoResourceOptimizeList"].type()) {
        vector<GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TurnOffAutoResourceOptimizeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        turnOffAutoResourceOptimizeList = make_shared<vector<GetAutoResourceOptimizeRulesResponseBodyDataTurnOffAutoResourceOptimizeList>>(expect1);
      }
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponseBodyData() = default;
};
class GetAutoResourceOptimizeRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAutoResourceOptimizeRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAutoResourceOptimizeRulesResponseBody() {}

  explicit GetAutoResourceOptimizeRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAutoResourceOptimizeRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAutoResourceOptimizeRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponseBody() = default;
};
class GetAutoResourceOptimizeRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutoResourceOptimizeRulesResponseBody> body{};

  GetAutoResourceOptimizeRulesResponse() {}

  explicit GetAutoResourceOptimizeRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutoResourceOptimizeRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutoResourceOptimizeRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutoResourceOptimizeRulesResponse() = default;
};
class GetAutoThrottleRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceIds{};

  GetAutoThrottleRulesRequest() {}

  explicit GetAutoThrottleRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~GetAutoThrottleRulesRequest() = default;
};
class GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList : public Darabonba::Model {
public:
  shared_ptr<double> abnormalDuration{};
  shared_ptr<long> activeSessions{};
  shared_ptr<string> allowThrottleEndTime{};
  shared_ptr<string> allowThrottleStartTime{};
  shared_ptr<bool> autoKillSession{};
  shared_ptr<string> cpuSessionRelation{};
  shared_ptr<double> cpuUsage{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> maxThrottleTime{};
  shared_ptr<string> userId{};
  shared_ptr<bool> visible{};

  GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList() {}

  explicit GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalDuration) {
      res["AbnormalDuration"] = boost::any(*abnormalDuration);
    }
    if (activeSessions) {
      res["ActiveSessions"] = boost::any(*activeSessions);
    }
    if (allowThrottleEndTime) {
      res["AllowThrottleEndTime"] = boost::any(*allowThrottleEndTime);
    }
    if (allowThrottleStartTime) {
      res["AllowThrottleStartTime"] = boost::any(*allowThrottleStartTime);
    }
    if (autoKillSession) {
      res["AutoKillSession"] = boost::any(*autoKillSession);
    }
    if (cpuSessionRelation) {
      res["CpuSessionRelation"] = boost::any(*cpuSessionRelation);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxThrottleTime) {
      res["MaxThrottleTime"] = boost::any(*maxThrottleTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (visible) {
      res["Visible"] = boost::any(*visible);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalDuration") != m.end() && !m["AbnormalDuration"].empty()) {
      abnormalDuration = make_shared<double>(boost::any_cast<double>(m["AbnormalDuration"]));
    }
    if (m.find("ActiveSessions") != m.end() && !m["ActiveSessions"].empty()) {
      activeSessions = make_shared<long>(boost::any_cast<long>(m["ActiveSessions"]));
    }
    if (m.find("AllowThrottleEndTime") != m.end() && !m["AllowThrottleEndTime"].empty()) {
      allowThrottleEndTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleEndTime"]));
    }
    if (m.find("AllowThrottleStartTime") != m.end() && !m["AllowThrottleStartTime"].empty()) {
      allowThrottleStartTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleStartTime"]));
    }
    if (m.find("AutoKillSession") != m.end() && !m["AutoKillSession"].empty()) {
      autoKillSession = make_shared<bool>(boost::any_cast<bool>(m["AutoKillSession"]));
    }
    if (m.find("CpuSessionRelation") != m.end() && !m["CpuSessionRelation"].empty()) {
      cpuSessionRelation = make_shared<string>(boost::any_cast<string>(m["CpuSessionRelation"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<double>(boost::any_cast<double>(m["CpuUsage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxThrottleTime") != m.end() && !m["MaxThrottleTime"].empty()) {
      maxThrottleTime = make_shared<double>(boost::any_cast<double>(m["MaxThrottleTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Visible") != m.end() && !m["Visible"].empty()) {
      visible = make_shared<bool>(boost::any_cast<bool>(m["Visible"]));
    }
  }


  virtual ~GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList() = default;
};
class GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList : public Darabonba::Model {
public:
  shared_ptr<double> abnormalDuration{};
  shared_ptr<long> activeSessions{};
  shared_ptr<string> allowThrottleEndTime{};
  shared_ptr<string> allowThrottleStartTime{};
  shared_ptr<bool> autoKillSession{};
  shared_ptr<string> cpuSessionRelation{};
  shared_ptr<double> cpuUsage{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> maxThrottleTime{};
  shared_ptr<string> userId{};
  shared_ptr<bool> visible{};

  GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList() {}

  explicit GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalDuration) {
      res["AbnormalDuration"] = boost::any(*abnormalDuration);
    }
    if (activeSessions) {
      res["ActiveSessions"] = boost::any(*activeSessions);
    }
    if (allowThrottleEndTime) {
      res["AllowThrottleEndTime"] = boost::any(*allowThrottleEndTime);
    }
    if (allowThrottleStartTime) {
      res["AllowThrottleStartTime"] = boost::any(*allowThrottleStartTime);
    }
    if (autoKillSession) {
      res["AutoKillSession"] = boost::any(*autoKillSession);
    }
    if (cpuSessionRelation) {
      res["CpuSessionRelation"] = boost::any(*cpuSessionRelation);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxThrottleTime) {
      res["MaxThrottleTime"] = boost::any(*maxThrottleTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (visible) {
      res["Visible"] = boost::any(*visible);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalDuration") != m.end() && !m["AbnormalDuration"].empty()) {
      abnormalDuration = make_shared<double>(boost::any_cast<double>(m["AbnormalDuration"]));
    }
    if (m.find("ActiveSessions") != m.end() && !m["ActiveSessions"].empty()) {
      activeSessions = make_shared<long>(boost::any_cast<long>(m["ActiveSessions"]));
    }
    if (m.find("AllowThrottleEndTime") != m.end() && !m["AllowThrottleEndTime"].empty()) {
      allowThrottleEndTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleEndTime"]));
    }
    if (m.find("AllowThrottleStartTime") != m.end() && !m["AllowThrottleStartTime"].empty()) {
      allowThrottleStartTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleStartTime"]));
    }
    if (m.find("AutoKillSession") != m.end() && !m["AutoKillSession"].empty()) {
      autoKillSession = make_shared<bool>(boost::any_cast<bool>(m["AutoKillSession"]));
    }
    if (m.find("CpuSessionRelation") != m.end() && !m["CpuSessionRelation"].empty()) {
      cpuSessionRelation = make_shared<string>(boost::any_cast<string>(m["CpuSessionRelation"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<double>(boost::any_cast<double>(m["CpuUsage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxThrottleTime") != m.end() && !m["MaxThrottleTime"].empty()) {
      maxThrottleTime = make_shared<double>(boost::any_cast<double>(m["MaxThrottleTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Visible") != m.end() && !m["Visible"].empty()) {
      visible = make_shared<bool>(boost::any_cast<bool>(m["Visible"]));
    }
  }


  virtual ~GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList() = default;
};
class GetAutoThrottleRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> enableAutoThrottleCount{};
  shared_ptr<vector<GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList>> enableAutoThrottleList{};
  shared_ptr<long> neverEnableAutoThrottleOrReleasedInstanceCount{};
  shared_ptr<vector<string>> neverEnableAutoThrottleOrReleasedInstanceIdList{};
  shared_ptr<long> totalAutoThrottleRulesCount{};
  shared_ptr<long> turnOffAutoThrottleCount{};
  shared_ptr<vector<GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList>> turnOffAutoThrottleList{};

  GetAutoThrottleRulesResponseBodyData() {}

  explicit GetAutoThrottleRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableAutoThrottleCount) {
      res["EnableAutoThrottleCount"] = boost::any(*enableAutoThrottleCount);
    }
    if (enableAutoThrottleList) {
      vector<boost::any> temp1;
      for(auto item1:*enableAutoThrottleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnableAutoThrottleList"] = boost::any(temp1);
    }
    if (neverEnableAutoThrottleOrReleasedInstanceCount) {
      res["NeverEnableAutoThrottleOrReleasedInstanceCount"] = boost::any(*neverEnableAutoThrottleOrReleasedInstanceCount);
    }
    if (neverEnableAutoThrottleOrReleasedInstanceIdList) {
      res["NeverEnableAutoThrottleOrReleasedInstanceIdList"] = boost::any(*neverEnableAutoThrottleOrReleasedInstanceIdList);
    }
    if (totalAutoThrottleRulesCount) {
      res["TotalAutoThrottleRulesCount"] = boost::any(*totalAutoThrottleRulesCount);
    }
    if (turnOffAutoThrottleCount) {
      res["TurnOffAutoThrottleCount"] = boost::any(*turnOffAutoThrottleCount);
    }
    if (turnOffAutoThrottleList) {
      vector<boost::any> temp1;
      for(auto item1:*turnOffAutoThrottleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TurnOffAutoThrottleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableAutoThrottleCount") != m.end() && !m["EnableAutoThrottleCount"].empty()) {
      enableAutoThrottleCount = make_shared<long>(boost::any_cast<long>(m["EnableAutoThrottleCount"]));
    }
    if (m.find("EnableAutoThrottleList") != m.end() && !m["EnableAutoThrottleList"].empty()) {
      if (typeid(vector<boost::any>) == m["EnableAutoThrottleList"].type()) {
        vector<GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnableAutoThrottleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enableAutoThrottleList = make_shared<vector<GetAutoThrottleRulesResponseBodyDataEnableAutoThrottleList>>(expect1);
      }
    }
    if (m.find("NeverEnableAutoThrottleOrReleasedInstanceCount") != m.end() && !m["NeverEnableAutoThrottleOrReleasedInstanceCount"].empty()) {
      neverEnableAutoThrottleOrReleasedInstanceCount = make_shared<long>(boost::any_cast<long>(m["NeverEnableAutoThrottleOrReleasedInstanceCount"]));
    }
    if (m.find("NeverEnableAutoThrottleOrReleasedInstanceIdList") != m.end() && !m["NeverEnableAutoThrottleOrReleasedInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NeverEnableAutoThrottleOrReleasedInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NeverEnableAutoThrottleOrReleasedInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      neverEnableAutoThrottleOrReleasedInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalAutoThrottleRulesCount") != m.end() && !m["TotalAutoThrottleRulesCount"].empty()) {
      totalAutoThrottleRulesCount = make_shared<long>(boost::any_cast<long>(m["TotalAutoThrottleRulesCount"]));
    }
    if (m.find("TurnOffAutoThrottleCount") != m.end() && !m["TurnOffAutoThrottleCount"].empty()) {
      turnOffAutoThrottleCount = make_shared<long>(boost::any_cast<long>(m["TurnOffAutoThrottleCount"]));
    }
    if (m.find("TurnOffAutoThrottleList") != m.end() && !m["TurnOffAutoThrottleList"].empty()) {
      if (typeid(vector<boost::any>) == m["TurnOffAutoThrottleList"].type()) {
        vector<GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TurnOffAutoThrottleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        turnOffAutoThrottleList = make_shared<vector<GetAutoThrottleRulesResponseBodyDataTurnOffAutoThrottleList>>(expect1);
      }
    }
  }


  virtual ~GetAutoThrottleRulesResponseBodyData() = default;
};
class GetAutoThrottleRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAutoThrottleRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAutoThrottleRulesResponseBody() {}

  explicit GetAutoThrottleRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAutoThrottleRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAutoThrottleRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAutoThrottleRulesResponseBody() = default;
};
class GetAutoThrottleRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutoThrottleRulesResponseBody> body{};

  GetAutoThrottleRulesResponse() {}

  explicit GetAutoThrottleRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutoThrottleRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutoThrottleRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutoThrottleRulesResponse() = default;
};
class GetAutonomousNotifyEventContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> spanId{};
  shared_ptr<string> context{};

  GetAutonomousNotifyEventContentRequest() {}

  explicit GetAutonomousNotifyEventContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
  }


  virtual ~GetAutonomousNotifyEventContentRequest() = default;
};
class GetAutonomousNotifyEventContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetAutonomousNotifyEventContentResponseBody() {}

  explicit GetAutonomousNotifyEventContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetAutonomousNotifyEventContentResponseBody() = default;
};
class GetAutonomousNotifyEventContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutonomousNotifyEventContentResponseBody> body{};

  GetAutonomousNotifyEventContentResponse() {}

  explicit GetAutonomousNotifyEventContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutonomousNotifyEventContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutonomousNotifyEventContentResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutonomousNotifyEventContentResponse() = default;
};
class GetAutonomousNotifyEventsInRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> minLevel{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> pageOffset{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> context{};

  GetAutonomousNotifyEventsInRangeRequest() {}

  explicit GetAutonomousNotifyEventsInRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventContext) {
      res["EventContext"] = boost::any(*eventContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (minLevel) {
      res["MinLevel"] = boost::any(*minLevel);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (pageOffset) {
      res["PageOffset"] = boost::any(*pageOffset);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventContext") != m.end() && !m["EventContext"].empty()) {
      eventContext = make_shared<string>(boost::any_cast<string>(m["EventContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MinLevel") != m.end() && !m["MinLevel"].empty()) {
      minLevel = make_shared<string>(boost::any_cast<string>(m["MinLevel"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PageOffset") != m.end() && !m["PageOffset"].empty()) {
      pageOffset = make_shared<string>(boost::any_cast<string>(m["PageOffset"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
  }


  virtual ~GetAutonomousNotifyEventsInRangeRequest() = default;
};
class GetAutonomousNotifyEventsInRangeResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> t{};

  GetAutonomousNotifyEventsInRangeResponseBodyDataList() {}

  explicit GetAutonomousNotifyEventsInRangeResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (t) {
      res["T"] = boost::any(*t);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("T") != m.end() && !m["T"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["T"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["T"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      t = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAutonomousNotifyEventsInRangeResponseBodyDataList() = default;
};
class GetAutonomousNotifyEventsInRangeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<GetAutonomousNotifyEventsInRangeResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetAutonomousNotifyEventsInRangeResponseBodyData() {}

  explicit GetAutonomousNotifyEventsInRangeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetAutonomousNotifyEventsInRangeResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetAutonomousNotifyEventsInRangeResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetAutonomousNotifyEventsInRangeResponseBodyData() = default;
};
class GetAutonomousNotifyEventsInRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAutonomousNotifyEventsInRangeResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetAutonomousNotifyEventsInRangeResponseBody() {}

  explicit GetAutonomousNotifyEventsInRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAutonomousNotifyEventsInRangeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAutonomousNotifyEventsInRangeResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetAutonomousNotifyEventsInRangeResponseBody() = default;
};
class GetAutonomousNotifyEventsInRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutonomousNotifyEventsInRangeResponseBody> body{};

  GetAutonomousNotifyEventsInRangeResponse() {}

  explicit GetAutonomousNotifyEventsInRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutonomousNotifyEventsInRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutonomousNotifyEventsInRangeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutonomousNotifyEventsInRangeResponse() = default;
};
class GetBlockingDetailListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> queryHash{};
  shared_ptr<string> startTime{};

  GetBlockingDetailListRequest() {}

  explicit GetBlockingDetailListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbNameList) {
      res["DbNameList"] = boost::any(*dbNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryHash) {
      res["QueryHash"] = boost::any(*queryHash);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbNameList") != m.end() && !m["DbNameList"].empty()) {
      dbNameList = make_shared<string>(boost::any_cast<string>(m["DbNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("QueryHash") != m.end() && !m["QueryHash"].empty()) {
      queryHash = make_shared<string>(boost::any_cast<string>(m["QueryHash"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetBlockingDetailListRequest() = default;
};
class GetBlockingDetailListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> batchId{};
  shared_ptr<string> clientAppName{};
  shared_ptr<long> currentCollectionTime{};
  shared_ptr<string> dataBase{};
  shared_ptr<string> hostName{};
  shared_ptr<string> loginId{};
  shared_ptr<string> queryHash{};
  shared_ptr<string> spid{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> startTime{};
  shared_ptr<long> waitTimeMs{};
  shared_ptr<string> waitType{};

  GetBlockingDetailListResponseBodyDataList() {}

  explicit GetBlockingDetailListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (clientAppName) {
      res["ClientAppName"] = boost::any(*clientAppName);
    }
    if (currentCollectionTime) {
      res["CurrentCollectionTime"] = boost::any(*currentCollectionTime);
    }
    if (dataBase) {
      res["DataBase"] = boost::any(*dataBase);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (loginId) {
      res["LoginId"] = boost::any(*loginId);
    }
    if (queryHash) {
      res["QueryHash"] = boost::any(*queryHash);
    }
    if (spid) {
      res["Spid"] = boost::any(*spid);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (waitTimeMs) {
      res["WaitTimeMs"] = boost::any(*waitTimeMs);
    }
    if (waitType) {
      res["WaitType"] = boost::any(*waitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<long>(boost::any_cast<long>(m["BatchId"]));
    }
    if (m.find("ClientAppName") != m.end() && !m["ClientAppName"].empty()) {
      clientAppName = make_shared<string>(boost::any_cast<string>(m["ClientAppName"]));
    }
    if (m.find("CurrentCollectionTime") != m.end() && !m["CurrentCollectionTime"].empty()) {
      currentCollectionTime = make_shared<long>(boost::any_cast<long>(m["CurrentCollectionTime"]));
    }
    if (m.find("DataBase") != m.end() && !m["DataBase"].empty()) {
      dataBase = make_shared<string>(boost::any_cast<string>(m["DataBase"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("LoginId") != m.end() && !m["LoginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["LoginId"]));
    }
    if (m.find("QueryHash") != m.end() && !m["QueryHash"].empty()) {
      queryHash = make_shared<string>(boost::any_cast<string>(m["QueryHash"]));
    }
    if (m.find("Spid") != m.end() && !m["Spid"].empty()) {
      spid = make_shared<string>(boost::any_cast<string>(m["Spid"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("WaitTimeMs") != m.end() && !m["WaitTimeMs"].empty()) {
      waitTimeMs = make_shared<long>(boost::any_cast<long>(m["WaitTimeMs"]));
    }
    if (m.find("WaitType") != m.end() && !m["WaitType"].empty()) {
      waitType = make_shared<string>(boost::any_cast<string>(m["WaitType"]));
    }
  }


  virtual ~GetBlockingDetailListResponseBodyDataList() = default;
};
class GetBlockingDetailListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetBlockingDetailListResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetBlockingDetailListResponseBodyData() {}

  explicit GetBlockingDetailListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetBlockingDetailListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBlockingDetailListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetBlockingDetailListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetBlockingDetailListResponseBodyData() = default;
};
class GetBlockingDetailListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetBlockingDetailListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetBlockingDetailListResponseBody() {}

  explicit GetBlockingDetailListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBlockingDetailListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBlockingDetailListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetBlockingDetailListResponseBody() = default;
};
class GetBlockingDetailListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBlockingDetailListResponseBody> body{};

  GetBlockingDetailListResponse() {}

  explicit GetBlockingDetailListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBlockingDetailListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBlockingDetailListResponseBody>(model1);
      }
    }
  }


  virtual ~GetBlockingDetailListResponse() = default;
};
class GetDBInstanceConnectivityDiagnosisRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> srcIp{};

  GetDBInstanceConnectivityDiagnosisRequest() {}

  explicit GetDBInstanceConnectivityDiagnosisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (srcIp) {
      res["SrcIp"] = boost::any(*srcIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SrcIp") != m.end() && !m["SrcIp"].empty()) {
      srcIp = make_shared<string>(boost::any_cast<string>(m["SrcIp"]));
    }
  }


  virtual ~GetDBInstanceConnectivityDiagnosisRequest() = default;
};
class GetDBInstanceConnectivityDiagnosisResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> connCheckErrorCode{};
  shared_ptr<string> connCheckErrorMessage{};
  shared_ptr<string> failType{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> success{};

  GetDBInstanceConnectivityDiagnosisResponseBodyData() {}

  explicit GetDBInstanceConnectivityDiagnosisResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connCheckErrorCode) {
      res["connCheckErrorCode"] = boost::any(*connCheckErrorCode);
    }
    if (connCheckErrorMessage) {
      res["connCheckErrorMessage"] = boost::any(*connCheckErrorMessage);
    }
    if (failType) {
      res["failType"] = boost::any(*failType);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("connCheckErrorCode") != m.end() && !m["connCheckErrorCode"].empty()) {
      connCheckErrorCode = make_shared<string>(boost::any_cast<string>(m["connCheckErrorCode"]));
    }
    if (m.find("connCheckErrorMessage") != m.end() && !m["connCheckErrorMessage"].empty()) {
      connCheckErrorMessage = make_shared<string>(boost::any_cast<string>(m["connCheckErrorMessage"]));
    }
    if (m.find("failType") != m.end() && !m["failType"].empty()) {
      failType = make_shared<string>(boost::any_cast<string>(m["failType"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetDBInstanceConnectivityDiagnosisResponseBodyData() = default;
};
class GetDBInstanceConnectivityDiagnosisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDBInstanceConnectivityDiagnosisResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetDBInstanceConnectivityDiagnosisResponseBody() {}

  explicit GetDBInstanceConnectivityDiagnosisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDBInstanceConnectivityDiagnosisResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDBInstanceConnectivityDiagnosisResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetDBInstanceConnectivityDiagnosisResponseBody() = default;
};
class GetDBInstanceConnectivityDiagnosisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDBInstanceConnectivityDiagnosisResponseBody> body{};

  GetDBInstanceConnectivityDiagnosisResponse() {}

  explicit GetDBInstanceConnectivityDiagnosisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDBInstanceConnectivityDiagnosisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDBInstanceConnectivityDiagnosisResponseBody>(model1);
      }
    }
  }


  virtual ~GetDBInstanceConnectivityDiagnosisResponse() = default;
};
class GetDasProServiceUsageRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetDasProServiceUsageRequest() {}

  explicit GetDasProServiceUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetDasProServiceUsageRequest() = default;
};
class GetDasProServiceUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> commodityInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<bool> isSpare{};
  shared_ptr<long> migrationPredictRemainingTime{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceUnitId{};
  shared_ptr<string> sqlRetention{};
  shared_ptr<long> startTime{};
  shared_ptr<double> storageFreeQuotaInMB{};
  shared_ptr<long> storageUsed{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};

  GetDasProServiceUsageResponseBodyData() {}

  explicit GetDasProServiceUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityInstanceId) {
      res["commodityInstanceId"] = boost::any(*commodityInstanceId);
    }
    if (engine) {
      res["engine"] = boost::any(*engine);
    }
    if (expireTime) {
      res["expireTime"] = boost::any(*expireTime);
    }
    if (instanceAlias) {
      res["instanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (isSpare) {
      res["isSpare"] = boost::any(*isSpare);
    }
    if (migrationPredictRemainingTime) {
      res["migrationPredictRemainingTime"] = boost::any(*migrationPredictRemainingTime);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (serviceUnitId) {
      res["serviceUnitId"] = boost::any(*serviceUnitId);
    }
    if (sqlRetention) {
      res["sqlRetention"] = boost::any(*sqlRetention);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (storageFreeQuotaInMB) {
      res["storageFreeQuotaInMB"] = boost::any(*storageFreeQuotaInMB);
    }
    if (storageUsed) {
      res["storageUsed"] = boost::any(*storageUsed);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commodityInstanceId") != m.end() && !m["commodityInstanceId"].empty()) {
      commodityInstanceId = make_shared<string>(boost::any_cast<string>(m["commodityInstanceId"]));
    }
    if (m.find("engine") != m.end() && !m["engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["engine"]));
    }
    if (m.find("expireTime") != m.end() && !m["expireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["expireTime"]));
    }
    if (m.find("instanceAlias") != m.end() && !m["instanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["instanceAlias"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("isSpare") != m.end() && !m["isSpare"].empty()) {
      isSpare = make_shared<bool>(boost::any_cast<bool>(m["isSpare"]));
    }
    if (m.find("migrationPredictRemainingTime") != m.end() && !m["migrationPredictRemainingTime"].empty()) {
      migrationPredictRemainingTime = make_shared<long>(boost::any_cast<long>(m["migrationPredictRemainingTime"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("serviceUnitId") != m.end() && !m["serviceUnitId"].empty()) {
      serviceUnitId = make_shared<string>(boost::any_cast<string>(m["serviceUnitId"]));
    }
    if (m.find("sqlRetention") != m.end() && !m["sqlRetention"].empty()) {
      sqlRetention = make_shared<string>(boost::any_cast<string>(m["sqlRetention"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("storageFreeQuotaInMB") != m.end() && !m["storageFreeQuotaInMB"].empty()) {
      storageFreeQuotaInMB = make_shared<double>(boost::any_cast<double>(m["storageFreeQuotaInMB"]));
    }
    if (m.find("storageUsed") != m.end() && !m["storageUsed"].empty()) {
      storageUsed = make_shared<long>(boost::any_cast<long>(m["storageUsed"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~GetDasProServiceUsageResponseBodyData() = default;
};
class GetDasProServiceUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetDasProServiceUsageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDasProServiceUsageResponseBody() {}

  explicit GetDasProServiceUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDasProServiceUsageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDasProServiceUsageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDasProServiceUsageResponseBody() = default;
};
class GetDasProServiceUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDasProServiceUsageResponseBody> body{};

  GetDasProServiceUsageResponse() {}

  explicit GetDasProServiceUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDasProServiceUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDasProServiceUsageResponseBody>(model1);
      }
    }
  }


  virtual ~GetDasProServiceUsageResponse() = default;
};
class GetDasSQLLogHotDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> childDBInstanceIDs{};
  shared_ptr<string> DBName{};
  shared_ptr<long> end{};
  shared_ptr<string> fail{};
  shared_ptr<string> hostAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logicalOperator{};
  shared_ptr<long> maxLatancy{};
  shared_ptr<long> maxRecordsPerPage{};
  shared_ptr<long> maxRows{};
  shared_ptr<long> maxScanRows{};
  shared_ptr<long> maxSpillCnt{};
  shared_ptr<long> minLatancy{};
  shared_ptr<long> minRows{};
  shared_ptr<long> minScanRows{};
  shared_ptr<long> minSpillCnt{};
  shared_ptr<long> pageNumbers{};
  shared_ptr<string> queryKeyword{};
  shared_ptr<string> role{};
  shared_ptr<string> sortKey{};
  shared_ptr<string> sortMethod{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> start{};
  shared_ptr<string> state{};
  shared_ptr<string> threadID{};
  shared_ptr<string> traceId{};
  shared_ptr<string> transactionId{};

  GetDasSQLLogHotDataRequest() {}

  explicit GetDasSQLLogHotDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (childDBInstanceIDs) {
      res["ChildDBInstanceIDs"] = boost::any(*childDBInstanceIDs);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logicalOperator) {
      res["LogicalOperator"] = boost::any(*logicalOperator);
    }
    if (maxLatancy) {
      res["MaxLatancy"] = boost::any(*maxLatancy);
    }
    if (maxRecordsPerPage) {
      res["MaxRecordsPerPage"] = boost::any(*maxRecordsPerPage);
    }
    if (maxRows) {
      res["MaxRows"] = boost::any(*maxRows);
    }
    if (maxScanRows) {
      res["MaxScanRows"] = boost::any(*maxScanRows);
    }
    if (maxSpillCnt) {
      res["MaxSpillCnt"] = boost::any(*maxSpillCnt);
    }
    if (minLatancy) {
      res["MinLatancy"] = boost::any(*minLatancy);
    }
    if (minRows) {
      res["MinRows"] = boost::any(*minRows);
    }
    if (minScanRows) {
      res["MinScanRows"] = boost::any(*minScanRows);
    }
    if (minSpillCnt) {
      res["MinSpillCnt"] = boost::any(*minSpillCnt);
    }
    if (pageNumbers) {
      res["PageNumbers"] = boost::any(*pageNumbers);
    }
    if (queryKeyword) {
      res["QueryKeyword"] = boost::any(*queryKeyword);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (sortKey) {
      res["SortKey"] = boost::any(*sortKey);
    }
    if (sortMethod) {
      res["SortMethod"] = boost::any(*sortMethod);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (threadID) {
      res["ThreadID"] = boost::any(*threadID);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (transactionId) {
      res["TransactionId"] = boost::any(*transactionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("ChildDBInstanceIDs") != m.end() && !m["ChildDBInstanceIDs"].empty()) {
      childDBInstanceIDs = make_shared<string>(boost::any_cast<string>(m["ChildDBInstanceIDs"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      fail = make_shared<string>(boost::any_cast<string>(m["Fail"]));
    }
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogicalOperator") != m.end() && !m["LogicalOperator"].empty()) {
      logicalOperator = make_shared<string>(boost::any_cast<string>(m["LogicalOperator"]));
    }
    if (m.find("MaxLatancy") != m.end() && !m["MaxLatancy"].empty()) {
      maxLatancy = make_shared<long>(boost::any_cast<long>(m["MaxLatancy"]));
    }
    if (m.find("MaxRecordsPerPage") != m.end() && !m["MaxRecordsPerPage"].empty()) {
      maxRecordsPerPage = make_shared<long>(boost::any_cast<long>(m["MaxRecordsPerPage"]));
    }
    if (m.find("MaxRows") != m.end() && !m["MaxRows"].empty()) {
      maxRows = make_shared<long>(boost::any_cast<long>(m["MaxRows"]));
    }
    if (m.find("MaxScanRows") != m.end() && !m["MaxScanRows"].empty()) {
      maxScanRows = make_shared<long>(boost::any_cast<long>(m["MaxScanRows"]));
    }
    if (m.find("MaxSpillCnt") != m.end() && !m["MaxSpillCnt"].empty()) {
      maxSpillCnt = make_shared<long>(boost::any_cast<long>(m["MaxSpillCnt"]));
    }
    if (m.find("MinLatancy") != m.end() && !m["MinLatancy"].empty()) {
      minLatancy = make_shared<long>(boost::any_cast<long>(m["MinLatancy"]));
    }
    if (m.find("MinRows") != m.end() && !m["MinRows"].empty()) {
      minRows = make_shared<long>(boost::any_cast<long>(m["MinRows"]));
    }
    if (m.find("MinScanRows") != m.end() && !m["MinScanRows"].empty()) {
      minScanRows = make_shared<long>(boost::any_cast<long>(m["MinScanRows"]));
    }
    if (m.find("MinSpillCnt") != m.end() && !m["MinSpillCnt"].empty()) {
      minSpillCnt = make_shared<long>(boost::any_cast<long>(m["MinSpillCnt"]));
    }
    if (m.find("PageNumbers") != m.end() && !m["PageNumbers"].empty()) {
      pageNumbers = make_shared<long>(boost::any_cast<long>(m["PageNumbers"]));
    }
    if (m.find("QueryKeyword") != m.end() && !m["QueryKeyword"].empty()) {
      queryKeyword = make_shared<string>(boost::any_cast<string>(m["QueryKeyword"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SortKey") != m.end() && !m["SortKey"].empty()) {
      sortKey = make_shared<string>(boost::any_cast<string>(m["SortKey"]));
    }
    if (m.find("SortMethod") != m.end() && !m["SortMethod"].empty()) {
      sortMethod = make_shared<string>(boost::any_cast<string>(m["SortMethod"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ThreadID") != m.end() && !m["ThreadID"].empty()) {
      threadID = make_shared<string>(boost::any_cast<string>(m["ThreadID"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("TransactionId") != m.end() && !m["TransactionId"].empty()) {
      transactionId = make_shared<string>(boost::any_cast<string>(m["TransactionId"]));
    }
  }


  virtual ~GetDasSQLLogHotDataRequest() = default;
};
class GetDasSQLLogHotDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> DBName{};
  shared_ptr<string> executeTime{};
  shared_ptr<string> ext{};
  shared_ptr<string> hostAddress{};
  shared_ptr<long> latancy{};
  shared_ptr<long> lockTime{};
  shared_ptr<long> logicRead{};
  shared_ptr<string> originTime{};
  shared_ptr<long> physicAsyncRead{};
  shared_ptr<long> physicSyncRead{};
  shared_ptr<long> returnRows{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> scanRows{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> state{};
  shared_ptr<long> threadID{};
  shared_ptr<string> transactionId{};
  shared_ptr<long> updateRows{};

  GetDasSQLLogHotDataResponseBodyDataList() {}

  explicit GetDasSQLLogHotDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (latancy) {
      res["Latancy"] = boost::any(*latancy);
    }
    if (lockTime) {
      res["LockTime"] = boost::any(*lockTime);
    }
    if (logicRead) {
      res["LogicRead"] = boost::any(*logicRead);
    }
    if (originTime) {
      res["OriginTime"] = boost::any(*originTime);
    }
    if (physicAsyncRead) {
      res["PhysicAsyncRead"] = boost::any(*physicAsyncRead);
    }
    if (physicSyncRead) {
      res["PhysicSyncRead"] = boost::any(*physicSyncRead);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (scanRows) {
      res["ScanRows"] = boost::any(*scanRows);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (threadID) {
      res["ThreadID"] = boost::any(*threadID);
    }
    if (transactionId) {
      res["TransactionId"] = boost::any(*transactionId);
    }
    if (updateRows) {
      res["UpdateRows"] = boost::any(*updateRows);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<string>(boost::any_cast<string>(m["ExecuteTime"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("Latancy") != m.end() && !m["Latancy"].empty()) {
      latancy = make_shared<long>(boost::any_cast<long>(m["Latancy"]));
    }
    if (m.find("LockTime") != m.end() && !m["LockTime"].empty()) {
      lockTime = make_shared<long>(boost::any_cast<long>(m["LockTime"]));
    }
    if (m.find("LogicRead") != m.end() && !m["LogicRead"].empty()) {
      logicRead = make_shared<long>(boost::any_cast<long>(m["LogicRead"]));
    }
    if (m.find("OriginTime") != m.end() && !m["OriginTime"].empty()) {
      originTime = make_shared<string>(boost::any_cast<string>(m["OriginTime"]));
    }
    if (m.find("PhysicAsyncRead") != m.end() && !m["PhysicAsyncRead"].empty()) {
      physicAsyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicAsyncRead"]));
    }
    if (m.find("PhysicSyncRead") != m.end() && !m["PhysicSyncRead"].empty()) {
      physicSyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicSyncRead"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("ScanRows") != m.end() && !m["ScanRows"].empty()) {
      scanRows = make_shared<long>(boost::any_cast<long>(m["ScanRows"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ThreadID") != m.end() && !m["ThreadID"].empty()) {
      threadID = make_shared<long>(boost::any_cast<long>(m["ThreadID"]));
    }
    if (m.find("TransactionId") != m.end() && !m["TransactionId"].empty()) {
      transactionId = make_shared<string>(boost::any_cast<string>(m["TransactionId"]));
    }
    if (m.find("UpdateRows") != m.end() && !m["UpdateRows"].empty()) {
      updateRows = make_shared<long>(boost::any_cast<long>(m["UpdateRows"]));
    }
  }


  virtual ~GetDasSQLLogHotDataResponseBodyDataList() = default;
};
class GetDasSQLLogHotDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<boost::any> extra{};
  shared_ptr<vector<GetDasSQLLogHotDataResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetDasSQLLogHotDataResponseBodyData() {}

  explicit GetDasSQLLogHotDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<boost::any>(boost::any_cast<boost::any>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetDasSQLLogHotDataResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDasSQLLogHotDataResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetDasSQLLogHotDataResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetDasSQLLogHotDataResponseBodyData() = default;
};
class GetDasSQLLogHotDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDasSQLLogHotDataResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetDasSQLLogHotDataResponseBody() {}

  explicit GetDasSQLLogHotDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDasSQLLogHotDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDasSQLLogHotDataResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetDasSQLLogHotDataResponseBody() = default;
};
class GetDasSQLLogHotDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDasSQLLogHotDataResponseBody> body{};

  GetDasSQLLogHotDataResponse() {}

  explicit GetDasSQLLogHotDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDasSQLLogHotDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDasSQLLogHotDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetDasSQLLogHotDataResponse() = default;
};
class GetDeadLockDetailListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};

  GetDeadLockDetailListRequest() {}

  explicit GetDeadLockDetailListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbNameList) {
      res["DbNameList"] = boost::any(*dbNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbNameList") != m.end() && !m["DbNameList"].empty()) {
      dbNameList = make_shared<string>(boost::any_cast<string>(m["DbNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetDeadLockDetailListRequest() = default;
};
class GetDeadLockDetailListResponseBodyDataListBlockProcessList : public Darabonba::Model {
public:
  shared_ptr<string> clientApp{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> hostName{};
  shared_ptr<long> lastTranStarted{};
  shared_ptr<string> lockMode{};
  shared_ptr<long> logUsed{};
  shared_ptr<string> loginName{};
  shared_ptr<string> objectOwned{};
  shared_ptr<string> objectRequested{};
  shared_ptr<string> ownMode{};
  shared_ptr<long> spid{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> status{};
  shared_ptr<long> victim{};
  shared_ptr<string> waitMode{};
  shared_ptr<string> waitResource{};
  shared_ptr<string> waitResourceDescription{};

  GetDeadLockDetailListResponseBodyDataListBlockProcessList() {}

  explicit GetDeadLockDetailListResponseBodyDataListBlockProcessList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientApp) {
      res["ClientApp"] = boost::any(*clientApp);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (lastTranStarted) {
      res["LastTranStarted"] = boost::any(*lastTranStarted);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (logUsed) {
      res["LogUsed"] = boost::any(*logUsed);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (objectOwned) {
      res["ObjectOwned"] = boost::any(*objectOwned);
    }
    if (objectRequested) {
      res["ObjectRequested"] = boost::any(*objectRequested);
    }
    if (ownMode) {
      res["OwnMode"] = boost::any(*ownMode);
    }
    if (spid) {
      res["Spid"] = boost::any(*spid);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (victim) {
      res["Victim"] = boost::any(*victim);
    }
    if (waitMode) {
      res["WaitMode"] = boost::any(*waitMode);
    }
    if (waitResource) {
      res["WaitResource"] = boost::any(*waitResource);
    }
    if (waitResourceDescription) {
      res["WaitResourceDescription"] = boost::any(*waitResourceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientApp") != m.end() && !m["ClientApp"].empty()) {
      clientApp = make_shared<string>(boost::any_cast<string>(m["ClientApp"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("LastTranStarted") != m.end() && !m["LastTranStarted"].empty()) {
      lastTranStarted = make_shared<long>(boost::any_cast<long>(m["LastTranStarted"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("LogUsed") != m.end() && !m["LogUsed"].empty()) {
      logUsed = make_shared<long>(boost::any_cast<long>(m["LogUsed"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("ObjectOwned") != m.end() && !m["ObjectOwned"].empty()) {
      objectOwned = make_shared<string>(boost::any_cast<string>(m["ObjectOwned"]));
    }
    if (m.find("ObjectRequested") != m.end() && !m["ObjectRequested"].empty()) {
      objectRequested = make_shared<string>(boost::any_cast<string>(m["ObjectRequested"]));
    }
    if (m.find("OwnMode") != m.end() && !m["OwnMode"].empty()) {
      ownMode = make_shared<string>(boost::any_cast<string>(m["OwnMode"]));
    }
    if (m.find("Spid") != m.end() && !m["Spid"].empty()) {
      spid = make_shared<long>(boost::any_cast<long>(m["Spid"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Victim") != m.end() && !m["Victim"].empty()) {
      victim = make_shared<long>(boost::any_cast<long>(m["Victim"]));
    }
    if (m.find("WaitMode") != m.end() && !m["WaitMode"].empty()) {
      waitMode = make_shared<string>(boost::any_cast<string>(m["WaitMode"]));
    }
    if (m.find("WaitResource") != m.end() && !m["WaitResource"].empty()) {
      waitResource = make_shared<string>(boost::any_cast<string>(m["WaitResource"]));
    }
    if (m.find("WaitResourceDescription") != m.end() && !m["WaitResourceDescription"].empty()) {
      waitResourceDescription = make_shared<string>(boost::any_cast<string>(m["WaitResourceDescription"]));
    }
  }


  virtual ~GetDeadLockDetailListResponseBodyDataListBlockProcessList() = default;
};
class GetDeadLockDetailListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> batchId{};
  shared_ptr<vector<GetDeadLockDetailListResponseBodyDataListBlockProcessList>> blockProcessList{};
  shared_ptr<string> clientApp{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> hostName{};
  shared_ptr<long> lastTranStarted{};
  shared_ptr<string> lockMode{};
  shared_ptr<long> logUsed{};
  shared_ptr<string> loginName{};
  shared_ptr<string> objectOwned{};
  shared_ptr<string> objectRequested{};
  shared_ptr<string> ownMode{};
  shared_ptr<long> spid{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> status{};
  shared_ptr<long> victim{};
  shared_ptr<string> waitMode{};
  shared_ptr<string> waitResource{};
  shared_ptr<string> waitResourceDescription{};

  GetDeadLockDetailListResponseBodyDataList() {}

  explicit GetDeadLockDetailListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (blockProcessList) {
      vector<boost::any> temp1;
      for(auto item1:*blockProcessList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockProcessList"] = boost::any(temp1);
    }
    if (clientApp) {
      res["ClientApp"] = boost::any(*clientApp);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (lastTranStarted) {
      res["LastTranStarted"] = boost::any(*lastTranStarted);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (logUsed) {
      res["LogUsed"] = boost::any(*logUsed);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (objectOwned) {
      res["ObjectOwned"] = boost::any(*objectOwned);
    }
    if (objectRequested) {
      res["ObjectRequested"] = boost::any(*objectRequested);
    }
    if (ownMode) {
      res["OwnMode"] = boost::any(*ownMode);
    }
    if (spid) {
      res["Spid"] = boost::any(*spid);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (victim) {
      res["Victim"] = boost::any(*victim);
    }
    if (waitMode) {
      res["WaitMode"] = boost::any(*waitMode);
    }
    if (waitResource) {
      res["WaitResource"] = boost::any(*waitResource);
    }
    if (waitResourceDescription) {
      res["WaitResourceDescription"] = boost::any(*waitResourceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<long>(boost::any_cast<long>(m["BatchId"]));
    }
    if (m.find("BlockProcessList") != m.end() && !m["BlockProcessList"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockProcessList"].type()) {
        vector<GetDeadLockDetailListResponseBodyDataListBlockProcessList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockProcessList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeadLockDetailListResponseBodyDataListBlockProcessList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockProcessList = make_shared<vector<GetDeadLockDetailListResponseBodyDataListBlockProcessList>>(expect1);
      }
    }
    if (m.find("ClientApp") != m.end() && !m["ClientApp"].empty()) {
      clientApp = make_shared<string>(boost::any_cast<string>(m["ClientApp"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("LastTranStarted") != m.end() && !m["LastTranStarted"].empty()) {
      lastTranStarted = make_shared<long>(boost::any_cast<long>(m["LastTranStarted"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("LogUsed") != m.end() && !m["LogUsed"].empty()) {
      logUsed = make_shared<long>(boost::any_cast<long>(m["LogUsed"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("ObjectOwned") != m.end() && !m["ObjectOwned"].empty()) {
      objectOwned = make_shared<string>(boost::any_cast<string>(m["ObjectOwned"]));
    }
    if (m.find("ObjectRequested") != m.end() && !m["ObjectRequested"].empty()) {
      objectRequested = make_shared<string>(boost::any_cast<string>(m["ObjectRequested"]));
    }
    if (m.find("OwnMode") != m.end() && !m["OwnMode"].empty()) {
      ownMode = make_shared<string>(boost::any_cast<string>(m["OwnMode"]));
    }
    if (m.find("Spid") != m.end() && !m["Spid"].empty()) {
      spid = make_shared<long>(boost::any_cast<long>(m["Spid"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Victim") != m.end() && !m["Victim"].empty()) {
      victim = make_shared<long>(boost::any_cast<long>(m["Victim"]));
    }
    if (m.find("WaitMode") != m.end() && !m["WaitMode"].empty()) {
      waitMode = make_shared<string>(boost::any_cast<string>(m["WaitMode"]));
    }
    if (m.find("WaitResource") != m.end() && !m["WaitResource"].empty()) {
      waitResource = make_shared<string>(boost::any_cast<string>(m["WaitResource"]));
    }
    if (m.find("WaitResourceDescription") != m.end() && !m["WaitResourceDescription"].empty()) {
      waitResourceDescription = make_shared<string>(boost::any_cast<string>(m["WaitResourceDescription"]));
    }
  }


  virtual ~GetDeadLockDetailListResponseBodyDataList() = default;
};
class GetDeadLockDetailListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetDeadLockDetailListResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetDeadLockDetailListResponseBodyData() {}

  explicit GetDeadLockDetailListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetDeadLockDetailListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeadLockDetailListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetDeadLockDetailListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetDeadLockDetailListResponseBodyData() = default;
};
class GetDeadLockDetailListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDeadLockDetailListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetDeadLockDetailListResponseBody() {}

  explicit GetDeadLockDetailListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeadLockDetailListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeadLockDetailListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetDeadLockDetailListResponseBody() = default;
};
class GetDeadLockDetailListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeadLockDetailListResponseBody> body{};

  GetDeadLockDetailListResponse() {}

  explicit GetDeadLockDetailListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeadLockDetailListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeadLockDetailListResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeadLockDetailListResponse() = default;
};
class GetEndpointSwitchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> context{};
  shared_ptr<string> accessKey{};
  shared_ptr<string> signature{};
  shared_ptr<string> skipAuth{};
  shared_ptr<string> timestamp{};

  GetEndpointSwitchTaskRequest() {}

  explicit GetEndpointSwitchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (skipAuth) {
      res["skipAuth"] = boost::any(*skipAuth);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("skipAuth") != m.end() && !m["skipAuth"].empty()) {
      skipAuth = make_shared<string>(boost::any_cast<string>(m["skipAuth"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~GetEndpointSwitchTaskRequest() = default;
};
class GetEndpointSwitchTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<long> dbLinkId{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> oriUuid{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> uuid{};

  GetEndpointSwitchTaskResponseBodyData() {}

  explicit GetEndpointSwitchTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (dbLinkId) {
      res["DbLinkId"] = boost::any(*dbLinkId);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (oriUuid) {
      res["OriUuid"] = boost::any(*oriUuid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("DbLinkId") != m.end() && !m["DbLinkId"].empty()) {
      dbLinkId = make_shared<long>(boost::any_cast<long>(m["DbLinkId"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("OriUuid") != m.end() && !m["OriUuid"].empty()) {
      oriUuid = make_shared<string>(boost::any_cast<string>(m["OriUuid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetEndpointSwitchTaskResponseBodyData() = default;
};
class GetEndpointSwitchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEndpointSwitchTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  GetEndpointSwitchTaskResponseBody() {}

  explicit GetEndpointSwitchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEndpointSwitchTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEndpointSwitchTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~GetEndpointSwitchTaskResponseBody() = default;
};
class GetEndpointSwitchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEndpointSwitchTaskResponseBody> body{};

  GetEndpointSwitchTaskResponse() {}

  explicit GetEndpointSwitchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEndpointSwitchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEndpointSwitchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetEndpointSwitchTaskResponse() = default;
};
class GetErrorRequestSampleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> start{};

  GetErrorRequestSampleRequest() {}

  explicit GetErrorRequestSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~GetErrorRequestSampleRequest() = default;
};
class GetErrorRequestSampleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> originHost{};
  shared_ptr<string> sql{};
  shared_ptr<string> sqlId{};
  shared_ptr<vector<string>> tables{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> user{};

  GetErrorRequestSampleResponseBodyData() {}

  explicit GetErrorRequestSampleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["database"] = boost::any(*database);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (originHost) {
      res["originHost"] = boost::any(*originHost);
    }
    if (sql) {
      res["sql"] = boost::any(*sql);
    }
    if (sqlId) {
      res["sqlId"] = boost::any(*sqlId);
    }
    if (tables) {
      res["tables"] = boost::any(*tables);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (user) {
      res["user"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("database") != m.end() && !m["database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["database"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("originHost") != m.end() && !m["originHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["originHost"]));
    }
    if (m.find("sql") != m.end() && !m["sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["sql"]));
    }
    if (m.find("sqlId") != m.end() && !m["sqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["sqlId"]));
    }
    if (m.find("tables") != m.end() && !m["tables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
    if (m.find("user") != m.end() && !m["user"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["user"]));
    }
  }


  virtual ~GetErrorRequestSampleResponseBodyData() = default;
};
class GetErrorRequestSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetErrorRequestSampleResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetErrorRequestSampleResponseBody() {}

  explicit GetErrorRequestSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetErrorRequestSampleResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetErrorRequestSampleResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetErrorRequestSampleResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetErrorRequestSampleResponseBody() = default;
};
class GetErrorRequestSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetErrorRequestSampleResponseBody> body{};

  GetErrorRequestSampleResponse() {}

  explicit GetErrorRequestSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetErrorRequestSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetErrorRequestSampleResponseBody>(model1);
      }
    }
  }


  virtual ~GetErrorRequestSampleResponse() = default;
};
class GetEventSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetEventSubscriptionRequest() {}

  explicit GetEventSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetEventSubscriptionRequest() = default;
};
class GetEventSubscriptionResponseBodyDataContactGroups : public Darabonba::Model {
public:
  shared_ptr<string> contacts{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetEventSubscriptionResponseBodyDataContactGroups() {}

  explicit GetEventSubscriptionResponseBodyDataContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      res["contacts"] = boost::any(*contacts);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contacts") != m.end() && !m["contacts"].empty()) {
      contacts = make_shared<string>(boost::any_cast<string>(m["contacts"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GetEventSubscriptionResponseBodyDataContactGroups() = default;
};
class GetEventSubscriptionResponseBodyDataContacts : public Darabonba::Model {
public:
  shared_ptr<string> dingtalkHook{};
  shared_ptr<string> email{};
  shared_ptr<vector<string>> groups{};
  shared_ptr<bool> isCmsReduplicated{};
  shared_ptr<string> name{};
  shared_ptr<string> phone{};
  shared_ptr<string> userId{};

  GetEventSubscriptionResponseBodyDataContacts() {}

  explicit GetEventSubscriptionResponseBodyDataContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkHook) {
      res["dingtalkHook"] = boost::any(*dingtalkHook);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (groups) {
      res["groups"] = boost::any(*groups);
    }
    if (isCmsReduplicated) {
      res["isCmsReduplicated"] = boost::any(*isCmsReduplicated);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dingtalkHook") != m.end() && !m["dingtalkHook"].empty()) {
      dingtalkHook = make_shared<string>(boost::any_cast<string>(m["dingtalkHook"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("groups") != m.end() && !m["groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isCmsReduplicated") != m.end() && !m["isCmsReduplicated"].empty()) {
      isCmsReduplicated = make_shared<bool>(boost::any_cast<bool>(m["isCmsReduplicated"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GetEventSubscriptionResponseBodyDataContacts() = default;
};
class GetEventSubscriptionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> active{};
  shared_ptr<string> channelType{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<GetEventSubscriptionResponseBodyDataContactGroups>> contactGroups{};
  shared_ptr<string> contactName{};
  shared_ptr<vector<GetEventSubscriptionResponseBodyDataContacts>> contacts{};
  shared_ptr<string> eventContext{};
  shared_ptr<vector<string>> eventSendGroup{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> minInterval{};
  shared_ptr<string> userId{};

  GetEventSubscriptionResponseBodyData() {}

  explicit GetEventSubscriptionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["active"] = boost::any(*active);
    }
    if (channelType) {
      res["channelType"] = boost::any(*channelType);
    }
    if (contactGroupName) {
      res["contactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactGroups) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contactGroups"] = boost::any(temp1);
    }
    if (contactName) {
      res["contactName"] = boost::any(*contactName);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contacts"] = boost::any(temp1);
    }
    if (eventContext) {
      res["eventContext"] = boost::any(*eventContext);
    }
    if (eventSendGroup) {
      res["eventSendGroup"] = boost::any(*eventSendGroup);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (minInterval) {
      res["minInterval"] = boost::any(*minInterval);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("active") != m.end() && !m["active"].empty()) {
      active = make_shared<long>(boost::any_cast<long>(m["active"]));
    }
    if (m.find("channelType") != m.end() && !m["channelType"].empty()) {
      channelType = make_shared<string>(boost::any_cast<string>(m["channelType"]));
    }
    if (m.find("contactGroupName") != m.end() && !m["contactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["contactGroupName"]));
    }
    if (m.find("contactGroups") != m.end() && !m["contactGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["contactGroups"].type()) {
        vector<GetEventSubscriptionResponseBodyDataContactGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contactGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventSubscriptionResponseBodyDataContactGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroups = make_shared<vector<GetEventSubscriptionResponseBodyDataContactGroups>>(expect1);
      }
    }
    if (m.find("contactName") != m.end() && !m["contactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contactName"]));
    }
    if (m.find("contacts") != m.end() && !m["contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["contacts"].type()) {
        vector<GetEventSubscriptionResponseBodyDataContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventSubscriptionResponseBodyDataContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<GetEventSubscriptionResponseBodyDataContacts>>(expect1);
      }
    }
    if (m.find("eventContext") != m.end() && !m["eventContext"].empty()) {
      eventContext = make_shared<string>(boost::any_cast<string>(m["eventContext"]));
    }
    if (m.find("eventSendGroup") != m.end() && !m["eventSendGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["eventSendGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["eventSendGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventSendGroup = make_shared<vector<string>>(toVec1);
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("minInterval") != m.end() && !m["minInterval"].empty()) {
      minInterval = make_shared<string>(boost::any_cast<string>(m["minInterval"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GetEventSubscriptionResponseBodyData() = default;
};
class GetEventSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEventSubscriptionResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetEventSubscriptionResponseBody() {}

  explicit GetEventSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEventSubscriptionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEventSubscriptionResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetEventSubscriptionResponseBody() = default;
};
class GetEventSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventSubscriptionResponseBody> body{};

  GetEventSubscriptionResponse() {}

  explicit GetEventSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventSubscriptionResponse() = default;
};
class GetFullRequestOriginStatByInstanceIdRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> role{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> start{};
  shared_ptr<string> userId{};

  GetFullRequestOriginStatByInstanceIdRequest() {}

  explicit GetFullRequestOriginStatByInstanceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetFullRequestOriginStatByInstanceIdRequest() = default;
};
class GetFullRequestOriginStatByInstanceIdResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<double> avgExaminedRows{};
  shared_ptr<long> avgFetchRows{};
  shared_ptr<double> avgLockWaitTime{};
  shared_ptr<double> avgLogicalRead{};
  shared_ptr<long> avgPhysicalAsyncRead{};
  shared_ptr<double> avgPhysicalSyncRead{};
  shared_ptr<double> avgReturnedRows{};
  shared_ptr<long> avgRows{};
  shared_ptr<double> avgRt{};
  shared_ptr<long> avgSqlCount{};
  shared_ptr<double> avgUpdatedRows{};
  shared_ptr<long> count{};
  shared_ptr<double> countRate{};
  shared_ptr<string> database{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> examinedRows{};
  shared_ptr<long> fetchRows{};
  shared_ptr<string> ip{};
  shared_ptr<string> key{};
  shared_ptr<double> lockWaitTime{};
  shared_ptr<long> logicalRead{};
  shared_ptr<string> originHost{};
  shared_ptr<long> physicalAsyncRead{};
  shared_ptr<long> physicalSyncRead{};
  shared_ptr<long> port{};
  shared_ptr<long> rows{};
  shared_ptr<long> rtGreaterThanOneSecondCount{};
  shared_ptr<double> rtRate{};
  shared_ptr<long> sqlCount{};
  shared_ptr<long> sumUpdatedRows{};
  shared_ptr<long> version{};
  shared_ptr<string> vpcId{};

  GetFullRequestOriginStatByInstanceIdResponseBodyDataList() {}

  explicit GetFullRequestOriginStatByInstanceIdResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgExaminedRows) {
      res["AvgExaminedRows"] = boost::any(*avgExaminedRows);
    }
    if (avgFetchRows) {
      res["AvgFetchRows"] = boost::any(*avgFetchRows);
    }
    if (avgLockWaitTime) {
      res["AvgLockWaitTime"] = boost::any(*avgLockWaitTime);
    }
    if (avgLogicalRead) {
      res["AvgLogicalRead"] = boost::any(*avgLogicalRead);
    }
    if (avgPhysicalAsyncRead) {
      res["AvgPhysicalAsyncRead"] = boost::any(*avgPhysicalAsyncRead);
    }
    if (avgPhysicalSyncRead) {
      res["AvgPhysicalSyncRead"] = boost::any(*avgPhysicalSyncRead);
    }
    if (avgReturnedRows) {
      res["AvgReturnedRows"] = boost::any(*avgReturnedRows);
    }
    if (avgRows) {
      res["AvgRows"] = boost::any(*avgRows);
    }
    if (avgRt) {
      res["AvgRt"] = boost::any(*avgRt);
    }
    if (avgSqlCount) {
      res["AvgSqlCount"] = boost::any(*avgSqlCount);
    }
    if (avgUpdatedRows) {
      res["AvgUpdatedRows"] = boost::any(*avgUpdatedRows);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (countRate) {
      res["CountRate"] = boost::any(*countRate);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (examinedRows) {
      res["ExaminedRows"] = boost::any(*examinedRows);
    }
    if (fetchRows) {
      res["FetchRows"] = boost::any(*fetchRows);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (lockWaitTime) {
      res["LockWaitTime"] = boost::any(*lockWaitTime);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (physicalAsyncRead) {
      res["PhysicalAsyncRead"] = boost::any(*physicalAsyncRead);
    }
    if (physicalSyncRead) {
      res["PhysicalSyncRead"] = boost::any(*physicalSyncRead);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (rtGreaterThanOneSecondCount) {
      res["RtGreaterThanOneSecondCount"] = boost::any(*rtGreaterThanOneSecondCount);
    }
    if (rtRate) {
      res["RtRate"] = boost::any(*rtRate);
    }
    if (sqlCount) {
      res["SqlCount"] = boost::any(*sqlCount);
    }
    if (sumUpdatedRows) {
      res["SumUpdatedRows"] = boost::any(*sumUpdatedRows);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgExaminedRows") != m.end() && !m["AvgExaminedRows"].empty()) {
      avgExaminedRows = make_shared<double>(boost::any_cast<double>(m["AvgExaminedRows"]));
    }
    if (m.find("AvgFetchRows") != m.end() && !m["AvgFetchRows"].empty()) {
      avgFetchRows = make_shared<long>(boost::any_cast<long>(m["AvgFetchRows"]));
    }
    if (m.find("AvgLockWaitTime") != m.end() && !m["AvgLockWaitTime"].empty()) {
      avgLockWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgLockWaitTime"]));
    }
    if (m.find("AvgLogicalRead") != m.end() && !m["AvgLogicalRead"].empty()) {
      avgLogicalRead = make_shared<double>(boost::any_cast<double>(m["AvgLogicalRead"]));
    }
    if (m.find("AvgPhysicalAsyncRead") != m.end() && !m["AvgPhysicalAsyncRead"].empty()) {
      avgPhysicalAsyncRead = make_shared<long>(boost::any_cast<long>(m["AvgPhysicalAsyncRead"]));
    }
    if (m.find("AvgPhysicalSyncRead") != m.end() && !m["AvgPhysicalSyncRead"].empty()) {
      avgPhysicalSyncRead = make_shared<double>(boost::any_cast<double>(m["AvgPhysicalSyncRead"]));
    }
    if (m.find("AvgReturnedRows") != m.end() && !m["AvgReturnedRows"].empty()) {
      avgReturnedRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnedRows"]));
    }
    if (m.find("AvgRows") != m.end() && !m["AvgRows"].empty()) {
      avgRows = make_shared<long>(boost::any_cast<long>(m["AvgRows"]));
    }
    if (m.find("AvgRt") != m.end() && !m["AvgRt"].empty()) {
      avgRt = make_shared<double>(boost::any_cast<double>(m["AvgRt"]));
    }
    if (m.find("AvgSqlCount") != m.end() && !m["AvgSqlCount"].empty()) {
      avgSqlCount = make_shared<long>(boost::any_cast<long>(m["AvgSqlCount"]));
    }
    if (m.find("AvgUpdatedRows") != m.end() && !m["AvgUpdatedRows"].empty()) {
      avgUpdatedRows = make_shared<double>(boost::any_cast<double>(m["AvgUpdatedRows"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CountRate") != m.end() && !m["CountRate"].empty()) {
      countRate = make_shared<double>(boost::any_cast<double>(m["CountRate"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("ExaminedRows") != m.end() && !m["ExaminedRows"].empty()) {
      examinedRows = make_shared<long>(boost::any_cast<long>(m["ExaminedRows"]));
    }
    if (m.find("FetchRows") != m.end() && !m["FetchRows"].empty()) {
      fetchRows = make_shared<long>(boost::any_cast<long>(m["FetchRows"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("LockWaitTime") != m.end() && !m["LockWaitTime"].empty()) {
      lockWaitTime = make_shared<double>(boost::any_cast<double>(m["LockWaitTime"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<long>(boost::any_cast<long>(m["LogicalRead"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("PhysicalAsyncRead") != m.end() && !m["PhysicalAsyncRead"].empty()) {
      physicalAsyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicalAsyncRead"]));
    }
    if (m.find("PhysicalSyncRead") != m.end() && !m["PhysicalSyncRead"].empty()) {
      physicalSyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicalSyncRead"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      rows = make_shared<long>(boost::any_cast<long>(m["Rows"]));
    }
    if (m.find("RtGreaterThanOneSecondCount") != m.end() && !m["RtGreaterThanOneSecondCount"].empty()) {
      rtGreaterThanOneSecondCount = make_shared<long>(boost::any_cast<long>(m["RtGreaterThanOneSecondCount"]));
    }
    if (m.find("RtRate") != m.end() && !m["RtRate"].empty()) {
      rtRate = make_shared<double>(boost::any_cast<double>(m["RtRate"]));
    }
    if (m.find("SqlCount") != m.end() && !m["SqlCount"].empty()) {
      sqlCount = make_shared<long>(boost::any_cast<long>(m["SqlCount"]));
    }
    if (m.find("SumUpdatedRows") != m.end() && !m["SumUpdatedRows"].empty()) {
      sumUpdatedRows = make_shared<long>(boost::any_cast<long>(m["SumUpdatedRows"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetFullRequestOriginStatByInstanceIdResponseBodyDataList() = default;
};
class GetFullRequestOriginStatByInstanceIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetFullRequestOriginStatByInstanceIdResponseBodyDataList>> list{};
  shared_ptr<long> total{};

  GetFullRequestOriginStatByInstanceIdResponseBodyData() {}

  explicit GetFullRequestOriginStatByInstanceIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetFullRequestOriginStatByInstanceIdResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFullRequestOriginStatByInstanceIdResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetFullRequestOriginStatByInstanceIdResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetFullRequestOriginStatByInstanceIdResponseBodyData() = default;
};
class GetFullRequestOriginStatByInstanceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetFullRequestOriginStatByInstanceIdResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFullRequestOriginStatByInstanceIdResponseBody() {}

  explicit GetFullRequestOriginStatByInstanceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFullRequestOriginStatByInstanceIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFullRequestOriginStatByInstanceIdResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFullRequestOriginStatByInstanceIdResponseBody() = default;
};
class GetFullRequestOriginStatByInstanceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFullRequestOriginStatByInstanceIdResponseBody> body{};

  GetFullRequestOriginStatByInstanceIdResponse() {}

  explicit GetFullRequestOriginStatByInstanceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFullRequestOriginStatByInstanceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFullRequestOriginStatByInstanceIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetFullRequestOriginStatByInstanceIdResponse() = default;
};
class GetFullRequestSampleByInstanceIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> role{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> start{};
  shared_ptr<string> userId{};

  GetFullRequestSampleByInstanceIdRequest() {}

  explicit GetFullRequestSampleByInstanceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetFullRequestSampleByInstanceIdRequest() = default;
};
class GetFullRequestSampleByInstanceIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<long> frows{};
  shared_ptr<double> lockWaitTime{};
  shared_ptr<double> logicalRead{};
  shared_ptr<string> originHost{};
  shared_ptr<double> physicalAsyncRead{};
  shared_ptr<double> physicalSyncRead{};
  shared_ptr<long> rows{};
  shared_ptr<long> rowsExamined{};
  shared_ptr<long> rowsReturned{};
  shared_ptr<double> rt{};
  shared_ptr<long> scanRows{};
  shared_ptr<long> scnt{};
  shared_ptr<string> sql{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> updateRows{};
  shared_ptr<string> user{};

  GetFullRequestSampleByInstanceIdResponseBodyData() {}

  explicit GetFullRequestSampleByInstanceIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (frows) {
      res["Frows"] = boost::any(*frows);
    }
    if (lockWaitTime) {
      res["LockWaitTime"] = boost::any(*lockWaitTime);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (physicalAsyncRead) {
      res["PhysicalAsyncRead"] = boost::any(*physicalAsyncRead);
    }
    if (physicalSyncRead) {
      res["PhysicalSyncRead"] = boost::any(*physicalSyncRead);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (rowsExamined) {
      res["RowsExamined"] = boost::any(*rowsExamined);
    }
    if (rowsReturned) {
      res["RowsReturned"] = boost::any(*rowsReturned);
    }
    if (rt) {
      res["Rt"] = boost::any(*rt);
    }
    if (scanRows) {
      res["ScanRows"] = boost::any(*scanRows);
    }
    if (scnt) {
      res["Scnt"] = boost::any(*scnt);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (updateRows) {
      res["UpdateRows"] = boost::any(*updateRows);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Frows") != m.end() && !m["Frows"].empty()) {
      frows = make_shared<long>(boost::any_cast<long>(m["Frows"]));
    }
    if (m.find("LockWaitTime") != m.end() && !m["LockWaitTime"].empty()) {
      lockWaitTime = make_shared<double>(boost::any_cast<double>(m["LockWaitTime"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<double>(boost::any_cast<double>(m["LogicalRead"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("PhysicalAsyncRead") != m.end() && !m["PhysicalAsyncRead"].empty()) {
      physicalAsyncRead = make_shared<double>(boost::any_cast<double>(m["PhysicalAsyncRead"]));
    }
    if (m.find("PhysicalSyncRead") != m.end() && !m["PhysicalSyncRead"].empty()) {
      physicalSyncRead = make_shared<double>(boost::any_cast<double>(m["PhysicalSyncRead"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      rows = make_shared<long>(boost::any_cast<long>(m["Rows"]));
    }
    if (m.find("RowsExamined") != m.end() && !m["RowsExamined"].empty()) {
      rowsExamined = make_shared<long>(boost::any_cast<long>(m["RowsExamined"]));
    }
    if (m.find("RowsReturned") != m.end() && !m["RowsReturned"].empty()) {
      rowsReturned = make_shared<long>(boost::any_cast<long>(m["RowsReturned"]));
    }
    if (m.find("Rt") != m.end() && !m["Rt"].empty()) {
      rt = make_shared<double>(boost::any_cast<double>(m["Rt"]));
    }
    if (m.find("ScanRows") != m.end() && !m["ScanRows"].empty()) {
      scanRows = make_shared<long>(boost::any_cast<long>(m["ScanRows"]));
    }
    if (m.find("Scnt") != m.end() && !m["Scnt"].empty()) {
      scnt = make_shared<long>(boost::any_cast<long>(m["Scnt"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UpdateRows") != m.end() && !m["UpdateRows"].empty()) {
      updateRows = make_shared<long>(boost::any_cast<long>(m["UpdateRows"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetFullRequestSampleByInstanceIdResponseBodyData() = default;
};
class GetFullRequestSampleByInstanceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetFullRequestSampleByInstanceIdResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFullRequestSampleByInstanceIdResponseBody() {}

  explicit GetFullRequestSampleByInstanceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetFullRequestSampleByInstanceIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFullRequestSampleByInstanceIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetFullRequestSampleByInstanceIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFullRequestSampleByInstanceIdResponseBody() = default;
};
class GetFullRequestSampleByInstanceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFullRequestSampleByInstanceIdResponseBody> body{};

  GetFullRequestSampleByInstanceIdResponse() {}

  explicit GetFullRequestSampleByInstanceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFullRequestSampleByInstanceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFullRequestSampleByInstanceIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetFullRequestSampleByInstanceIdResponse() = default;
};
class GetFullRequestStatResultByInstanceIdRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<string> dbName{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> originHost{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> role{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> start{};
  shared_ptr<string> userId{};

  GetFullRequestStatResultByInstanceIdRequest() {}

  explicit GetFullRequestStatResultByInstanceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdRequest() = default;
};
class GetFullRequestStatResultByInstanceIdResponseBodyDataResultList : public Darabonba::Model {
public:
  shared_ptr<double> avgExaminedRows{};
  shared_ptr<long> avgFetchRows{};
  shared_ptr<double> avgLockWaitTime{};
  shared_ptr<double> avgLogicalRead{};
  shared_ptr<long> avgPhysicalAsyncRead{};
  shared_ptr<long> avgPhysicalSyncRead{};
  shared_ptr<double> avgReturnedRows{};
  shared_ptr<double> avgRt{};
  shared_ptr<long> avgSqlCount{};
  shared_ptr<long> avgUpdatedRows{};
  shared_ptr<long> count{};
  shared_ptr<double> countRate{};
  shared_ptr<string> database{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> examinedRows{};
  shared_ptr<long> fetchRows{};
  shared_ptr<string> ip{};
  shared_ptr<double> lockWaitTime{};
  shared_ptr<long> logicalRead{};
  shared_ptr<long> physicalAsyncRead{};
  shared_ptr<long> physicalSyncRead{};
  shared_ptr<long> port{};
  shared_ptr<string> psql{};
  shared_ptr<long> rows{};
  shared_ptr<long> rtGreaterThanOneSecondCount{};
  shared_ptr<double> rtRate{};
  shared_ptr<long> sqlCount{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> sumUpdatedRows{};
  shared_ptr<vector<string>> tables{};
  shared_ptr<long> version{};
  shared_ptr<string> vpcId{};

  GetFullRequestStatResultByInstanceIdResponseBodyDataResultList() {}

  explicit GetFullRequestStatResultByInstanceIdResponseBodyDataResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgExaminedRows) {
      res["AvgExaminedRows"] = boost::any(*avgExaminedRows);
    }
    if (avgFetchRows) {
      res["AvgFetchRows"] = boost::any(*avgFetchRows);
    }
    if (avgLockWaitTime) {
      res["AvgLockWaitTime"] = boost::any(*avgLockWaitTime);
    }
    if (avgLogicalRead) {
      res["AvgLogicalRead"] = boost::any(*avgLogicalRead);
    }
    if (avgPhysicalAsyncRead) {
      res["AvgPhysicalAsyncRead"] = boost::any(*avgPhysicalAsyncRead);
    }
    if (avgPhysicalSyncRead) {
      res["AvgPhysicalSyncRead"] = boost::any(*avgPhysicalSyncRead);
    }
    if (avgReturnedRows) {
      res["AvgReturnedRows"] = boost::any(*avgReturnedRows);
    }
    if (avgRt) {
      res["AvgRt"] = boost::any(*avgRt);
    }
    if (avgSqlCount) {
      res["AvgSqlCount"] = boost::any(*avgSqlCount);
    }
    if (avgUpdatedRows) {
      res["AvgUpdatedRows"] = boost::any(*avgUpdatedRows);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (countRate) {
      res["CountRate"] = boost::any(*countRate);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (examinedRows) {
      res["ExaminedRows"] = boost::any(*examinedRows);
    }
    if (fetchRows) {
      res["FetchRows"] = boost::any(*fetchRows);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (lockWaitTime) {
      res["LockWaitTime"] = boost::any(*lockWaitTime);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (physicalAsyncRead) {
      res["PhysicalAsyncRead"] = boost::any(*physicalAsyncRead);
    }
    if (physicalSyncRead) {
      res["PhysicalSyncRead"] = boost::any(*physicalSyncRead);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (psql) {
      res["Psql"] = boost::any(*psql);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (rtGreaterThanOneSecondCount) {
      res["RtGreaterThanOneSecondCount"] = boost::any(*rtGreaterThanOneSecondCount);
    }
    if (rtRate) {
      res["RtRate"] = boost::any(*rtRate);
    }
    if (sqlCount) {
      res["SqlCount"] = boost::any(*sqlCount);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sumUpdatedRows) {
      res["SumUpdatedRows"] = boost::any(*sumUpdatedRows);
    }
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgExaminedRows") != m.end() && !m["AvgExaminedRows"].empty()) {
      avgExaminedRows = make_shared<double>(boost::any_cast<double>(m["AvgExaminedRows"]));
    }
    if (m.find("AvgFetchRows") != m.end() && !m["AvgFetchRows"].empty()) {
      avgFetchRows = make_shared<long>(boost::any_cast<long>(m["AvgFetchRows"]));
    }
    if (m.find("AvgLockWaitTime") != m.end() && !m["AvgLockWaitTime"].empty()) {
      avgLockWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgLockWaitTime"]));
    }
    if (m.find("AvgLogicalRead") != m.end() && !m["AvgLogicalRead"].empty()) {
      avgLogicalRead = make_shared<double>(boost::any_cast<double>(m["AvgLogicalRead"]));
    }
    if (m.find("AvgPhysicalAsyncRead") != m.end() && !m["AvgPhysicalAsyncRead"].empty()) {
      avgPhysicalAsyncRead = make_shared<long>(boost::any_cast<long>(m["AvgPhysicalAsyncRead"]));
    }
    if (m.find("AvgPhysicalSyncRead") != m.end() && !m["AvgPhysicalSyncRead"].empty()) {
      avgPhysicalSyncRead = make_shared<long>(boost::any_cast<long>(m["AvgPhysicalSyncRead"]));
    }
    if (m.find("AvgReturnedRows") != m.end() && !m["AvgReturnedRows"].empty()) {
      avgReturnedRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnedRows"]));
    }
    if (m.find("AvgRt") != m.end() && !m["AvgRt"].empty()) {
      avgRt = make_shared<double>(boost::any_cast<double>(m["AvgRt"]));
    }
    if (m.find("AvgSqlCount") != m.end() && !m["AvgSqlCount"].empty()) {
      avgSqlCount = make_shared<long>(boost::any_cast<long>(m["AvgSqlCount"]));
    }
    if (m.find("AvgUpdatedRows") != m.end() && !m["AvgUpdatedRows"].empty()) {
      avgUpdatedRows = make_shared<long>(boost::any_cast<long>(m["AvgUpdatedRows"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CountRate") != m.end() && !m["CountRate"].empty()) {
      countRate = make_shared<double>(boost::any_cast<double>(m["CountRate"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("ExaminedRows") != m.end() && !m["ExaminedRows"].empty()) {
      examinedRows = make_shared<long>(boost::any_cast<long>(m["ExaminedRows"]));
    }
    if (m.find("FetchRows") != m.end() && !m["FetchRows"].empty()) {
      fetchRows = make_shared<long>(boost::any_cast<long>(m["FetchRows"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LockWaitTime") != m.end() && !m["LockWaitTime"].empty()) {
      lockWaitTime = make_shared<double>(boost::any_cast<double>(m["LockWaitTime"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<long>(boost::any_cast<long>(m["LogicalRead"]));
    }
    if (m.find("PhysicalAsyncRead") != m.end() && !m["PhysicalAsyncRead"].empty()) {
      physicalAsyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicalAsyncRead"]));
    }
    if (m.find("PhysicalSyncRead") != m.end() && !m["PhysicalSyncRead"].empty()) {
      physicalSyncRead = make_shared<long>(boost::any_cast<long>(m["PhysicalSyncRead"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Psql") != m.end() && !m["Psql"].empty()) {
      psql = make_shared<string>(boost::any_cast<string>(m["Psql"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      rows = make_shared<long>(boost::any_cast<long>(m["Rows"]));
    }
    if (m.find("RtGreaterThanOneSecondCount") != m.end() && !m["RtGreaterThanOneSecondCount"].empty()) {
      rtGreaterThanOneSecondCount = make_shared<long>(boost::any_cast<long>(m["RtGreaterThanOneSecondCount"]));
    }
    if (m.find("RtRate") != m.end() && !m["RtRate"].empty()) {
      rtRate = make_shared<double>(boost::any_cast<double>(m["RtRate"]));
    }
    if (m.find("SqlCount") != m.end() && !m["SqlCount"].empty()) {
      sqlCount = make_shared<long>(boost::any_cast<long>(m["SqlCount"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SumUpdatedRows") != m.end() && !m["SumUpdatedRows"].empty()) {
      sumUpdatedRows = make_shared<long>(boost::any_cast<long>(m["SumUpdatedRows"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdResponseBodyDataResultList() = default;
};
class GetFullRequestStatResultByInstanceIdResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetFullRequestStatResultByInstanceIdResponseBodyDataResultList>> list{};
  shared_ptr<long> total{};

  GetFullRequestStatResultByInstanceIdResponseBodyDataResult() {}

  explicit GetFullRequestStatResultByInstanceIdResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetFullRequestStatResultByInstanceIdResponseBodyDataResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFullRequestStatResultByInstanceIdResponseBodyDataResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetFullRequestStatResultByInstanceIdResponseBodyDataResultList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdResponseBodyDataResult() = default;
};
class GetFullRequestStatResultByInstanceIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<GetFullRequestStatResultByInstanceIdResponseBodyDataResult> result{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  GetFullRequestStatResultByInstanceIdResponseBodyData() {}

  explicit GetFullRequestStatResultByInstanceIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["IsFinish"] = boost::any(*isFinish);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["Fail"]));
    }
    if (m.find("IsFinish") != m.end() && !m["IsFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["IsFinish"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetFullRequestStatResultByInstanceIdResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetFullRequestStatResultByInstanceIdResponseBodyDataResult>(model1);
      }
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdResponseBodyData() = default;
};
class GetFullRequestStatResultByInstanceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetFullRequestStatResultByInstanceIdResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFullRequestStatResultByInstanceIdResponseBody() {}

  explicit GetFullRequestStatResultByInstanceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFullRequestStatResultByInstanceIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFullRequestStatResultByInstanceIdResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdResponseBody() = default;
};
class GetFullRequestStatResultByInstanceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFullRequestStatResultByInstanceIdResponseBody> body{};

  GetFullRequestStatResultByInstanceIdResponse() {}

  explicit GetFullRequestStatResultByInstanceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFullRequestStatResultByInstanceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFullRequestStatResultByInstanceIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetFullRequestStatResultByInstanceIdResponse() = default;
};
class GetHDMAliyunResourceSyncResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> context{};
  shared_ptr<string> accessKey{};
  shared_ptr<string> signature{};
  shared_ptr<string> skipAuth{};
  shared_ptr<string> timestamp{};

  GetHDMAliyunResourceSyncResultRequest() {}

  explicit GetHDMAliyunResourceSyncResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (skipAuth) {
      res["skipAuth"] = boost::any(*skipAuth);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("skipAuth") != m.end() && !m["skipAuth"].empty()) {
      skipAuth = make_shared<string>(boost::any_cast<string>(m["skipAuth"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultRequest() = default;
};
class GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> resourceType{};
  shared_ptr<bool> success{};
  shared_ptr<long> syncCount{};

  GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult() {}

  explicit GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (syncCount) {
      res["SyncCount"] = boost::any(*syncCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SyncCount") != m.end() && !m["SyncCount"].empty()) {
      syncCount = make_shared<long>(boost::any_cast<long>(m["SyncCount"]));
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult() = default;
};
class GetHDMAliyunResourceSyncResultResponseBodyDataSubResults : public Darabonba::Model {
public:
  shared_ptr<vector<GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult>> resourceSyncSubResult{};

  GetHDMAliyunResourceSyncResultResponseBodyDataSubResults() {}

  explicit GetHDMAliyunResourceSyncResultResponseBodyDataSubResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceSyncSubResult) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSyncSubResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSyncSubResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceSyncSubResult") != m.end() && !m["ResourceSyncSubResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSyncSubResult"].type()) {
        vector<GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSyncSubResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSyncSubResult = make_shared<vector<GetHDMAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult>>(expect1);
      }
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultResponseBodyDataSubResults() = default;
};
class GetHDMAliyunResourceSyncResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> results{};
  shared_ptr<GetHDMAliyunResourceSyncResultResponseBodyDataSubResults> subResults{};
  shared_ptr<string> syncStatus{};

  GetHDMAliyunResourceSyncResultResponseBodyData() {}

  explicit GetHDMAliyunResourceSyncResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (results) {
      res["Results"] = boost::any(*results);
    }
    if (subResults) {
      res["SubResults"] = subResults ? boost::any(subResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (syncStatus) {
      res["SyncStatus"] = boost::any(*syncStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      results = make_shared<string>(boost::any_cast<string>(m["Results"]));
    }
    if (m.find("SubResults") != m.end() && !m["SubResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubResults"].type()) {
        GetHDMAliyunResourceSyncResultResponseBodyDataSubResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubResults"]));
        subResults = make_shared<GetHDMAliyunResourceSyncResultResponseBodyDataSubResults>(model1);
      }
    }
    if (m.find("SyncStatus") != m.end() && !m["SyncStatus"].empty()) {
      syncStatus = make_shared<string>(boost::any_cast<string>(m["SyncStatus"]));
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultResponseBodyData() = default;
};
class GetHDMAliyunResourceSyncResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHDMAliyunResourceSyncResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  GetHDMAliyunResourceSyncResultResponseBody() {}

  explicit GetHDMAliyunResourceSyncResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHDMAliyunResourceSyncResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHDMAliyunResourceSyncResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultResponseBody() = default;
};
class GetHDMAliyunResourceSyncResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHDMAliyunResourceSyncResultResponseBody> body{};

  GetHDMAliyunResourceSyncResultResponse() {}

  explicit GetHDMAliyunResourceSyncResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHDMAliyunResourceSyncResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHDMAliyunResourceSyncResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetHDMAliyunResourceSyncResultResponse() = default;
};
class GetHDMLastAliyunResourceSyncResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> context{};
  shared_ptr<string> accessKey{};
  shared_ptr<string> signature{};
  shared_ptr<string> skipAuth{};
  shared_ptr<string> timestamp{};

  GetHDMLastAliyunResourceSyncResultRequest() {}

  explicit GetHDMLastAliyunResourceSyncResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (skipAuth) {
      res["skipAuth"] = boost::any(*skipAuth);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("skipAuth") != m.end() && !m["skipAuth"].empty()) {
      skipAuth = make_shared<string>(boost::any_cast<string>(m["skipAuth"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultRequest() = default;
};
class GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> resourceType{};
  shared_ptr<bool> success{};
  shared_ptr<long> syncCount{};

  GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult() {}

  explicit GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (syncCount) {
      res["SyncCount"] = boost::any(*syncCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SyncCount") != m.end() && !m["SyncCount"].empty()) {
      syncCount = make_shared<long>(boost::any_cast<long>(m["SyncCount"]));
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult() = default;
};
class GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults : public Darabonba::Model {
public:
  shared_ptr<vector<GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult>> resourceSyncSubResult{};

  GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults() {}

  explicit GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceSyncSubResult) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSyncSubResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSyncSubResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceSyncSubResult") != m.end() && !m["ResourceSyncSubResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSyncSubResult"].type()) {
        vector<GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSyncSubResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSyncSubResult = make_shared<vector<GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResultsResourceSyncSubResult>>(expect1);
      }
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults() = default;
};
class GetHDMLastAliyunResourceSyncResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> results{};
  shared_ptr<GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults> subResults{};
  shared_ptr<string> syncStatus{};

  GetHDMLastAliyunResourceSyncResultResponseBodyData() {}

  explicit GetHDMLastAliyunResourceSyncResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (results) {
      res["Results"] = boost::any(*results);
    }
    if (subResults) {
      res["SubResults"] = subResults ? boost::any(subResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (syncStatus) {
      res["SyncStatus"] = boost::any(*syncStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      results = make_shared<string>(boost::any_cast<string>(m["Results"]));
    }
    if (m.find("SubResults") != m.end() && !m["SubResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubResults"].type()) {
        GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubResults"]));
        subResults = make_shared<GetHDMLastAliyunResourceSyncResultResponseBodyDataSubResults>(model1);
      }
    }
    if (m.find("SyncStatus") != m.end() && !m["SyncStatus"].empty()) {
      syncStatus = make_shared<string>(boost::any_cast<string>(m["SyncStatus"]));
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultResponseBodyData() = default;
};
class GetHDMLastAliyunResourceSyncResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHDMLastAliyunResourceSyncResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  GetHDMLastAliyunResourceSyncResultResponseBody() {}

  explicit GetHDMLastAliyunResourceSyncResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHDMLastAliyunResourceSyncResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHDMLastAliyunResourceSyncResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultResponseBody() = default;
};
class GetHDMLastAliyunResourceSyncResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHDMLastAliyunResourceSyncResultResponseBody> body{};

  GetHDMLastAliyunResourceSyncResultResponse() {}

  explicit GetHDMLastAliyunResourceSyncResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHDMLastAliyunResourceSyncResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHDMLastAliyunResourceSyncResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetHDMLastAliyunResourceSyncResultResponse() = default;
};
class GetInstanceInspectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceArea{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> searchMap{};
  shared_ptr<string> startTime{};

  GetInstanceInspectionsRequest() {}

  explicit GetInstanceInspectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceArea) {
      res["InstanceArea"] = boost::any(*instanceArea);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (searchMap) {
      res["SearchMap"] = boost::any(*searchMap);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceArea") != m.end() && !m["InstanceArea"].empty()) {
      instanceArea = make_shared<string>(boost::any_cast<string>(m["InstanceArea"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SearchMap") != m.end() && !m["SearchMap"].empty()) {
      searchMap = make_shared<string>(boost::any_cast<string>(m["SearchMap"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetInstanceInspectionsRequest() = default;
};
class GetInstanceInspectionsResponseBodyDataListAutoFunction : public Darabonba::Model {
public:
  shared_ptr<long> autoIndex{};
  shared_ptr<long> autoLimitedSql{};
  shared_ptr<long> autoResourceOptimize{};
  shared_ptr<long> autoScale{};
  shared_ptr<long> eventSubscription{};

  GetInstanceInspectionsResponseBodyDataListAutoFunction() {}

  explicit GetInstanceInspectionsResponseBodyDataListAutoFunction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIndex) {
      res["AutoIndex"] = boost::any(*autoIndex);
    }
    if (autoLimitedSql) {
      res["AutoLimitedSql"] = boost::any(*autoLimitedSql);
    }
    if (autoResourceOptimize) {
      res["AutoResourceOptimize"] = boost::any(*autoResourceOptimize);
    }
    if (autoScale) {
      res["AutoScale"] = boost::any(*autoScale);
    }
    if (eventSubscription) {
      res["EventSubscription"] = boost::any(*eventSubscription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIndex") != m.end() && !m["AutoIndex"].empty()) {
      autoIndex = make_shared<long>(boost::any_cast<long>(m["AutoIndex"]));
    }
    if (m.find("AutoLimitedSql") != m.end() && !m["AutoLimitedSql"].empty()) {
      autoLimitedSql = make_shared<long>(boost::any_cast<long>(m["AutoLimitedSql"]));
    }
    if (m.find("AutoResourceOptimize") != m.end() && !m["AutoResourceOptimize"].empty()) {
      autoResourceOptimize = make_shared<long>(boost::any_cast<long>(m["AutoResourceOptimize"]));
    }
    if (m.find("AutoScale") != m.end() && !m["AutoScale"].empty()) {
      autoScale = make_shared<long>(boost::any_cast<long>(m["AutoScale"]));
    }
    if (m.find("EventSubscription") != m.end() && !m["EventSubscription"].empty()) {
      eventSubscription = make_shared<long>(boost::any_cast<long>(m["EventSubscription"]));
    }
  }


  virtual ~GetInstanceInspectionsResponseBodyDataListAutoFunction() = default;
};
class GetInstanceInspectionsResponseBodyDataListInstance : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> category{};
  shared_ptr<string> cpu{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceArea{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> memory{};
  shared_ptr<string> networkType{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> region{};
  shared_ptr<long> storage{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcId{};

  GetInstanceInspectionsResponseBodyDataListInstance() {}

  explicit GetInstanceInspectionsResponseBodyDataListInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceArea) {
      res["InstanceArea"] = boost::any(*instanceArea);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceArea") != m.end() && !m["InstanceArea"].empty()) {
      instanceArea = make_shared<string>(boost::any_cast<string>(m["InstanceArea"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["Storage"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetInstanceInspectionsResponseBodyDataListInstance() = default;
};
class GetInstanceInspectionsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<GetInstanceInspectionsResponseBodyDataListAutoFunction> autoFunction{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<long> enableDasPro{};
  shared_ptr<long> endTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<GetInstanceInspectionsResponseBodyDataListInstance> instance{};
  shared_ptr<long> score{};
  shared_ptr<map<string, boost::any>> scoreMap{};
  shared_ptr<long> startTime{};
  shared_ptr<long> state{};
  shared_ptr<long> taskType{};

  GetInstanceInspectionsResponseBodyDataList() {}

  explicit GetInstanceInspectionsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoFunction) {
      res["AutoFunction"] = autoFunction ? boost::any(autoFunction->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (enableDasPro) {
      res["EnableDasPro"] = boost::any(*enableDasPro);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (scoreMap) {
      res["ScoreMap"] = boost::any(*scoreMap);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoFunction") != m.end() && !m["AutoFunction"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoFunction"].type()) {
        GetInstanceInspectionsResponseBodyDataListAutoFunction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoFunction"]));
        autoFunction = make_shared<GetInstanceInspectionsResponseBodyDataListAutoFunction>(model1);
      }
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EnableDasPro") != m.end() && !m["EnableDasPro"].empty()) {
      enableDasPro = make_shared<long>(boost::any_cast<long>(m["EnableDasPro"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        GetInstanceInspectionsResponseBodyDataListInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<GetInstanceInspectionsResponseBodyDataListInstance>(model1);
      }
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("ScoreMap") != m.end() && !m["ScoreMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ScoreMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      scoreMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~GetInstanceInspectionsResponseBodyDataList() = default;
};
class GetInstanceInspectionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceInspectionsResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetInstanceInspectionsResponseBodyData() {}

  explicit GetInstanceInspectionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetInstanceInspectionsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceInspectionsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetInstanceInspectionsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetInstanceInspectionsResponseBodyData() = default;
};
class GetInstanceInspectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceInspectionsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetInstanceInspectionsResponseBody() {}

  explicit GetInstanceInspectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceInspectionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceInspectionsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetInstanceInspectionsResponseBody() = default;
};
class GetInstanceInspectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceInspectionsResponseBody> body{};

  GetInstanceInspectionsResponse() {}

  explicit GetInstanceInspectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceInspectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceInspectionsResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceInspectionsResponse() = default;
};
class GetInstanceMissingIndexListRequest : public Darabonba::Model {
public:
  shared_ptr<string> avgTotalUserCost{};
  shared_ptr<string> avgUserImpact{};
  shared_ptr<string> endTime{};
  shared_ptr<string> indexCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectName{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> reservedPages{};
  shared_ptr<string> reservedSize{};
  shared_ptr<string> rowCount{};
  shared_ptr<string> startTime{};
  shared_ptr<string> uniqueCompiles{};
  shared_ptr<string> userScans{};
  shared_ptr<string> userSeeks{};

  GetInstanceMissingIndexListRequest() {}

  explicit GetInstanceMissingIndexListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgTotalUserCost) {
      res["AvgTotalUserCost"] = boost::any(*avgTotalUserCost);
    }
    if (avgUserImpact) {
      res["AvgUserImpact"] = boost::any(*avgUserImpact);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (indexCount) {
      res["IndexCount"] = boost::any(*indexCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reservedPages) {
      res["ReservedPages"] = boost::any(*reservedPages);
    }
    if (reservedSize) {
      res["ReservedSize"] = boost::any(*reservedSize);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (uniqueCompiles) {
      res["UniqueCompiles"] = boost::any(*uniqueCompiles);
    }
    if (userScans) {
      res["UserScans"] = boost::any(*userScans);
    }
    if (userSeeks) {
      res["UserSeeks"] = boost::any(*userSeeks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgTotalUserCost") != m.end() && !m["AvgTotalUserCost"].empty()) {
      avgTotalUserCost = make_shared<string>(boost::any_cast<string>(m["AvgTotalUserCost"]));
    }
    if (m.find("AvgUserImpact") != m.end() && !m["AvgUserImpact"].empty()) {
      avgUserImpact = make_shared<string>(boost::any_cast<string>(m["AvgUserImpact"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IndexCount") != m.end() && !m["IndexCount"].empty()) {
      indexCount = make_shared<string>(boost::any_cast<string>(m["IndexCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ReservedPages") != m.end() && !m["ReservedPages"].empty()) {
      reservedPages = make_shared<string>(boost::any_cast<string>(m["ReservedPages"]));
    }
    if (m.find("ReservedSize") != m.end() && !m["ReservedSize"].empty()) {
      reservedSize = make_shared<string>(boost::any_cast<string>(m["ReservedSize"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<string>(boost::any_cast<string>(m["RowCount"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UniqueCompiles") != m.end() && !m["UniqueCompiles"].empty()) {
      uniqueCompiles = make_shared<string>(boost::any_cast<string>(m["UniqueCompiles"]));
    }
    if (m.find("UserScans") != m.end() && !m["UserScans"].empty()) {
      userScans = make_shared<string>(boost::any_cast<string>(m["UserScans"]));
    }
    if (m.find("UserSeeks") != m.end() && !m["UserSeeks"].empty()) {
      userSeeks = make_shared<string>(boost::any_cast<string>(m["UserSeeks"]));
    }
  }


  virtual ~GetInstanceMissingIndexListRequest() = default;
};
class GetInstanceMissingIndexListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<double> avgTotalUserCost{};
  shared_ptr<double> avgUserImpact{};
  shared_ptr<string> createIndex{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> equalityColumns{};
  shared_ptr<string> includedColumns{};
  shared_ptr<long> indexCount{};
  shared_ptr<string> inequalityColumns{};
  shared_ptr<long> lastUserSeek{};
  shared_ptr<string> objectName{};
  shared_ptr<long> reservedPages{};
  shared_ptr<double> reservedSize{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> schemaName{};
  shared_ptr<long> systemScans{};
  shared_ptr<long> systemSeeks{};
  shared_ptr<long> uniqueCompiles{};
  shared_ptr<long> userScans{};
  shared_ptr<long> userSeeks{};

  GetInstanceMissingIndexListResponseBodyDataList() {}

  explicit GetInstanceMissingIndexListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgTotalUserCost) {
      res["AvgTotalUserCost"] = boost::any(*avgTotalUserCost);
    }
    if (avgUserImpact) {
      res["AvgUserImpact"] = boost::any(*avgUserImpact);
    }
    if (createIndex) {
      res["CreateIndex"] = boost::any(*createIndex);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (equalityColumns) {
      res["EqualityColumns"] = boost::any(*equalityColumns);
    }
    if (includedColumns) {
      res["IncludedColumns"] = boost::any(*includedColumns);
    }
    if (indexCount) {
      res["IndexCount"] = boost::any(*indexCount);
    }
    if (inequalityColumns) {
      res["InequalityColumns"] = boost::any(*inequalityColumns);
    }
    if (lastUserSeek) {
      res["LastUserSeek"] = boost::any(*lastUserSeek);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (reservedPages) {
      res["ReservedPages"] = boost::any(*reservedPages);
    }
    if (reservedSize) {
      res["ReservedSize"] = boost::any(*reservedSize);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (systemScans) {
      res["SystemScans"] = boost::any(*systemScans);
    }
    if (systemSeeks) {
      res["SystemSeeks"] = boost::any(*systemSeeks);
    }
    if (uniqueCompiles) {
      res["UniqueCompiles"] = boost::any(*uniqueCompiles);
    }
    if (userScans) {
      res["UserScans"] = boost::any(*userScans);
    }
    if (userSeeks) {
      res["UserSeeks"] = boost::any(*userSeeks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgTotalUserCost") != m.end() && !m["AvgTotalUserCost"].empty()) {
      avgTotalUserCost = make_shared<double>(boost::any_cast<double>(m["AvgTotalUserCost"]));
    }
    if (m.find("AvgUserImpact") != m.end() && !m["AvgUserImpact"].empty()) {
      avgUserImpact = make_shared<double>(boost::any_cast<double>(m["AvgUserImpact"]));
    }
    if (m.find("CreateIndex") != m.end() && !m["CreateIndex"].empty()) {
      createIndex = make_shared<string>(boost::any_cast<string>(m["CreateIndex"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EqualityColumns") != m.end() && !m["EqualityColumns"].empty()) {
      equalityColumns = make_shared<string>(boost::any_cast<string>(m["EqualityColumns"]));
    }
    if (m.find("IncludedColumns") != m.end() && !m["IncludedColumns"].empty()) {
      includedColumns = make_shared<string>(boost::any_cast<string>(m["IncludedColumns"]));
    }
    if (m.find("IndexCount") != m.end() && !m["IndexCount"].empty()) {
      indexCount = make_shared<long>(boost::any_cast<long>(m["IndexCount"]));
    }
    if (m.find("InequalityColumns") != m.end() && !m["InequalityColumns"].empty()) {
      inequalityColumns = make_shared<string>(boost::any_cast<string>(m["InequalityColumns"]));
    }
    if (m.find("LastUserSeek") != m.end() && !m["LastUserSeek"].empty()) {
      lastUserSeek = make_shared<long>(boost::any_cast<long>(m["LastUserSeek"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ReservedPages") != m.end() && !m["ReservedPages"].empty()) {
      reservedPages = make_shared<long>(boost::any_cast<long>(m["ReservedPages"]));
    }
    if (m.find("ReservedSize") != m.end() && !m["ReservedSize"].empty()) {
      reservedSize = make_shared<double>(boost::any_cast<double>(m["ReservedSize"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SystemScans") != m.end() && !m["SystemScans"].empty()) {
      systemScans = make_shared<long>(boost::any_cast<long>(m["SystemScans"]));
    }
    if (m.find("SystemSeeks") != m.end() && !m["SystemSeeks"].empty()) {
      systemSeeks = make_shared<long>(boost::any_cast<long>(m["SystemSeeks"]));
    }
    if (m.find("UniqueCompiles") != m.end() && !m["UniqueCompiles"].empty()) {
      uniqueCompiles = make_shared<long>(boost::any_cast<long>(m["UniqueCompiles"]));
    }
    if (m.find("UserScans") != m.end() && !m["UserScans"].empty()) {
      userScans = make_shared<long>(boost::any_cast<long>(m["UserScans"]));
    }
    if (m.find("UserSeeks") != m.end() && !m["UserSeeks"].empty()) {
      userSeeks = make_shared<long>(boost::any_cast<long>(m["UserSeeks"]));
    }
  }


  virtual ~GetInstanceMissingIndexListResponseBodyDataList() = default;
};
class GetInstanceMissingIndexListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceMissingIndexListResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetInstanceMissingIndexListResponseBodyData() {}

  explicit GetInstanceMissingIndexListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetInstanceMissingIndexListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceMissingIndexListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetInstanceMissingIndexListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetInstanceMissingIndexListResponseBodyData() = default;
};
class GetInstanceMissingIndexListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceMissingIndexListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetInstanceMissingIndexListResponseBody() {}

  explicit GetInstanceMissingIndexListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceMissingIndexListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceMissingIndexListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetInstanceMissingIndexListResponseBody() = default;
};
class GetInstanceMissingIndexListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceMissingIndexListResponseBody> body{};

  GetInstanceMissingIndexListResponse() {}

  explicit GetInstanceMissingIndexListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceMissingIndexListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceMissingIndexListResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceMissingIndexListResponse() = default;
};
class GetInstanceSqlOptimizeStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> filterEnable{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> threshold{};
  shared_ptr<string> useMerging{};

  GetInstanceSqlOptimizeStatisticRequest() {}

  explicit GetInstanceSqlOptimizeStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterEnable) {
      res["FilterEnable"] = boost::any(*filterEnable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (useMerging) {
      res["UseMerging"] = boost::any(*useMerging);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterEnable") != m.end() && !m["FilterEnable"].empty()) {
      filterEnable = make_shared<string>(boost::any_cast<string>(m["FilterEnable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("UseMerging") != m.end() && !m["UseMerging"].empty()) {
      useMerging = make_shared<string>(boost::any_cast<string>(m["UseMerging"]));
    }
  }


  virtual ~GetInstanceSqlOptimizeStatisticRequest() = default;
};
class GetInstanceSqlOptimizeStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<double> improvement{};

  GetInstanceSqlOptimizeStatisticResponseBodyData() {}

  explicit GetInstanceSqlOptimizeStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (improvement) {
      res["improvement"] = boost::any(*improvement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("improvement") != m.end() && !m["improvement"].empty()) {
      improvement = make_shared<double>(boost::any_cast<double>(m["improvement"]));
    }
  }


  virtual ~GetInstanceSqlOptimizeStatisticResponseBodyData() = default;
};
class GetInstanceSqlOptimizeStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceSqlOptimizeStatisticResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetInstanceSqlOptimizeStatisticResponseBody() {}

  explicit GetInstanceSqlOptimizeStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceSqlOptimizeStatisticResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceSqlOptimizeStatisticResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetInstanceSqlOptimizeStatisticResponseBody() = default;
};
class GetInstanceSqlOptimizeStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceSqlOptimizeStatisticResponseBody> body{};

  GetInstanceSqlOptimizeStatisticResponse() {}

  explicit GetInstanceSqlOptimizeStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceSqlOptimizeStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceSqlOptimizeStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceSqlOptimizeStatisticResponse() = default;
};
class GetKillInstanceSessionTaskResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> taskId{};

  GetKillInstanceSessionTaskResultRequest() {}

  explicit GetKillInstanceSessionTaskResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetKillInstanceSessionTaskResultRequest() = default;
};
class GetKillInstanceSessionTaskResultResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> command{};
  shared_ptr<string> db{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> info{};
  shared_ptr<string> reason{};
  shared_ptr<string> state{};
  shared_ptr<string> taskId{};
  shared_ptr<long> time{};
  shared_ptr<string> user{};

  GetKillInstanceSessionTaskResultResponseBodyDataResult() {}

  explicit GetKillInstanceSessionTaskResultResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<string>(boost::any_cast<string>(m["Db"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetKillInstanceSessionTaskResultResponseBodyDataResult() = default;
};
class GetKillInstanceSessionTaskResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ignoredUserSessionCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> killFailCount{};
  shared_ptr<long> killSuccessCount{};
  shared_ptr<string> nodeId{};
  shared_ptr<vector<GetKillInstanceSessionTaskResultResponseBodyDataResult>> result{};
  shared_ptr<vector<long>> sessions{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<string> userId{};

  GetKillInstanceSessionTaskResultResponseBodyData() {}

  explicit GetKillInstanceSessionTaskResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredUserSessionCount) {
      res["IgnoredUserSessionCount"] = boost::any(*ignoredUserSessionCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (killFailCount) {
      res["KillFailCount"] = boost::any(*killFailCount);
    }
    if (killSuccessCount) {
      res["KillSuccessCount"] = boost::any(*killSuccessCount);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (sessions) {
      res["Sessions"] = boost::any(*sessions);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredUserSessionCount") != m.end() && !m["IgnoredUserSessionCount"].empty()) {
      ignoredUserSessionCount = make_shared<long>(boost::any_cast<long>(m["IgnoredUserSessionCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KillFailCount") != m.end() && !m["KillFailCount"].empty()) {
      killFailCount = make_shared<long>(boost::any_cast<long>(m["KillFailCount"]));
    }
    if (m.find("KillSuccessCount") != m.end() && !m["KillSuccessCount"].empty()) {
      killSuccessCount = make_shared<long>(boost::any_cast<long>(m["KillSuccessCount"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetKillInstanceSessionTaskResultResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetKillInstanceSessionTaskResultResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetKillInstanceSessionTaskResultResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sessions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sessions = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetKillInstanceSessionTaskResultResponseBodyData() = default;
};
class GetKillInstanceSessionTaskResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetKillInstanceSessionTaskResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetKillInstanceSessionTaskResultResponseBody() {}

  explicit GetKillInstanceSessionTaskResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetKillInstanceSessionTaskResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetKillInstanceSessionTaskResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetKillInstanceSessionTaskResultResponseBody() = default;
};
class GetKillInstanceSessionTaskResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetKillInstanceSessionTaskResultResponseBody> body{};

  GetKillInstanceSessionTaskResultResponse() {}

  explicit GetKillInstanceSessionTaskResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetKillInstanceSessionTaskResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetKillInstanceSessionTaskResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetKillInstanceSessionTaskResultResponse() = default;
};
class GetMongoDBCurrentOpRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterDoc{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> role{};

  GetMongoDBCurrentOpRequest() {}

  explicit GetMongoDBCurrentOpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterDoc) {
      res["FilterDoc"] = boost::any(*filterDoc);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterDoc") != m.end() && !m["FilterDoc"].empty()) {
      filterDoc = make_shared<string>(boost::any_cast<string>(m["FilterDoc"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~GetMongoDBCurrentOpRequest() = default;
};
class GetMongoDBCurrentOpResponseBodyDataSessionList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> client{};
  shared_ptr<string> command{};
  shared_ptr<long> connectionId{};
  shared_ptr<string> desc{};
  shared_ptr<string> driver{};
  shared_ptr<string> host{};
  shared_ptr<bool> killPending{};
  shared_ptr<string> ns{};
  shared_ptr<string> op{};
  shared_ptr<string> opId{};
  shared_ptr<string> osArch{};
  shared_ptr<string> osName{};
  shared_ptr<string> osType{};
  shared_ptr<string> planSummary{};
  shared_ptr<string> platform{};
  shared_ptr<long> secsRunning{};
  shared_ptr<string> shard{};

  GetMongoDBCurrentOpResponseBodyDataSessionList() {}

  explicit GetMongoDBCurrentOpResponseBodyDataSessionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (client) {
      res["Client"] = boost::any(*client);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (driver) {
      res["Driver"] = boost::any(*driver);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (killPending) {
      res["KillPending"] = boost::any(*killPending);
    }
    if (ns) {
      res["Ns"] = boost::any(*ns);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (opId) {
      res["OpId"] = boost::any(*opId);
    }
    if (osArch) {
      res["OsArch"] = boost::any(*osArch);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (planSummary) {
      res["PlanSummary"] = boost::any(*planSummary);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (secsRunning) {
      res["SecsRunning"] = boost::any(*secsRunning);
    }
    if (shard) {
      res["Shard"] = boost::any(*shard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("Client") != m.end() && !m["Client"].empty()) {
      client = make_shared<string>(boost::any_cast<string>(m["Client"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Driver") != m.end() && !m["Driver"].empty()) {
      driver = make_shared<string>(boost::any_cast<string>(m["Driver"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("KillPending") != m.end() && !m["KillPending"].empty()) {
      killPending = make_shared<bool>(boost::any_cast<bool>(m["KillPending"]));
    }
    if (m.find("Ns") != m.end() && !m["Ns"].empty()) {
      ns = make_shared<string>(boost::any_cast<string>(m["Ns"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("OpId") != m.end() && !m["OpId"].empty()) {
      opId = make_shared<string>(boost::any_cast<string>(m["OpId"]));
    }
    if (m.find("OsArch") != m.end() && !m["OsArch"].empty()) {
      osArch = make_shared<string>(boost::any_cast<string>(m["OsArch"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("PlanSummary") != m.end() && !m["PlanSummary"].empty()) {
      planSummary = make_shared<string>(boost::any_cast<string>(m["PlanSummary"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("SecsRunning") != m.end() && !m["SecsRunning"].empty()) {
      secsRunning = make_shared<long>(boost::any_cast<long>(m["SecsRunning"]));
    }
    if (m.find("Shard") != m.end() && !m["Shard"].empty()) {
      shard = make_shared<string>(boost::any_cast<string>(m["Shard"]));
    }
  }


  virtual ~GetMongoDBCurrentOpResponseBodyDataSessionList() = default;
};
class GetMongoDBCurrentOpResponseBodyDataSessionStat : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<map<string, DataSessionStatClientStatsValue>> clientStats{};
  shared_ptr<map<string, DataSessionStatDbStatsValue>> dbStats{};
  shared_ptr<long> longestSecsRunning{};
  shared_ptr<long> totalCount{};

  GetMongoDBCurrentOpResponseBodyDataSessionStat() {}

  explicit GetMongoDBCurrentOpResponseBodyDataSessionStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (clientStats) {
      map<string, boost::any> temp1;
      for(auto item1:*clientStats){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["ClientStats"] = boost::any(temp1);
    }
    if (dbStats) {
      map<string, boost::any> temp1;
      for(auto item1:*dbStats){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["DbStats"] = boost::any(temp1);
    }
    if (longestSecsRunning) {
      res["LongestSecsRunning"] = boost::any(*longestSecsRunning);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("ClientStats") != m.end() && !m["ClientStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientStats"].type()) {
        map<string, DataSessionStatClientStatsValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["ClientStats"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataSessionStatClientStatsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        clientStats = make_shared<map<string, DataSessionStatClientStatsValue>>(expect1);
      }
    }
    if (m.find("DbStats") != m.end() && !m["DbStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["DbStats"].type()) {
        map<string, DataSessionStatDbStatsValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["DbStats"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataSessionStatDbStatsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        dbStats = make_shared<map<string, DataSessionStatDbStatsValue>>(expect1);
      }
    }
    if (m.find("LongestSecsRunning") != m.end() && !m["LongestSecsRunning"].empty()) {
      longestSecsRunning = make_shared<long>(boost::any_cast<long>(m["LongestSecsRunning"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetMongoDBCurrentOpResponseBodyDataSessionStat() = default;
};
class GetMongoDBCurrentOpResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetMongoDBCurrentOpResponseBodyDataSessionList>> sessionList{};
  shared_ptr<GetMongoDBCurrentOpResponseBodyDataSessionStat> sessionStat{};
  shared_ptr<long> timestamp{};

  GetMongoDBCurrentOpResponseBodyData() {}

  explicit GetMongoDBCurrentOpResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sessionList) {
      vector<boost::any> temp1;
      for(auto item1:*sessionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SessionList"] = boost::any(temp1);
    }
    if (sessionStat) {
      res["SessionStat"] = sessionStat ? boost::any(sessionStat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SessionList") != m.end() && !m["SessionList"].empty()) {
      if (typeid(vector<boost::any>) == m["SessionList"].type()) {
        vector<GetMongoDBCurrentOpResponseBodyDataSessionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SessionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMongoDBCurrentOpResponseBodyDataSessionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessionList = make_shared<vector<GetMongoDBCurrentOpResponseBodyDataSessionList>>(expect1);
      }
    }
    if (m.find("SessionStat") != m.end() && !m["SessionStat"].empty()) {
      if (typeid(map<string, boost::any>) == m["SessionStat"].type()) {
        GetMongoDBCurrentOpResponseBodyDataSessionStat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SessionStat"]));
        sessionStat = make_shared<GetMongoDBCurrentOpResponseBodyDataSessionStat>(model1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetMongoDBCurrentOpResponseBodyData() = default;
};
class GetMongoDBCurrentOpResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetMongoDBCurrentOpResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMongoDBCurrentOpResponseBody() {}

  explicit GetMongoDBCurrentOpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMongoDBCurrentOpResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMongoDBCurrentOpResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMongoDBCurrentOpResponseBody() = default;
};
class GetMongoDBCurrentOpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMongoDBCurrentOpResponseBody> body{};

  GetMongoDBCurrentOpResponse() {}

  explicit GetMongoDBCurrentOpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMongoDBCurrentOpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMongoDBCurrentOpResponseBody>(model1);
      }
    }
  }


  virtual ~GetMongoDBCurrentOpResponse() = default;
};
class GetMySQLAllSessionAsyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> resultId{};

  GetMySQLAllSessionAsyncRequest() {}

  explicit GetMySQLAllSessionAsyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
  }


  virtual ~GetMySQLAllSessionAsyncRequest() = default;
};
class GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<string> key{};
  shared_ptr<vector<long>> threadIdList{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> userList{};

  GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats() {}

  explicit GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (threadIdList) {
      res["ThreadIdList"] = boost::any(*threadIdList);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ThreadIdList") != m.end() && !m["ThreadIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ThreadIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ThreadIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      threadIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats() = default;
};
class GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<string> key{};
  shared_ptr<vector<long>> threadIdList{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> userList{};

  GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats() {}

  explicit GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (threadIdList) {
      res["ThreadIdList"] = boost::any(*threadIdList);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ThreadIdList") != m.end() && !m["ThreadIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ThreadIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ThreadIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      threadIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats() = default;
};
class GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList : public Darabonba::Model {
public:
  shared_ptr<string> client{};
  shared_ptr<string> command{};
  shared_ptr<string> dbName{};
  shared_ptr<long> sessionId{};
  shared_ptr<string> sqlTemplateId{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> state{};
  shared_ptr<long> time{};
  shared_ptr<long> trxDuration{};
  shared_ptr<string> trxId{};
  shared_ptr<string> user{};
  shared_ptr<string> userClientAlias{};

  GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList() {}

  explicit GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (client) {
      res["Client"] = boost::any(*client);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sqlTemplateId) {
      res["SqlTemplateId"] = boost::any(*sqlTemplateId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (trxDuration) {
      res["TrxDuration"] = boost::any(*trxDuration);
    }
    if (trxId) {
      res["TrxId"] = boost::any(*trxId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (userClientAlias) {
      res["UserClientAlias"] = boost::any(*userClientAlias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Client") != m.end() && !m["Client"].empty()) {
      client = make_shared<string>(boost::any_cast<string>(m["Client"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<long>(boost::any_cast<long>(m["SessionId"]));
    }
    if (m.find("SqlTemplateId") != m.end() && !m["SqlTemplateId"].empty()) {
      sqlTemplateId = make_shared<string>(boost::any_cast<string>(m["SqlTemplateId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("TrxDuration") != m.end() && !m["TrxDuration"].empty()) {
      trxDuration = make_shared<long>(boost::any_cast<long>(m["TrxDuration"]));
    }
    if (m.find("TrxId") != m.end() && !m["TrxId"].empty()) {
      trxId = make_shared<string>(boost::any_cast<string>(m["TrxId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("UserClientAlias") != m.end() && !m["UserClientAlias"].empty()) {
      userClientAlias = make_shared<string>(boost::any_cast<string>(m["UserClientAlias"]));
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList() = default;
};
class GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<string> key{};
  shared_ptr<vector<long>> threadIdList{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> userList{};

  GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats() {}

  explicit GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["ActiveCount"] = boost::any(*activeCount);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (threadIdList) {
      res["ThreadIdList"] = boost::any(*threadIdList);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCount") != m.end() && !m["ActiveCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["ActiveCount"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ThreadIdList") != m.end() && !m["ThreadIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ThreadIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ThreadIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      threadIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats() = default;
};
class GetMySQLAllSessionAsyncResponseBodyDataSessionData : public Darabonba::Model {
public:
  shared_ptr<long> activeSessionCount{};
  shared_ptr<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats>> clientStats{};
  shared_ptr<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats>> dbStats{};
  shared_ptr<long> maxActiveTime{};
  shared_ptr<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList>> sessionList{};
  shared_ptr<long> timeStamp{};
  shared_ptr<long> totalSessionCount{};
  shared_ptr<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats>> userStats{};

  GetMySQLAllSessionAsyncResponseBodyDataSessionData() {}

  explicit GetMySQLAllSessionAsyncResponseBodyDataSessionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionCount) {
      res["ActiveSessionCount"] = boost::any(*activeSessionCount);
    }
    if (clientStats) {
      vector<boost::any> temp1;
      for(auto item1:*clientStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientStats"] = boost::any(temp1);
    }
    if (dbStats) {
      vector<boost::any> temp1;
      for(auto item1:*dbStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbStats"] = boost::any(temp1);
    }
    if (maxActiveTime) {
      res["MaxActiveTime"] = boost::any(*maxActiveTime);
    }
    if (sessionList) {
      vector<boost::any> temp1;
      for(auto item1:*sessionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SessionList"] = boost::any(temp1);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (totalSessionCount) {
      res["TotalSessionCount"] = boost::any(*totalSessionCount);
    }
    if (userStats) {
      vector<boost::any> temp1;
      for(auto item1:*userStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserStats"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionCount") != m.end() && !m["ActiveSessionCount"].empty()) {
      activeSessionCount = make_shared<long>(boost::any_cast<long>(m["ActiveSessionCount"]));
    }
    if (m.find("ClientStats") != m.end() && !m["ClientStats"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientStats"].type()) {
        vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientStats = make_shared<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataClientStats>>(expect1);
      }
    }
    if (m.find("DbStats") != m.end() && !m["DbStats"].empty()) {
      if (typeid(vector<boost::any>) == m["DbStats"].type()) {
        vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbStats = make_shared<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataDbStats>>(expect1);
      }
    }
    if (m.find("MaxActiveTime") != m.end() && !m["MaxActiveTime"].empty()) {
      maxActiveTime = make_shared<long>(boost::any_cast<long>(m["MaxActiveTime"]));
    }
    if (m.find("SessionList") != m.end() && !m["SessionList"].empty()) {
      if (typeid(vector<boost::any>) == m["SessionList"].type()) {
        vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SessionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessionList = make_shared<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataSessionList>>(expect1);
      }
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
    if (m.find("TotalSessionCount") != m.end() && !m["TotalSessionCount"].empty()) {
      totalSessionCount = make_shared<long>(boost::any_cast<long>(m["TotalSessionCount"]));
    }
    if (m.find("UserStats") != m.end() && !m["UserStats"].empty()) {
      if (typeid(vector<boost::any>) == m["UserStats"].type()) {
        vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userStats = make_shared<vector<GetMySQLAllSessionAsyncResponseBodyDataSessionDataUserStats>>(expect1);
      }
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyDataSessionData() = default;
};
class GetMySQLAllSessionAsyncResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<string> resultId{};
  shared_ptr<GetMySQLAllSessionAsyncResponseBodyDataSessionData> sessionData{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  GetMySQLAllSessionAsyncResponseBodyData() {}

  explicit GetMySQLAllSessionAsyncResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["IsFinish"] = boost::any(*isFinish);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    if (sessionData) {
      res["SessionData"] = sessionData ? boost::any(sessionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["Fail"]));
    }
    if (m.find("IsFinish") != m.end() && !m["IsFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["IsFinish"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
    if (m.find("SessionData") != m.end() && !m["SessionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["SessionData"].type()) {
        GetMySQLAllSessionAsyncResponseBodyDataSessionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SessionData"]));
        sessionData = make_shared<GetMySQLAllSessionAsyncResponseBodyDataSessionData>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBodyData() = default;
};
class GetMySQLAllSessionAsyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetMySQLAllSessionAsyncResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMySQLAllSessionAsyncResponseBody() {}

  explicit GetMySQLAllSessionAsyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMySQLAllSessionAsyncResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMySQLAllSessionAsyncResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponseBody() = default;
};
class GetMySQLAllSessionAsyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMySQLAllSessionAsyncResponseBody> body{};

  GetMySQLAllSessionAsyncResponse() {}

  explicit GetMySQLAllSessionAsyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMySQLAllSessionAsyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMySQLAllSessionAsyncResponseBody>(model1);
      }
    }
  }


  virtual ~GetMySQLAllSessionAsyncResponse() = default;
};
class GetPartitionsHeatmapRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timeRange{};
  shared_ptr<string> type{};

  GetPartitionsHeatmapRequest() {}

  explicit GetPartitionsHeatmapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPartitionsHeatmapRequest() = default;
};
class GetPartitionsHeatmapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetPartitionsHeatmapResponseBody() {}

  explicit GetPartitionsHeatmapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetPartitionsHeatmapResponseBody() = default;
};
class GetPartitionsHeatmapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPartitionsHeatmapResponseBody> body{};

  GetPartitionsHeatmapResponse() {}

  explicit GetPartitionsHeatmapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPartitionsHeatmapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPartitionsHeatmapResponseBody>(model1);
      }
    }
  }


  virtual ~GetPartitionsHeatmapResponse() = default;
};
class GetPfsMetricTrendsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metric{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> startTime{};

  GetPfsMetricTrendsRequest() {}

  explicit GetPfsMetricTrendsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetPfsMetricTrendsRequest() = default;
};
class GetPfsMetricTrendsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<map<string, vector<DataValue>>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPfsMetricTrendsResponseBody() {}

  explicit GetPfsMetricTrendsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      map<string, boost::any> temp1;
      for(auto item1:*data){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        map<string, vector<DataValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Data"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        data = make_shared<map<string, vector<DataValue>>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPfsMetricTrendsResponseBody() = default;
};
class GetPfsMetricTrendsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPfsMetricTrendsResponseBody> body{};

  GetPfsMetricTrendsResponse() {}

  explicit GetPfsMetricTrendsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPfsMetricTrendsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPfsMetricTrendsResponseBody>(model1);
      }
    }
  }


  virtual ~GetPfsMetricTrendsResponse() = default;
};
class GetPfsSqlSampleRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> startTime{};

  GetPfsSqlSampleRequest() {}

  explicit GetPfsSqlSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetPfsSqlSampleRequest() = default;
};
class GetPfsSqlSampleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> createTmpDiskTables{};
  shared_ptr<long> createTmpTables{};
  shared_ptr<string> db{};
  shared_ptr<long> endEventId{};
  shared_ptr<long> errors{};
  shared_ptr<long> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> latency{};
  shared_ptr<double> lockLatency{};
  shared_ptr<string> logicId{};
  shared_ptr<long> noGoodIndexUsed{};
  shared_ptr<long> noIndexUsed{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> rowsAffected{};
  shared_ptr<long> rowsExamined{};
  shared_ptr<long> rowsSent{};
  shared_ptr<long> selectFullJoin{};
  shared_ptr<long> selectFullRangeJoin{};
  shared_ptr<long> selectRange{};
  shared_ptr<long> selectRangeCheck{};
  shared_ptr<long> selectScan{};
  shared_ptr<long> sortMergePasses{};
  shared_ptr<long> sortRange{};
  shared_ptr<long> sortRows{};
  shared_ptr<long> sortScan{};
  shared_ptr<string> sql{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> threadId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userId{};
  shared_ptr<long> warnings{};

  GetPfsSqlSampleResponseBodyData() {}

  explicit GetPfsSqlSampleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTmpDiskTables) {
      res["CreateTmpDiskTables"] = boost::any(*createTmpDiskTables);
    }
    if (createTmpTables) {
      res["CreateTmpTables"] = boost::any(*createTmpTables);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (endEventId) {
      res["EndEventId"] = boost::any(*endEventId);
    }
    if (errors) {
      res["Errors"] = boost::any(*errors);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (latency) {
      res["Latency"] = boost::any(*latency);
    }
    if (lockLatency) {
      res["LockLatency"] = boost::any(*lockLatency);
    }
    if (logicId) {
      res["LogicId"] = boost::any(*logicId);
    }
    if (noGoodIndexUsed) {
      res["NoGoodIndexUsed"] = boost::any(*noGoodIndexUsed);
    }
    if (noIndexUsed) {
      res["NoIndexUsed"] = boost::any(*noIndexUsed);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (rowsAffected) {
      res["RowsAffected"] = boost::any(*rowsAffected);
    }
    if (rowsExamined) {
      res["RowsExamined"] = boost::any(*rowsExamined);
    }
    if (rowsSent) {
      res["RowsSent"] = boost::any(*rowsSent);
    }
    if (selectFullJoin) {
      res["SelectFullJoin"] = boost::any(*selectFullJoin);
    }
    if (selectFullRangeJoin) {
      res["SelectFullRangeJoin"] = boost::any(*selectFullRangeJoin);
    }
    if (selectRange) {
      res["SelectRange"] = boost::any(*selectRange);
    }
    if (selectRangeCheck) {
      res["SelectRangeCheck"] = boost::any(*selectRangeCheck);
    }
    if (selectScan) {
      res["SelectScan"] = boost::any(*selectScan);
    }
    if (sortMergePasses) {
      res["SortMergePasses"] = boost::any(*sortMergePasses);
    }
    if (sortRange) {
      res["SortRange"] = boost::any(*sortRange);
    }
    if (sortRows) {
      res["SortRows"] = boost::any(*sortRows);
    }
    if (sortScan) {
      res["SortScan"] = boost::any(*sortScan);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (threadId) {
      res["ThreadId"] = boost::any(*threadId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (warnings) {
      res["Warnings"] = boost::any(*warnings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTmpDiskTables") != m.end() && !m["CreateTmpDiskTables"].empty()) {
      createTmpDiskTables = make_shared<long>(boost::any_cast<long>(m["CreateTmpDiskTables"]));
    }
    if (m.find("CreateTmpTables") != m.end() && !m["CreateTmpTables"].empty()) {
      createTmpTables = make_shared<long>(boost::any_cast<long>(m["CreateTmpTables"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<string>(boost::any_cast<string>(m["Db"]));
    }
    if (m.find("EndEventId") != m.end() && !m["EndEventId"].empty()) {
      endEventId = make_shared<long>(boost::any_cast<long>(m["EndEventId"]));
    }
    if (m.find("Errors") != m.end() && !m["Errors"].empty()) {
      errors = make_shared<long>(boost::any_cast<long>(m["Errors"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["EventId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Latency") != m.end() && !m["Latency"].empty()) {
      latency = make_shared<double>(boost::any_cast<double>(m["Latency"]));
    }
    if (m.find("LockLatency") != m.end() && !m["LockLatency"].empty()) {
      lockLatency = make_shared<double>(boost::any_cast<double>(m["LockLatency"]));
    }
    if (m.find("LogicId") != m.end() && !m["LogicId"].empty()) {
      logicId = make_shared<string>(boost::any_cast<string>(m["LogicId"]));
    }
    if (m.find("NoGoodIndexUsed") != m.end() && !m["NoGoodIndexUsed"].empty()) {
      noGoodIndexUsed = make_shared<long>(boost::any_cast<long>(m["NoGoodIndexUsed"]));
    }
    if (m.find("NoIndexUsed") != m.end() && !m["NoIndexUsed"].empty()) {
      noIndexUsed = make_shared<long>(boost::any_cast<long>(m["NoIndexUsed"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("RowsAffected") != m.end() && !m["RowsAffected"].empty()) {
      rowsAffected = make_shared<long>(boost::any_cast<long>(m["RowsAffected"]));
    }
    if (m.find("RowsExamined") != m.end() && !m["RowsExamined"].empty()) {
      rowsExamined = make_shared<long>(boost::any_cast<long>(m["RowsExamined"]));
    }
    if (m.find("RowsSent") != m.end() && !m["RowsSent"].empty()) {
      rowsSent = make_shared<long>(boost::any_cast<long>(m["RowsSent"]));
    }
    if (m.find("SelectFullJoin") != m.end() && !m["SelectFullJoin"].empty()) {
      selectFullJoin = make_shared<long>(boost::any_cast<long>(m["SelectFullJoin"]));
    }
    if (m.find("SelectFullRangeJoin") != m.end() && !m["SelectFullRangeJoin"].empty()) {
      selectFullRangeJoin = make_shared<long>(boost::any_cast<long>(m["SelectFullRangeJoin"]));
    }
    if (m.find("SelectRange") != m.end() && !m["SelectRange"].empty()) {
      selectRange = make_shared<long>(boost::any_cast<long>(m["SelectRange"]));
    }
    if (m.find("SelectRangeCheck") != m.end() && !m["SelectRangeCheck"].empty()) {
      selectRangeCheck = make_shared<long>(boost::any_cast<long>(m["SelectRangeCheck"]));
    }
    if (m.find("SelectScan") != m.end() && !m["SelectScan"].empty()) {
      selectScan = make_shared<long>(boost::any_cast<long>(m["SelectScan"]));
    }
    if (m.find("SortMergePasses") != m.end() && !m["SortMergePasses"].empty()) {
      sortMergePasses = make_shared<long>(boost::any_cast<long>(m["SortMergePasses"]));
    }
    if (m.find("SortRange") != m.end() && !m["SortRange"].empty()) {
      sortRange = make_shared<long>(boost::any_cast<long>(m["SortRange"]));
    }
    if (m.find("SortRows") != m.end() && !m["SortRows"].empty()) {
      sortRows = make_shared<long>(boost::any_cast<long>(m["SortRows"]));
    }
    if (m.find("SortScan") != m.end() && !m["SortScan"].empty()) {
      sortScan = make_shared<long>(boost::any_cast<long>(m["SortScan"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("ThreadId") != m.end() && !m["ThreadId"].empty()) {
      threadId = make_shared<long>(boost::any_cast<long>(m["ThreadId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Warnings") != m.end() && !m["Warnings"].empty()) {
      warnings = make_shared<long>(boost::any_cast<long>(m["Warnings"]));
    }
  }


  virtual ~GetPfsSqlSampleResponseBodyData() = default;
};
class GetPfsSqlSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetPfsSqlSampleResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPfsSqlSampleResponseBody() {}

  explicit GetPfsSqlSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetPfsSqlSampleResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPfsSqlSampleResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetPfsSqlSampleResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPfsSqlSampleResponseBody() = default;
};
class GetPfsSqlSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPfsSqlSampleResponseBody> body{};

  GetPfsSqlSampleResponse() {}

  explicit GetPfsSqlSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPfsSqlSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPfsSqlSampleResponseBody>(model1);
      }
    }
  }


  virtual ~GetPfsSqlSampleResponse() = default;
};
class GetPfsSqlSummariesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keywords{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> startTime{};

  GetPfsSqlSummariesRequest() {}

  explicit GetPfsSqlSummariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetPfsSqlSummariesRequest() = default;
};
class GetPfsSqlSummariesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<double> avgLatency{};
  shared_ptr<long> count{};
  shared_ptr<double> countRate{};
  shared_ptr<double> cpuRate{};
  shared_ptr<double> cpuTime{};
  shared_ptr<double> dataReadTime{};
  shared_ptr<long> dataReads{};
  shared_ptr<double> dataWriteTime{};
  shared_ptr<long> dataWrites{};
  shared_ptr<string> db{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<long> errCount{};
  shared_ptr<long> firstTime{};
  shared_ptr<bool> fullScan{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastTime{};
  shared_ptr<double> lockLatencyAvg{};
  shared_ptr<long> logicId{};
  shared_ptr<long> logicReads{};
  shared_ptr<double> maxLatency{};
  shared_ptr<long> mutexSpins{};
  shared_ptr<long> mutexWaits{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> physicalAsyncReads{};
  shared_ptr<long> physicalReads{};
  shared_ptr<string> psql{};
  shared_ptr<long> redoWrites{};
  shared_ptr<long> rowsAffected{};
  shared_ptr<double> rowsAffectedAvg{};
  shared_ptr<long> rowsExamined{};
  shared_ptr<double> rowsExaminedAvg{};
  shared_ptr<double> rowsSendAvg{};
  shared_ptr<long> rowsSent{};
  shared_ptr<double> rowsSentAvg{};
  shared_ptr<long> rowsSorted{};
  shared_ptr<double> rtRate{};
  shared_ptr<long> rwlockOsWaits{};
  shared_ptr<long> rwlockSpinRounds{};
  shared_ptr<long> rwlockSpinWaits{};
  shared_ptr<double> selectFullJoinAvg{};
  shared_ptr<double> selectFullRangeJoinAvg{};
  shared_ptr<double> selectRangeAvg{};
  shared_ptr<double> selectScanAvg{};
  shared_ptr<double> semisyncDelayTime{};
  shared_ptr<double> serverLockTime{};
  shared_ptr<long> sortMergePasses{};
  shared_ptr<double> sortRangeAvg{};
  shared_ptr<double> sortRowsAvg{};
  shared_ptr<double> sortScanAvg{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlType{};
  shared_ptr<vector<string>> tables{};
  shared_ptr<double> timerWaitAvg{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> tmpDiskTables{};
  shared_ptr<double> tmpDiskTablesAvg{};
  shared_ptr<long> tmpTables{};
  shared_ptr<double> tmpTablesAvg{};
  shared_ptr<double> totalLatency{};
  shared_ptr<double> transactionLockTime{};
  shared_ptr<string> userId{};
  shared_ptr<long> warnCount{};

  GetPfsSqlSummariesResponseBodyDataList() {}

  explicit GetPfsSqlSummariesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgLatency) {
      res["AvgLatency"] = boost::any(*avgLatency);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (countRate) {
      res["CountRate"] = boost::any(*countRate);
    }
    if (cpuRate) {
      res["CpuRate"] = boost::any(*cpuRate);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dataReadTime) {
      res["DataReadTime"] = boost::any(*dataReadTime);
    }
    if (dataReads) {
      res["DataReads"] = boost::any(*dataReads);
    }
    if (dataWriteTime) {
      res["DataWriteTime"] = boost::any(*dataWriteTime);
    }
    if (dataWrites) {
      res["DataWrites"] = boost::any(*dataWrites);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (errCount) {
      res["ErrCount"] = boost::any(*errCount);
    }
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (fullScan) {
      res["FullScan"] = boost::any(*fullScan);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (lockLatencyAvg) {
      res["LockLatencyAvg"] = boost::any(*lockLatencyAvg);
    }
    if (logicId) {
      res["LogicId"] = boost::any(*logicId);
    }
    if (logicReads) {
      res["LogicReads"] = boost::any(*logicReads);
    }
    if (maxLatency) {
      res["MaxLatency"] = boost::any(*maxLatency);
    }
    if (mutexSpins) {
      res["MutexSpins"] = boost::any(*mutexSpins);
    }
    if (mutexWaits) {
      res["MutexWaits"] = boost::any(*mutexWaits);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (physicalAsyncReads) {
      res["PhysicalAsyncReads"] = boost::any(*physicalAsyncReads);
    }
    if (physicalReads) {
      res["PhysicalReads"] = boost::any(*physicalReads);
    }
    if (psql) {
      res["Psql"] = boost::any(*psql);
    }
    if (redoWrites) {
      res["RedoWrites"] = boost::any(*redoWrites);
    }
    if (rowsAffected) {
      res["RowsAffected"] = boost::any(*rowsAffected);
    }
    if (rowsAffectedAvg) {
      res["RowsAffectedAvg"] = boost::any(*rowsAffectedAvg);
    }
    if (rowsExamined) {
      res["RowsExamined"] = boost::any(*rowsExamined);
    }
    if (rowsExaminedAvg) {
      res["RowsExaminedAvg"] = boost::any(*rowsExaminedAvg);
    }
    if (rowsSendAvg) {
      res["RowsSendAvg"] = boost::any(*rowsSendAvg);
    }
    if (rowsSent) {
      res["RowsSent"] = boost::any(*rowsSent);
    }
    if (rowsSentAvg) {
      res["RowsSentAvg"] = boost::any(*rowsSentAvg);
    }
    if (rowsSorted) {
      res["RowsSorted"] = boost::any(*rowsSorted);
    }
    if (rtRate) {
      res["RtRate"] = boost::any(*rtRate);
    }
    if (rwlockOsWaits) {
      res["RwlockOsWaits"] = boost::any(*rwlockOsWaits);
    }
    if (rwlockSpinRounds) {
      res["RwlockSpinRounds"] = boost::any(*rwlockSpinRounds);
    }
    if (rwlockSpinWaits) {
      res["RwlockSpinWaits"] = boost::any(*rwlockSpinWaits);
    }
    if (selectFullJoinAvg) {
      res["SelectFullJoinAvg"] = boost::any(*selectFullJoinAvg);
    }
    if (selectFullRangeJoinAvg) {
      res["SelectFullRangeJoinAvg"] = boost::any(*selectFullRangeJoinAvg);
    }
    if (selectRangeAvg) {
      res["SelectRangeAvg"] = boost::any(*selectRangeAvg);
    }
    if (selectScanAvg) {
      res["SelectScanAvg"] = boost::any(*selectScanAvg);
    }
    if (semisyncDelayTime) {
      res["SemisyncDelayTime"] = boost::any(*semisyncDelayTime);
    }
    if (serverLockTime) {
      res["ServerLockTime"] = boost::any(*serverLockTime);
    }
    if (sortMergePasses) {
      res["SortMergePasses"] = boost::any(*sortMergePasses);
    }
    if (sortRangeAvg) {
      res["SortRangeAvg"] = boost::any(*sortRangeAvg);
    }
    if (sortRowsAvg) {
      res["SortRowsAvg"] = boost::any(*sortRowsAvg);
    }
    if (sortScanAvg) {
      res["SortScanAvg"] = boost::any(*sortScanAvg);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (timerWaitAvg) {
      res["TimerWaitAvg"] = boost::any(*timerWaitAvg);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (tmpDiskTables) {
      res["TmpDiskTables"] = boost::any(*tmpDiskTables);
    }
    if (tmpDiskTablesAvg) {
      res["TmpDiskTablesAvg"] = boost::any(*tmpDiskTablesAvg);
    }
    if (tmpTables) {
      res["TmpTables"] = boost::any(*tmpTables);
    }
    if (tmpTablesAvg) {
      res["TmpTablesAvg"] = boost::any(*tmpTablesAvg);
    }
    if (totalLatency) {
      res["TotalLatency"] = boost::any(*totalLatency);
    }
    if (transactionLockTime) {
      res["TransactionLockTime"] = boost::any(*transactionLockTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (warnCount) {
      res["WarnCount"] = boost::any(*warnCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgLatency") != m.end() && !m["AvgLatency"].empty()) {
      avgLatency = make_shared<double>(boost::any_cast<double>(m["AvgLatency"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CountRate") != m.end() && !m["CountRate"].empty()) {
      countRate = make_shared<double>(boost::any_cast<double>(m["CountRate"]));
    }
    if (m.find("CpuRate") != m.end() && !m["CpuRate"].empty()) {
      cpuRate = make_shared<double>(boost::any_cast<double>(m["CpuRate"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DataReadTime") != m.end() && !m["DataReadTime"].empty()) {
      dataReadTime = make_shared<double>(boost::any_cast<double>(m["DataReadTime"]));
    }
    if (m.find("DataReads") != m.end() && !m["DataReads"].empty()) {
      dataReads = make_shared<long>(boost::any_cast<long>(m["DataReads"]));
    }
    if (m.find("DataWriteTime") != m.end() && !m["DataWriteTime"].empty()) {
      dataWriteTime = make_shared<double>(boost::any_cast<double>(m["DataWriteTime"]));
    }
    if (m.find("DataWrites") != m.end() && !m["DataWrites"].empty()) {
      dataWrites = make_shared<long>(boost::any_cast<long>(m["DataWrites"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<string>(boost::any_cast<string>(m["Db"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("ErrCount") != m.end() && !m["ErrCount"].empty()) {
      errCount = make_shared<long>(boost::any_cast<long>(m["ErrCount"]));
    }
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("FullScan") != m.end() && !m["FullScan"].empty()) {
      fullScan = make_shared<bool>(boost::any_cast<bool>(m["FullScan"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("LockLatencyAvg") != m.end() && !m["LockLatencyAvg"].empty()) {
      lockLatencyAvg = make_shared<double>(boost::any_cast<double>(m["LockLatencyAvg"]));
    }
    if (m.find("LogicId") != m.end() && !m["LogicId"].empty()) {
      logicId = make_shared<long>(boost::any_cast<long>(m["LogicId"]));
    }
    if (m.find("LogicReads") != m.end() && !m["LogicReads"].empty()) {
      logicReads = make_shared<long>(boost::any_cast<long>(m["LogicReads"]));
    }
    if (m.find("MaxLatency") != m.end() && !m["MaxLatency"].empty()) {
      maxLatency = make_shared<double>(boost::any_cast<double>(m["MaxLatency"]));
    }
    if (m.find("MutexSpins") != m.end() && !m["MutexSpins"].empty()) {
      mutexSpins = make_shared<long>(boost::any_cast<long>(m["MutexSpins"]));
    }
    if (m.find("MutexWaits") != m.end() && !m["MutexWaits"].empty()) {
      mutexWaits = make_shared<long>(boost::any_cast<long>(m["MutexWaits"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PhysicalAsyncReads") != m.end() && !m["PhysicalAsyncReads"].empty()) {
      physicalAsyncReads = make_shared<long>(boost::any_cast<long>(m["PhysicalAsyncReads"]));
    }
    if (m.find("PhysicalReads") != m.end() && !m["PhysicalReads"].empty()) {
      physicalReads = make_shared<long>(boost::any_cast<long>(m["PhysicalReads"]));
    }
    if (m.find("Psql") != m.end() && !m["Psql"].empty()) {
      psql = make_shared<string>(boost::any_cast<string>(m["Psql"]));
    }
    if (m.find("RedoWrites") != m.end() && !m["RedoWrites"].empty()) {
      redoWrites = make_shared<long>(boost::any_cast<long>(m["RedoWrites"]));
    }
    if (m.find("RowsAffected") != m.end() && !m["RowsAffected"].empty()) {
      rowsAffected = make_shared<long>(boost::any_cast<long>(m["RowsAffected"]));
    }
    if (m.find("RowsAffectedAvg") != m.end() && !m["RowsAffectedAvg"].empty()) {
      rowsAffectedAvg = make_shared<double>(boost::any_cast<double>(m["RowsAffectedAvg"]));
    }
    if (m.find("RowsExamined") != m.end() && !m["RowsExamined"].empty()) {
      rowsExamined = make_shared<long>(boost::any_cast<long>(m["RowsExamined"]));
    }
    if (m.find("RowsExaminedAvg") != m.end() && !m["RowsExaminedAvg"].empty()) {
      rowsExaminedAvg = make_shared<double>(boost::any_cast<double>(m["RowsExaminedAvg"]));
    }
    if (m.find("RowsSendAvg") != m.end() && !m["RowsSendAvg"].empty()) {
      rowsSendAvg = make_shared<double>(boost::any_cast<double>(m["RowsSendAvg"]));
    }
    if (m.find("RowsSent") != m.end() && !m["RowsSent"].empty()) {
      rowsSent = make_shared<long>(boost::any_cast<long>(m["RowsSent"]));
    }
    if (m.find("RowsSentAvg") != m.end() && !m["RowsSentAvg"].empty()) {
      rowsSentAvg = make_shared<double>(boost::any_cast<double>(m["RowsSentAvg"]));
    }
    if (m.find("RowsSorted") != m.end() && !m["RowsSorted"].empty()) {
      rowsSorted = make_shared<long>(boost::any_cast<long>(m["RowsSorted"]));
    }
    if (m.find("RtRate") != m.end() && !m["RtRate"].empty()) {
      rtRate = make_shared<double>(boost::any_cast<double>(m["RtRate"]));
    }
    if (m.find("RwlockOsWaits") != m.end() && !m["RwlockOsWaits"].empty()) {
      rwlockOsWaits = make_shared<long>(boost::any_cast<long>(m["RwlockOsWaits"]));
    }
    if (m.find("RwlockSpinRounds") != m.end() && !m["RwlockSpinRounds"].empty()) {
      rwlockSpinRounds = make_shared<long>(boost::any_cast<long>(m["RwlockSpinRounds"]));
    }
    if (m.find("RwlockSpinWaits") != m.end() && !m["RwlockSpinWaits"].empty()) {
      rwlockSpinWaits = make_shared<long>(boost::any_cast<long>(m["RwlockSpinWaits"]));
    }
    if (m.find("SelectFullJoinAvg") != m.end() && !m["SelectFullJoinAvg"].empty()) {
      selectFullJoinAvg = make_shared<double>(boost::any_cast<double>(m["SelectFullJoinAvg"]));
    }
    if (m.find("SelectFullRangeJoinAvg") != m.end() && !m["SelectFullRangeJoinAvg"].empty()) {
      selectFullRangeJoinAvg = make_shared<double>(boost::any_cast<double>(m["SelectFullRangeJoinAvg"]));
    }
    if (m.find("SelectRangeAvg") != m.end() && !m["SelectRangeAvg"].empty()) {
      selectRangeAvg = make_shared<double>(boost::any_cast<double>(m["SelectRangeAvg"]));
    }
    if (m.find("SelectScanAvg") != m.end() && !m["SelectScanAvg"].empty()) {
      selectScanAvg = make_shared<double>(boost::any_cast<double>(m["SelectScanAvg"]));
    }
    if (m.find("SemisyncDelayTime") != m.end() && !m["SemisyncDelayTime"].empty()) {
      semisyncDelayTime = make_shared<double>(boost::any_cast<double>(m["SemisyncDelayTime"]));
    }
    if (m.find("ServerLockTime") != m.end() && !m["ServerLockTime"].empty()) {
      serverLockTime = make_shared<double>(boost::any_cast<double>(m["ServerLockTime"]));
    }
    if (m.find("SortMergePasses") != m.end() && !m["SortMergePasses"].empty()) {
      sortMergePasses = make_shared<long>(boost::any_cast<long>(m["SortMergePasses"]));
    }
    if (m.find("SortRangeAvg") != m.end() && !m["SortRangeAvg"].empty()) {
      sortRangeAvg = make_shared<double>(boost::any_cast<double>(m["SortRangeAvg"]));
    }
    if (m.find("SortRowsAvg") != m.end() && !m["SortRowsAvg"].empty()) {
      sortRowsAvg = make_shared<double>(boost::any_cast<double>(m["SortRowsAvg"]));
    }
    if (m.find("SortScanAvg") != m.end() && !m["SortScanAvg"].empty()) {
      sortScanAvg = make_shared<double>(boost::any_cast<double>(m["SortScanAvg"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimerWaitAvg") != m.end() && !m["TimerWaitAvg"].empty()) {
      timerWaitAvg = make_shared<double>(boost::any_cast<double>(m["TimerWaitAvg"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TmpDiskTables") != m.end() && !m["TmpDiskTables"].empty()) {
      tmpDiskTables = make_shared<long>(boost::any_cast<long>(m["TmpDiskTables"]));
    }
    if (m.find("TmpDiskTablesAvg") != m.end() && !m["TmpDiskTablesAvg"].empty()) {
      tmpDiskTablesAvg = make_shared<double>(boost::any_cast<double>(m["TmpDiskTablesAvg"]));
    }
    if (m.find("TmpTables") != m.end() && !m["TmpTables"].empty()) {
      tmpTables = make_shared<long>(boost::any_cast<long>(m["TmpTables"]));
    }
    if (m.find("TmpTablesAvg") != m.end() && !m["TmpTablesAvg"].empty()) {
      tmpTablesAvg = make_shared<double>(boost::any_cast<double>(m["TmpTablesAvg"]));
    }
    if (m.find("TotalLatency") != m.end() && !m["TotalLatency"].empty()) {
      totalLatency = make_shared<double>(boost::any_cast<double>(m["TotalLatency"]));
    }
    if (m.find("TransactionLockTime") != m.end() && !m["TransactionLockTime"].empty()) {
      transactionLockTime = make_shared<double>(boost::any_cast<double>(m["TransactionLockTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WarnCount") != m.end() && !m["WarnCount"].empty()) {
      warnCount = make_shared<long>(boost::any_cast<long>(m["WarnCount"]));
    }
  }


  virtual ~GetPfsSqlSummariesResponseBodyDataList() = default;
};
class GetPfsSqlSummariesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<boost::any> extra{};
  shared_ptr<vector<GetPfsSqlSummariesResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetPfsSqlSummariesResponseBodyData() {}

  explicit GetPfsSqlSummariesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<boost::any>(boost::any_cast<boost::any>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetPfsSqlSummariesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPfsSqlSummariesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetPfsSqlSummariesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetPfsSqlSummariesResponseBodyData() = default;
};
class GetPfsSqlSummariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPfsSqlSummariesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPfsSqlSummariesResponseBody() {}

  explicit GetPfsSqlSummariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPfsSqlSummariesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPfsSqlSummariesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPfsSqlSummariesResponseBody() = default;
};
class GetPfsSqlSummariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPfsSqlSummariesResponseBody> body{};

  GetPfsSqlSummariesResponse() {}

  explicit GetPfsSqlSummariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPfsSqlSummariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPfsSqlSummariesResponseBody>(model1);
      }
    }
  }


  virtual ~GetPfsSqlSummariesResponse() = default;
};
class GetQueryOptimizeDataStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> asc{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> keywords{};
  shared_ptr<string> logicalOperator{};
  shared_ptr<string> onlyOptimizedSql{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> rules{};
  shared_ptr<string> sqlIds{};
  shared_ptr<string> tagNames{};
  shared_ptr<string> time{};
  shared_ptr<string> user{};

  GetQueryOptimizeDataStatsRequest() {}

  explicit GetQueryOptimizeDataStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (logicalOperator) {
      res["LogicalOperator"] = boost::any(*logicalOperator);
    }
    if (onlyOptimizedSql) {
      res["OnlyOptimizedSql"] = boost::any(*onlyOptimizedSql);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (sqlIds) {
      res["SqlIds"] = boost::any(*sqlIds);
    }
    if (tagNames) {
      res["TagNames"] = boost::any(*tagNames);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<string>(boost::any_cast<string>(m["Asc"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("LogicalOperator") != m.end() && !m["LogicalOperator"].empty()) {
      logicalOperator = make_shared<string>(boost::any_cast<string>(m["LogicalOperator"]));
    }
    if (m.find("OnlyOptimizedSql") != m.end() && !m["OnlyOptimizedSql"].empty()) {
      onlyOptimizedSql = make_shared<string>(boost::any_cast<string>(m["OnlyOptimizedSql"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("SqlIds") != m.end() && !m["SqlIds"].empty()) {
      sqlIds = make_shared<string>(boost::any_cast<string>(m["SqlIds"]));
    }
    if (m.find("TagNames") != m.end() && !m["TagNames"].empty()) {
      tagNames = make_shared<string>(boost::any_cast<string>(m["TagNames"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetQueryOptimizeDataStatsRequest() = default;
};
class GetQueryOptimizeDataStatsResponseBodyDataListRuleList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetQueryOptimizeDataStatsResponseBodyDataListRuleList() {}

  explicit GetQueryOptimizeDataStatsResponseBodyDataListRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetQueryOptimizeDataStatsResponseBodyDataListRuleList() = default;
};
class GetQueryOptimizeDataStatsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<double> avgLockTime{};
  shared_ptr<double> avgQueryTime{};
  shared_ptr<double> avgRowsAffected{};
  shared_ptr<double> avgRowsExamined{};
  shared_ptr<double> avgRowsSent{};
  shared_ptr<long> count{};
  shared_ptr<string> dbname{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> maxLockTime{};
  shared_ptr<double> maxQueryTime{};
  shared_ptr<long> maxRowsAffected{};
  shared_ptr<long> maxRowsExamined{};
  shared_ptr<long> maxRowsSent{};
  shared_ptr<string> psql{};
  shared_ptr<vector<GetQueryOptimizeDataStatsResponseBodyDataListRuleList>> ruleList{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlSample{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> user{};

  GetQueryOptimizeDataStatsResponseBodyDataList() {}

  explicit GetQueryOptimizeDataStatsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgLockTime) {
      res["AvgLockTime"] = boost::any(*avgLockTime);
    }
    if (avgQueryTime) {
      res["AvgQueryTime"] = boost::any(*avgQueryTime);
    }
    if (avgRowsAffected) {
      res["AvgRowsAffected"] = boost::any(*avgRowsAffected);
    }
    if (avgRowsExamined) {
      res["AvgRowsExamined"] = boost::any(*avgRowsExamined);
    }
    if (avgRowsSent) {
      res["AvgRowsSent"] = boost::any(*avgRowsSent);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dbname) {
      res["Dbname"] = boost::any(*dbname);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxLockTime) {
      res["MaxLockTime"] = boost::any(*maxLockTime);
    }
    if (maxQueryTime) {
      res["MaxQueryTime"] = boost::any(*maxQueryTime);
    }
    if (maxRowsAffected) {
      res["MaxRowsAffected"] = boost::any(*maxRowsAffected);
    }
    if (maxRowsExamined) {
      res["MaxRowsExamined"] = boost::any(*maxRowsExamined);
    }
    if (maxRowsSent) {
      res["MaxRowsSent"] = boost::any(*maxRowsSent);
    }
    if (psql) {
      res["Psql"] = boost::any(*psql);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlSample) {
      res["SqlSample"] = boost::any(*sqlSample);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgLockTime") != m.end() && !m["AvgLockTime"].empty()) {
      avgLockTime = make_shared<double>(boost::any_cast<double>(m["AvgLockTime"]));
    }
    if (m.find("AvgQueryTime") != m.end() && !m["AvgQueryTime"].empty()) {
      avgQueryTime = make_shared<double>(boost::any_cast<double>(m["AvgQueryTime"]));
    }
    if (m.find("AvgRowsAffected") != m.end() && !m["AvgRowsAffected"].empty()) {
      avgRowsAffected = make_shared<double>(boost::any_cast<double>(m["AvgRowsAffected"]));
    }
    if (m.find("AvgRowsExamined") != m.end() && !m["AvgRowsExamined"].empty()) {
      avgRowsExamined = make_shared<double>(boost::any_cast<double>(m["AvgRowsExamined"]));
    }
    if (m.find("AvgRowsSent") != m.end() && !m["AvgRowsSent"].empty()) {
      avgRowsSent = make_shared<double>(boost::any_cast<double>(m["AvgRowsSent"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Dbname") != m.end() && !m["Dbname"].empty()) {
      dbname = make_shared<string>(boost::any_cast<string>(m["Dbname"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxLockTime") != m.end() && !m["MaxLockTime"].empty()) {
      maxLockTime = make_shared<double>(boost::any_cast<double>(m["MaxLockTime"]));
    }
    if (m.find("MaxQueryTime") != m.end() && !m["MaxQueryTime"].empty()) {
      maxQueryTime = make_shared<double>(boost::any_cast<double>(m["MaxQueryTime"]));
    }
    if (m.find("MaxRowsAffected") != m.end() && !m["MaxRowsAffected"].empty()) {
      maxRowsAffected = make_shared<long>(boost::any_cast<long>(m["MaxRowsAffected"]));
    }
    if (m.find("MaxRowsExamined") != m.end() && !m["MaxRowsExamined"].empty()) {
      maxRowsExamined = make_shared<long>(boost::any_cast<long>(m["MaxRowsExamined"]));
    }
    if (m.find("MaxRowsSent") != m.end() && !m["MaxRowsSent"].empty()) {
      maxRowsSent = make_shared<long>(boost::any_cast<long>(m["MaxRowsSent"]));
    }
    if (m.find("Psql") != m.end() && !m["Psql"].empty()) {
      psql = make_shared<string>(boost::any_cast<string>(m["Psql"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<GetQueryOptimizeDataStatsResponseBodyDataListRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeDataStatsResponseBodyDataListRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<GetQueryOptimizeDataStatsResponseBodyDataListRuleList>>(expect1);
      }
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlSample") != m.end() && !m["SqlSample"].empty()) {
      sqlSample = make_shared<string>(boost::any_cast<string>(m["SqlSample"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetQueryOptimizeDataStatsResponseBodyDataList() = default;
};
class GetQueryOptimizeDataStatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeDataStatsResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeDataStatsResponseBodyData() {}

  explicit GetQueryOptimizeDataStatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeDataStatsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeDataStatsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeDataStatsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeDataStatsResponseBodyData() = default;
};
class GetQueryOptimizeDataStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeDataStatsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeDataStatsResponseBody() {}

  explicit GetQueryOptimizeDataStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeDataStatsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeDataStatsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeDataStatsResponseBody() = default;
};
class GetQueryOptimizeDataStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeDataStatsResponseBody> body{};

  GetQueryOptimizeDataStatsResponse() {}

  explicit GetQueryOptimizeDataStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeDataStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeDataStatsResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeDataStatsResponse() = default;
};
class GetQueryOptimizeDataTopRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> region{};
  shared_ptr<string> tagNames{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  GetQueryOptimizeDataTopRequest() {}

  explicit GetQueryOptimizeDataTopRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tagNames) {
      res["TagNames"] = boost::any(*tagNames);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TagNames") != m.end() && !m["TagNames"].empty()) {
      tagNames = make_shared<string>(boost::any_cast<string>(m["TagNames"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetQueryOptimizeDataTopRequest() = default;
};
class GetQueryOptimizeDataTopResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> type{};
  shared_ptr<double> value{};

  GetQueryOptimizeDataTopResponseBodyDataList() {}

  explicit GetQueryOptimizeDataTopResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetQueryOptimizeDataTopResponseBodyDataList() = default;
};
class GetQueryOptimizeDataTopResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeDataTopResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeDataTopResponseBodyData() {}

  explicit GetQueryOptimizeDataTopResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeDataTopResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeDataTopResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeDataTopResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeDataTopResponseBodyData() = default;
};
class GetQueryOptimizeDataTopResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeDataTopResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeDataTopResponseBody() {}

  explicit GetQueryOptimizeDataTopResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeDataTopResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeDataTopResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeDataTopResponseBody() = default;
};
class GetQueryOptimizeDataTopResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeDataTopResponseBody> body{};

  GetQueryOptimizeDataTopResponse() {}

  explicit GetQueryOptimizeDataTopResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeDataTopResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeDataTopResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeDataTopResponse() = default;
};
class GetQueryOptimizeDataTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> region{};
  shared_ptr<string> start{};
  shared_ptr<string> tagNames{};

  GetQueryOptimizeDataTrendRequest() {}

  explicit GetQueryOptimizeDataTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tagNames) {
      res["TagNames"] = boost::any(*tagNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TagNames") != m.end() && !m["TagNames"].empty()) {
      tagNames = make_shared<string>(boost::any_cast<string>(m["TagNames"]));
    }
  }


  virtual ~GetQueryOptimizeDataTrendRequest() = default;
};
class GetQueryOptimizeDataTrendResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> kpi{};
  shared_ptr<long> timestamp{};
  shared_ptr<double> value{};

  GetQueryOptimizeDataTrendResponseBodyDataList() {}

  explicit GetQueryOptimizeDataTrendResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kpi) {
      res["Kpi"] = boost::any(*kpi);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Kpi") != m.end() && !m["Kpi"].empty()) {
      kpi = make_shared<string>(boost::any_cast<string>(m["Kpi"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetQueryOptimizeDataTrendResponseBodyDataList() = default;
};
class GetQueryOptimizeDataTrendResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeDataTrendResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeDataTrendResponseBodyData() {}

  explicit GetQueryOptimizeDataTrendResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeDataTrendResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeDataTrendResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeDataTrendResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeDataTrendResponseBodyData() = default;
};
class GetQueryOptimizeDataTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeDataTrendResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeDataTrendResponseBody() {}

  explicit GetQueryOptimizeDataTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeDataTrendResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeDataTrendResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeDataTrendResponseBody() = default;
};
class GetQueryOptimizeDataTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeDataTrendResponseBody> body{};

  GetQueryOptimizeDataTrendResponse() {}

  explicit GetQueryOptimizeDataTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeDataTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeDataTrendResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeDataTrendResponse() = default;
};
class GetQueryOptimizeExecErrorSampleRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> time{};

  GetQueryOptimizeExecErrorSampleRequest() {}

  explicit GetQueryOptimizeExecErrorSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorSampleRequest() = default;
};
class GetQueryOptimizeExecErrorSampleResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> dbname{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> origHost{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlText{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> user{};

  GetQueryOptimizeExecErrorSampleResponseBodyDataList() {}

  explicit GetQueryOptimizeExecErrorSampleResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbname) {
      res["Dbname"] = boost::any(*dbname);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (origHost) {
      res["OrigHost"] = boost::any(*origHost);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dbname") != m.end() && !m["Dbname"].empty()) {
      dbname = make_shared<string>(boost::any_cast<string>(m["Dbname"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OrigHost") != m.end() && !m["OrigHost"].empty()) {
      origHost = make_shared<string>(boost::any_cast<string>(m["OrigHost"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorSampleResponseBodyDataList() = default;
};
class GetQueryOptimizeExecErrorSampleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeExecErrorSampleResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeExecErrorSampleResponseBodyData() {}

  explicit GetQueryOptimizeExecErrorSampleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeExecErrorSampleResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeExecErrorSampleResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeExecErrorSampleResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorSampleResponseBodyData() = default;
};
class GetQueryOptimizeExecErrorSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeExecErrorSampleResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeExecErrorSampleResponseBody() {}

  explicit GetQueryOptimizeExecErrorSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeExecErrorSampleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeExecErrorSampleResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorSampleResponseBody() = default;
};
class GetQueryOptimizeExecErrorSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeExecErrorSampleResponseBody> body{};

  GetQueryOptimizeExecErrorSampleResponse() {}

  explicit GetQueryOptimizeExecErrorSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeExecErrorSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeExecErrorSampleResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeExecErrorSampleResponse() = default;
};
class GetQueryOptimizeExecErrorStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> asc{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> keywords{};
  shared_ptr<string> logicalOperator{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> time{};

  GetQueryOptimizeExecErrorStatsRequest() {}

  explicit GetQueryOptimizeExecErrorStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (logicalOperator) {
      res["LogicalOperator"] = boost::any(*logicalOperator);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<string>(boost::any_cast<string>(m["Asc"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("LogicalOperator") != m.end() && !m["LogicalOperator"].empty()) {
      logicalOperator = make_shared<string>(boost::any_cast<string>(m["LogicalOperator"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorStatsRequest() = default;
};
class GetQueryOptimizeExecErrorStatsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> dbname{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> errorCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlText{};

  GetQueryOptimizeExecErrorStatsResponseBodyDataList() {}

  explicit GetQueryOptimizeExecErrorStatsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbname) {
      res["Dbname"] = boost::any(*dbname);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dbname") != m.end() && !m["Dbname"].empty()) {
      dbname = make_shared<string>(boost::any_cast<string>(m["Dbname"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorStatsResponseBodyDataList() = default;
};
class GetQueryOptimizeExecErrorStatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeExecErrorStatsResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeExecErrorStatsResponseBodyData() {}

  explicit GetQueryOptimizeExecErrorStatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeExecErrorStatsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeExecErrorStatsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeExecErrorStatsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorStatsResponseBodyData() = default;
};
class GetQueryOptimizeExecErrorStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeExecErrorStatsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeExecErrorStatsResponseBody() {}

  explicit GetQueryOptimizeExecErrorStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeExecErrorStatsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeExecErrorStatsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeExecErrorStatsResponseBody() = default;
};
class GetQueryOptimizeExecErrorStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeExecErrorStatsResponseBody> body{};

  GetQueryOptimizeExecErrorStatsResponse() {}

  explicit GetQueryOptimizeExecErrorStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeExecErrorStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeExecErrorStatsResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeExecErrorStatsResponse() = default;
};
class GetQueryOptimizeRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> region{};
  shared_ptr<string> tagNames{};

  GetQueryOptimizeRuleListRequest() {}

  explicit GetQueryOptimizeRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tagNames) {
      res["TagNames"] = boost::any(*tagNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TagNames") != m.end() && !m["TagNames"].empty()) {
      tagNames = make_shared<string>(boost::any_cast<string>(m["TagNames"]));
    }
  }


  virtual ~GetQueryOptimizeRuleListRequest() = default;
};
class GetQueryOptimizeRuleListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> type{};

  GetQueryOptimizeRuleListResponseBodyDataList() {}

  explicit GetQueryOptimizeRuleListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetQueryOptimizeRuleListResponseBodyDataList() = default;
};
class GetQueryOptimizeRuleListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeRuleListResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeRuleListResponseBodyData() {}

  explicit GetQueryOptimizeRuleListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeRuleListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeRuleListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeRuleListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeRuleListResponseBodyData() = default;
};
class GetQueryOptimizeRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeRuleListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeRuleListResponseBody() {}

  explicit GetQueryOptimizeRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeRuleListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeRuleListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeRuleListResponseBody() = default;
};
class GetQueryOptimizeRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeRuleListResponseBody> body{};

  GetQueryOptimizeRuleListResponse() {}

  explicit GetQueryOptimizeRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeRuleListResponse() = default;
};
class GetQueryOptimizeShareUrlRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> keywords{};
  shared_ptr<string> logicalOperator{};
  shared_ptr<bool> onlyOptimizedSql{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> rules{};
  shared_ptr<string> sqlIds{};
  shared_ptr<string> tagNames{};
  shared_ptr<long> time{};
  shared_ptr<string> user{};

  GetQueryOptimizeShareUrlRequest() {}

  explicit GetQueryOptimizeShareUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (logicalOperator) {
      res["LogicalOperator"] = boost::any(*logicalOperator);
    }
    if (onlyOptimizedSql) {
      res["OnlyOptimizedSql"] = boost::any(*onlyOptimizedSql);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (sqlIds) {
      res["SqlIds"] = boost::any(*sqlIds);
    }
    if (tagNames) {
      res["TagNames"] = boost::any(*tagNames);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("LogicalOperator") != m.end() && !m["LogicalOperator"].empty()) {
      logicalOperator = make_shared<string>(boost::any_cast<string>(m["LogicalOperator"]));
    }
    if (m.find("OnlyOptimizedSql") != m.end() && !m["OnlyOptimizedSql"].empty()) {
      onlyOptimizedSql = make_shared<bool>(boost::any_cast<bool>(m["OnlyOptimizedSql"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("SqlIds") != m.end() && !m["SqlIds"].empty()) {
      sqlIds = make_shared<string>(boost::any_cast<string>(m["SqlIds"]));
    }
    if (m.find("TagNames") != m.end() && !m["TagNames"].empty()) {
      tagNames = make_shared<string>(boost::any_cast<string>(m["TagNames"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetQueryOptimizeShareUrlRequest() = default;
};
class GetQueryOptimizeShareUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeShareUrlResponseBody() {}

  explicit GetQueryOptimizeShareUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeShareUrlResponseBody() = default;
};
class GetQueryOptimizeShareUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeShareUrlResponseBody> body{};

  GetQueryOptimizeShareUrlResponse() {}

  explicit GetQueryOptimizeShareUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeShareUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeShareUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeShareUrlResponse() = default;
};
class GetQueryOptimizeSolutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ruleIds{};
  shared_ptr<string> sqlId{};

  GetQueryOptimizeSolutionRequest() {}

  explicit GetQueryOptimizeSolutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
  }


  virtual ~GetQueryOptimizeSolutionRequest() = default;
};
class GetQueryOptimizeSolutionResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> solution{};
  shared_ptr<string> solutionExt{};

  GetQueryOptimizeSolutionResponseBodyDataList() {}

  explicit GetQueryOptimizeSolutionResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (solutionExt) {
      res["SolutionExt"] = boost::any(*solutionExt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("SolutionExt") != m.end() && !m["SolutionExt"].empty()) {
      solutionExt = make_shared<string>(boost::any_cast<string>(m["SolutionExt"]));
    }
  }


  virtual ~GetQueryOptimizeSolutionResponseBodyDataList() = default;
};
class GetQueryOptimizeSolutionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetQueryOptimizeSolutionResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetQueryOptimizeSolutionResponseBodyData() {}

  explicit GetQueryOptimizeSolutionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetQueryOptimizeSolutionResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQueryOptimizeSolutionResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetQueryOptimizeSolutionResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetQueryOptimizeSolutionResponseBodyData() = default;
};
class GetQueryOptimizeSolutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeSolutionResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeSolutionResponseBody() {}

  explicit GetQueryOptimizeSolutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeSolutionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeSolutionResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeSolutionResponseBody() = default;
};
class GetQueryOptimizeSolutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeSolutionResponseBody> body{};

  GetQueryOptimizeSolutionResponse() {}

  explicit GetQueryOptimizeSolutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeSolutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeSolutionResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeSolutionResponse() = default;
};
class GetQueryOptimizeTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};

  GetQueryOptimizeTagRequest() {}

  explicit GetQueryOptimizeTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
  }


  virtual ~GetQueryOptimizeTagRequest() = default;
};
class GetQueryOptimizeTagResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> comments{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> tags{};

  GetQueryOptimizeTagResponseBodyData() {}

  explicit GetQueryOptimizeTagResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetQueryOptimizeTagResponseBodyData() = default;
};
class GetQueryOptimizeTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetQueryOptimizeTagResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetQueryOptimizeTagResponseBody() {}

  explicit GetQueryOptimizeTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQueryOptimizeTagResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQueryOptimizeTagResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetQueryOptimizeTagResponseBody() = default;
};
class GetQueryOptimizeTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueryOptimizeTagResponseBody> body{};

  GetQueryOptimizeTagResponse() {}

  explicit GetQueryOptimizeTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueryOptimizeTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueryOptimizeTagResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueryOptimizeTagResponse() = default;
};
class GetRedisAllSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};

  GetRedisAllSessionRequest() {}

  explicit GetRedisAllSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetRedisAllSessionRequest() = default;
};
class GetRedisAllSessionResponseBodyDataSessions : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> age{};
  shared_ptr<string> client{};
  shared_ptr<string> clientDesc{};
  shared_ptr<string> cmd{};
  shared_ptr<long> db{};
  shared_ptr<string> events{};
  shared_ptr<long> fd{};
  shared_ptr<string> flags{};
  shared_ptr<long> id{};
  shared_ptr<long> idle{};
  shared_ptr<long> multi{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> obl{};
  shared_ptr<long> oll{};
  shared_ptr<long> omem{};
  shared_ptr<long> psub{};
  shared_ptr<long> qbuf{};
  shared_ptr<long> qbufFree{};
  shared_ptr<long> sub{};

  GetRedisAllSessionResponseBodyDataSessions() {}

  explicit GetRedisAllSessionResponseBodyDataSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (age) {
      res["Age"] = boost::any(*age);
    }
    if (client) {
      res["Client"] = boost::any(*client);
    }
    if (clientDesc) {
      res["ClientDesc"] = boost::any(*clientDesc);
    }
    if (cmd) {
      res["Cmd"] = boost::any(*cmd);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (events) {
      res["Events"] = boost::any(*events);
    }
    if (fd) {
      res["Fd"] = boost::any(*fd);
    }
    if (flags) {
      res["Flags"] = boost::any(*flags);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idle) {
      res["Idle"] = boost::any(*idle);
    }
    if (multi) {
      res["Multi"] = boost::any(*multi);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (obl) {
      res["Obl"] = boost::any(*obl);
    }
    if (oll) {
      res["Oll"] = boost::any(*oll);
    }
    if (omem) {
      res["Omem"] = boost::any(*omem);
    }
    if (psub) {
      res["Psub"] = boost::any(*psub);
    }
    if (qbuf) {
      res["Qbuf"] = boost::any(*qbuf);
    }
    if (qbufFree) {
      res["QbufFree"] = boost::any(*qbufFree);
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("Age") != m.end() && !m["Age"].empty()) {
      age = make_shared<string>(boost::any_cast<string>(m["Age"]));
    }
    if (m.find("Client") != m.end() && !m["Client"].empty()) {
      client = make_shared<string>(boost::any_cast<string>(m["Client"]));
    }
    if (m.find("ClientDesc") != m.end() && !m["ClientDesc"].empty()) {
      clientDesc = make_shared<string>(boost::any_cast<string>(m["ClientDesc"]));
    }
    if (m.find("Cmd") != m.end() && !m["Cmd"].empty()) {
      cmd = make_shared<string>(boost::any_cast<string>(m["Cmd"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<long>(boost::any_cast<long>(m["Db"]));
    }
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      events = make_shared<string>(boost::any_cast<string>(m["Events"]));
    }
    if (m.find("Fd") != m.end() && !m["Fd"].empty()) {
      fd = make_shared<long>(boost::any_cast<long>(m["Fd"]));
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      flags = make_shared<string>(boost::any_cast<string>(m["Flags"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Idle") != m.end() && !m["Idle"].empty()) {
      idle = make_shared<long>(boost::any_cast<long>(m["Idle"]));
    }
    if (m.find("Multi") != m.end() && !m["Multi"].empty()) {
      multi = make_shared<long>(boost::any_cast<long>(m["Multi"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Obl") != m.end() && !m["Obl"].empty()) {
      obl = make_shared<long>(boost::any_cast<long>(m["Obl"]));
    }
    if (m.find("Oll") != m.end() && !m["Oll"].empty()) {
      oll = make_shared<long>(boost::any_cast<long>(m["Oll"]));
    }
    if (m.find("Omem") != m.end() && !m["Omem"].empty()) {
      omem = make_shared<long>(boost::any_cast<long>(m["Omem"]));
    }
    if (m.find("Psub") != m.end() && !m["Psub"].empty()) {
      psub = make_shared<long>(boost::any_cast<long>(m["Psub"]));
    }
    if (m.find("Qbuf") != m.end() && !m["Qbuf"].empty()) {
      qbuf = make_shared<long>(boost::any_cast<long>(m["Qbuf"]));
    }
    if (m.find("QbufFree") != m.end() && !m["QbufFree"].empty()) {
      qbufFree = make_shared<long>(boost::any_cast<long>(m["QbufFree"]));
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<long>(boost::any_cast<long>(m["Sub"]));
    }
  }


  virtual ~GetRedisAllSessionResponseBodyDataSessions() = default;
};
class GetRedisAllSessionResponseBodyDataSourceStats : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> key{};

  GetRedisAllSessionResponseBodyDataSourceStats() {}

  explicit GetRedisAllSessionResponseBodyDataSourceStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~GetRedisAllSessionResponseBodyDataSourceStats() = default;
};
class GetRedisAllSessionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetRedisAllSessionResponseBodyDataSessions>> sessions{};
  shared_ptr<vector<GetRedisAllSessionResponseBodyDataSourceStats>> sourceStats{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> total{};

  GetRedisAllSessionResponseBodyData() {}

  explicit GetRedisAllSessionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    if (sourceStats) {
      vector<boost::any> temp1;
      for(auto item1:*sourceStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceStats"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<GetRedisAllSessionResponseBodyDataSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRedisAllSessionResponseBodyDataSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<GetRedisAllSessionResponseBodyDataSessions>>(expect1);
      }
    }
    if (m.find("SourceStats") != m.end() && !m["SourceStats"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceStats"].type()) {
        vector<GetRedisAllSessionResponseBodyDataSourceStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRedisAllSessionResponseBodyDataSourceStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceStats = make_shared<vector<GetRedisAllSessionResponseBodyDataSourceStats>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetRedisAllSessionResponseBodyData() = default;
};
class GetRedisAllSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetRedisAllSessionResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRedisAllSessionResponseBody() {}

  explicit GetRedisAllSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRedisAllSessionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRedisAllSessionResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRedisAllSessionResponseBody() = default;
};
class GetRedisAllSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRedisAllSessionResponseBody> body{};

  GetRedisAllSessionResponse() {}

  explicit GetRedisAllSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRedisAllSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRedisAllSessionResponseBody>(model1);
      }
    }
  }


  virtual ~GetRedisAllSessionResponse() = default;
};
class GetRequestDiagnosisPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  GetRequestDiagnosisPageRequest() {}

  explicit GetRequestDiagnosisPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetRequestDiagnosisPageRequest() = default;
};
class GetRequestDiagnosisPageResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> dbSchema{};
  shared_ptr<string> engine{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> messageId{};
  shared_ptr<string> param{};
  shared_ptr<string> result{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> state{};
  shared_ptr<string> uuid{};

  GetRequestDiagnosisPageResponseBodyDataList() {}

  explicit GetRequestDiagnosisPageResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (dbSchema) {
      res["dbSchema"] = boost::any(*dbSchema);
    }
    if (engine) {
      res["engine"] = boost::any(*engine);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (messageId) {
      res["messageId"] = boost::any(*messageId);
    }
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (sqlId) {
      res["sqlId"] = boost::any(*sqlId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("dbSchema") != m.end() && !m["dbSchema"].empty()) {
      dbSchema = make_shared<string>(boost::any_cast<string>(m["dbSchema"]));
    }
    if (m.find("engine") != m.end() && !m["engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["engine"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("messageId") != m.end() && !m["messageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["messageId"]));
    }
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("sqlId") != m.end() && !m["sqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["sqlId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["state"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~GetRequestDiagnosisPageResponseBodyDataList() = default;
};
class GetRequestDiagnosisPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extra{};
  shared_ptr<vector<GetRequestDiagnosisPageResponseBodyDataList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetRequestDiagnosisPageResponseBodyData() {}

  explicit GetRequestDiagnosisPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["list"] = boost::any(temp1);
    }
    if (pageNo) {
      res["pageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("list") != m.end() && !m["list"].empty()) {
      if (typeid(vector<boost::any>) == m["list"].type()) {
        vector<GetRequestDiagnosisPageResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRequestDiagnosisPageResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetRequestDiagnosisPageResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("pageNo") != m.end() && !m["pageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["pageNo"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~GetRequestDiagnosisPageResponseBodyData() = default;
};
class GetRequestDiagnosisPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRequestDiagnosisPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetRequestDiagnosisPageResponseBody() {}

  explicit GetRequestDiagnosisPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRequestDiagnosisPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRequestDiagnosisPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetRequestDiagnosisPageResponseBody() = default;
};
class GetRequestDiagnosisPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRequestDiagnosisPageResponseBody> body{};

  GetRequestDiagnosisPageResponse() {}

  explicit GetRequestDiagnosisPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRequestDiagnosisPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRequestDiagnosisPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetRequestDiagnosisPageResponse() = default;
};
class GetRequestDiagnosisResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> messageId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> source{};
  shared_ptr<string> sqlId{};

  GetRequestDiagnosisResultRequest() {}

  explicit GetRequestDiagnosisResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
  }


  virtual ~GetRequestDiagnosisResultRequest() = default;
};
class GetRequestDiagnosisResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> dbSchema{};
  shared_ptr<string> engine{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> messageId{};
  shared_ptr<string> param{};
  shared_ptr<string> result{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> state{};
  shared_ptr<string> uuid{};

  GetRequestDiagnosisResultResponseBodyData() {}

  explicit GetRequestDiagnosisResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (dbSchema) {
      res["dbSchema"] = boost::any(*dbSchema);
    }
    if (engine) {
      res["engine"] = boost::any(*engine);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (messageId) {
      res["messageId"] = boost::any(*messageId);
    }
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (sqlId) {
      res["sqlId"] = boost::any(*sqlId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("dbSchema") != m.end() && !m["dbSchema"].empty()) {
      dbSchema = make_shared<string>(boost::any_cast<string>(m["dbSchema"]));
    }
    if (m.find("engine") != m.end() && !m["engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["engine"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("messageId") != m.end() && !m["messageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["messageId"]));
    }
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("sqlId") != m.end() && !m["sqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["sqlId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["state"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~GetRequestDiagnosisResultResponseBodyData() = default;
};
class GetRequestDiagnosisResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRequestDiagnosisResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetRequestDiagnosisResultResponseBody() {}

  explicit GetRequestDiagnosisResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRequestDiagnosisResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRequestDiagnosisResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetRequestDiagnosisResultResponseBody() = default;
};
class GetRequestDiagnosisResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRequestDiagnosisResultResponseBody> body{};

  GetRequestDiagnosisResultResponse() {}

  explicit GetRequestDiagnosisResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRequestDiagnosisResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRequestDiagnosisResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetRequestDiagnosisResultResponse() = default;
};
class GetRunningSqlConcurrencyControlRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  GetRunningSqlConcurrencyControlRulesRequest() {}

  explicit GetRunningSqlConcurrencyControlRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesRequest() = default;
};
class GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules : public Darabonba::Model {
public:
  shared_ptr<long> concurrencyControlTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> keywordsHash{};
  shared_ptr<string> maxConcurrency{};
  shared_ptr<string> sqlKeywords{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules() {}

  explicit GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrencyControlTime) {
      res["ConcurrencyControlTime"] = boost::any(*concurrencyControlTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (keywordsHash) {
      res["KeywordsHash"] = boost::any(*keywordsHash);
    }
    if (maxConcurrency) {
      res["MaxConcurrency"] = boost::any(*maxConcurrency);
    }
    if (sqlKeywords) {
      res["SqlKeywords"] = boost::any(*sqlKeywords);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrencyControlTime") != m.end() && !m["ConcurrencyControlTime"].empty()) {
      concurrencyControlTime = make_shared<long>(boost::any_cast<long>(m["ConcurrencyControlTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("KeywordsHash") != m.end() && !m["KeywordsHash"].empty()) {
      keywordsHash = make_shared<string>(boost::any_cast<string>(m["KeywordsHash"]));
    }
    if (m.find("MaxConcurrency") != m.end() && !m["MaxConcurrency"].empty()) {
      maxConcurrency = make_shared<string>(boost::any_cast<string>(m["MaxConcurrency"]));
    }
    if (m.find("SqlKeywords") != m.end() && !m["SqlKeywords"].empty()) {
      sqlKeywords = make_shared<string>(boost::any_cast<string>(m["SqlKeywords"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules() = default;
};
class GetRunningSqlConcurrencyControlRulesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules>> runningRules{};

  GetRunningSqlConcurrencyControlRulesResponseBodyDataList() {}

  explicit GetRunningSqlConcurrencyControlRulesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runningRules) {
      vector<boost::any> temp1;
      for(auto item1:*runningRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["runningRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("runningRules") != m.end() && !m["runningRules"].empty()) {
      if (typeid(vector<boost::any>) == m["runningRules"].type()) {
        vector<GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["runningRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runningRules = make_shared<vector<GetRunningSqlConcurrencyControlRulesResponseBodyDataListRunningRules>>(expect1);
      }
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesResponseBodyDataList() = default;
};
class GetRunningSqlConcurrencyControlRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetRunningSqlConcurrencyControlRulesResponseBodyDataList> list{};
  shared_ptr<long> total{};

  GetRunningSqlConcurrencyControlRulesResponseBodyData() {}

  explicit GetRunningSqlConcurrencyControlRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetRunningSqlConcurrencyControlRulesResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetRunningSqlConcurrencyControlRulesResponseBodyDataList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesResponseBodyData() = default;
};
class GetRunningSqlConcurrencyControlRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRunningSqlConcurrencyControlRulesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetRunningSqlConcurrencyControlRulesResponseBody() {}

  explicit GetRunningSqlConcurrencyControlRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRunningSqlConcurrencyControlRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRunningSqlConcurrencyControlRulesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesResponseBody() = default;
};
class GetRunningSqlConcurrencyControlRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRunningSqlConcurrencyControlRulesResponseBody> body{};

  GetRunningSqlConcurrencyControlRulesResponse() {}

  explicit GetRunningSqlConcurrencyControlRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRunningSqlConcurrencyControlRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRunningSqlConcurrencyControlRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetRunningSqlConcurrencyControlRulesResponse() = default;
};
class GetSqlConcurrencyControlKeywordsFromSqlTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlText{};

  GetSqlConcurrencyControlKeywordsFromSqlTextRequest() {}

  explicit GetSqlConcurrencyControlKeywordsFromSqlTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
  }


  virtual ~GetSqlConcurrencyControlKeywordsFromSqlTextRequest() = default;
};
class GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody() {}

  explicit GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody() = default;
};
class GetSqlConcurrencyControlKeywordsFromSqlTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody> body{};

  GetSqlConcurrencyControlKeywordsFromSqlTextResponse() {}

  explicit GetSqlConcurrencyControlKeywordsFromSqlTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody>(model1);
      }
    }
  }


  virtual ~GetSqlConcurrencyControlKeywordsFromSqlTextResponse() = default;
};
class GetSqlConcurrencyControlRulesHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  GetSqlConcurrencyControlRulesHistoryRequest() {}

  explicit GetSqlConcurrencyControlRulesHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryRequest() = default;
};
class GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules : public Darabonba::Model {
public:
  shared_ptr<long> concurrencyControlTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> keywordsHash{};
  shared_ptr<long> maxConcurrency{};
  shared_ptr<string> sqlKeywords{};
  shared_ptr<string> sqlType{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules() {}

  explicit GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrencyControlTime) {
      res["ConcurrencyControlTime"] = boost::any(*concurrencyControlTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (keywordsHash) {
      res["KeywordsHash"] = boost::any(*keywordsHash);
    }
    if (maxConcurrency) {
      res["MaxConcurrency"] = boost::any(*maxConcurrency);
    }
    if (sqlKeywords) {
      res["SqlKeywords"] = boost::any(*sqlKeywords);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrencyControlTime") != m.end() && !m["ConcurrencyControlTime"].empty()) {
      concurrencyControlTime = make_shared<long>(boost::any_cast<long>(m["ConcurrencyControlTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("KeywordsHash") != m.end() && !m["KeywordsHash"].empty()) {
      keywordsHash = make_shared<string>(boost::any_cast<string>(m["KeywordsHash"]));
    }
    if (m.find("MaxConcurrency") != m.end() && !m["MaxConcurrency"].empty()) {
      maxConcurrency = make_shared<long>(boost::any_cast<long>(m["MaxConcurrency"]));
    }
    if (m.find("SqlKeywords") != m.end() && !m["SqlKeywords"].empty()) {
      sqlKeywords = make_shared<string>(boost::any_cast<string>(m["SqlKeywords"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules() = default;
};
class GetSqlConcurrencyControlRulesHistoryResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules>> rules{};

  GetSqlConcurrencyControlRulesHistoryResponseBodyDataList() {}

  explicit GetSqlConcurrencyControlRulesHistoryResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("rules") != m.end() && !m["rules"].empty()) {
      if (typeid(vector<boost::any>) == m["rules"].type()) {
        vector<GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<GetSqlConcurrencyControlRulesHistoryResponseBodyDataListRules>>(expect1);
      }
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryResponseBodyDataList() = default;
};
class GetSqlConcurrencyControlRulesHistoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetSqlConcurrencyControlRulesHistoryResponseBodyDataList> list{};
  shared_ptr<long> total{};

  GetSqlConcurrencyControlRulesHistoryResponseBodyData() {}

  explicit GetSqlConcurrencyControlRulesHistoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetSqlConcurrencyControlRulesHistoryResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetSqlConcurrencyControlRulesHistoryResponseBodyDataList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryResponseBodyData() = default;
};
class GetSqlConcurrencyControlRulesHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSqlConcurrencyControlRulesHistoryResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetSqlConcurrencyControlRulesHistoryResponseBody() {}

  explicit GetSqlConcurrencyControlRulesHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSqlConcurrencyControlRulesHistoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSqlConcurrencyControlRulesHistoryResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryResponseBody() = default;
};
class GetSqlConcurrencyControlRulesHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSqlConcurrencyControlRulesHistoryResponseBody> body{};

  GetSqlConcurrencyControlRulesHistoryResponse() {}

  explicit GetSqlConcurrencyControlRulesHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSqlConcurrencyControlRulesHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSqlConcurrencyControlRulesHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetSqlConcurrencyControlRulesHistoryResponse() = default;
};
class GetSqlOptimizeAdviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> endDt{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> region{};
  shared_ptr<string> startDt{};

  GetSqlOptimizeAdviceRequest() {}

  explicit GetSqlOptimizeAdviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (endDt) {
      res["EndDt"] = boost::any(*endDt);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startDt) {
      res["StartDt"] = boost::any(*startDt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("EndDt") != m.end() && !m["EndDt"].empty()) {
      endDt = make_shared<string>(boost::any_cast<string>(m["EndDt"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartDt") != m.end() && !m["StartDt"].empty()) {
      startDt = make_shared<string>(boost::any_cast<string>(m["StartDt"]));
    }
  }


  virtual ~GetSqlOptimizeAdviceRequest() = default;
};
class GetSqlOptimizeAdviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> status{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> taskId{};

  GetSqlOptimizeAdviceResponseBodyData() {}

  explicit GetSqlOptimizeAdviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetSqlOptimizeAdviceResponseBodyData() = default;
};
class GetSqlOptimizeAdviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSqlOptimizeAdviceResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetSqlOptimizeAdviceResponseBody() {}

  explicit GetSqlOptimizeAdviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSqlOptimizeAdviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSqlOptimizeAdviceResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetSqlOptimizeAdviceResponseBody() = default;
};
class GetSqlOptimizeAdviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSqlOptimizeAdviceResponseBody> body{};

  GetSqlOptimizeAdviceResponse() {}

  explicit GetSqlOptimizeAdviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSqlOptimizeAdviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSqlOptimizeAdviceResponseBody>(model1);
      }
    }
  }


  virtual ~GetSqlOptimizeAdviceResponse() = default;
};
class GetStorageAnalysisResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> taskId{};

  GetStorageAnalysisResultRequest() {}

  explicit GetStorageAnalysisResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetStorageAnalysisResultRequest() = default;
};
class GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList : public Darabonba::Model {
public:
  shared_ptr<string> associatedData{};
  shared_ptr<string> dbName{};
  shared_ptr<string> optimizeAdvice{};
  shared_ptr<string> optimizeItemName{};
  shared_ptr<string> tableName{};

  GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList() {}

  explicit GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedData) {
      res["AssociatedData"] = boost::any(*associatedData);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (optimizeAdvice) {
      res["OptimizeAdvice"] = boost::any(*optimizeAdvice);
    }
    if (optimizeItemName) {
      res["OptimizeItemName"] = boost::any(*optimizeItemName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedData") != m.end() && !m["AssociatedData"].empty()) {
      associatedData = make_shared<string>(boost::any_cast<string>(m["AssociatedData"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("OptimizeAdvice") != m.end() && !m["OptimizeAdvice"].empty()) {
      optimizeAdvice = make_shared<string>(boost::any_cast<string>(m["OptimizeAdvice"]));
    }
    if (m.find("OptimizeItemName") != m.end() && !m["OptimizeItemName"].empty()) {
      optimizeItemName = make_shared<string>(boost::any_cast<string>(m["OptimizeItemName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList() = default;
};
class GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats : public Darabonba::Model {
public:
  shared_ptr<long> avgRowLength{};
  shared_ptr<long> dataFree{};
  shared_ptr<long> dataSize{};
  shared_ptr<string> dbName{};
  shared_ptr<string> engine{};
  shared_ptr<long> fragmentSize{};
  shared_ptr<long> indexSize{};
  shared_ptr<long> phyTotalSize{};
  shared_ptr<long> physicalFileSize{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tableRows{};
  shared_ptr<string> tableType{};
  shared_ptr<long> totalSize{};

  GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats() {}

  explicit GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgRowLength) {
      res["AvgRowLength"] = boost::any(*avgRowLength);
    }
    if (dataFree) {
      res["DataFree"] = boost::any(*dataFree);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (fragmentSize) {
      res["FragmentSize"] = boost::any(*fragmentSize);
    }
    if (indexSize) {
      res["IndexSize"] = boost::any(*indexSize);
    }
    if (phyTotalSize) {
      res["PhyTotalSize"] = boost::any(*phyTotalSize);
    }
    if (physicalFileSize) {
      res["PhysicalFileSize"] = boost::any(*physicalFileSize);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableRows) {
      res["TableRows"] = boost::any(*tableRows);
    }
    if (tableType) {
      res["TableType"] = boost::any(*tableType);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgRowLength") != m.end() && !m["AvgRowLength"].empty()) {
      avgRowLength = make_shared<long>(boost::any_cast<long>(m["AvgRowLength"]));
    }
    if (m.find("DataFree") != m.end() && !m["DataFree"].empty()) {
      dataFree = make_shared<long>(boost::any_cast<long>(m["DataFree"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("FragmentSize") != m.end() && !m["FragmentSize"].empty()) {
      fragmentSize = make_shared<long>(boost::any_cast<long>(m["FragmentSize"]));
    }
    if (m.find("IndexSize") != m.end() && !m["IndexSize"].empty()) {
      indexSize = make_shared<long>(boost::any_cast<long>(m["IndexSize"]));
    }
    if (m.find("PhyTotalSize") != m.end() && !m["PhyTotalSize"].empty()) {
      phyTotalSize = make_shared<long>(boost::any_cast<long>(m["PhyTotalSize"]));
    }
    if (m.find("PhysicalFileSize") != m.end() && !m["PhysicalFileSize"].empty()) {
      physicalFileSize = make_shared<long>(boost::any_cast<long>(m["PhysicalFileSize"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableRows") != m.end() && !m["TableRows"].empty()) {
      tableRows = make_shared<long>(boost::any_cast<long>(m["TableRows"]));
    }
    if (m.find("TableType") != m.end() && !m["TableType"].empty()) {
      tableType = make_shared<string>(boost::any_cast<string>(m["TableType"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats() = default;
};
class GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult : public Darabonba::Model {
public:
  shared_ptr<string> analysisErrorType{};
  shared_ptr<bool> analysisSuccess{};
  shared_ptr<long> dailyIncrement{};
  shared_ptr<long> estimateAvailableDays{};
  shared_ptr<vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList>> needOptimizeItemList{};
  shared_ptr<vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats>> tableStats{};
  shared_ptr<long> totalFreeStorageSize{};
  shared_ptr<long> totalStorageSize{};
  shared_ptr<long> totalUsedStorageSize{};

  GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult() {}

  explicit GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisErrorType) {
      res["AnalysisErrorType"] = boost::any(*analysisErrorType);
    }
    if (analysisSuccess) {
      res["AnalysisSuccess"] = boost::any(*analysisSuccess);
    }
    if (dailyIncrement) {
      res["DailyIncrement"] = boost::any(*dailyIncrement);
    }
    if (estimateAvailableDays) {
      res["EstimateAvailableDays"] = boost::any(*estimateAvailableDays);
    }
    if (needOptimizeItemList) {
      vector<boost::any> temp1;
      for(auto item1:*needOptimizeItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NeedOptimizeItemList"] = boost::any(temp1);
    }
    if (tableStats) {
      vector<boost::any> temp1;
      for(auto item1:*tableStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableStats"] = boost::any(temp1);
    }
    if (totalFreeStorageSize) {
      res["TotalFreeStorageSize"] = boost::any(*totalFreeStorageSize);
    }
    if (totalStorageSize) {
      res["TotalStorageSize"] = boost::any(*totalStorageSize);
    }
    if (totalUsedStorageSize) {
      res["TotalUsedStorageSize"] = boost::any(*totalUsedStorageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisErrorType") != m.end() && !m["AnalysisErrorType"].empty()) {
      analysisErrorType = make_shared<string>(boost::any_cast<string>(m["AnalysisErrorType"]));
    }
    if (m.find("AnalysisSuccess") != m.end() && !m["AnalysisSuccess"].empty()) {
      analysisSuccess = make_shared<bool>(boost::any_cast<bool>(m["AnalysisSuccess"]));
    }
    if (m.find("DailyIncrement") != m.end() && !m["DailyIncrement"].empty()) {
      dailyIncrement = make_shared<long>(boost::any_cast<long>(m["DailyIncrement"]));
    }
    if (m.find("EstimateAvailableDays") != m.end() && !m["EstimateAvailableDays"].empty()) {
      estimateAvailableDays = make_shared<long>(boost::any_cast<long>(m["EstimateAvailableDays"]));
    }
    if (m.find("NeedOptimizeItemList") != m.end() && !m["NeedOptimizeItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["NeedOptimizeItemList"].type()) {
        vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NeedOptimizeItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        needOptimizeItemList = make_shared<vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultNeedOptimizeItemList>>(expect1);
      }
    }
    if (m.find("TableStats") != m.end() && !m["TableStats"].empty()) {
      if (typeid(vector<boost::any>) == m["TableStats"].type()) {
        vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableStats = make_shared<vector<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResultTableStats>>(expect1);
      }
    }
    if (m.find("TotalFreeStorageSize") != m.end() && !m["TotalFreeStorageSize"].empty()) {
      totalFreeStorageSize = make_shared<long>(boost::any_cast<long>(m["TotalFreeStorageSize"]));
    }
    if (m.find("TotalStorageSize") != m.end() && !m["TotalStorageSize"].empty()) {
      totalStorageSize = make_shared<long>(boost::any_cast<long>(m["TotalStorageSize"]));
    }
    if (m.find("TotalUsedStorageSize") != m.end() && !m["TotalUsedStorageSize"].empty()) {
      totalUsedStorageSize = make_shared<long>(boost::any_cast<long>(m["TotalUsedStorageSize"]));
    }
  }


  virtual ~GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult() = default;
};
class GetStorageAnalysisResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> analyzedDbCount{};
  shared_ptr<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult> storageAnalysisResult{};
  shared_ptr<bool> taskFinish{};
  shared_ptr<string> taskId{};
  shared_ptr<long> taskProgress{};
  shared_ptr<string> taskState{};
  shared_ptr<bool> taskSuccess{};
  shared_ptr<long> totalDbCount{};

  GetStorageAnalysisResultResponseBodyData() {}

  explicit GetStorageAnalysisResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyzedDbCount) {
      res["AnalyzedDbCount"] = boost::any(*analyzedDbCount);
    }
    if (storageAnalysisResult) {
      res["StorageAnalysisResult"] = storageAnalysisResult ? boost::any(storageAnalysisResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskFinish) {
      res["TaskFinish"] = boost::any(*taskFinish);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskProgress) {
      res["TaskProgress"] = boost::any(*taskProgress);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (taskSuccess) {
      res["TaskSuccess"] = boost::any(*taskSuccess);
    }
    if (totalDbCount) {
      res["TotalDbCount"] = boost::any(*totalDbCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalyzedDbCount") != m.end() && !m["AnalyzedDbCount"].empty()) {
      analyzedDbCount = make_shared<long>(boost::any_cast<long>(m["AnalyzedDbCount"]));
    }
    if (m.find("StorageAnalysisResult") != m.end() && !m["StorageAnalysisResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageAnalysisResult"].type()) {
        GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageAnalysisResult"]));
        storageAnalysisResult = make_shared<GetStorageAnalysisResultResponseBodyDataStorageAnalysisResult>(model1);
      }
    }
    if (m.find("TaskFinish") != m.end() && !m["TaskFinish"].empty()) {
      taskFinish = make_shared<bool>(boost::any_cast<bool>(m["TaskFinish"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskProgress") != m.end() && !m["TaskProgress"].empty()) {
      taskProgress = make_shared<long>(boost::any_cast<long>(m["TaskProgress"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TaskSuccess") != m.end() && !m["TaskSuccess"].empty()) {
      taskSuccess = make_shared<bool>(boost::any_cast<bool>(m["TaskSuccess"]));
    }
    if (m.find("TotalDbCount") != m.end() && !m["TotalDbCount"].empty()) {
      totalDbCount = make_shared<long>(boost::any_cast<long>(m["TotalDbCount"]));
    }
  }


  virtual ~GetStorageAnalysisResultResponseBodyData() = default;
};
class GetStorageAnalysisResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetStorageAnalysisResultResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetStorageAnalysisResultResponseBody() {}

  explicit GetStorageAnalysisResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetStorageAnalysisResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetStorageAnalysisResultResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStorageAnalysisResultResponseBody() = default;
};
class GetStorageAnalysisResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStorageAnalysisResultResponseBody> body{};

  GetStorageAnalysisResultResponse() {}

  explicit GetStorageAnalysisResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStorageAnalysisResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStorageAnalysisResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetStorageAnalysisResultResponse() = default;
};
class KillInstanceAllSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceId{};

  KillInstanceAllSessionRequest() {}

  explicit KillInstanceAllSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~KillInstanceAllSessionRequest() = default;
};
class KillInstanceAllSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  KillInstanceAllSessionResponseBody() {}

  explicit KillInstanceAllSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~KillInstanceAllSessionResponseBody() = default;
};
class KillInstanceAllSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<KillInstanceAllSessionResponseBody> body{};

  KillInstanceAllSessionResponse() {}

  explicit KillInstanceAllSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KillInstanceAllSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KillInstanceAllSessionResponseBody>(model1);
      }
    }
  }


  virtual ~KillInstanceAllSessionResponse() = default;
};
class ModifyAutoScalingConfigRequestBandwidth : public Darabonba::Model {
public:
  shared_ptr<bool> apply{};
  shared_ptr<long> bandwidthUsageLowerThreshold{};
  shared_ptr<long> bandwidthUsageUpperThreshold{};
  shared_ptr<bool> downgrade{};
  shared_ptr<string> observationWindowSize{};
  shared_ptr<bool> upgrade{};

  ModifyAutoScalingConfigRequestBandwidth() {}

  explicit ModifyAutoScalingConfigRequestBandwidth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apply) {
      res["Apply"] = boost::any(*apply);
    }
    if (bandwidthUsageLowerThreshold) {
      res["BandwidthUsageLowerThreshold"] = boost::any(*bandwidthUsageLowerThreshold);
    }
    if (bandwidthUsageUpperThreshold) {
      res["BandwidthUsageUpperThreshold"] = boost::any(*bandwidthUsageUpperThreshold);
    }
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (observationWindowSize) {
      res["ObservationWindowSize"] = boost::any(*observationWindowSize);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apply") != m.end() && !m["Apply"].empty()) {
      apply = make_shared<bool>(boost::any_cast<bool>(m["Apply"]));
    }
    if (m.find("BandwidthUsageLowerThreshold") != m.end() && !m["BandwidthUsageLowerThreshold"].empty()) {
      bandwidthUsageLowerThreshold = make_shared<long>(boost::any_cast<long>(m["BandwidthUsageLowerThreshold"]));
    }
    if (m.find("BandwidthUsageUpperThreshold") != m.end() && !m["BandwidthUsageUpperThreshold"].empty()) {
      bandwidthUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["BandwidthUsageUpperThreshold"]));
    }
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("ObservationWindowSize") != m.end() && !m["ObservationWindowSize"].empty()) {
      observationWindowSize = make_shared<string>(boost::any_cast<string>(m["ObservationWindowSize"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~ModifyAutoScalingConfigRequestBandwidth() = default;
};
class ModifyAutoScalingConfigRequestResource : public Darabonba::Model {
public:
  shared_ptr<bool> apply{};
  shared_ptr<long> cpuUsageUpperThreshold{};
  shared_ptr<string> downgradeObservationWindowSize{};
  shared_ptr<bool> enable{};
  shared_ptr<string> upgradeObservationWindowSize{};

  ModifyAutoScalingConfigRequestResource() {}

  explicit ModifyAutoScalingConfigRequestResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apply) {
      res["Apply"] = boost::any(*apply);
    }
    if (cpuUsageUpperThreshold) {
      res["CpuUsageUpperThreshold"] = boost::any(*cpuUsageUpperThreshold);
    }
    if (downgradeObservationWindowSize) {
      res["DowngradeObservationWindowSize"] = boost::any(*downgradeObservationWindowSize);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (upgradeObservationWindowSize) {
      res["UpgradeObservationWindowSize"] = boost::any(*upgradeObservationWindowSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apply") != m.end() && !m["Apply"].empty()) {
      apply = make_shared<bool>(boost::any_cast<bool>(m["Apply"]));
    }
    if (m.find("CpuUsageUpperThreshold") != m.end() && !m["CpuUsageUpperThreshold"].empty()) {
      cpuUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["CpuUsageUpperThreshold"]));
    }
    if (m.find("DowngradeObservationWindowSize") != m.end() && !m["DowngradeObservationWindowSize"].empty()) {
      downgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["DowngradeObservationWindowSize"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("UpgradeObservationWindowSize") != m.end() && !m["UpgradeObservationWindowSize"].empty()) {
      upgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["UpgradeObservationWindowSize"]));
    }
  }


  virtual ~ModifyAutoScalingConfigRequestResource() = default;
};
class ModifyAutoScalingConfigRequestShard : public Darabonba::Model {
public:
  shared_ptr<bool> apply{};
  shared_ptr<bool> downgrade{};
  shared_ptr<string> downgradeObservationWindowSize{};
  shared_ptr<long> maxShards{};
  shared_ptr<long> memUsageLowerThreshold{};
  shared_ptr<long> memUsageUpperThreshold{};
  shared_ptr<long> minShards{};
  shared_ptr<bool> upgrade{};
  shared_ptr<string> upgradeObservationWindowSize{};

  ModifyAutoScalingConfigRequestShard() {}

  explicit ModifyAutoScalingConfigRequestShard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apply) {
      res["Apply"] = boost::any(*apply);
    }
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (downgradeObservationWindowSize) {
      res["DowngradeObservationWindowSize"] = boost::any(*downgradeObservationWindowSize);
    }
    if (maxShards) {
      res["MaxShards"] = boost::any(*maxShards);
    }
    if (memUsageLowerThreshold) {
      res["MemUsageLowerThreshold"] = boost::any(*memUsageLowerThreshold);
    }
    if (memUsageUpperThreshold) {
      res["MemUsageUpperThreshold"] = boost::any(*memUsageUpperThreshold);
    }
    if (minShards) {
      res["MinShards"] = boost::any(*minShards);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    if (upgradeObservationWindowSize) {
      res["UpgradeObservationWindowSize"] = boost::any(*upgradeObservationWindowSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apply") != m.end() && !m["Apply"].empty()) {
      apply = make_shared<bool>(boost::any_cast<bool>(m["Apply"]));
    }
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("DowngradeObservationWindowSize") != m.end() && !m["DowngradeObservationWindowSize"].empty()) {
      downgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["DowngradeObservationWindowSize"]));
    }
    if (m.find("MaxShards") != m.end() && !m["MaxShards"].empty()) {
      maxShards = make_shared<long>(boost::any_cast<long>(m["MaxShards"]));
    }
    if (m.find("MemUsageLowerThreshold") != m.end() && !m["MemUsageLowerThreshold"].empty()) {
      memUsageLowerThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageLowerThreshold"]));
    }
    if (m.find("MemUsageUpperThreshold") != m.end() && !m["MemUsageUpperThreshold"].empty()) {
      memUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageUpperThreshold"]));
    }
    if (m.find("MinShards") != m.end() && !m["MinShards"].empty()) {
      minShards = make_shared<long>(boost::any_cast<long>(m["MinShards"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
    if (m.find("UpgradeObservationWindowSize") != m.end() && !m["UpgradeObservationWindowSize"].empty()) {
      upgradeObservationWindowSize = make_shared<string>(boost::any_cast<string>(m["UpgradeObservationWindowSize"]));
    }
  }


  virtual ~ModifyAutoScalingConfigRequestShard() = default;
};
class ModifyAutoScalingConfigRequestSpec : public Darabonba::Model {
public:
  shared_ptr<bool> apply{};
  shared_ptr<string> coolDownTime{};
  shared_ptr<long> cpuUsageUpperThreshold{};
  shared_ptr<bool> downgrade{};
  shared_ptr<long> maxReadOnlyNodes{};
  shared_ptr<string> maxSpec{};
  shared_ptr<long> memUsageUpperThreshold{};
  shared_ptr<string> observationWindowSize{};
  shared_ptr<bool> upgrade{};

  ModifyAutoScalingConfigRequestSpec() {}

  explicit ModifyAutoScalingConfigRequestSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apply) {
      res["Apply"] = boost::any(*apply);
    }
    if (coolDownTime) {
      res["CoolDownTime"] = boost::any(*coolDownTime);
    }
    if (cpuUsageUpperThreshold) {
      res["CpuUsageUpperThreshold"] = boost::any(*cpuUsageUpperThreshold);
    }
    if (downgrade) {
      res["Downgrade"] = boost::any(*downgrade);
    }
    if (maxReadOnlyNodes) {
      res["MaxReadOnlyNodes"] = boost::any(*maxReadOnlyNodes);
    }
    if (maxSpec) {
      res["MaxSpec"] = boost::any(*maxSpec);
    }
    if (memUsageUpperThreshold) {
      res["MemUsageUpperThreshold"] = boost::any(*memUsageUpperThreshold);
    }
    if (observationWindowSize) {
      res["ObservationWindowSize"] = boost::any(*observationWindowSize);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apply") != m.end() && !m["Apply"].empty()) {
      apply = make_shared<bool>(boost::any_cast<bool>(m["Apply"]));
    }
    if (m.find("CoolDownTime") != m.end() && !m["CoolDownTime"].empty()) {
      coolDownTime = make_shared<string>(boost::any_cast<string>(m["CoolDownTime"]));
    }
    if (m.find("CpuUsageUpperThreshold") != m.end() && !m["CpuUsageUpperThreshold"].empty()) {
      cpuUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["CpuUsageUpperThreshold"]));
    }
    if (m.find("Downgrade") != m.end() && !m["Downgrade"].empty()) {
      downgrade = make_shared<bool>(boost::any_cast<bool>(m["Downgrade"]));
    }
    if (m.find("MaxReadOnlyNodes") != m.end() && !m["MaxReadOnlyNodes"].empty()) {
      maxReadOnlyNodes = make_shared<long>(boost::any_cast<long>(m["MaxReadOnlyNodes"]));
    }
    if (m.find("MaxSpec") != m.end() && !m["MaxSpec"].empty()) {
      maxSpec = make_shared<string>(boost::any_cast<string>(m["MaxSpec"]));
    }
    if (m.find("MemUsageUpperThreshold") != m.end() && !m["MemUsageUpperThreshold"].empty()) {
      memUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["MemUsageUpperThreshold"]));
    }
    if (m.find("ObservationWindowSize") != m.end() && !m["ObservationWindowSize"].empty()) {
      observationWindowSize = make_shared<string>(boost::any_cast<string>(m["ObservationWindowSize"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~ModifyAutoScalingConfigRequestSpec() = default;
};
class ModifyAutoScalingConfigRequestStorage : public Darabonba::Model {
public:
  shared_ptr<bool> apply{};
  shared_ptr<long> diskUsageUpperThreshold{};
  shared_ptr<long> maxStorage{};
  shared_ptr<bool> upgrade{};

  ModifyAutoScalingConfigRequestStorage() {}

  explicit ModifyAutoScalingConfigRequestStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apply) {
      res["Apply"] = boost::any(*apply);
    }
    if (diskUsageUpperThreshold) {
      res["DiskUsageUpperThreshold"] = boost::any(*diskUsageUpperThreshold);
    }
    if (maxStorage) {
      res["MaxStorage"] = boost::any(*maxStorage);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apply") != m.end() && !m["Apply"].empty()) {
      apply = make_shared<bool>(boost::any_cast<bool>(m["Apply"]));
    }
    if (m.find("DiskUsageUpperThreshold") != m.end() && !m["DiskUsageUpperThreshold"].empty()) {
      diskUsageUpperThreshold = make_shared<long>(boost::any_cast<long>(m["DiskUsageUpperThreshold"]));
    }
    if (m.find("MaxStorage") != m.end() && !m["MaxStorage"].empty()) {
      maxStorage = make_shared<long>(boost::any_cast<long>(m["MaxStorage"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
  }


  virtual ~ModifyAutoScalingConfigRequestStorage() = default;
};
class ModifyAutoScalingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyAutoScalingConfigRequestBandwidth> bandwidth{};
  shared_ptr<string> instanceId{};
  shared_ptr<ModifyAutoScalingConfigRequestResource> resource{};
  shared_ptr<ModifyAutoScalingConfigRequestShard> shard{};
  shared_ptr<ModifyAutoScalingConfigRequestSpec> spec{};
  shared_ptr<ModifyAutoScalingConfigRequestStorage> storage{};

  ModifyAutoScalingConfigRequest() {}

  explicit ModifyAutoScalingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = bandwidth ? boost::any(bandwidth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shard) {
      res["Shard"] = shard ? boost::any(shard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storage) {
      res["Storage"] = storage ? boost::any(storage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      if (typeid(map<string, boost::any>) == m["Bandwidth"].type()) {
        ModifyAutoScalingConfigRequestBandwidth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Bandwidth"]));
        bandwidth = make_shared<ModifyAutoScalingConfigRequestBandwidth>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        ModifyAutoScalingConfigRequestResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<ModifyAutoScalingConfigRequestResource>(model1);
      }
    }
    if (m.find("Shard") != m.end() && !m["Shard"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shard"].type()) {
        ModifyAutoScalingConfigRequestShard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shard"]));
        shard = make_shared<ModifyAutoScalingConfigRequestShard>(model1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        ModifyAutoScalingConfigRequestSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<ModifyAutoScalingConfigRequestSpec>(model1);
      }
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Storage"].type()) {
        ModifyAutoScalingConfigRequestStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Storage"]));
        storage = make_shared<ModifyAutoScalingConfigRequestStorage>(model1);
      }
    }
  }


  virtual ~ModifyAutoScalingConfigRequest() = default;
};
class ModifyAutoScalingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyAutoScalingConfigResponseBody() {}

  explicit ModifyAutoScalingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyAutoScalingConfigResponseBody() = default;
};
class ModifyAutoScalingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAutoScalingConfigResponseBody> body{};

  ModifyAutoScalingConfigResponse() {}

  explicit ModifyAutoScalingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoScalingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoScalingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoScalingConfigResponse() = default;
};
class ModifySqlLogConfigRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifySqlLogConfigRequestFilters() {}

  explicit ModifySqlLogConfigRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifySqlLogConfigRequestFilters() = default;
};
class ModifySqlLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<vector<ModifySqlLogConfigRequestFilters>> filters{};
  shared_ptr<long> hotRetention{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> requestEnable{};
  shared_ptr<long> retention{};

  ModifySqlLogConfigRequest() {}

  explicit ModifySqlLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (hotRetention) {
      res["HotRetention"] = boost::any(*hotRetention);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestEnable) {
      res["RequestEnable"] = boost::any(*requestEnable);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<ModifySqlLogConfigRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifySqlLogConfigRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<ModifySqlLogConfigRequestFilters>>(expect1);
      }
    }
    if (m.find("HotRetention") != m.end() && !m["HotRetention"].empty()) {
      hotRetention = make_shared<long>(boost::any_cast<long>(m["HotRetention"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestEnable") != m.end() && !m["RequestEnable"].empty()) {
      requestEnable = make_shared<bool>(boost::any_cast<bool>(m["RequestEnable"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
  }


  virtual ~ModifySqlLogConfigRequest() = default;
};
class ModifySqlLogConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> coldEnable{};
  shared_ptr<long> coldRetention{};
  shared_ptr<long> coldStartTime{};
  shared_ptr<string> collectorVersion{};
  shared_ptr<bool> hotEnable{};
  shared_ptr<long> hotRetention{};
  shared_ptr<long> hotStartTime{};
  shared_ptr<string> logFilter{};
  shared_ptr<bool> requestEnable{};
  shared_ptr<long> requestStartTime{};
  shared_ptr<long> requestStopTime{};
  shared_ptr<long> retention{};
  shared_ptr<bool> sqlLogEnable{};
  shared_ptr<string> sqlLogState{};
  shared_ptr<long> sqlLogVisibleTime{};
  shared_ptr<string> supportVersion{};
  shared_ptr<string> version{};

  ModifySqlLogConfigResponseBodyData() {}

  explicit ModifySqlLogConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldEnable) {
      res["ColdEnable"] = boost::any(*coldEnable);
    }
    if (coldRetention) {
      res["ColdRetention"] = boost::any(*coldRetention);
    }
    if (coldStartTime) {
      res["ColdStartTime"] = boost::any(*coldStartTime);
    }
    if (collectorVersion) {
      res["CollectorVersion"] = boost::any(*collectorVersion);
    }
    if (hotEnable) {
      res["HotEnable"] = boost::any(*hotEnable);
    }
    if (hotRetention) {
      res["HotRetention"] = boost::any(*hotRetention);
    }
    if (hotStartTime) {
      res["HotStartTime"] = boost::any(*hotStartTime);
    }
    if (logFilter) {
      res["LogFilter"] = boost::any(*logFilter);
    }
    if (requestEnable) {
      res["RequestEnable"] = boost::any(*requestEnable);
    }
    if (requestStartTime) {
      res["RequestStartTime"] = boost::any(*requestStartTime);
    }
    if (requestStopTime) {
      res["RequestStopTime"] = boost::any(*requestStopTime);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (sqlLogEnable) {
      res["SqlLogEnable"] = boost::any(*sqlLogEnable);
    }
    if (sqlLogState) {
      res["SqlLogState"] = boost::any(*sqlLogState);
    }
    if (sqlLogVisibleTime) {
      res["SqlLogVisibleTime"] = boost::any(*sqlLogVisibleTime);
    }
    if (supportVersion) {
      res["SupportVersion"] = boost::any(*supportVersion);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdEnable") != m.end() && !m["ColdEnable"].empty()) {
      coldEnable = make_shared<bool>(boost::any_cast<bool>(m["ColdEnable"]));
    }
    if (m.find("ColdRetention") != m.end() && !m["ColdRetention"].empty()) {
      coldRetention = make_shared<long>(boost::any_cast<long>(m["ColdRetention"]));
    }
    if (m.find("ColdStartTime") != m.end() && !m["ColdStartTime"].empty()) {
      coldStartTime = make_shared<long>(boost::any_cast<long>(m["ColdStartTime"]));
    }
    if (m.find("CollectorVersion") != m.end() && !m["CollectorVersion"].empty()) {
      collectorVersion = make_shared<string>(boost::any_cast<string>(m["CollectorVersion"]));
    }
    if (m.find("HotEnable") != m.end() && !m["HotEnable"].empty()) {
      hotEnable = make_shared<bool>(boost::any_cast<bool>(m["HotEnable"]));
    }
    if (m.find("HotRetention") != m.end() && !m["HotRetention"].empty()) {
      hotRetention = make_shared<long>(boost::any_cast<long>(m["HotRetention"]));
    }
    if (m.find("HotStartTime") != m.end() && !m["HotStartTime"].empty()) {
      hotStartTime = make_shared<long>(boost::any_cast<long>(m["HotStartTime"]));
    }
    if (m.find("LogFilter") != m.end() && !m["LogFilter"].empty()) {
      logFilter = make_shared<string>(boost::any_cast<string>(m["LogFilter"]));
    }
    if (m.find("RequestEnable") != m.end() && !m["RequestEnable"].empty()) {
      requestEnable = make_shared<bool>(boost::any_cast<bool>(m["RequestEnable"]));
    }
    if (m.find("RequestStartTime") != m.end() && !m["RequestStartTime"].empty()) {
      requestStartTime = make_shared<long>(boost::any_cast<long>(m["RequestStartTime"]));
    }
    if (m.find("RequestStopTime") != m.end() && !m["RequestStopTime"].empty()) {
      requestStopTime = make_shared<long>(boost::any_cast<long>(m["RequestStopTime"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SqlLogEnable") != m.end() && !m["SqlLogEnable"].empty()) {
      sqlLogEnable = make_shared<bool>(boost::any_cast<bool>(m["SqlLogEnable"]));
    }
    if (m.find("SqlLogState") != m.end() && !m["SqlLogState"].empty()) {
      sqlLogState = make_shared<string>(boost::any_cast<string>(m["SqlLogState"]));
    }
    if (m.find("SqlLogVisibleTime") != m.end() && !m["SqlLogVisibleTime"].empty()) {
      sqlLogVisibleTime = make_shared<long>(boost::any_cast<long>(m["SqlLogVisibleTime"]));
    }
    if (m.find("SupportVersion") != m.end() && !m["SupportVersion"].empty()) {
      supportVersion = make_shared<string>(boost::any_cast<string>(m["SupportVersion"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ModifySqlLogConfigResponseBodyData() = default;
};
class ModifySqlLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifySqlLogConfigResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifySqlLogConfigResponseBody() {}

  explicit ModifySqlLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifySqlLogConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifySqlLogConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifySqlLogConfigResponseBody() = default;
};
class ModifySqlLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySqlLogConfigResponseBody> body{};

  ModifySqlLogConfigResponse() {}

  explicit ModifySqlLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySqlLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySqlLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySqlLogConfigResponse() = default;
};
class RunCloudBenchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  RunCloudBenchTaskRequest() {}

  explicit RunCloudBenchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RunCloudBenchTaskRequest() = default;
};
class RunCloudBenchTaskResponseBodyDataPreCheckItem : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> details{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<long> order{};
  shared_ptr<string> status{};

  RunCloudBenchTaskResponseBodyDataPreCheckItem() {}

  explicit RunCloudBenchTaskResponseBodyDataPreCheckItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~RunCloudBenchTaskResponseBodyDataPreCheckItem() = default;
};
class RunCloudBenchTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<RunCloudBenchTaskResponseBodyDataPreCheckItem>> preCheckItem{};

  RunCloudBenchTaskResponseBodyData() {}

  explicit RunCloudBenchTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preCheckItem) {
      vector<boost::any> temp1;
      for(auto item1:*preCheckItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreCheckItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreCheckItem") != m.end() && !m["PreCheckItem"].empty()) {
      if (typeid(vector<boost::any>) == m["PreCheckItem"].type()) {
        vector<RunCloudBenchTaskResponseBodyDataPreCheckItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreCheckItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunCloudBenchTaskResponseBodyDataPreCheckItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preCheckItem = make_shared<vector<RunCloudBenchTaskResponseBodyDataPreCheckItem>>(expect1);
      }
    }
  }


  virtual ~RunCloudBenchTaskResponseBodyData() = default;
};
class RunCloudBenchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RunCloudBenchTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  RunCloudBenchTaskResponseBody() {}

  explicit RunCloudBenchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RunCloudBenchTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RunCloudBenchTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~RunCloudBenchTaskResponseBody() = default;
};
class RunCloudBenchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunCloudBenchTaskResponseBody> body{};

  RunCloudBenchTaskResponse() {}

  explicit RunCloudBenchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCloudBenchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCloudBenchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RunCloudBenchTaskResponse() = default;
};
class SetEventSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> active{};
  shared_ptr<string> channelType{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dispatchRule{};
  shared_ptr<string> eventContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> minInterval{};
  shared_ptr<string> severity{};

  SetEventSubscriptionRequest() {}

  explicit SetEventSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (channelType) {
      res["ChannelType"] = boost::any(*channelType);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dispatchRule) {
      res["DispatchRule"] = boost::any(*dispatchRule);
    }
    if (eventContext) {
      res["EventContext"] = boost::any(*eventContext);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (minInterval) {
      res["MinInterval"] = boost::any(*minInterval);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<string>(boost::any_cast<string>(m["Active"]));
    }
    if (m.find("ChannelType") != m.end() && !m["ChannelType"].empty()) {
      channelType = make_shared<string>(boost::any_cast<string>(m["ChannelType"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      dispatchRule = make_shared<string>(boost::any_cast<string>(m["DispatchRule"]));
    }
    if (m.find("EventContext") != m.end() && !m["EventContext"].empty()) {
      eventContext = make_shared<string>(boost::any_cast<string>(m["EventContext"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MinInterval") != m.end() && !m["MinInterval"].empty()) {
      minInterval = make_shared<string>(boost::any_cast<string>(m["MinInterval"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~SetEventSubscriptionRequest() = default;
};
class SetEventSubscriptionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> active{};
  shared_ptr<string> channelType{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactName{};
  shared_ptr<string> eventContext{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<long> minInterval{};
  shared_ptr<string> userId{};

  SetEventSubscriptionResponseBodyData() {}

  explicit SetEventSubscriptionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["active"] = boost::any(*active);
    }
    if (channelType) {
      res["channelType"] = boost::any(*channelType);
    }
    if (contactGroupName) {
      res["contactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactName) {
      res["contactName"] = boost::any(*contactName);
    }
    if (eventContext) {
      res["eventContext"] = boost::any(*eventContext);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (minInterval) {
      res["minInterval"] = boost::any(*minInterval);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("active") != m.end() && !m["active"].empty()) {
      active = make_shared<long>(boost::any_cast<long>(m["active"]));
    }
    if (m.find("channelType") != m.end() && !m["channelType"].empty()) {
      channelType = make_shared<string>(boost::any_cast<string>(m["channelType"]));
    }
    if (m.find("contactGroupName") != m.end() && !m["contactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["contactGroupName"]));
    }
    if (m.find("contactName") != m.end() && !m["contactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contactName"]));
    }
    if (m.find("eventContext") != m.end() && !m["eventContext"].empty()) {
      eventContext = make_shared<string>(boost::any_cast<string>(m["eventContext"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("minInterval") != m.end() && !m["minInterval"].empty()) {
      minInterval = make_shared<long>(boost::any_cast<long>(m["minInterval"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~SetEventSubscriptionResponseBodyData() = default;
};
class SetEventSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SetEventSubscriptionResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SetEventSubscriptionResponseBody() {}

  explicit SetEventSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetEventSubscriptionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetEventSubscriptionResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SetEventSubscriptionResponseBody() = default;
};
class SetEventSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetEventSubscriptionResponseBody> body{};

  SetEventSubscriptionResponse() {}

  explicit SetEventSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEventSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEventSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~SetEventSubscriptionResponse() = default;
};
class StopCloudBenchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  StopCloudBenchTaskRequest() {}

  explicit StopCloudBenchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopCloudBenchTaskRequest() = default;
};
class StopCloudBenchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StopCloudBenchTaskResponseBody() {}

  explicit StopCloudBenchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StopCloudBenchTaskResponseBody() = default;
};
class StopCloudBenchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCloudBenchTaskResponseBody> body{};

  StopCloudBenchTaskResponse() {}

  explicit StopCloudBenchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCloudBenchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCloudBenchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopCloudBenchTaskResponse() = default;
};
class SyncHDMAliyunResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> async{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> waitForModifySecurityIps{};
  shared_ptr<string> context{};
  shared_ptr<string> accessKey{};
  shared_ptr<string> signature{};
  shared_ptr<string> skipAuth{};
  shared_ptr<string> timestamp{};

  SyncHDMAliyunResourceRequest() {}

  explicit SyncHDMAliyunResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (waitForModifySecurityIps) {
      res["WaitForModifySecurityIps"] = boost::any(*waitForModifySecurityIps);
    }
    if (context) {
      res["__context"] = boost::any(*context);
    }
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (skipAuth) {
      res["skipAuth"] = boost::any(*skipAuth);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<string>(boost::any_cast<string>(m["Async"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WaitForModifySecurityIps") != m.end() && !m["WaitForModifySecurityIps"].empty()) {
      waitForModifySecurityIps = make_shared<string>(boost::any_cast<string>(m["WaitForModifySecurityIps"]));
    }
    if (m.find("__context") != m.end() && !m["__context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["__context"]));
    }
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("skipAuth") != m.end() && !m["skipAuth"].empty()) {
      skipAuth = make_shared<string>(boost::any_cast<string>(m["skipAuth"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~SyncHDMAliyunResourceRequest() = default;
};
class SyncHDMAliyunResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchro{};

  SyncHDMAliyunResourceResponseBody() {}

  explicit SyncHDMAliyunResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchro) {
      res["Synchro"] = boost::any(*synchro);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Synchro") != m.end() && !m["Synchro"].empty()) {
      synchro = make_shared<string>(boost::any_cast<string>(m["Synchro"]));
    }
  }


  virtual ~SyncHDMAliyunResourceResponseBody() = default;
};
class SyncHDMAliyunResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncHDMAliyunResourceResponseBody> body{};

  SyncHDMAliyunResourceResponse() {}

  explicit SyncHDMAliyunResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncHDMAliyunResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncHDMAliyunResourceResponseBody>(model1);
      }
    }
  }


  virtual ~SyncHDMAliyunResourceResponse() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> consoleContext{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> resultId{};
  shared_ptr<double> tableFragmentationRatio{};
  shared_ptr<double> tableSpaceSize{};

  UpdateAutoResourceOptimizeRulesAsyncRequest() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    if (tableFragmentationRatio) {
      res["TableFragmentationRatio"] = boost::any(*tableFragmentationRatio);
    }
    if (tableSpaceSize) {
      res["TableSpaceSize"] = boost::any(*tableSpaceSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
    if (m.find("TableFragmentationRatio") != m.end() && !m["TableFragmentationRatio"].empty()) {
      tableFragmentationRatio = make_shared<double>(boost::any_cast<double>(m["TableFragmentationRatio"]));
    }
    if (m.find("TableSpaceSize") != m.end() && !m["TableSpaceSize"].empty()) {
      tableSpaceSize = make_shared<double>(boost::any_cast<double>(m["TableSpaceSize"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncRequest() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};

  UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> instanceId{};

  UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse : public Darabonba::Model {
public:
  shared_ptr<long> configFailInstanceCount{};
  shared_ptr<vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList>> configFailInstanceList{};
  shared_ptr<long> configSuccessInstanceCount{};
  shared_ptr<vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList>> configSuccessInstanceList{};
  shared_ptr<long> totalInstanceCount{};

  UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFailInstanceCount) {
      res["ConfigFailInstanceCount"] = boost::any(*configFailInstanceCount);
    }
    if (configFailInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configFailInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFailInstanceList"] = boost::any(temp1);
    }
    if (configSuccessInstanceCount) {
      res["ConfigSuccessInstanceCount"] = boost::any(*configSuccessInstanceCount);
    }
    if (configSuccessInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configSuccessInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigSuccessInstanceList"] = boost::any(temp1);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFailInstanceCount") != m.end() && !m["ConfigFailInstanceCount"].empty()) {
      configFailInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigFailInstanceCount"]));
    }
    if (m.find("ConfigFailInstanceList") != m.end() && !m["ConfigFailInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFailInstanceList"].type()) {
        vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFailInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFailInstanceList = make_shared<vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList>>(expect1);
      }
    }
    if (m.find("ConfigSuccessInstanceCount") != m.end() && !m["ConfigSuccessInstanceCount"].empty()) {
      configSuccessInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigSuccessInstanceCount"]));
    }
    if (m.find("ConfigSuccessInstanceList") != m.end() && !m["ConfigSuccessInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigSuccessInstanceList"].type()) {
        vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigSuccessInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configSuccessInstanceList = make_shared<vector<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList>>(expect1);
      }
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse> configResponse{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  UpdateAutoResourceOptimizeRulesAsyncResponseBodyData() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (configResponse) {
      res["ConfigResponse"] = configResponse ? boost::any(configResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["IsFinish"] = boost::any(*isFinish);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("ConfigResponse") != m.end() && !m["ConfigResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigResponse"].type()) {
        UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigResponse"]));
        configResponse = make_shared<UpdateAutoResourceOptimizeRulesAsyncResponseBodyDataConfigResponse>(model1);
      }
    }
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["Fail"]));
    }
    if (m.find("IsFinish") != m.end() && !m["IsFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["IsFinish"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponseBodyData() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateAutoResourceOptimizeRulesAsyncResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAutoResourceOptimizeRulesAsyncResponseBody() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateAutoResourceOptimizeRulesAsyncResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateAutoResourceOptimizeRulesAsyncResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponseBody() = default;
};
class UpdateAutoResourceOptimizeRulesAsyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAutoResourceOptimizeRulesAsyncResponseBody> body{};

  UpdateAutoResourceOptimizeRulesAsyncResponse() {}

  explicit UpdateAutoResourceOptimizeRulesAsyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAutoResourceOptimizeRulesAsyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAutoResourceOptimizeRulesAsyncResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAutoResourceOptimizeRulesAsyncResponse() = default;
};
class UpdateAutoSqlOptimizeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instances{};
  shared_ptr<long> status{};

  UpdateAutoSqlOptimizeStatusRequest() {}

  explicit UpdateAutoSqlOptimizeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<string>(boost::any_cast<string>(m["Instances"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UpdateAutoSqlOptimizeStatusRequest() = default;
};
class UpdateAutoSqlOptimizeStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> success{};

  UpdateAutoSqlOptimizeStatusResponseBodyData() {}

  explicit UpdateAutoSqlOptimizeStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateAutoSqlOptimizeStatusResponseBodyData() = default;
};
class UpdateAutoSqlOptimizeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateAutoSqlOptimizeStatusResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateAutoSqlOptimizeStatusResponseBody() {}

  explicit UpdateAutoSqlOptimizeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateAutoSqlOptimizeStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateAutoSqlOptimizeStatusResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateAutoSqlOptimizeStatusResponseBody() = default;
};
class UpdateAutoSqlOptimizeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAutoSqlOptimizeStatusResponseBody> body{};

  UpdateAutoSqlOptimizeStatusResponse() {}

  explicit UpdateAutoSqlOptimizeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAutoSqlOptimizeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAutoSqlOptimizeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAutoSqlOptimizeStatusResponse() = default;
};
class UpdateAutoThrottleRulesAsyncRequest : public Darabonba::Model {
public:
  shared_ptr<double> abnormalDuration{};
  shared_ptr<long> activeSessions{};
  shared_ptr<string> allowThrottleEndTime{};
  shared_ptr<string> allowThrottleStartTime{};
  shared_ptr<bool> autoKillSession{};
  shared_ptr<string> consoleContext{};
  shared_ptr<string> cpuSessionRelation{};
  shared_ptr<double> cpuUsage{};
  shared_ptr<string> instanceIds{};
  shared_ptr<double> maxThrottleTime{};
  shared_ptr<string> resultId{};

  UpdateAutoThrottleRulesAsyncRequest() {}

  explicit UpdateAutoThrottleRulesAsyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalDuration) {
      res["AbnormalDuration"] = boost::any(*abnormalDuration);
    }
    if (activeSessions) {
      res["ActiveSessions"] = boost::any(*activeSessions);
    }
    if (allowThrottleEndTime) {
      res["AllowThrottleEndTime"] = boost::any(*allowThrottleEndTime);
    }
    if (allowThrottleStartTime) {
      res["AllowThrottleStartTime"] = boost::any(*allowThrottleStartTime);
    }
    if (autoKillSession) {
      res["AutoKillSession"] = boost::any(*autoKillSession);
    }
    if (consoleContext) {
      res["ConsoleContext"] = boost::any(*consoleContext);
    }
    if (cpuSessionRelation) {
      res["CpuSessionRelation"] = boost::any(*cpuSessionRelation);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (maxThrottleTime) {
      res["MaxThrottleTime"] = boost::any(*maxThrottleTime);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalDuration") != m.end() && !m["AbnormalDuration"].empty()) {
      abnormalDuration = make_shared<double>(boost::any_cast<double>(m["AbnormalDuration"]));
    }
    if (m.find("ActiveSessions") != m.end() && !m["ActiveSessions"].empty()) {
      activeSessions = make_shared<long>(boost::any_cast<long>(m["ActiveSessions"]));
    }
    if (m.find("AllowThrottleEndTime") != m.end() && !m["AllowThrottleEndTime"].empty()) {
      allowThrottleEndTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleEndTime"]));
    }
    if (m.find("AllowThrottleStartTime") != m.end() && !m["AllowThrottleStartTime"].empty()) {
      allowThrottleStartTime = make_shared<string>(boost::any_cast<string>(m["AllowThrottleStartTime"]));
    }
    if (m.find("AutoKillSession") != m.end() && !m["AutoKillSession"].empty()) {
      autoKillSession = make_shared<bool>(boost::any_cast<bool>(m["AutoKillSession"]));
    }
    if (m.find("ConsoleContext") != m.end() && !m["ConsoleContext"].empty()) {
      consoleContext = make_shared<string>(boost::any_cast<string>(m["ConsoleContext"]));
    }
    if (m.find("CpuSessionRelation") != m.end() && !m["CpuSessionRelation"].empty()) {
      cpuSessionRelation = make_shared<string>(boost::any_cast<string>(m["CpuSessionRelation"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<double>(boost::any_cast<double>(m["CpuUsage"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("MaxThrottleTime") != m.end() && !m["MaxThrottleTime"].empty()) {
      maxThrottleTime = make_shared<double>(boost::any_cast<double>(m["MaxThrottleTime"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncRequest() = default;
};
class UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};

  UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList() {}

  explicit UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList() = default;
};
class UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> configSuccess{};
  shared_ptr<string> instanceId{};

  UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList() {}

  explicit UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSuccess) {
      res["ConfigSuccess"] = boost::any(*configSuccess);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigSuccess") != m.end() && !m["ConfigSuccess"].empty()) {
      configSuccess = make_shared<bool>(boost::any_cast<bool>(m["ConfigSuccess"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList() = default;
};
class UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse : public Darabonba::Model {
public:
  shared_ptr<long> configFailInstanceCount{};
  shared_ptr<vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList>> configFailInstanceList{};
  shared_ptr<long> configSuccessInstanceCount{};
  shared_ptr<vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList>> configSuccessInstanceList{};
  shared_ptr<long> totalInstanceCount{};

  UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse() {}

  explicit UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configFailInstanceCount) {
      res["ConfigFailInstanceCount"] = boost::any(*configFailInstanceCount);
    }
    if (configFailInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configFailInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigFailInstanceList"] = boost::any(temp1);
    }
    if (configSuccessInstanceCount) {
      res["ConfigSuccessInstanceCount"] = boost::any(*configSuccessInstanceCount);
    }
    if (configSuccessInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*configSuccessInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigSuccessInstanceList"] = boost::any(temp1);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigFailInstanceCount") != m.end() && !m["ConfigFailInstanceCount"].empty()) {
      configFailInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigFailInstanceCount"]));
    }
    if (m.find("ConfigFailInstanceList") != m.end() && !m["ConfigFailInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigFailInstanceList"].type()) {
        vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigFailInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configFailInstanceList = make_shared<vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigFailInstanceList>>(expect1);
      }
    }
    if (m.find("ConfigSuccessInstanceCount") != m.end() && !m["ConfigSuccessInstanceCount"].empty()) {
      configSuccessInstanceCount = make_shared<long>(boost::any_cast<long>(m["ConfigSuccessInstanceCount"]));
    }
    if (m.find("ConfigSuccessInstanceList") != m.end() && !m["ConfigSuccessInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigSuccessInstanceList"].type()) {
        vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigSuccessInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configSuccessInstanceList = make_shared<vector<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponseConfigSuccessInstanceList>>(expect1);
      }
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse() = default;
};
class UpdateAutoThrottleRulesAsyncResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse> configResponse{};
  shared_ptr<bool> fail{};
  shared_ptr<bool> isFinish{};
  shared_ptr<string> resultId{};
  shared_ptr<string> state{};
  shared_ptr<long> timestamp{};

  UpdateAutoThrottleRulesAsyncResponseBodyData() {}

  explicit UpdateAutoThrottleRulesAsyncResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (configResponse) {
      res["ConfigResponse"] = configResponse ? boost::any(configResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    if (isFinish) {
      res["IsFinish"] = boost::any(*isFinish);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("ConfigResponse") != m.end() && !m["ConfigResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigResponse"].type()) {
        UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigResponse"]));
        configResponse = make_shared<UpdateAutoThrottleRulesAsyncResponseBodyDataConfigResponse>(model1);
      }
    }
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      fail = make_shared<bool>(boost::any_cast<bool>(m["Fail"]));
    }
    if (m.find("IsFinish") != m.end() && !m["IsFinish"].empty()) {
      isFinish = make_shared<bool>(boost::any_cast<bool>(m["IsFinish"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponseBodyData() = default;
};
class UpdateAutoThrottleRulesAsyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateAutoThrottleRulesAsyncResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAutoThrottleRulesAsyncResponseBody() {}

  explicit UpdateAutoThrottleRulesAsyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateAutoThrottleRulesAsyncResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateAutoThrottleRulesAsyncResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponseBody() = default;
};
class UpdateAutoThrottleRulesAsyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAutoThrottleRulesAsyncResponseBody> body{};

  UpdateAutoThrottleRulesAsyncResponse() {}

  explicit UpdateAutoThrottleRulesAsyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAutoThrottleRulesAsyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAutoThrottleRulesAsyncResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAutoThrottleRulesAsyncResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddHDMInstanceResponse addHDMInstanceWithOptions(shared_ptr<AddHDMInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddHDMInstanceResponse addHDMInstance(shared_ptr<AddHDMInstanceRequest> request);
  CreateAdamBenchTaskResponse createAdamBenchTaskWithOptions(shared_ptr<CreateAdamBenchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAdamBenchTaskResponse createAdamBenchTask(shared_ptr<CreateAdamBenchTaskRequest> request);
  CreateCacheAnalysisJobResponse createCacheAnalysisJobWithOptions(shared_ptr<CreateCacheAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCacheAnalysisJobResponse createCacheAnalysisJob(shared_ptr<CreateCacheAnalysisJobRequest> request);
  CreateCloudBenchTasksResponse createCloudBenchTasksWithOptions(shared_ptr<CreateCloudBenchTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudBenchTasksResponse createCloudBenchTasks(shared_ptr<CreateCloudBenchTasksRequest> request);
  CreateDiagnosticReportResponse createDiagnosticReportWithOptions(shared_ptr<CreateDiagnosticReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnosticReportResponse createDiagnosticReport(shared_ptr<CreateDiagnosticReportRequest> request);
  CreateKillInstanceSessionTaskResponse createKillInstanceSessionTaskWithOptions(shared_ptr<CreateKillInstanceSessionTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKillInstanceSessionTaskResponse createKillInstanceSessionTask(shared_ptr<CreateKillInstanceSessionTaskRequest> request);
  CreateKillInstanceSessionTaskWithMaintainUserResponse createKillInstanceSessionTaskWithMaintainUserWithOptions(shared_ptr<CreateKillInstanceSessionTaskWithMaintainUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKillInstanceSessionTaskWithMaintainUserResponse createKillInstanceSessionTaskWithMaintainUser(shared_ptr<CreateKillInstanceSessionTaskWithMaintainUserRequest> request);
  CreateQueryOptimizeTagResponse createQueryOptimizeTagWithOptions(shared_ptr<CreateQueryOptimizeTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQueryOptimizeTagResponse createQueryOptimizeTag(shared_ptr<CreateQueryOptimizeTagRequest> request);
  CreateRequestDiagnosisResponse createRequestDiagnosisWithOptions(shared_ptr<CreateRequestDiagnosisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRequestDiagnosisResponse createRequestDiagnosis(shared_ptr<CreateRequestDiagnosisRequest> request);
  CreateSqlLogTaskResponse createSqlLogTaskWithOptions(shared_ptr<CreateSqlLogTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSqlLogTaskResponse createSqlLogTask(shared_ptr<CreateSqlLogTaskRequest> request);
  CreateStorageAnalysisTaskResponse createStorageAnalysisTaskWithOptions(shared_ptr<CreateStorageAnalysisTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStorageAnalysisTaskResponse createStorageAnalysisTask(shared_ptr<CreateStorageAnalysisTaskRequest> request);
  DeleteCloudBenchTaskResponse deleteCloudBenchTaskWithOptions(shared_ptr<DeleteCloudBenchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudBenchTaskResponse deleteCloudBenchTask(shared_ptr<DeleteCloudBenchTaskRequest> request);
  DeleteStopGatewayResponse deleteStopGatewayWithOptions(shared_ptr<DeleteStopGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStopGatewayResponse deleteStopGateway(shared_ptr<DeleteStopGatewayRequest> request);
  DescribeAutoScalingConfigResponse describeAutoScalingConfigWithOptions(shared_ptr<DescribeAutoScalingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoScalingConfigResponse describeAutoScalingConfig(shared_ptr<DescribeAutoScalingConfigRequest> request);
  DescribeAutoScalingHistoryResponse describeAutoScalingHistoryWithOptions(shared_ptr<DescribeAutoScalingHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoScalingHistoryResponse describeAutoScalingHistory(shared_ptr<DescribeAutoScalingHistoryRequest> request);
  DescribeCacheAnalysisJobResponse describeCacheAnalysisJobWithOptions(shared_ptr<DescribeCacheAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCacheAnalysisJobResponse describeCacheAnalysisJob(shared_ptr<DescribeCacheAnalysisJobRequest> request);
  DescribeCacheAnalysisJobsResponse describeCacheAnalysisJobsWithOptions(shared_ptr<DescribeCacheAnalysisJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCacheAnalysisJobsResponse describeCacheAnalysisJobs(shared_ptr<DescribeCacheAnalysisJobsRequest> request);
  DescribeCloudBenchTasksResponse describeCloudBenchTasksWithOptions(shared_ptr<DescribeCloudBenchTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudBenchTasksResponse describeCloudBenchTasks(shared_ptr<DescribeCloudBenchTasksRequest> request);
  DescribeCloudbenchTaskResponse describeCloudbenchTaskWithOptions(shared_ptr<DescribeCloudbenchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudbenchTaskResponse describeCloudbenchTask(shared_ptr<DescribeCloudbenchTaskRequest> request);
  DescribeCloudbenchTaskConfigResponse describeCloudbenchTaskConfigWithOptions(shared_ptr<DescribeCloudbenchTaskConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudbenchTaskConfigResponse describeCloudbenchTaskConfig(shared_ptr<DescribeCloudbenchTaskConfigRequest> request);
  DescribeDiagnosticReportListResponse describeDiagnosticReportListWithOptions(shared_ptr<DescribeDiagnosticReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnosticReportListResponse describeDiagnosticReportList(shared_ptr<DescribeDiagnosticReportListRequest> request);
  DescribeHotBigKeysResponse describeHotBigKeysWithOptions(shared_ptr<DescribeHotBigKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHotBigKeysResponse describeHotBigKeys(shared_ptr<DescribeHotBigKeysRequest> request);
  DescribeHotKeysResponse describeHotKeysWithOptions(shared_ptr<DescribeHotKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHotKeysResponse describeHotKeys(shared_ptr<DescribeHotKeysRequest> request);
  DescribeInstanceDasProResponse describeInstanceDasProWithOptions(shared_ptr<DescribeInstanceDasProRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceDasProResponse describeInstanceDasPro(shared_ptr<DescribeInstanceDasProRequest> request);
  DescribeSqlLogConfigResponse describeSqlLogConfigWithOptions(shared_ptr<DescribeSqlLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSqlLogConfigResponse describeSqlLogConfig(shared_ptr<DescribeSqlLogConfigRequest> request);
  DescribeSqlLogRecordsResponse describeSqlLogRecordsWithOptions(shared_ptr<DescribeSqlLogRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSqlLogRecordsResponse describeSqlLogRecords(shared_ptr<DescribeSqlLogRecordsRequest> request);
  DescribeSqlLogStatisticResponse describeSqlLogStatisticWithOptions(shared_ptr<DescribeSqlLogStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSqlLogStatisticResponse describeSqlLogStatistic(shared_ptr<DescribeSqlLogStatisticRequest> request);
  DescribeSqlLogTaskResponse describeSqlLogTaskWithOptions(shared_ptr<DescribeSqlLogTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSqlLogTaskResponse describeSqlLogTask(shared_ptr<DescribeSqlLogTaskRequest> request);
  DescribeSqlLogTasksResponse describeSqlLogTasksWithOptions(shared_ptr<DescribeSqlLogTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSqlLogTasksResponse describeSqlLogTasks(shared_ptr<DescribeSqlLogTasksRequest> request);
  DescribeTopBigKeysResponse describeTopBigKeysWithOptions(shared_ptr<DescribeTopBigKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTopBigKeysResponse describeTopBigKeys(shared_ptr<DescribeTopBigKeysRequest> request);
  DescribeTopHotKeysResponse describeTopHotKeysWithOptions(shared_ptr<DescribeTopHotKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTopHotKeysResponse describeTopHotKeys(shared_ptr<DescribeTopHotKeysRequest> request);
  DisableAllSqlConcurrencyControlRulesResponse disableAllSqlConcurrencyControlRulesWithOptions(shared_ptr<DisableAllSqlConcurrencyControlRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableAllSqlConcurrencyControlRulesResponse disableAllSqlConcurrencyControlRules(shared_ptr<DisableAllSqlConcurrencyControlRulesRequest> request);
  DisableAutoResourceOptimizeRulesResponse disableAutoResourceOptimizeRulesWithOptions(shared_ptr<DisableAutoResourceOptimizeRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableAutoResourceOptimizeRulesResponse disableAutoResourceOptimizeRules(shared_ptr<DisableAutoResourceOptimizeRulesRequest> request);
  DisableAutoThrottleRulesResponse disableAutoThrottleRulesWithOptions(shared_ptr<DisableAutoThrottleRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableAutoThrottleRulesResponse disableAutoThrottleRules(shared_ptr<DisableAutoThrottleRulesRequest> request);
  DisableDasProResponse disableDasProWithOptions(shared_ptr<DisableDasProRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDasProResponse disableDasPro(shared_ptr<DisableDasProRequest> request);
  DisableInstanceDasConfigResponse disableInstanceDasConfigWithOptions(shared_ptr<DisableInstanceDasConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableInstanceDasConfigResponse disableInstanceDasConfig(shared_ptr<DisableInstanceDasConfigRequest> request);
  DisableSqlConcurrencyControlResponse disableSqlConcurrencyControlWithOptions(shared_ptr<DisableSqlConcurrencyControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSqlConcurrencyControlResponse disableSqlConcurrencyControl(shared_ptr<DisableSqlConcurrencyControlRequest> request);
  EnableDasProResponse enableDasProWithOptions(shared_ptr<EnableDasProRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDasProResponse enableDasPro(shared_ptr<EnableDasProRequest> request);
  EnableSqlConcurrencyControlResponse enableSqlConcurrencyControlWithOptions(shared_ptr<EnableSqlConcurrencyControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSqlConcurrencyControlResponse enableSqlConcurrencyControl(shared_ptr<EnableSqlConcurrencyControlRequest> request);
  GetAsyncErrorRequestListByCodeResponse getAsyncErrorRequestListByCodeWithOptions(shared_ptr<GetAsyncErrorRequestListByCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAsyncErrorRequestListByCodeResponse getAsyncErrorRequestListByCode(shared_ptr<GetAsyncErrorRequestListByCodeRequest> request);
  GetAsyncErrorRequestStatByCodeResponse getAsyncErrorRequestStatByCodeWithOptions(shared_ptr<GetAsyncErrorRequestStatByCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAsyncErrorRequestStatByCodeResponse getAsyncErrorRequestStatByCode(shared_ptr<GetAsyncErrorRequestStatByCodeRequest> request);
  GetAsyncErrorRequestStatResultResponse getAsyncErrorRequestStatResultWithOptions(shared_ptr<GetAsyncErrorRequestStatResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAsyncErrorRequestStatResultResponse getAsyncErrorRequestStatResult(shared_ptr<GetAsyncErrorRequestStatResultRequest> request);
  GetAutoIncrementUsageStatisticResponse getAutoIncrementUsageStatisticWithOptions(shared_ptr<GetAutoIncrementUsageStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutoIncrementUsageStatisticResponse getAutoIncrementUsageStatistic(shared_ptr<GetAutoIncrementUsageStatisticRequest> request);
  GetAutoResourceOptimizeRulesResponse getAutoResourceOptimizeRulesWithOptions(shared_ptr<GetAutoResourceOptimizeRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutoResourceOptimizeRulesResponse getAutoResourceOptimizeRules(shared_ptr<GetAutoResourceOptimizeRulesRequest> request);
  GetAutoThrottleRulesResponse getAutoThrottleRulesWithOptions(shared_ptr<GetAutoThrottleRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutoThrottleRulesResponse getAutoThrottleRules(shared_ptr<GetAutoThrottleRulesRequest> request);
  GetAutonomousNotifyEventContentResponse getAutonomousNotifyEventContentWithOptions(shared_ptr<GetAutonomousNotifyEventContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutonomousNotifyEventContentResponse getAutonomousNotifyEventContent(shared_ptr<GetAutonomousNotifyEventContentRequest> request);
  GetAutonomousNotifyEventsInRangeResponse getAutonomousNotifyEventsInRangeWithOptions(shared_ptr<GetAutonomousNotifyEventsInRangeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutonomousNotifyEventsInRangeResponse getAutonomousNotifyEventsInRange(shared_ptr<GetAutonomousNotifyEventsInRangeRequest> request);
  GetBlockingDetailListResponse getBlockingDetailListWithOptions(shared_ptr<GetBlockingDetailListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBlockingDetailListResponse getBlockingDetailList(shared_ptr<GetBlockingDetailListRequest> request);
  GetDBInstanceConnectivityDiagnosisResponse getDBInstanceConnectivityDiagnosisWithOptions(shared_ptr<GetDBInstanceConnectivityDiagnosisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDBInstanceConnectivityDiagnosisResponse getDBInstanceConnectivityDiagnosis(shared_ptr<GetDBInstanceConnectivityDiagnosisRequest> request);
  GetDasProServiceUsageResponse getDasProServiceUsageWithOptions(shared_ptr<GetDasProServiceUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDasProServiceUsageResponse getDasProServiceUsage(shared_ptr<GetDasProServiceUsageRequest> request);
  GetDasSQLLogHotDataResponse getDasSQLLogHotDataWithOptions(shared_ptr<GetDasSQLLogHotDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDasSQLLogHotDataResponse getDasSQLLogHotData(shared_ptr<GetDasSQLLogHotDataRequest> request);
  GetDeadLockDetailListResponse getDeadLockDetailListWithOptions(shared_ptr<GetDeadLockDetailListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeadLockDetailListResponse getDeadLockDetailList(shared_ptr<GetDeadLockDetailListRequest> request);
  GetEndpointSwitchTaskResponse getEndpointSwitchTaskWithOptions(shared_ptr<GetEndpointSwitchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEndpointSwitchTaskResponse getEndpointSwitchTask(shared_ptr<GetEndpointSwitchTaskRequest> request);
  GetErrorRequestSampleResponse getErrorRequestSampleWithOptions(shared_ptr<GetErrorRequestSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetErrorRequestSampleResponse getErrorRequestSample(shared_ptr<GetErrorRequestSampleRequest> request);
  GetEventSubscriptionResponse getEventSubscriptionWithOptions(shared_ptr<GetEventSubscriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventSubscriptionResponse getEventSubscription(shared_ptr<GetEventSubscriptionRequest> request);
  GetFullRequestOriginStatByInstanceIdResponse getFullRequestOriginStatByInstanceIdWithOptions(shared_ptr<GetFullRequestOriginStatByInstanceIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFullRequestOriginStatByInstanceIdResponse getFullRequestOriginStatByInstanceId(shared_ptr<GetFullRequestOriginStatByInstanceIdRequest> request);
  GetFullRequestSampleByInstanceIdResponse getFullRequestSampleByInstanceIdWithOptions(shared_ptr<GetFullRequestSampleByInstanceIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFullRequestSampleByInstanceIdResponse getFullRequestSampleByInstanceId(shared_ptr<GetFullRequestSampleByInstanceIdRequest> request);
  GetFullRequestStatResultByInstanceIdResponse getFullRequestStatResultByInstanceIdWithOptions(shared_ptr<GetFullRequestStatResultByInstanceIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFullRequestStatResultByInstanceIdResponse getFullRequestStatResultByInstanceId(shared_ptr<GetFullRequestStatResultByInstanceIdRequest> request);
  GetHDMAliyunResourceSyncResultResponse getHDMAliyunResourceSyncResultWithOptions(shared_ptr<GetHDMAliyunResourceSyncResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHDMAliyunResourceSyncResultResponse getHDMAliyunResourceSyncResult(shared_ptr<GetHDMAliyunResourceSyncResultRequest> request);
  GetHDMLastAliyunResourceSyncResultResponse getHDMLastAliyunResourceSyncResultWithOptions(shared_ptr<GetHDMLastAliyunResourceSyncResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHDMLastAliyunResourceSyncResultResponse getHDMLastAliyunResourceSyncResult(shared_ptr<GetHDMLastAliyunResourceSyncResultRequest> request);
  GetInstanceInspectionsResponse getInstanceInspectionsWithOptions(shared_ptr<GetInstanceInspectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceInspectionsResponse getInstanceInspections(shared_ptr<GetInstanceInspectionsRequest> request);
  GetInstanceMissingIndexListResponse getInstanceMissingIndexListWithOptions(shared_ptr<GetInstanceMissingIndexListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceMissingIndexListResponse getInstanceMissingIndexList(shared_ptr<GetInstanceMissingIndexListRequest> request);
  GetInstanceSqlOptimizeStatisticResponse getInstanceSqlOptimizeStatisticWithOptions(shared_ptr<GetInstanceSqlOptimizeStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceSqlOptimizeStatisticResponse getInstanceSqlOptimizeStatistic(shared_ptr<GetInstanceSqlOptimizeStatisticRequest> request);
  GetKillInstanceSessionTaskResultResponse getKillInstanceSessionTaskResultWithOptions(shared_ptr<GetKillInstanceSessionTaskResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKillInstanceSessionTaskResultResponse getKillInstanceSessionTaskResult(shared_ptr<GetKillInstanceSessionTaskResultRequest> request);
  GetMongoDBCurrentOpResponse getMongoDBCurrentOpWithOptions(shared_ptr<GetMongoDBCurrentOpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMongoDBCurrentOpResponse getMongoDBCurrentOp(shared_ptr<GetMongoDBCurrentOpRequest> request);
  GetMySQLAllSessionAsyncResponse getMySQLAllSessionAsyncWithOptions(shared_ptr<GetMySQLAllSessionAsyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMySQLAllSessionAsyncResponse getMySQLAllSessionAsync(shared_ptr<GetMySQLAllSessionAsyncRequest> request);
  GetPartitionsHeatmapResponse getPartitionsHeatmapWithOptions(shared_ptr<GetPartitionsHeatmapRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPartitionsHeatmapResponse getPartitionsHeatmap(shared_ptr<GetPartitionsHeatmapRequest> request);
  GetPfsMetricTrendsResponse getPfsMetricTrendsWithOptions(shared_ptr<GetPfsMetricTrendsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPfsMetricTrendsResponse getPfsMetricTrends(shared_ptr<GetPfsMetricTrendsRequest> request);
  GetPfsSqlSampleResponse getPfsSqlSampleWithOptions(shared_ptr<GetPfsSqlSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPfsSqlSampleResponse getPfsSqlSample(shared_ptr<GetPfsSqlSampleRequest> request);
  GetPfsSqlSummariesResponse getPfsSqlSummariesWithOptions(shared_ptr<GetPfsSqlSummariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPfsSqlSummariesResponse getPfsSqlSummaries(shared_ptr<GetPfsSqlSummariesRequest> request);
  GetQueryOptimizeDataStatsResponse getQueryOptimizeDataStatsWithOptions(shared_ptr<GetQueryOptimizeDataStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeDataStatsResponse getQueryOptimizeDataStats(shared_ptr<GetQueryOptimizeDataStatsRequest> request);
  GetQueryOptimizeDataTopResponse getQueryOptimizeDataTopWithOptions(shared_ptr<GetQueryOptimizeDataTopRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeDataTopResponse getQueryOptimizeDataTop(shared_ptr<GetQueryOptimizeDataTopRequest> request);
  GetQueryOptimizeDataTrendResponse getQueryOptimizeDataTrendWithOptions(shared_ptr<GetQueryOptimizeDataTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeDataTrendResponse getQueryOptimizeDataTrend(shared_ptr<GetQueryOptimizeDataTrendRequest> request);
  GetQueryOptimizeExecErrorSampleResponse getQueryOptimizeExecErrorSampleWithOptions(shared_ptr<GetQueryOptimizeExecErrorSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeExecErrorSampleResponse getQueryOptimizeExecErrorSample(shared_ptr<GetQueryOptimizeExecErrorSampleRequest> request);
  GetQueryOptimizeExecErrorStatsResponse getQueryOptimizeExecErrorStatsWithOptions(shared_ptr<GetQueryOptimizeExecErrorStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeExecErrorStatsResponse getQueryOptimizeExecErrorStats(shared_ptr<GetQueryOptimizeExecErrorStatsRequest> request);
  GetQueryOptimizeRuleListResponse getQueryOptimizeRuleListWithOptions(shared_ptr<GetQueryOptimizeRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeRuleListResponse getQueryOptimizeRuleList(shared_ptr<GetQueryOptimizeRuleListRequest> request);
  GetQueryOptimizeShareUrlResponse getQueryOptimizeShareUrlWithOptions(shared_ptr<GetQueryOptimizeShareUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeShareUrlResponse getQueryOptimizeShareUrl(shared_ptr<GetQueryOptimizeShareUrlRequest> request);
  GetQueryOptimizeSolutionResponse getQueryOptimizeSolutionWithOptions(shared_ptr<GetQueryOptimizeSolutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeSolutionResponse getQueryOptimizeSolution(shared_ptr<GetQueryOptimizeSolutionRequest> request);
  GetQueryOptimizeTagResponse getQueryOptimizeTagWithOptions(shared_ptr<GetQueryOptimizeTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueryOptimizeTagResponse getQueryOptimizeTag(shared_ptr<GetQueryOptimizeTagRequest> request);
  GetRedisAllSessionResponse getRedisAllSessionWithOptions(shared_ptr<GetRedisAllSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRedisAllSessionResponse getRedisAllSession(shared_ptr<GetRedisAllSessionRequest> request);
  GetRequestDiagnosisPageResponse getRequestDiagnosisPageWithOptions(shared_ptr<GetRequestDiagnosisPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRequestDiagnosisPageResponse getRequestDiagnosisPage(shared_ptr<GetRequestDiagnosisPageRequest> request);
  GetRequestDiagnosisResultResponse getRequestDiagnosisResultWithOptions(shared_ptr<GetRequestDiagnosisResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRequestDiagnosisResultResponse getRequestDiagnosisResult(shared_ptr<GetRequestDiagnosisResultRequest> request);
  GetRunningSqlConcurrencyControlRulesResponse getRunningSqlConcurrencyControlRulesWithOptions(shared_ptr<GetRunningSqlConcurrencyControlRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRunningSqlConcurrencyControlRulesResponse getRunningSqlConcurrencyControlRules(shared_ptr<GetRunningSqlConcurrencyControlRulesRequest> request);
  GetSqlConcurrencyControlKeywordsFromSqlTextResponse getSqlConcurrencyControlKeywordsFromSqlTextWithOptions(shared_ptr<GetSqlConcurrencyControlKeywordsFromSqlTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSqlConcurrencyControlKeywordsFromSqlTextResponse getSqlConcurrencyControlKeywordsFromSqlText(shared_ptr<GetSqlConcurrencyControlKeywordsFromSqlTextRequest> request);
  GetSqlConcurrencyControlRulesHistoryResponse getSqlConcurrencyControlRulesHistoryWithOptions(shared_ptr<GetSqlConcurrencyControlRulesHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSqlConcurrencyControlRulesHistoryResponse getSqlConcurrencyControlRulesHistory(shared_ptr<GetSqlConcurrencyControlRulesHistoryRequest> request);
  GetSqlOptimizeAdviceResponse getSqlOptimizeAdviceWithOptions(shared_ptr<GetSqlOptimizeAdviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSqlOptimizeAdviceResponse getSqlOptimizeAdvice(shared_ptr<GetSqlOptimizeAdviceRequest> request);
  GetStorageAnalysisResultResponse getStorageAnalysisResultWithOptions(shared_ptr<GetStorageAnalysisResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStorageAnalysisResultResponse getStorageAnalysisResult(shared_ptr<GetStorageAnalysisResultRequest> request);
  KillInstanceAllSessionResponse killInstanceAllSessionWithOptions(shared_ptr<KillInstanceAllSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KillInstanceAllSessionResponse killInstanceAllSession(shared_ptr<KillInstanceAllSessionRequest> request);
  ModifyAutoScalingConfigResponse modifyAutoScalingConfigWithOptions(shared_ptr<ModifyAutoScalingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoScalingConfigResponse modifyAutoScalingConfig(shared_ptr<ModifyAutoScalingConfigRequest> request);
  ModifySqlLogConfigResponse modifySqlLogConfigWithOptions(shared_ptr<ModifySqlLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySqlLogConfigResponse modifySqlLogConfig(shared_ptr<ModifySqlLogConfigRequest> request);
  RunCloudBenchTaskResponse runCloudBenchTaskWithOptions(shared_ptr<RunCloudBenchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCloudBenchTaskResponse runCloudBenchTask(shared_ptr<RunCloudBenchTaskRequest> request);
  SetEventSubscriptionResponse setEventSubscriptionWithOptions(shared_ptr<SetEventSubscriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEventSubscriptionResponse setEventSubscription(shared_ptr<SetEventSubscriptionRequest> request);
  StopCloudBenchTaskResponse stopCloudBenchTaskWithOptions(shared_ptr<StopCloudBenchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCloudBenchTaskResponse stopCloudBenchTask(shared_ptr<StopCloudBenchTaskRequest> request);
  SyncHDMAliyunResourceResponse syncHDMAliyunResourceWithOptions(shared_ptr<SyncHDMAliyunResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncHDMAliyunResourceResponse syncHDMAliyunResource(shared_ptr<SyncHDMAliyunResourceRequest> request);
  UpdateAutoResourceOptimizeRulesAsyncResponse updateAutoResourceOptimizeRulesAsyncWithOptions(shared_ptr<UpdateAutoResourceOptimizeRulesAsyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAutoResourceOptimizeRulesAsyncResponse updateAutoResourceOptimizeRulesAsync(shared_ptr<UpdateAutoResourceOptimizeRulesAsyncRequest> request);
  UpdateAutoSqlOptimizeStatusResponse updateAutoSqlOptimizeStatusWithOptions(shared_ptr<UpdateAutoSqlOptimizeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAutoSqlOptimizeStatusResponse updateAutoSqlOptimizeStatus(shared_ptr<UpdateAutoSqlOptimizeStatusRequest> request);
  UpdateAutoThrottleRulesAsyncResponse updateAutoThrottleRulesAsyncWithOptions(shared_ptr<UpdateAutoThrottleRulesAsyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAutoThrottleRulesAsyncResponse updateAutoThrottleRulesAsync(shared_ptr<UpdateAutoThrottleRulesAsyncRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_DAS20200116

#endif
