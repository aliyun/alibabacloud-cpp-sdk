// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CMN20200825_H_
#define ALIBABACLOUD_CMN20200825_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Cmn20200825 {
class Agent : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> agentVersion{};
  shared_ptr<string> cpuUsage{};
  shared_ptr<string> diskUsage{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> ip{};
  shared_ptr<string> kernelVersion{};
  shared_ptr<string> memoryUsage{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> status{};

  Agent() {}

  explicit Agent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (agentVersion) {
      res["AgentVersion"] = boost::any(*agentVersion);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (diskUsage) {
      res["DiskUsage"] = boost::any(*diskUsage);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (kernelVersion) {
      res["KernelVersion"] = boost::any(*kernelVersion);
    }
    if (memoryUsage) {
      res["MemoryUsage"] = boost::any(*memoryUsage);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("AgentVersion") != m.end() && !m["AgentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["AgentVersion"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<string>(boost::any_cast<string>(m["CpuUsage"]));
    }
    if (m.find("DiskUsage") != m.end() && !m["DiskUsage"].empty()) {
      diskUsage = make_shared<string>(boost::any_cast<string>(m["DiskUsage"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("KernelVersion") != m.end() && !m["KernelVersion"].empty()) {
      kernelVersion = make_shared<string>(boost::any_cast<string>(m["KernelVersion"]));
    }
    if (m.find("MemoryUsage") != m.end() && !m["MemoryUsage"].empty()) {
      memoryUsage = make_shared<string>(boost::any_cast<string>(m["MemoryUsage"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~Agent() = default;
};
class AgentsTask : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<string> agentType{};
  shared_ptr<string> agentsTaskId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> params{};
  shared_ptr<string> status{};

  AgentsTask() {}

  explicit AgentsTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (agentsTaskId) {
      res["AgentsTaskId"] = boost::any(*agentsTaskId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("AgentsTaskId") != m.end() && !m["AgentsTaskId"].empty()) {
      agentsTaskId = make_shared<string>(boost::any_cast<string>(m["AgentsTaskId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~AgentsTask() = default;
};
class AggregateData : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataDescription{};
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> aggregateDataName{};
  shared_ptr<vector<string>> aggregateModeList{};
  shared_ptr<string> dataItem{};
  shared_ptr<vector<string>> deviceIdList{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> isAllDevice{};
  shared_ptr<string> monitorItemId{};

  AggregateData() {}

  explicit AggregateData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataDescription) {
      res["AggregateDataDescription"] = boost::any(*aggregateDataDescription);
    }
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (aggregateDataName) {
      res["AggregateDataName"] = boost::any(*aggregateDataName);
    }
    if (aggregateModeList) {
      res["AggregateModeList"] = boost::any(*aggregateModeList);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (deviceIdList) {
      res["DeviceIdList"] = boost::any(*deviceIdList);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (isAllDevice) {
      res["IsAllDevice"] = boost::any(*isAllDevice);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataDescription") != m.end() && !m["AggregateDataDescription"].empty()) {
      aggregateDataDescription = make_shared<string>(boost::any_cast<string>(m["AggregateDataDescription"]));
    }
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AggregateDataName") != m.end() && !m["AggregateDataName"].empty()) {
      aggregateDataName = make_shared<string>(boost::any_cast<string>(m["AggregateDataName"]));
    }
    if (m.find("AggregateModeList") != m.end() && !m["AggregateModeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AggregateModeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AggregateModeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aggregateModeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DeviceIdList") != m.end() && !m["DeviceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IsAllDevice") != m.end() && !m["IsAllDevice"].empty()) {
      isAllDevice = make_shared<long>(boost::any_cast<long>(m["IsAllDevice"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
  }


  virtual ~AggregateData() = default;
};
class AlarmOverviewConditionList : public Darabonba::Model {
public:
  shared_ptr<string> conditionName{};
  shared_ptr<string> conditionValue{};

  AlarmOverviewConditionList() {}

  explicit AlarmOverviewConditionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionName) {
      res["ConditionName"] = boost::any(*conditionName);
    }
    if (conditionValue) {
      res["ConditionValue"] = boost::any(*conditionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionName") != m.end() && !m["ConditionName"].empty()) {
      conditionName = make_shared<string>(boost::any_cast<string>(m["ConditionName"]));
    }
    if (m.find("ConditionValue") != m.end() && !m["ConditionValue"].empty()) {
      conditionValue = make_shared<string>(boost::any_cast<string>(m["ConditionValue"]));
    }
  }


  virtual ~AlarmOverviewConditionList() = default;
};
class AlarmOverview : public Darabonba::Model {
public:
  shared_ptr<string> alarmOverviewId{};
  shared_ptr<string> alarmOverviewName{};
  shared_ptr<vector<AlarmOverviewConditionList>> conditionList{};
  shared_ptr<long> serialNumber{};

  AlarmOverview() {}

  explicit AlarmOverview(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmOverviewId) {
      res["AlarmOverviewId"] = boost::any(*alarmOverviewId);
    }
    if (alarmOverviewName) {
      res["AlarmOverviewName"] = boost::any(*alarmOverviewName);
    }
    if (conditionList) {
      vector<boost::any> temp1;
      for(auto item1:*conditionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionList"] = boost::any(temp1);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmOverviewId") != m.end() && !m["AlarmOverviewId"].empty()) {
      alarmOverviewId = make_shared<string>(boost::any_cast<string>(m["AlarmOverviewId"]));
    }
    if (m.find("AlarmOverviewName") != m.end() && !m["AlarmOverviewName"].empty()) {
      alarmOverviewName = make_shared<string>(boost::any_cast<string>(m["AlarmOverviewName"]));
    }
    if (m.find("ConditionList") != m.end() && !m["ConditionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionList"].type()) {
        vector<AlarmOverviewConditionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AlarmOverviewConditionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionList = make_shared<vector<AlarmOverviewConditionList>>(expect1);
      }
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
  }


  virtual ~AlarmOverview() = default;
};
class AtomicStepInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  AtomicStepInput() {}

  explicit AtomicStepInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AtomicStepInput() = default;
};
class AtomicStepOutput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  AtomicStepOutput() {}

  explicit AtomicStepOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AtomicStepOutput() = default;
};
class AtomicStep : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<AtomicStepInput>> input{};
  shared_ptr<vector<AtomicStepOutput>> output{};
  shared_ptr<string> stepId{};
  shared_ptr<string> stepName{};
  shared_ptr<string> stepType{};

  AtomicStep() {}

  explicit AtomicStep(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      vector<boost::any> temp1;
      for(auto item1:*input){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Input"] = boost::any(temp1);
    }
    if (output) {
      vector<boost::any> temp1;
      for(auto item1:*output){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Output"] = boost::any(temp1);
    }
    if (stepId) {
      res["StepId"] = boost::any(*stepId);
    }
    if (stepName) {
      res["StepName"] = boost::any(*stepName);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(vector<boost::any>) == m["Input"].type()) {
        vector<AtomicStepInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Input"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AtomicStepInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        input = make_shared<vector<AtomicStepInput>>(expect1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(vector<boost::any>) == m["Output"].type()) {
        vector<AtomicStepOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Output"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AtomicStepOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        output = make_shared<vector<AtomicStepOutput>>(expect1);
      }
    }
    if (m.find("StepId") != m.end() && !m["StepId"].empty()) {
      stepId = make_shared<string>(boost::any_cast<string>(m["StepId"]));
    }
    if (m.find("StepName") != m.end() && !m["StepName"].empty()) {
      stepName = make_shared<string>(boost::any_cast<string>(m["StepName"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
  }


  virtual ~AtomicStep() = default;
};
class BusinessType : public Darabonba::Model {
public:
  shared_ptr<string> abbr{};
  shared_ptr<string> actionFlag{};
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> direction{};
  shared_ptr<long> gateway{};
  shared_ptr<string> leaseTime{};
  shared_ptr<string> mask{};
  shared_ptr<string> name{};
  shared_ptr<long> reserveNumber{};
  shared_ptr<string> sharing{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vlan{};
  shared_ptr<string> zoneType{};

  BusinessType() {}

  explicit BusinessType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbr) {
      res["Abbr"] = boost::any(*abbr);
    }
    if (actionFlag) {
      res["ActionFlag"] = boost::any(*actionFlag);
    }
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (leaseTime) {
      res["LeaseTime"] = boost::any(*leaseTime);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reserveNumber) {
      res["ReserveNumber"] = boost::any(*reserveNumber);
    }
    if (sharing) {
      res["Sharing"] = boost::any(*sharing);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    if (zoneType) {
      res["ZoneType"] = boost::any(*zoneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbr") != m.end() && !m["Abbr"].empty()) {
      abbr = make_shared<string>(boost::any_cast<string>(m["Abbr"]));
    }
    if (m.find("ActionFlag") != m.end() && !m["ActionFlag"].empty()) {
      actionFlag = make_shared<string>(boost::any_cast<string>(m["ActionFlag"]));
    }
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<long>(boost::any_cast<long>(m["Direction"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<long>(boost::any_cast<long>(m["Gateway"]));
    }
    if (m.find("LeaseTime") != m.end() && !m["LeaseTime"].empty()) {
      leaseTime = make_shared<string>(boost::any_cast<string>(m["LeaseTime"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReserveNumber") != m.end() && !m["ReserveNumber"].empty()) {
      reserveNumber = make_shared<long>(boost::any_cast<long>(m["ReserveNumber"]));
    }
    if (m.find("Sharing") != m.end() && !m["Sharing"].empty()) {
      sharing = make_shared<string>(boost::any_cast<string>(m["Sharing"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
    if (m.find("ZoneType") != m.end() && !m["ZoneType"].empty()) {
      zoneType = make_shared<string>(boost::any_cast<string>(m["ZoneType"]));
    }
  }


  virtual ~BusinessType() = default;
};
class CliTask : public Darabonba::Model {
public:
  shared_ptr<string> agentIp{};
  shared_ptr<string> cliTaskId{};
  shared_ptr<string> command{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> output{};
  shared_ptr<string> protocol{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> status{};
  shared_ptr<long> timeout{};

  CliTask() {}

  explicit CliTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIp) {
      res["AgentIp"] = boost::any(*agentIp);
    }
    if (cliTaskId) {
      res["CliTaskId"] = boost::any(*cliTaskId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIp") != m.end() && !m["AgentIp"].empty()) {
      agentIp = make_shared<string>(boost::any_cast<string>(m["AgentIp"]));
    }
    if (m.find("CliTaskId") != m.end() && !m["CliTaskId"].empty()) {
      cliTaskId = make_shared<string>(boost::any_cast<string>(m["CliTaskId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CliTask() = default;
};
class ConfigurationSpecification : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> model{};
  shared_ptr<vector<string>> relatedVariate{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendor{};

  ConfigurationSpecification() {}

  explicit ConfigurationSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariate) {
      res["RelatedVariate"] = boost::any(*relatedVariate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedVariate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedVariate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedVariate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ConfigurationSpecification() = default;
};
class ConfigurationVariate : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> formatFunction{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variateName{};

  ConfigurationVariate() {}

  explicit ConfigurationVariate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (formatFunction) {
      res["FormatFunction"] = boost::any(*formatFunction);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FormatFunction") != m.end() && !m["FormatFunction"].empty()) {
      formatFunction = make_shared<string>(boost::any_cast<string>(m["FormatFunction"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~ConfigurationVariate() = default;
};
class ConnectionPolicy : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> connectionPolicyId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> downlinkDeviceId{};
  shared_ptr<string> downlinkModuleId{};
  shared_ptr<string> id{};
  shared_ptr<long> linkCount{};
  shared_ptr<string> name{};
  shared_ptr<string> networkArchitectureIterationId{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uplinkDeviceId{};
  shared_ptr<string> uplinkModelId{};

  ConnectionPolicy() {}

  explicit ConnectionPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (connectionPolicyId) {
      res["ConnectionPolicyId"] = boost::any(*connectionPolicyId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downlinkDeviceId) {
      res["DownlinkDeviceId"] = boost::any(*downlinkDeviceId);
    }
    if (downlinkModuleId) {
      res["DownlinkModuleId"] = boost::any(*downlinkModuleId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkCount) {
      res["LinkCount"] = boost::any(*linkCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkArchitectureIterationId) {
      res["NetworkArchitectureIterationId"] = boost::any(*networkArchitectureIterationId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uplinkDeviceId) {
      res["UplinkDeviceId"] = boost::any(*uplinkDeviceId);
    }
    if (uplinkModelId) {
      res["UplinkModelId"] = boost::any(*uplinkModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("ConnectionPolicyId") != m.end() && !m["ConnectionPolicyId"].empty()) {
      connectionPolicyId = make_shared<string>(boost::any_cast<string>(m["ConnectionPolicyId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DownlinkDeviceId") != m.end() && !m["DownlinkDeviceId"].empty()) {
      downlinkDeviceId = make_shared<string>(boost::any_cast<string>(m["DownlinkDeviceId"]));
    }
    if (m.find("DownlinkModuleId") != m.end() && !m["DownlinkModuleId"].empty()) {
      downlinkModuleId = make_shared<string>(boost::any_cast<string>(m["DownlinkModuleId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkCount") != m.end() && !m["LinkCount"].empty()) {
      linkCount = make_shared<long>(boost::any_cast<long>(m["LinkCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkArchitectureIterationId") != m.end() && !m["NetworkArchitectureIterationId"].empty()) {
      networkArchitectureIterationId = make_shared<string>(boost::any_cast<string>(m["NetworkArchitectureIterationId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UplinkDeviceId") != m.end() && !m["UplinkDeviceId"].empty()) {
      uplinkDeviceId = make_shared<string>(boost::any_cast<string>(m["UplinkDeviceId"]));
    }
    if (m.find("UplinkModelId") != m.end() && !m["UplinkModelId"].empty()) {
      uplinkModelId = make_shared<string>(boost::any_cast<string>(m["UplinkModelId"]));
    }
  }


  virtual ~ConnectionPolicy() = default;
};
class DataViewChart : public Darabonba::Model {
public:
  shared_ptr<string> chartType{};
  shared_ptr<string> dataViewId{};
  shared_ptr<string> dataViewSource{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> grid{};

  DataViewChart() {}

  explicit DataViewChart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chartType) {
      res["ChartType"] = boost::any(*chartType);
    }
    if (dataViewId) {
      res["DataViewId"] = boost::any(*dataViewId);
    }
    if (dataViewSource) {
      res["DataViewSource"] = boost::any(*dataViewSource);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (grid) {
      res["Grid"] = boost::any(*grid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChartType") != m.end() && !m["ChartType"].empty()) {
      chartType = make_shared<string>(boost::any_cast<string>(m["ChartType"]));
    }
    if (m.find("DataViewId") != m.end() && !m["DataViewId"].empty()) {
      dataViewId = make_shared<string>(boost::any_cast<string>(m["DataViewId"]));
    }
    if (m.find("DataViewSource") != m.end() && !m["DataViewSource"].empty()) {
      dataViewSource = make_shared<string>(boost::any_cast<string>(m["DataViewSource"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Grid") != m.end() && !m["Grid"].empty()) {
      grid = make_shared<string>(boost::any_cast<string>(m["Grid"]));
    }
  }


  virtual ~DataViewChart() = default;
};
class DataView : public Darabonba::Model {
public:
  shared_ptr<vector<DataViewChart>> dataViewChartList{};
  shared_ptr<string> dataViewDescription{};
  shared_ptr<string> dataViewId{};
  shared_ptr<string> dataViewName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  DataView() {}

  explicit DataView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataViewChartList) {
      vector<boost::any> temp1;
      for(auto item1:*dataViewChartList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataViewChartList"] = boost::any(temp1);
    }
    if (dataViewDescription) {
      res["DataViewDescription"] = boost::any(*dataViewDescription);
    }
    if (dataViewId) {
      res["DataViewId"] = boost::any(*dataViewId);
    }
    if (dataViewName) {
      res["DataViewName"] = boost::any(*dataViewName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataViewChartList") != m.end() && !m["DataViewChartList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataViewChartList"].type()) {
        vector<DataViewChart> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataViewChartList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataViewChart model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataViewChartList = make_shared<vector<DataViewChart>>(expect1);
      }
    }
    if (m.find("DataViewDescription") != m.end() && !m["DataViewDescription"].empty()) {
      dataViewDescription = make_shared<string>(boost::any_cast<string>(m["DataViewDescription"]));
    }
    if (m.find("DataViewId") != m.end() && !m["DataViewId"].empty()) {
      dataViewId = make_shared<string>(boost::any_cast<string>(m["DataViewId"]));
    }
    if (m.find("DataViewName") != m.end() && !m["DataViewName"].empty()) {
      dataViewName = make_shared<string>(boost::any_cast<string>(m["DataViewName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~DataView() = default;
};
class DedicatedLine : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> isp{};
  shared_ptr<string> lineGateway{};
  shared_ptr<string> lineId{};
  shared_ptr<string> lineIp{};
  shared_ptr<string> lineRole{};

  DedicatedLine() {}

  explicit DedicatedLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (lineGateway) {
      res["LineGateway"] = boost::any(*lineGateway);
    }
    if (lineId) {
      res["LineId"] = boost::any(*lineId);
    }
    if (lineIp) {
      res["LineIp"] = boost::any(*lineIp);
    }
    if (lineRole) {
      res["LineRole"] = boost::any(*lineRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("LineGateway") != m.end() && !m["LineGateway"].empty()) {
      lineGateway = make_shared<string>(boost::any_cast<string>(m["LineGateway"]));
    }
    if (m.find("LineId") != m.end() && !m["LineId"].empty()) {
      lineId = make_shared<string>(boost::any_cast<string>(m["LineId"]));
    }
    if (m.find("LineIp") != m.end() && !m["LineIp"].empty()) {
      lineIp = make_shared<string>(boost::any_cast<string>(m["LineIp"]));
    }
    if (m.find("LineRole") != m.end() && !m["LineRole"].empty()) {
      lineRole = make_shared<string>(boost::any_cast<string>(m["LineRole"]));
    }
  }


  virtual ~DedicatedLine() = default;
};
class Device : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> accountVersion{};
  shared_ptr<string> authPassPhrase{};
  shared_ptr<string> authProtocol{};
  shared_ptr<string> community{};
  shared_ptr<string> deviceForm{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceIp{};
  shared_ptr<string> deviceMac{};
  shared_ptr<string> deviceSn{};
  shared_ptr<string> hostname{};
  shared_ptr<string> model{};
  shared_ptr<string> privacyPassPhrase{};
  shared_ptr<string> privacyProtocol{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> securityLevel{};
  shared_ptr<string> space{};
  shared_ptr<string> sshAccount{};
  shared_ptr<string> sshPassword{};
  shared_ptr<string> status{};
  shared_ptr<string> telnetAccount{};
  shared_ptr<string> telnetPassword{};
  shared_ptr<string> userName{};
  shared_ptr<string> vendor{};

  Device() {}

  explicit Device(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accountVersion) {
      res["AccountVersion"] = boost::any(*accountVersion);
    }
    if (authPassPhrase) {
      res["AuthPassPhrase"] = boost::any(*authPassPhrase);
    }
    if (authProtocol) {
      res["AuthProtocol"] = boost::any(*authProtocol);
    }
    if (community) {
      res["Community"] = boost::any(*community);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceIp) {
      res["DeviceIp"] = boost::any(*deviceIp);
    }
    if (deviceMac) {
      res["DeviceMac"] = boost::any(*deviceMac);
    }
    if (deviceSn) {
      res["DeviceSn"] = boost::any(*deviceSn);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (privacyPassPhrase) {
      res["PrivacyPassPhrase"] = boost::any(*privacyPassPhrase);
    }
    if (privacyProtocol) {
      res["PrivacyProtocol"] = boost::any(*privacyProtocol);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (sshAccount) {
      res["SshAccount"] = boost::any(*sshAccount);
    }
    if (sshPassword) {
      res["SshPassword"] = boost::any(*sshPassword);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (telnetAccount) {
      res["TelnetAccount"] = boost::any(*telnetAccount);
    }
    if (telnetPassword) {
      res["TelnetPassword"] = boost::any(*telnetPassword);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("AccountVersion") != m.end() && !m["AccountVersion"].empty()) {
      accountVersion = make_shared<string>(boost::any_cast<string>(m["AccountVersion"]));
    }
    if (m.find("AuthPassPhrase") != m.end() && !m["AuthPassPhrase"].empty()) {
      authPassPhrase = make_shared<string>(boost::any_cast<string>(m["AuthPassPhrase"]));
    }
    if (m.find("AuthProtocol") != m.end() && !m["AuthProtocol"].empty()) {
      authProtocol = make_shared<string>(boost::any_cast<string>(m["AuthProtocol"]));
    }
    if (m.find("Community") != m.end() && !m["Community"].empty()) {
      community = make_shared<string>(boost::any_cast<string>(m["Community"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceIp") != m.end() && !m["DeviceIp"].empty()) {
      deviceIp = make_shared<string>(boost::any_cast<string>(m["DeviceIp"]));
    }
    if (m.find("DeviceMac") != m.end() && !m["DeviceMac"].empty()) {
      deviceMac = make_shared<string>(boost::any_cast<string>(m["DeviceMac"]));
    }
    if (m.find("DeviceSn") != m.end() && !m["DeviceSn"].empty()) {
      deviceSn = make_shared<string>(boost::any_cast<string>(m["DeviceSn"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PrivacyPassPhrase") != m.end() && !m["PrivacyPassPhrase"].empty()) {
      privacyPassPhrase = make_shared<string>(boost::any_cast<string>(m["PrivacyPassPhrase"]));
    }
    if (m.find("PrivacyProtocol") != m.end() && !m["PrivacyProtocol"].empty()) {
      privacyProtocol = make_shared<string>(boost::any_cast<string>(m["PrivacyProtocol"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("SshAccount") != m.end() && !m["SshAccount"].empty()) {
      sshAccount = make_shared<string>(boost::any_cast<string>(m["SshAccount"]));
    }
    if (m.find("SshPassword") != m.end() && !m["SshPassword"].empty()) {
      sshPassword = make_shared<string>(boost::any_cast<string>(m["SshPassword"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TelnetAccount") != m.end() && !m["TelnetAccount"].empty()) {
      telnetAccount = make_shared<string>(boost::any_cast<string>(m["TelnetAccount"]));
    }
    if (m.find("TelnetPassword") != m.end() && !m["TelnetPassword"].empty()) {
      telnetPassword = make_shared<string>(boost::any_cast<string>(m["TelnetPassword"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~Device() = default;
};
class DeviceFormProperty : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> keyword{};
  shared_ptr<bool> placeholder{};
  shared_ptr<bool> required{};
  shared_ptr<bool> searchSupported{};
  shared_ptr<long> sequence{};
  shared_ptr<bool> tableVisible{};
  shared_ptr<bool> uniqueness{};
  shared_ptr<string> valueReference{};
  shared_ptr<string> valueSource{};
  shared_ptr<string> valueType{};

  DeviceFormProperty() {}

  explicit DeviceFormProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (placeholder) {
      res["Placeholder"] = boost::any(*placeholder);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (searchSupported) {
      res["SearchSupported"] = boost::any(*searchSupported);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (tableVisible) {
      res["TableVisible"] = boost::any(*tableVisible);
    }
    if (uniqueness) {
      res["Uniqueness"] = boost::any(*uniqueness);
    }
    if (valueReference) {
      res["ValueReference"] = boost::any(*valueReference);
    }
    if (valueSource) {
      res["ValueSource"] = boost::any(*valueSource);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Placeholder") != m.end() && !m["Placeholder"].empty()) {
      placeholder = make_shared<bool>(boost::any_cast<bool>(m["Placeholder"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("SearchSupported") != m.end() && !m["SearchSupported"].empty()) {
      searchSupported = make_shared<bool>(boost::any_cast<bool>(m["SearchSupported"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("TableVisible") != m.end() && !m["TableVisible"].empty()) {
      tableVisible = make_shared<bool>(boost::any_cast<bool>(m["TableVisible"]));
    }
    if (m.find("Uniqueness") != m.end() && !m["Uniqueness"].empty()) {
      uniqueness = make_shared<bool>(boost::any_cast<bool>(m["Uniqueness"]));
    }
    if (m.find("ValueReference") != m.end() && !m["ValueReference"].empty()) {
      valueReference = make_shared<string>(boost::any_cast<string>(m["ValueReference"]));
    }
    if (m.find("ValueSource") != m.end() && !m["ValueSource"].empty()) {
      valueSource = make_shared<string>(boost::any_cast<string>(m["ValueSource"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~DeviceFormProperty() = default;
};
class DeviceForm : public Darabonba::Model {
public:
  shared_ptr<string> accountConfig{};
  shared_ptr<string> configCompare{};
  shared_ptr<string> formId{};
  shared_ptr<string> formName{};
  shared_ptr<vector<DeviceFormProperty>> propertiesList{};

  DeviceForm() {}

  explicit DeviceForm(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (formId) {
      res["FormId"] = boost::any(*formId);
    }
    if (formName) {
      res["FormName"] = boost::any(*formName);
    }
    if (propertiesList) {
      vector<boost::any> temp1;
      for(auto item1:*propertiesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertiesList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<string>(boost::any_cast<string>(m["AccountConfig"]));
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<string>(boost::any_cast<string>(m["ConfigCompare"]));
    }
    if (m.find("FormId") != m.end() && !m["FormId"].empty()) {
      formId = make_shared<string>(boost::any_cast<string>(m["FormId"]));
    }
    if (m.find("FormName") != m.end() && !m["FormName"].empty()) {
      formName = make_shared<string>(boost::any_cast<string>(m["FormName"]));
    }
    if (m.find("PropertiesList") != m.end() && !m["PropertiesList"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertiesList"].type()) {
        vector<DeviceFormProperty> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertiesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeviceFormProperty model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertiesList = make_shared<vector<DeviceFormProperty>>(expect1);
      }
    }
  }


  virtual ~DeviceForm() = default;
};
class DeviceProperty : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> deviceForm{};
  shared_ptr<string> format{};
  shared_ptr<string> nameCn{};
  shared_ptr<string> nameEn{};
  shared_ptr<string> propertyId{};

  DeviceProperty() {}

  explicit DeviceProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (nameCn) {
      res["NameCn"] = boost::any(*nameCn);
    }
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (propertyId) {
      res["PropertyId"] = boost::any(*propertyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("NameCn") != m.end() && !m["NameCn"].empty()) {
      nameCn = make_shared<string>(boost::any_cast<string>(m["NameCn"]));
    }
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("PropertyId") != m.end() && !m["PropertyId"].empty()) {
      propertyId = make_shared<string>(boost::any_cast<string>(m["PropertyId"]));
    }
  }


  virtual ~DeviceProperty() = default;
};
class DeviceResourceDeviceResource : public Darabonba::Model {
public:
  shared_ptr<string> blockNumber{};
  shared_ptr<string> business{};
  shared_ptr<string> config{};
  shared_ptr<bool> configGenerate{};
  shared_ptr<string> configTaskStatus{};
  shared_ptr<string> deliveryIp{};
  shared_ptr<string> deviceNumber{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> interConnection{};
  shared_ptr<string> location{};
  shared_ptr<string> loopback{};
  shared_ptr<string> managerIp{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> sn{};
  shared_ptr<bool> stack{};
  shared_ptr<string> vendor{};

  DeviceResourceDeviceResource() {}

  explicit DeviceResourceDeviceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockNumber) {
      res["BlockNumber"] = boost::any(*blockNumber);
    }
    if (business) {
      res["Business"] = boost::any(*business);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (configGenerate) {
      res["ConfigGenerate"] = boost::any(*configGenerate);
    }
    if (configTaskStatus) {
      res["ConfigTaskStatus"] = boost::any(*configTaskStatus);
    }
    if (deliveryIp) {
      res["DeliveryIp"] = boost::any(*deliveryIp);
    }
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (interConnection) {
      res["InterConnection"] = boost::any(*interConnection);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (loopback) {
      res["Loopback"] = boost::any(*loopback);
    }
    if (managerIp) {
      res["ManagerIp"] = boost::any(*managerIp);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (stack) {
      res["Stack"] = boost::any(*stack);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockNumber") != m.end() && !m["BlockNumber"].empty()) {
      blockNumber = make_shared<string>(boost::any_cast<string>(m["BlockNumber"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      business = make_shared<string>(boost::any_cast<string>(m["Business"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ConfigGenerate") != m.end() && !m["ConfigGenerate"].empty()) {
      configGenerate = make_shared<bool>(boost::any_cast<bool>(m["ConfigGenerate"]));
    }
    if (m.find("ConfigTaskStatus") != m.end() && !m["ConfigTaskStatus"].empty()) {
      configTaskStatus = make_shared<string>(boost::any_cast<string>(m["ConfigTaskStatus"]));
    }
    if (m.find("DeliveryIp") != m.end() && !m["DeliveryIp"].empty()) {
      deliveryIp = make_shared<string>(boost::any_cast<string>(m["DeliveryIp"]));
    }
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<string>(boost::any_cast<string>(m["DeviceNumber"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InterConnection") != m.end() && !m["InterConnection"].empty()) {
      interConnection = make_shared<string>(boost::any_cast<string>(m["InterConnection"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Loopback") != m.end() && !m["Loopback"].empty()) {
      loopback = make_shared<string>(boost::any_cast<string>(m["Loopback"]));
    }
    if (m.find("ManagerIp") != m.end() && !m["ManagerIp"].empty()) {
      managerIp = make_shared<string>(boost::any_cast<string>(m["ManagerIp"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("Stack") != m.end() && !m["Stack"].empty()) {
      stack = make_shared<bool>(boost::any_cast<bool>(m["Stack"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DeviceResourceDeviceResource() = default;
};
class DeviceResource : public Darabonba::Model {
public:
  shared_ptr<string> archId{};
  shared_ptr<string> businessType{};
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> businessTypeParams{};
  shared_ptr<string> createTime{};
  shared_ptr<string> data{};
  shared_ptr<vector<DeviceResourceDeviceResource>> deviceResource{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<vector<string>> deviceResourceIds{};
  shared_ptr<string> downloadType{};
  shared_ptr<string> ipType{};
  shared_ptr<string> listType{};
  shared_ptr<string> loopbackPort{};
  shared_ptr<string> netLocation{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> type{};

  DeviceResource() {}

  explicit DeviceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archId) {
      res["ArchId"] = boost::any(*archId);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (businessTypeParams) {
      res["BusinessTypeParams"] = boost::any(*businessTypeParams);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (deviceResource) {
      vector<boost::any> temp1;
      for(auto item1:*deviceResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceResource"] = boost::any(temp1);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIds) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIds);
    }
    if (downloadType) {
      res["DownloadType"] = boost::any(*downloadType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (listType) {
      res["ListType"] = boost::any(*listType);
    }
    if (loopbackPort) {
      res["LoopbackPort"] = boost::any(*loopbackPort);
    }
    if (netLocation) {
      res["NetLocation"] = boost::any(*netLocation);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchId") != m.end() && !m["ArchId"].empty()) {
      archId = make_shared<string>(boost::any_cast<string>(m["ArchId"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("BusinessTypeParams") != m.end() && !m["BusinessTypeParams"].empty()) {
      businessTypeParams = make_shared<string>(boost::any_cast<string>(m["BusinessTypeParams"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DeviceResource") != m.end() && !m["DeviceResource"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceResource"].type()) {
        vector<DeviceResourceDeviceResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeviceResourceDeviceResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceResource = make_shared<vector<DeviceResourceDeviceResource>>(expect1);
      }
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DownloadType") != m.end() && !m["DownloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["DownloadType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("ListType") != m.end() && !m["ListType"].empty()) {
      listType = make_shared<string>(boost::any_cast<string>(m["ListType"]));
    }
    if (m.find("LoopbackPort") != m.end() && !m["LoopbackPort"].empty()) {
      loopbackPort = make_shared<string>(boost::any_cast<string>(m["LoopbackPort"]));
    }
    if (m.find("NetLocation") != m.end() && !m["NetLocation"].empty()) {
      netLocation = make_shared<string>(boost::any_cast<string>(m["NetLocation"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeviceResource() = default;
};
class DeviceTask : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceIp{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceTaskId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> output{};
  shared_ptr<string> params{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  DeviceTask() {}

  explicit DeviceTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceIp) {
      res["DeviceIp"] = boost::any(*deviceIp);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceTaskId) {
      res["DeviceTaskId"] = boost::any(*deviceTaskId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceIp") != m.end() && !m["DeviceIp"].empty()) {
      deviceIp = make_shared<string>(boost::any_cast<string>(m["DeviceIp"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceTaskId") != m.end() && !m["DeviceTaskId"].empty()) {
      deviceTaskId = make_shared<string>(boost::any_cast<string>(m["DeviceTaskId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DeviceTask() = default;
};
class EventResourceDevice : public Darabonba::Model {
public:
  shared_ptr<string> hostName{};
  shared_ptr<string> physicalSpace{};

  EventResourceDevice() {}

  explicit EventResourceDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (physicalSpace) {
      res["PhysicalSpace"] = boost::any(*physicalSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("PhysicalSpace") != m.end() && !m["PhysicalSpace"].empty()) {
      physicalSpace = make_shared<string>(boost::any_cast<string>(m["PhysicalSpace"]));
    }
  }


  virtual ~EventResourceDevice() = default;
};
class Event : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventObject{};
  shared_ptr<string> eventObjectId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> message{};
  shared_ptr<EventResourceDevice> resourceDevice{};
  shared_ptr<string> templateId{};
  shared_ptr<string> updateTime{};

  Event() {}

  explicit Event(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventObject) {
      res["EventObject"] = boost::any(*eventObject);
    }
    if (eventObjectId) {
      res["EventObjectId"] = boost::any(*eventObjectId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (resourceDevice) {
      res["ResourceDevice"] = resourceDevice ? boost::any(resourceDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventObject") != m.end() && !m["EventObject"].empty()) {
      eventObject = make_shared<string>(boost::any_cast<string>(m["EventObject"]));
    }
    if (m.find("EventObjectId") != m.end() && !m["EventObjectId"].empty()) {
      eventObjectId = make_shared<string>(boost::any_cast<string>(m["EventObjectId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ResourceDevice") != m.end() && !m["ResourceDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDevice"].type()) {
        EventResourceDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDevice"]));
        resourceDevice = make_shared<EventResourceDevice>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Event() = default;
};
class EventDefinition : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> templateId{};
  shared_ptr<string> updateTime{};

  EventDefinition() {}

  explicit EventDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~EventDefinition() = default;
};
class InspectionItem : public Darabonba::Model {
public:
  shared_ptr<string> inspectionCrontab{};
  shared_ptr<string> itemDescription{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  InspectionItem() {}

  explicit InspectionItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionCrontab) {
      res["InspectionCrontab"] = boost::any(*inspectionCrontab);
    }
    if (itemDescription) {
      res["ItemDescription"] = boost::any(*itemDescription);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionCrontab") != m.end() && !m["InspectionCrontab"].empty()) {
      inspectionCrontab = make_shared<string>(boost::any_cast<string>(m["InspectionCrontab"]));
    }
    if (m.find("ItemDescription") != m.end() && !m["ItemDescription"].empty()) {
      itemDescription = make_shared<string>(boost::any_cast<string>(m["ItemDescription"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~InspectionItem() = default;
};
class InspectionScriptInspectionAlarmRules : public Darabonba::Model {
public:
  shared_ptr<string> alarmExpression{};
  shared_ptr<string> alarmLevel{};
  shared_ptr<string> alarmOperator{};
  shared_ptr<string> alarmValue{};

  InspectionScriptInspectionAlarmRules() {}

  explicit InspectionScriptInspectionAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmExpression) {
      res["AlarmExpression"] = boost::any(*alarmExpression);
    }
    if (alarmLevel) {
      res["AlarmLevel"] = boost::any(*alarmLevel);
    }
    if (alarmOperator) {
      res["AlarmOperator"] = boost::any(*alarmOperator);
    }
    if (alarmValue) {
      res["AlarmValue"] = boost::any(*alarmValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmExpression") != m.end() && !m["AlarmExpression"].empty()) {
      alarmExpression = make_shared<string>(boost::any_cast<string>(m["AlarmExpression"]));
    }
    if (m.find("AlarmLevel") != m.end() && !m["AlarmLevel"].empty()) {
      alarmLevel = make_shared<string>(boost::any_cast<string>(m["AlarmLevel"]));
    }
    if (m.find("AlarmOperator") != m.end() && !m["AlarmOperator"].empty()) {
      alarmOperator = make_shared<string>(boost::any_cast<string>(m["AlarmOperator"]));
    }
    if (m.find("AlarmValue") != m.end() && !m["AlarmValue"].empty()) {
      alarmValue = make_shared<string>(boost::any_cast<string>(m["AlarmValue"]));
    }
  }


  virtual ~InspectionScriptInspectionAlarmRules() = default;
};
class InspectionScript : public Darabonba::Model {
public:
  shared_ptr<vector<InspectionScriptInspectionAlarmRules>> inspectionAlarmRules{};
  shared_ptr<string> inspectionCrontab{};
  shared_ptr<string> itemDescription{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> script{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptStatus{};
  shared_ptr<string> vendor{};

  InspectionScript() {}

  explicit InspectionScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionAlarmRules"] = boost::any(temp1);
    }
    if (inspectionCrontab) {
      res["InspectionCrontab"] = boost::any(*inspectionCrontab);
    }
    if (itemDescription) {
      res["ItemDescription"] = boost::any(*itemDescription);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptStatus) {
      res["ScriptStatus"] = boost::any(*scriptStatus);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionAlarmRules") != m.end() && !m["InspectionAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionAlarmRules"].type()) {
        vector<InspectionScriptInspectionAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InspectionScriptInspectionAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionAlarmRules = make_shared<vector<InspectionScriptInspectionAlarmRules>>(expect1);
      }
    }
    if (m.find("InspectionCrontab") != m.end() && !m["InspectionCrontab"].empty()) {
      inspectionCrontab = make_shared<string>(boost::any_cast<string>(m["InspectionCrontab"]));
    }
    if (m.find("ItemDescription") != m.end() && !m["ItemDescription"].empty()) {
      itemDescription = make_shared<string>(boost::any_cast<string>(m["ItemDescription"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptStatus") != m.end() && !m["ScriptStatus"].empty()) {
      scriptStatus = make_shared<string>(boost::any_cast<string>(m["ScriptStatus"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~InspectionScript() = default;
};
class InspectionTaskInspectionAlarmRules : public Darabonba::Model {
public:
  shared_ptr<string> actualValue{};
  shared_ptr<string> expression{};
  shared_ptr<string> level{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  InspectionTaskInspectionAlarmRules() {}

  explicit InspectionTaskInspectionAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualValue) {
      res["ActualValue"] = boost::any(*actualValue);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualValue") != m.end() && !m["ActualValue"].empty()) {
      actualValue = make_shared<string>(boost::any_cast<string>(m["ActualValue"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~InspectionTaskInspectionAlarmRules() = default;
};
class InspectionTask : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> executionBeginTime{};
  shared_ptr<string> executionEndTime{};
  shared_ptr<string> hostname{};
  shared_ptr<string> IP{};
  shared_ptr<vector<InspectionTaskInspectionAlarmRules>> inspectionAlarmRules{};
  shared_ptr<string> inspectionResult{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> templateId{};
  shared_ptr<string> vendor{};

  InspectionTask() {}

  explicit InspectionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (executionBeginTime) {
      res["ExecutionBeginTime"] = boost::any(*executionBeginTime);
    }
    if (executionEndTime) {
      res["ExecutionEndTime"] = boost::any(*executionEndTime);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (inspectionAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionAlarmRules"] = boost::any(temp1);
    }
    if (inspectionResult) {
      res["InspectionResult"] = boost::any(*inspectionResult);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ExecutionBeginTime") != m.end() && !m["ExecutionBeginTime"].empty()) {
      executionBeginTime = make_shared<string>(boost::any_cast<string>(m["ExecutionBeginTime"]));
    }
    if (m.find("ExecutionEndTime") != m.end() && !m["ExecutionEndTime"].empty()) {
      executionEndTime = make_shared<string>(boost::any_cast<string>(m["ExecutionEndTime"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InspectionAlarmRules") != m.end() && !m["InspectionAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionAlarmRules"].type()) {
        vector<InspectionTaskInspectionAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InspectionTaskInspectionAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionAlarmRules = make_shared<vector<InspectionTaskInspectionAlarmRules>>(expect1);
      }
    }
    if (m.find("InspectionResult") != m.end() && !m["InspectionResult"].empty()) {
      inspectionResult = make_shared<string>(boost::any_cast<string>(m["InspectionResult"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~InspectionTask() = default;
};
class IpZoneLayer : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  IpZoneLayer() {}

  explicit IpZoneLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~IpZoneLayer() = default;
};
class Ip : public Darabonba::Model {
public:
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> businessTypeName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deviceMac{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> ipId{};
  shared_ptr<string> ipName{};
  shared_ptr<string> parentIpBlock{};
  shared_ptr<string> port{};
  shared_ptr<string> status{};
  shared_ptr<vector<IpZoneLayer>> zoneLayer{};

  Ip() {}

  explicit Ip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (businessTypeName) {
      res["BusinessTypeName"] = boost::any(*businessTypeName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceMac) {
      res["DeviceMac"] = boost::any(*deviceMac);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (ipId) {
      res["IpId"] = boost::any(*ipId);
    }
    if (ipName) {
      res["IpName"] = boost::any(*ipName);
    }
    if (parentIpBlock) {
      res["ParentIpBlock"] = boost::any(*parentIpBlock);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("BusinessTypeName") != m.end() && !m["BusinessTypeName"].empty()) {
      businessTypeName = make_shared<string>(boost::any_cast<string>(m["BusinessTypeName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeviceMac") != m.end() && !m["DeviceMac"].empty()) {
      deviceMac = make_shared<string>(boost::any_cast<string>(m["DeviceMac"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("IpId") != m.end() && !m["IpId"].empty()) {
      ipId = make_shared<string>(boost::any_cast<string>(m["IpId"]));
    }
    if (m.find("IpName") != m.end() && !m["IpName"].empty()) {
      ipName = make_shared<string>(boost::any_cast<string>(m["IpName"]));
    }
    if (m.find("ParentIpBlock") != m.end() && !m["ParentIpBlock"].empty()) {
      parentIpBlock = make_shared<string>(boost::any_cast<string>(m["ParentIpBlock"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneLayer") != m.end() && !m["ZoneLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneLayer"].type()) {
        vector<IpZoneLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpZoneLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneLayer = make_shared<vector<IpZoneLayer>>(expect1);
      }
    }
  }


  virtual ~Ip() = default;
};
class IpBlockZoneLayer : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  IpBlockZoneLayer() {}

  explicit IpBlockZoneLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~IpBlockZoneLayer() = default;
};
class IpBlock : public Darabonba::Model {
public:
  shared_ptr<string> application{};
  shared_ptr<string> backupDeviceName{};
  shared_ptr<string> block{};
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> ipBlockId{};
  shared_ptr<string> mask{};
  shared_ptr<string> netBusiness{};
  shared_ptr<string> netType{};
  shared_ptr<string> ownership{};
  shared_ptr<string> parentId{};
  shared_ptr<string> reserveParentBlock{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> updateType{};
  shared_ptr<vector<IpBlockZoneLayer>> zoneLayer{};
  shared_ptr<string> zoneName{};

  IpBlock() {}

  explicit IpBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (backupDeviceName) {
      res["BackupDeviceName"] = boost::any(*backupDeviceName);
    }
    if (block) {
      res["Block"] = boost::any(*block);
    }
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (ipBlockId) {
      res["IpBlockId"] = boost::any(*ipBlockId);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (netBusiness) {
      res["NetBusiness"] = boost::any(*netBusiness);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (ownership) {
      res["Ownership"] = boost::any(*ownership);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (reserveParentBlock) {
      res["ReserveParentBlock"] = boost::any(*reserveParentBlock);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (updateType) {
      res["UpdateType"] = boost::any(*updateType);
    }
    if (zoneLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneLayer"] = boost::any(temp1);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("BackupDeviceName") != m.end() && !m["BackupDeviceName"].empty()) {
      backupDeviceName = make_shared<string>(boost::any_cast<string>(m["BackupDeviceName"]));
    }
    if (m.find("Block") != m.end() && !m["Block"].empty()) {
      block = make_shared<string>(boost::any_cast<string>(m["Block"]));
    }
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IpBlockId") != m.end() && !m["IpBlockId"].empty()) {
      ipBlockId = make_shared<string>(boost::any_cast<string>(m["IpBlockId"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("NetBusiness") != m.end() && !m["NetBusiness"].empty()) {
      netBusiness = make_shared<string>(boost::any_cast<string>(m["NetBusiness"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("Ownership") != m.end() && !m["Ownership"].empty()) {
      ownership = make_shared<string>(boost::any_cast<string>(m["Ownership"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ReserveParentBlock") != m.end() && !m["ReserveParentBlock"].empty()) {
      reserveParentBlock = make_shared<string>(boost::any_cast<string>(m["ReserveParentBlock"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("UpdateType") != m.end() && !m["UpdateType"].empty()) {
      updateType = make_shared<string>(boost::any_cast<string>(m["UpdateType"]));
    }
    if (m.find("ZoneLayer") != m.end() && !m["ZoneLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneLayer"].type()) {
        vector<IpBlockZoneLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpBlockZoneLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneLayer = make_shared<vector<IpBlockZoneLayer>>(expect1);
      }
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~IpBlock() = default;
};
class IpBlockRecordDetailZoneLayer : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  IpBlockRecordDetailZoneLayer() {}

  explicit IpBlockRecordDetailZoneLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~IpBlockRecordDetailZoneLayer() = default;
};
class IpBlockRecordDetail : public Darabonba::Model {
public:
  shared_ptr<string> businessTypeName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> gateway{};
  shared_ptr<vector<string>> parentIpBlocks{};
  shared_ptr<vector<IpBlockRecordDetailZoneLayer>> zoneLayer{};

  IpBlockRecordDetail() {}

  explicit IpBlockRecordDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTypeName) {
      res["BusinessTypeName"] = boost::any(*businessTypeName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (parentIpBlocks) {
      res["ParentIpBlocks"] = boost::any(*parentIpBlocks);
    }
    if (zoneLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTypeName") != m.end() && !m["BusinessTypeName"].empty()) {
      businessTypeName = make_shared<string>(boost::any_cast<string>(m["BusinessTypeName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ParentIpBlocks") != m.end() && !m["ParentIpBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParentIpBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParentIpBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIpBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneLayer") != m.end() && !m["ZoneLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneLayer"].type()) {
        vector<IpBlockRecordDetailZoneLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpBlockRecordDetailZoneLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneLayer = make_shared<vector<IpBlockRecordDetailZoneLayer>>(expect1);
      }
    }
  }


  virtual ~IpBlockRecordDetail() = default;
};
class IpBlockRecord : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> creator{};
  shared_ptr<string> description{};
  shared_ptr<vector<IpBlockRecordDetail>> detail{};
  shared_ptr<vector<string>> ipBlockCode{};
  shared_ptr<string> ipBlockRecordId{};
  shared_ptr<string> netType{};
  shared_ptr<string> recordType{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> workNo{};
  shared_ptr<string> zoneName{};

  IpBlockRecord() {}

  explicit IpBlockRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (ipBlockCode) {
      res["IpBlockCode"] = boost::any(*ipBlockCode);
    }
    if (ipBlockRecordId) {
      res["IpBlockRecordId"] = boost::any(*ipBlockRecordId);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workNo) {
      res["WorkNo"] = boost::any(*workNo);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<IpBlockRecordDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpBlockRecordDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<IpBlockRecordDetail>>(expect1);
      }
    }
    if (m.find("IpBlockCode") != m.end() && !m["IpBlockCode"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpBlockCode"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpBlockCode"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipBlockCode = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpBlockRecordId") != m.end() && !m["IpBlockRecordId"].empty()) {
      ipBlockRecordId = make_shared<string>(boost::any_cast<string>(m["IpBlockRecordId"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("WorkNo") != m.end() && !m["WorkNo"].empty()) {
      workNo = make_shared<string>(boost::any_cast<string>(m["WorkNo"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~IpBlockRecord() = default;
};
class IpRecordDetailZoneLayer : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  IpRecordDetailZoneLayer() {}

  explicit IpRecordDetailZoneLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~IpRecordDetailZoneLayer() = default;
};
class IpRecordDetail : public Darabonba::Model {
public:
  shared_ptr<string> deviceMac{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> gateway{};
  shared_ptr<string> ip{};
  shared_ptr<vector<string>> parentIpBlocks{};
  shared_ptr<string> port{};
  shared_ptr<string> remoteDeviceName{};
  shared_ptr<string> remoteIp{};
  shared_ptr<string> remotePort{};
  shared_ptr<vector<IpRecordDetailZoneLayer>> zoneLayer{};

  IpRecordDetail() {}

  explicit IpRecordDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceMac) {
      res["DeviceMac"] = boost::any(*deviceMac);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (parentIpBlocks) {
      res["ParentIpBlocks"] = boost::any(*parentIpBlocks);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (remoteDeviceName) {
      res["RemoteDeviceName"] = boost::any(*remoteDeviceName);
    }
    if (remoteIp) {
      res["RemoteIp"] = boost::any(*remoteIp);
    }
    if (remotePort) {
      res["RemotePort"] = boost::any(*remotePort);
    }
    if (zoneLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceMac") != m.end() && !m["DeviceMac"].empty()) {
      deviceMac = make_shared<string>(boost::any_cast<string>(m["DeviceMac"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ParentIpBlocks") != m.end() && !m["ParentIpBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParentIpBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParentIpBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIpBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RemoteDeviceName") != m.end() && !m["RemoteDeviceName"].empty()) {
      remoteDeviceName = make_shared<string>(boost::any_cast<string>(m["RemoteDeviceName"]));
    }
    if (m.find("RemoteIp") != m.end() && !m["RemoteIp"].empty()) {
      remoteIp = make_shared<string>(boost::any_cast<string>(m["RemoteIp"]));
    }
    if (m.find("RemotePort") != m.end() && !m["RemotePort"].empty()) {
      remotePort = make_shared<string>(boost::any_cast<string>(m["RemotePort"]));
    }
    if (m.find("ZoneLayer") != m.end() && !m["ZoneLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneLayer"].type()) {
        vector<IpRecordDetailZoneLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpRecordDetailZoneLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneLayer = make_shared<vector<IpRecordDetailZoneLayer>>(expect1);
      }
    }
  }


  virtual ~IpRecordDetail() = default;
};
class IpRecord : public Darabonba::Model {
public:
  shared_ptr<string> businessTypeName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<vector<IpRecordDetail>> detail{};
  shared_ptr<string> ipBlock{};
  shared_ptr<vector<string>> ipCode{};
  shared_ptr<string> ipRecordId{};
  shared_ptr<string> recodeType{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> zoneName{};

  IpRecord() {}

  explicit IpRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTypeName) {
      res["BusinessTypeName"] = boost::any(*businessTypeName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (ipBlock) {
      res["IpBlock"] = boost::any(*ipBlock);
    }
    if (ipCode) {
      res["IpCode"] = boost::any(*ipCode);
    }
    if (ipRecordId) {
      res["IpRecordId"] = boost::any(*ipRecordId);
    }
    if (recodeType) {
      res["RecodeType"] = boost::any(*recodeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTypeName") != m.end() && !m["BusinessTypeName"].empty()) {
      businessTypeName = make_shared<string>(boost::any_cast<string>(m["BusinessTypeName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<IpRecordDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IpRecordDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<IpRecordDetail>>(expect1);
      }
    }
    if (m.find("IpBlock") != m.end() && !m["IpBlock"].empty()) {
      ipBlock = make_shared<string>(boost::any_cast<string>(m["IpBlock"]));
    }
    if (m.find("IpCode") != m.end() && !m["IpCode"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpCode"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpCode"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipCode = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpRecordId") != m.end() && !m["IpRecordId"].empty()) {
      ipRecordId = make_shared<string>(boost::any_cast<string>(m["IpRecordId"]));
    }
    if (m.find("RecodeType") != m.end() && !m["RecodeType"].empty()) {
      recodeType = make_shared<string>(boost::any_cast<string>(m["RecodeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~IpRecord() = default;
};
class ModelToRole : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> model{};
  shared_ptr<string> modelToRoleId{};
  shared_ptr<string> networkArchitectureIterationId{};
  shared_ptr<string> role{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendor{};

  ModelToRole() {}

  explicit ModelToRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelToRoleId) {
      res["ModelToRoleId"] = boost::any(*modelToRoleId);
    }
    if (networkArchitectureIterationId) {
      res["NetworkArchitectureIterationId"] = boost::any(*networkArchitectureIterationId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelToRoleId") != m.end() && !m["ModelToRoleId"].empty()) {
      modelToRoleId = make_shared<string>(boost::any_cast<string>(m["ModelToRoleId"]));
    }
    if (m.find("NetworkArchitectureIterationId") != m.end() && !m["NetworkArchitectureIterationId"].empty()) {
      networkArchitectureIterationId = make_shared<string>(boost::any_cast<string>(m["NetworkArchitectureIterationId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ModelToRole() = default;
};
class ModuleDevice : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<long> deviceCount{};
  shared_ptr<string> deviceRole{};
  shared_ptr<string> deviceX{};
  shared_ptr<string> deviceY{};
  shared_ptr<string> id{};
  shared_ptr<string> role{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};

  ModuleDevice() {}

  explicit ModuleDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (deviceRole) {
      res["DeviceRole"] = boost::any(*deviceRole);
    }
    if (deviceX) {
      res["DeviceX"] = boost::any(*deviceX);
    }
    if (deviceY) {
      res["DeviceY"] = boost::any(*deviceY);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("DeviceRole") != m.end() && !m["DeviceRole"].empty()) {
      deviceRole = make_shared<string>(boost::any_cast<string>(m["DeviceRole"]));
    }
    if (m.find("DeviceX") != m.end() && !m["DeviceX"].empty()) {
      deviceX = make_shared<string>(boost::any_cast<string>(m["DeviceX"]));
    }
    if (m.find("DeviceY") != m.end() && !m["DeviceY"].empty()) {
      deviceY = make_shared<string>(boost::any_cast<string>(m["DeviceY"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
  }


  virtual ~ModuleDevice() = default;
};
class ModuleModuleDetailsDeviceDetails : public Darabonba::Model {
public:
  shared_ptr<long> orderNumber{};

  ModuleModuleDetailsDeviceDetails() {}

  explicit ModuleModuleDetailsDeviceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<long>(boost::any_cast<long>(m["OrderNumber"]));
    }
  }


  virtual ~ModuleModuleDetailsDeviceDetails() = default;
};
class ModuleModuleDetails : public Darabonba::Model {
public:
  shared_ptr<vector<ModuleModuleDetailsDeviceDetails>> deviceDetails{};
  shared_ptr<long> orderNumber{};

  ModuleModuleDetails() {}

  explicit ModuleModuleDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*deviceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceDetails"] = boost::any(temp1);
    }
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceDetails") != m.end() && !m["DeviceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceDetails"].type()) {
        vector<ModuleModuleDetailsDeviceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModuleModuleDetailsDeviceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceDetails = make_shared<vector<ModuleModuleDetailsDeviceDetails>>(expect1);
      }
    }
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<long>(boost::any_cast<long>(m["OrderNumber"]));
    }
  }


  virtual ~ModuleModuleDetails() = default;
};
class Module : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<ModuleDevice> device{};
  shared_ptr<string> id{};
  shared_ptr<long> maxCount{};
  shared_ptr<long> minCount{};
  shared_ptr<vector<ModuleModuleDetails>> moduleDetails{};
  shared_ptr<string> moduleId{};
  shared_ptr<string> moduleType{};
  shared_ptr<string> name{};
  shared_ptr<string> parentModuleId{};
  shared_ptr<bool> stack{};
  shared_ptr<string> updateTime{};

  Module() {}

  explicit Module(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (device) {
      res["Device"] = device ? boost::any(device->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxCount) {
      res["MaxCount"] = boost::any(*maxCount);
    }
    if (minCount) {
      res["MinCount"] = boost::any(*minCount);
    }
    if (moduleDetails) {
      vector<boost::any> temp1;
      for(auto item1:*moduleDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleDetails"] = boost::any(temp1);
    }
    if (moduleId) {
      res["ModuleId"] = boost::any(*moduleId);
    }
    if (moduleType) {
      res["ModuleType"] = boost::any(*moduleType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentModuleId) {
      res["ParentModuleId"] = boost::any(*parentModuleId);
    }
    if (stack) {
      res["Stack"] = boost::any(*stack);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(map<string, boost::any>) == m["Device"].type()) {
        ModuleDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Device"]));
        device = make_shared<ModuleDevice>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MaxCount") != m.end() && !m["MaxCount"].empty()) {
      maxCount = make_shared<long>(boost::any_cast<long>(m["MaxCount"]));
    }
    if (m.find("MinCount") != m.end() && !m["MinCount"].empty()) {
      minCount = make_shared<long>(boost::any_cast<long>(m["MinCount"]));
    }
    if (m.find("ModuleDetails") != m.end() && !m["ModuleDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleDetails"].type()) {
        vector<ModuleModuleDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModuleModuleDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleDetails = make_shared<vector<ModuleModuleDetails>>(expect1);
      }
    }
    if (m.find("ModuleId") != m.end() && !m["ModuleId"].empty()) {
      moduleId = make_shared<string>(boost::any_cast<string>(m["ModuleId"]));
    }
    if (m.find("ModuleType") != m.end() && !m["ModuleType"].empty()) {
      moduleType = make_shared<string>(boost::any_cast<string>(m["ModuleType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentModuleId") != m.end() && !m["ParentModuleId"].empty()) {
      parentModuleId = make_shared<string>(boost::any_cast<string>(m["ParentModuleId"]));
    }
    if (m.find("Stack") != m.end() && !m["Stack"].empty()) {
      stack = make_shared<bool>(boost::any_cast<bool>(m["Stack"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Module() = default;
};
class MonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> analysisCode{};
  shared_ptr<string> collectionType{};
  shared_ptr<string> config{};
  shared_ptr<long> enable{};
  shared_ptr<string> execInterval{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> monitorItemName{};
  shared_ptr<string> securityDomain{};

  MonitorItem() {}

  explicit MonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisCode) {
      res["AnalysisCode"] = boost::any(*analysisCode);
    }
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (execInterval) {
      res["ExecInterval"] = boost::any(*execInterval);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisCode") != m.end() && !m["AnalysisCode"].empty()) {
      analysisCode = make_shared<string>(boost::any_cast<string>(m["AnalysisCode"]));
    }
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("ExecInterval") != m.end() && !m["ExecInterval"].empty()) {
      execInterval = make_shared<string>(boost::any_cast<string>(m["ExecInterval"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
  }


  virtual ~MonitorItem() = default;
};
class NetworkArchitecture : public Darabonba::Model {
public:
  shared_ptr<string> archVersionIterationId{};
  shared_ptr<bool> availabe{};
  shared_ptr<vector<string>> children{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> deviceNumber{};
  shared_ptr<long> groupNumber{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkArchitectureId{};
  shared_ptr<string> role{};
  shared_ptr<bool> selected{};
  shared_ptr<bool> stack{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> version{};

  NetworkArchitecture() {}

  explicit NetworkArchitecture(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archVersionIterationId) {
      res["ArchVersionIterationId"] = boost::any(*archVersionIterationId);
    }
    if (availabe) {
      res["Availabe"] = boost::any(*availabe);
    }
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (groupNumber) {
      res["GroupNumber"] = boost::any(*groupNumber);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkArchitectureId) {
      res["NetworkArchitectureId"] = boost::any(*networkArchitectureId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    if (stack) {
      res["Stack"] = boost::any(*stack);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchVersionIterationId") != m.end() && !m["ArchVersionIterationId"].empty()) {
      archVersionIterationId = make_shared<string>(boost::any_cast<string>(m["ArchVersionIterationId"]));
    }
    if (m.find("Availabe") != m.end() && !m["Availabe"].empty()) {
      availabe = make_shared<bool>(boost::any_cast<bool>(m["Availabe"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      children = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<long>(boost::any_cast<long>(m["DeviceNumber"]));
    }
    if (m.find("GroupNumber") != m.end() && !m["GroupNumber"].empty()) {
      groupNumber = make_shared<long>(boost::any_cast<long>(m["GroupNumber"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkArchitectureId") != m.end() && !m["NetworkArchitectureId"].empty()) {
      networkArchitectureId = make_shared<string>(boost::any_cast<string>(m["NetworkArchitectureId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
    if (m.find("Stack") != m.end() && !m["Stack"].empty()) {
      stack = make_shared<bool>(boost::any_cast<bool>(m["Stack"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~NetworkArchitecture() = default;
};
class NotificationGroup : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> notificationGroupDescription{};
  shared_ptr<string> notificationGroupId{};
  shared_ptr<string> notificationGroupName{};
  shared_ptr<string> notificationGroupType{};
  shared_ptr<string> webhook{};

  NotificationGroup() {}

  explicit NotificationGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (notificationGroupDescription) {
      res["NotificationGroupDescription"] = boost::any(*notificationGroupDescription);
    }
    if (notificationGroupId) {
      res["NotificationGroupId"] = boost::any(*notificationGroupId);
    }
    if (notificationGroupName) {
      res["NotificationGroupName"] = boost::any(*notificationGroupName);
    }
    if (notificationGroupType) {
      res["NotificationGroupType"] = boost::any(*notificationGroupType);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("NotificationGroupDescription") != m.end() && !m["NotificationGroupDescription"].empty()) {
      notificationGroupDescription = make_shared<string>(boost::any_cast<string>(m["NotificationGroupDescription"]));
    }
    if (m.find("NotificationGroupId") != m.end() && !m["NotificationGroupId"].empty()) {
      notificationGroupId = make_shared<string>(boost::any_cast<string>(m["NotificationGroupId"]));
    }
    if (m.find("NotificationGroupName") != m.end() && !m["NotificationGroupName"].empty()) {
      notificationGroupName = make_shared<string>(boost::any_cast<string>(m["NotificationGroupName"]));
    }
    if (m.find("NotificationGroupType") != m.end() && !m["NotificationGroupType"].empty()) {
      notificationGroupType = make_shared<string>(boost::any_cast<string>(m["NotificationGroupType"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~NotificationGroup() = default;
};
class Order : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> orderId{};
  shared_ptr<string> output{};
  shared_ptr<string> params{};
  shared_ptr<string> schemeId{};
  shared_ptr<string> schemeName{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  Order() {}

  explicit Order(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (schemeId) {
      res["SchemeId"] = boost::any(*schemeId);
    }
    if (schemeName) {
      res["SchemeName"] = boost::any(*schemeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("SchemeId") != m.end() && !m["SchemeId"].empty()) {
      schemeId = make_shared<string>(boost::any_cast<string>(m["SchemeId"]));
    }
    if (m.find("SchemeName") != m.end() && !m["SchemeName"].empty()) {
      schemeName = make_shared<string>(boost::any_cast<string>(m["SchemeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~Order() = default;
};
class OrderStepRestriction : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  OrderStepRestriction() {}

  explicit OrderStepRestriction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~OrderStepRestriction() = default;
};
class OrderStep : public Darabonba::Model {
public:
  shared_ptr<string> displayMethod{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> jobKwargs{};
  shared_ptr<string> jobMessage{};
  shared_ptr<string> jobReturnStatus{};
  shared_ptr<string> jobReturnValues{};
  shared_ptr<string> jobSystem{};
  shared_ptr<string> orderId{};
  shared_ptr<string> orderStepId{};
  shared_ptr<string> realNextStep{};
  shared_ptr<vector<OrderStepRestriction>> restriction{};
  shared_ptr<string> stepName{};
  shared_ptr<string> stepStatus{};
  shared_ptr<string> stepTitle{};
  shared_ptr<string> stepType{};

  OrderStep() {}

  explicit OrderStep(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayMethod) {
      res["DisplayMethod"] = boost::any(*displayMethod);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (jobKwargs) {
      res["JobKwargs"] = boost::any(*jobKwargs);
    }
    if (jobMessage) {
      res["JobMessage"] = boost::any(*jobMessage);
    }
    if (jobReturnStatus) {
      res["JobReturnStatus"] = boost::any(*jobReturnStatus);
    }
    if (jobReturnValues) {
      res["JobReturnValues"] = boost::any(*jobReturnValues);
    }
    if (jobSystem) {
      res["JobSystem"] = boost::any(*jobSystem);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderStepId) {
      res["OrderStepId"] = boost::any(*orderStepId);
    }
    if (realNextStep) {
      res["RealNextStep"] = boost::any(*realNextStep);
    }
    if (restriction) {
      vector<boost::any> temp1;
      for(auto item1:*restriction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Restriction"] = boost::any(temp1);
    }
    if (stepName) {
      res["StepName"] = boost::any(*stepName);
    }
    if (stepStatus) {
      res["StepStatus"] = boost::any(*stepStatus);
    }
    if (stepTitle) {
      res["StepTitle"] = boost::any(*stepTitle);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayMethod") != m.end() && !m["DisplayMethod"].empty()) {
      displayMethod = make_shared<string>(boost::any_cast<string>(m["DisplayMethod"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("JobKwargs") != m.end() && !m["JobKwargs"].empty()) {
      jobKwargs = make_shared<string>(boost::any_cast<string>(m["JobKwargs"]));
    }
    if (m.find("JobMessage") != m.end() && !m["JobMessage"].empty()) {
      jobMessage = make_shared<string>(boost::any_cast<string>(m["JobMessage"]));
    }
    if (m.find("JobReturnStatus") != m.end() && !m["JobReturnStatus"].empty()) {
      jobReturnStatus = make_shared<string>(boost::any_cast<string>(m["JobReturnStatus"]));
    }
    if (m.find("JobReturnValues") != m.end() && !m["JobReturnValues"].empty()) {
      jobReturnValues = make_shared<string>(boost::any_cast<string>(m["JobReturnValues"]));
    }
    if (m.find("JobSystem") != m.end() && !m["JobSystem"].empty()) {
      jobSystem = make_shared<string>(boost::any_cast<string>(m["JobSystem"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderStepId") != m.end() && !m["OrderStepId"].empty()) {
      orderStepId = make_shared<string>(boost::any_cast<string>(m["OrderStepId"]));
    }
    if (m.find("RealNextStep") != m.end() && !m["RealNextStep"].empty()) {
      realNextStep = make_shared<string>(boost::any_cast<string>(m["RealNextStep"]));
    }
    if (m.find("Restriction") != m.end() && !m["Restriction"].empty()) {
      if (typeid(vector<boost::any>) == m["Restriction"].type()) {
        vector<OrderStepRestriction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Restriction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OrderStepRestriction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restriction = make_shared<vector<OrderStepRestriction>>(expect1);
      }
    }
    if (m.find("StepName") != m.end() && !m["StepName"].empty()) {
      stepName = make_shared<string>(boost::any_cast<string>(m["StepName"]));
    }
    if (m.find("StepStatus") != m.end() && !m["StepStatus"].empty()) {
      stepStatus = make_shared<string>(boost::any_cast<string>(m["StepStatus"]));
    }
    if (m.find("StepTitle") != m.end() && !m["StepTitle"].empty()) {
      stepTitle = make_shared<string>(boost::any_cast<string>(m["StepTitle"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
  }


  virtual ~OrderStep() = default;
};
class OsVersion : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> directory{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> model{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> osVersionId{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> status{};
  shared_ptr<string> vendor{};

  OsVersion() {}

  explicit OsVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~OsVersion() = default;
};
class PhysicalSpace : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> province{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};

  PhysicalSpace() {}

  explicit PhysicalSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
  }


  virtual ~PhysicalSpace() = default;
};
class PhysicalSpaceDto : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<PhysicalSpaceDto>> children{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> fullParentPath{};
  shared_ptr<string> instance{};
  shared_ptr<string> owner{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> securityDomainList{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};

  PhysicalSpaceDto() {}

  explicit PhysicalSpaceDto(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (fullParentPath) {
      res["FullParentPath"] = boost::any(*fullParentPath);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainList) {
      res["SecurityDomainList"] = boost::any(*securityDomainList);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<PhysicalSpaceDto> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PhysicalSpaceDto model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<PhysicalSpaceDto>>(expect1);
      }
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("FullParentPath") != m.end() && !m["FullParentPath"].empty()) {
      fullParentPath = make_shared<string>(boost::any_cast<string>(m["FullParentPath"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomainList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomainList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomainList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~PhysicalSpaceDto() = default;
};
class Port : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> portName{};

  Port() {}

  explicit Port(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
  }


  virtual ~Port() = default;
};
class PortCollection : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> portCollectionDescription{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> portCollectionName{};
  shared_ptr<vector<Port>> portList{};

  PortCollection() {}

  explicit PortCollection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (portCollectionDescription) {
      res["PortCollectionDescription"] = boost::any(*portCollectionDescription);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (portCollectionName) {
      res["PortCollectionName"] = boost::any(*portCollectionName);
    }
    if (portList) {
      vector<boost::any> temp1;
      for(auto item1:*portList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PortCollectionDescription") != m.end() && !m["PortCollectionDescription"].empty()) {
      portCollectionDescription = make_shared<string>(boost::any_cast<string>(m["PortCollectionDescription"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("PortCollectionName") != m.end() && !m["PortCollectionName"].empty()) {
      portCollectionName = make_shared<string>(boost::any_cast<string>(m["PortCollectionName"]));
    }
    if (m.find("PortList") != m.end() && !m["PortList"].empty()) {
      if (typeid(vector<boost::any>) == m["PortList"].type()) {
        vector<Port> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Port model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portList = make_shared<vector<Port>>(expect1);
      }
    }
  }


  virtual ~PortCollection() = default;
};
class ResourceInformationInformation : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> keyAttribute{};
  shared_ptr<string> keyDescription{};

  ResourceInformationInformation() {}

  explicit ResourceInformationInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (keyAttribute) {
      res["KeyAttribute"] = boost::any(*keyAttribute);
    }
    if (keyDescription) {
      res["KeyDescription"] = boost::any(*keyDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("KeyAttribute") != m.end() && !m["KeyAttribute"].empty()) {
      keyAttribute = make_shared<string>(boost::any_cast<string>(m["KeyAttribute"]));
    }
    if (m.find("KeyDescription") != m.end() && !m["KeyDescription"].empty()) {
      keyDescription = make_shared<string>(boost::any_cast<string>(m["KeyDescription"]));
    }
  }


  virtual ~ResourceInformationInformation() = default;
};
class ResourceInformation : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<ResourceInformationInformation>> information{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> updateTime{};

  ResourceInformation() {}

  explicit ResourceInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (information) {
      vector<boost::any> temp1;
      for(auto item1:*information){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Information"] = boost::any(temp1);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Information") != m.end() && !m["Information"].empty()) {
      if (typeid(vector<boost::any>) == m["Information"].type()) {
        vector<ResourceInformationInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Information"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResourceInformationInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        information = make_shared<vector<ResourceInformationInformation>>(expect1);
      }
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ResourceInformation() = default;
};
class ScheduleDutyTypeWorkerList : public Darabonba::Model {
public:
  shared_ptr<string> scheduleTypeId{};
  shared_ptr<vector<string>> scheduleWorkerName{};

  ScheduleDutyTypeWorkerList() {}

  explicit ScheduleDutyTypeWorkerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleTypeId) {
      res["ScheduleTypeId"] = boost::any(*scheduleTypeId);
    }
    if (scheduleWorkerName) {
      res["ScheduleWorkerName"] = boost::any(*scheduleWorkerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleTypeId") != m.end() && !m["ScheduleTypeId"].empty()) {
      scheduleTypeId = make_shared<string>(boost::any_cast<string>(m["ScheduleTypeId"]));
    }
    if (m.find("ScheduleWorkerName") != m.end() && !m["ScheduleWorkerName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScheduleWorkerName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScheduleWorkerName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scheduleWorkerName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ScheduleDutyTypeWorkerList() = default;
};
class ScheduleDuty : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> endDate{};
  shared_ptr<string> scheduleDutyId{};
  shared_ptr<vector<string>> scheduleTypeIds{};
  shared_ptr<string> startDate{};
  shared_ptr<vector<ScheduleDutyTypeWorkerList>> typeWorkerList{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> workDate{};
  shared_ptr<string> workType{};
  shared_ptr<string> workerId{};
  shared_ptr<string> workerName{};

  ScheduleDuty() {}

  explicit ScheduleDuty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (scheduleDutyId) {
      res["ScheduleDutyId"] = boost::any(*scheduleDutyId);
    }
    if (scheduleTypeIds) {
      res["ScheduleTypeIds"] = boost::any(*scheduleTypeIds);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (typeWorkerList) {
      vector<boost::any> temp1;
      for(auto item1:*typeWorkerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TypeWorkerList"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workDate) {
      res["WorkDate"] = boost::any(*workDate);
    }
    if (workType) {
      res["WorkType"] = boost::any(*workType);
    }
    if (workerId) {
      res["WorkerId"] = boost::any(*workerId);
    }
    if (workerName) {
      res["WorkerName"] = boost::any(*workerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ScheduleDutyId") != m.end() && !m["ScheduleDutyId"].empty()) {
      scheduleDutyId = make_shared<string>(boost::any_cast<string>(m["ScheduleDutyId"]));
    }
    if (m.find("ScheduleTypeIds") != m.end() && !m["ScheduleTypeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScheduleTypeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScheduleTypeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scheduleTypeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("TypeWorkerList") != m.end() && !m["TypeWorkerList"].empty()) {
      if (typeid(vector<boost::any>) == m["TypeWorkerList"].type()) {
        vector<ScheduleDutyTypeWorkerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TypeWorkerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScheduleDutyTypeWorkerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        typeWorkerList = make_shared<vector<ScheduleDutyTypeWorkerList>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("WorkDate") != m.end() && !m["WorkDate"].empty()) {
      workDate = make_shared<string>(boost::any_cast<string>(m["WorkDate"]));
    }
    if (m.find("WorkType") != m.end() && !m["WorkType"].empty()) {
      workType = make_shared<string>(boost::any_cast<string>(m["WorkType"]));
    }
    if (m.find("WorkerId") != m.end() && !m["WorkerId"].empty()) {
      workerId = make_shared<string>(boost::any_cast<string>(m["WorkerId"]));
    }
    if (m.find("WorkerName") != m.end() && !m["WorkerName"].empty()) {
      workerName = make_shared<string>(boost::any_cast<string>(m["WorkerName"]));
    }
  }


  virtual ~ScheduleDuty() = default;
};
class ScheduleType : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> relatedWorker{};
  shared_ptr<string> scheduleTypeId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> value{};

  ScheduleType() {}

  explicit ScheduleType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (relatedWorker) {
      res["RelatedWorker"] = boost::any(*relatedWorker);
    }
    if (scheduleTypeId) {
      res["ScheduleTypeId"] = boost::any(*scheduleTypeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RelatedWorker") != m.end() && !m["RelatedWorker"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedWorker"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedWorker"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedWorker = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleTypeId") != m.end() && !m["ScheduleTypeId"].empty()) {
      scheduleTypeId = make_shared<string>(boost::any_cast<string>(m["ScheduleTypeId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ScheduleType() = default;
};
class ScheduleWorker : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> scheduleWorkerId{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> workerContact{};
  shared_ptr<string> workerId{};
  shared_ptr<string> workerName{};

  ScheduleWorker() {}

  explicit ScheduleWorker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (scheduleWorkerId) {
      res["ScheduleWorkerId"] = boost::any(*scheduleWorkerId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workerContact) {
      res["WorkerContact"] = boost::any(*workerContact);
    }
    if (workerId) {
      res["WorkerId"] = boost::any(*workerId);
    }
    if (workerName) {
      res["WorkerName"] = boost::any(*workerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ScheduleWorkerId") != m.end() && !m["ScheduleWorkerId"].empty()) {
      scheduleWorkerId = make_shared<string>(boost::any_cast<string>(m["ScheduleWorkerId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("WorkerContact") != m.end() && !m["WorkerContact"].empty()) {
      workerContact = make_shared<string>(boost::any_cast<string>(m["WorkerContact"]));
    }
    if (m.find("WorkerId") != m.end() && !m["WorkerId"].empty()) {
      workerId = make_shared<string>(boost::any_cast<string>(m["WorkerId"]));
    }
    if (m.find("WorkerName") != m.end() && !m["WorkerName"].empty()) {
      workerName = make_shared<string>(boost::any_cast<string>(m["WorkerName"]));
    }
  }


  virtual ~ScheduleWorker() = default;
};
class SchemeInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  SchemeInput() {}

  explicit SchemeInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SchemeInput() = default;
};
class SchemeOutput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  SchemeOutput() {}

  explicit SchemeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SchemeOutput() = default;
};
class Scheme : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<vector<SchemeInput>> input{};
  shared_ptr<vector<SchemeOutput>> output{};
  shared_ptr<string> schemeId{};
  shared_ptr<string> schemeName{};
  shared_ptr<string> status{};
  shared_ptr<string> view{};

  Scheme() {}

  explicit Scheme(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (input) {
      vector<boost::any> temp1;
      for(auto item1:*input){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Input"] = boost::any(temp1);
    }
    if (output) {
      vector<boost::any> temp1;
      for(auto item1:*output){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Output"] = boost::any(temp1);
    }
    if (schemeId) {
      res["SchemeId"] = boost::any(*schemeId);
    }
    if (schemeName) {
      res["SchemeName"] = boost::any(*schemeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (view) {
      res["View"] = boost::any(*view);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(vector<boost::any>) == m["Input"].type()) {
        vector<SchemeInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Input"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SchemeInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        input = make_shared<vector<SchemeInput>>(expect1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(vector<boost::any>) == m["Output"].type()) {
        vector<SchemeOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Output"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SchemeOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        output = make_shared<vector<SchemeOutput>>(expect1);
      }
    }
    if (m.find("SchemeId") != m.end() && !m["SchemeId"].empty()) {
      schemeId = make_shared<string>(boost::any_cast<string>(m["SchemeId"]));
    }
    if (m.find("SchemeName") != m.end() && !m["SchemeName"].empty()) {
      schemeName = make_shared<string>(boost::any_cast<string>(m["SchemeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("View") != m.end() && !m["View"].empty()) {
      view = make_shared<string>(boost::any_cast<string>(m["View"]));
    }
  }


  virtual ~Scheme() = default;
};
class ScriptInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  ScriptInput() {}

  explicit ScriptInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ScriptInput() = default;
};
class ScriptOutput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  ScriptOutput() {}

  explicit ScriptOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ScriptOutput() = default;
};
class ScriptRule : public Darabonba::Model {
public:
  shared_ptr<string> arch{};
  shared_ptr<string> domain{};
  shared_ptr<string> model{};
  shared_ptr<string> os{};
  shared_ptr<string> role{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> vendor{};

  ScriptRule() {}

  explicit ScriptRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arch) {
      res["Arch"] = boost::any(*arch);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arch") != m.end() && !m["Arch"].empty()) {
      arch = make_shared<string>(boost::any_cast<string>(m["Arch"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ScriptRule() = default;
};
class Script : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<vector<ScriptInput>> input{};
  shared_ptr<vector<ScriptOutput>> output{};
  shared_ptr<vector<ScriptRule>> rules{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> versionId{};

  Script() {}

  explicit Script(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (input) {
      vector<boost::any> temp1;
      for(auto item1:*input){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Input"] = boost::any(temp1);
    }
    if (output) {
      vector<boost::any> temp1;
      for(auto item1:*output){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Output"] = boost::any(temp1);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(vector<boost::any>) == m["Input"].type()) {
        vector<ScriptInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Input"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScriptInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        input = make_shared<vector<ScriptInput>>(expect1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(vector<boost::any>) == m["Output"].type()) {
        vector<ScriptOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Output"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScriptOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        output = make_shared<vector<ScriptOutput>>(expect1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ScriptRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScriptRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ScriptRule>>(expect1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~Script() = default;
};
class ScriptHistoryInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  ScriptHistoryInput() {}

  explicit ScriptHistoryInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ScriptHistoryInput() = default;
};
class ScriptHistoryOutput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  ScriptHistoryOutput() {}

  explicit ScriptHistoryOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ScriptHistoryOutput() = default;
};
class ScriptHistory : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> content{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<vector<ScriptHistoryInput>> input{};
  shared_ptr<vector<ScriptHistoryOutput>> output{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> versionId{};

  ScriptHistory() {}

  explicit ScriptHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (input) {
      vector<boost::any> temp1;
      for(auto item1:*input){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Input"] = boost::any(temp1);
    }
    if (output) {
      vector<boost::any> temp1;
      for(auto item1:*output){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Output"] = boost::any(temp1);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(vector<boost::any>) == m["Input"].type()) {
        vector<ScriptHistoryInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Input"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScriptHistoryInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        input = make_shared<vector<ScriptHistoryInput>>(expect1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(vector<boost::any>) == m["Output"].type()) {
        vector<ScriptHistoryOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Output"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScriptHistoryOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        output = make_shared<vector<ScriptHistoryOutput>>(expect1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~ScriptHistory() = default;
};
class SetupProjectPackages : public Darabonba::Model {
public:
  shared_ptr<string> deviceNumber{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> vendor{};

  SetupProjectPackages() {}

  explicit SetupProjectPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<string>(boost::any_cast<string>(m["DeviceNumber"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~SetupProjectPackages() = default;
};
class SetupProject : public Darabonba::Model {
public:
  shared_ptr<string> archId{};
  shared_ptr<string> archVersion{};
  shared_ptr<string> architectureId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nodes{};
  shared_ptr<vector<SetupProjectPackages>> packages{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> setupProjectName{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};

  SetupProject() {}

  explicit SetupProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archId) {
      res["ArchId"] = boost::any(*archId);
    }
    if (archVersion) {
      res["ArchVersion"] = boost::any(*archVersion);
    }
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodes) {
      res["Nodes"] = boost::any(*nodes);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (setupProjectName) {
      res["SetupProjectName"] = boost::any(*setupProjectName);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchId") != m.end() && !m["ArchId"].empty()) {
      archId = make_shared<string>(boost::any_cast<string>(m["ArchId"]));
    }
    if (m.find("ArchVersion") != m.end() && !m["ArchVersion"].empty()) {
      archVersion = make_shared<string>(boost::any_cast<string>(m["ArchVersion"]));
    }
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      nodes = make_shared<string>(boost::any_cast<string>(m["Nodes"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<SetupProjectPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetupProjectPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<SetupProjectPackages>>(expect1);
      }
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SetupProjectName") != m.end() && !m["SetupProjectName"].empty()) {
      setupProjectName = make_shared<string>(boost::any_cast<string>(m["SetupProjectName"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetupProject() = default;
};
class SpaceModelSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  SpaceModelSort() {}

  explicit SpaceModelSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~SpaceModelSort() = default;
};
class SpaceModelSpaceModelSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levleName{};

  SpaceModelSpaceModelSort() {}

  explicit SpaceModelSpaceModelSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levleName) {
      res["LevleName"] = boost::any(*levleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevleName") != m.end() && !m["LevleName"].empty()) {
      levleName = make_shared<string>(boost::any_cast<string>(m["LevleName"]));
    }
  }


  virtual ~SpaceModelSpaceModelSort() = default;
};
class SpaceModelSpaceModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<SpaceModelSpaceModelSort> sort{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  SpaceModelSpaceModel() {}

  explicit SpaceModelSpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (sort) {
      res["Sort"] = sort ? boost::any(sort->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sort"].type()) {
        SpaceModelSpaceModelSort model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sort"]));
        sort = make_shared<SpaceModelSpaceModelSort>(model1);
      }
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~SpaceModelSpaceModel() = default;
};
class SpaceModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> instance{};
  shared_ptr<string> operateType{};
  shared_ptr<SpaceModelSort> sort{};
  shared_ptr<string> spaceId{};
  shared_ptr<SpaceModelSpaceModel> spaceModel{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceModelName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};

  SpaceModel() {}

  explicit SpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (sort) {
      res["Sort"] = sort ? boost::any(sort->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceModel) {
      res["SpaceModel"] = spaceModel ? boost::any(spaceModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceModelName) {
      res["SpaceModelName"] = boost::any(*spaceModelName);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sort"].type()) {
        SpaceModelSort model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sort"]));
        sort = make_shared<SpaceModelSort>(model1);
      }
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceModel") != m.end() && !m["SpaceModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpaceModel"].type()) {
        SpaceModelSpaceModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpaceModel"]));
        spaceModel = make_shared<SpaceModelSpaceModel>(model1);
      }
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceModelName") != m.end() && !m["SpaceModelName"].empty()) {
      spaceModelName = make_shared<string>(boost::any_cast<string>(m["SpaceModelName"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SpaceModel() = default;
};
class SubscriptionItem : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> language{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> notificationGroupId{};
  shared_ptr<string> notificationMode{};
  shared_ptr<long> recoveryNotice{};
  shared_ptr<string> subscriptionItemId{};
  shared_ptr<string> subscriptionType{};
  shared_ptr<string> suppressionStrategy{};
  shared_ptr<long> triggerTimes{};

  SubscriptionItem() {}

  explicit SubscriptionItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (notificationGroupId) {
      res["NotificationGroupId"] = boost::any(*notificationGroupId);
    }
    if (notificationMode) {
      res["NotificationMode"] = boost::any(*notificationMode);
    }
    if (recoveryNotice) {
      res["RecoveryNotice"] = boost::any(*recoveryNotice);
    }
    if (subscriptionItemId) {
      res["SubscriptionItemId"] = boost::any(*subscriptionItemId);
    }
    if (subscriptionType) {
      res["SubscriptionType"] = boost::any(*subscriptionType);
    }
    if (suppressionStrategy) {
      res["SuppressionStrategy"] = boost::any(*suppressionStrategy);
    }
    if (triggerTimes) {
      res["TriggerTimes"] = boost::any(*triggerTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NotificationGroupId") != m.end() && !m["NotificationGroupId"].empty()) {
      notificationGroupId = make_shared<string>(boost::any_cast<string>(m["NotificationGroupId"]));
    }
    if (m.find("NotificationMode") != m.end() && !m["NotificationMode"].empty()) {
      notificationMode = make_shared<string>(boost::any_cast<string>(m["NotificationMode"]));
    }
    if (m.find("RecoveryNotice") != m.end() && !m["RecoveryNotice"].empty()) {
      recoveryNotice = make_shared<long>(boost::any_cast<long>(m["RecoveryNotice"]));
    }
    if (m.find("SubscriptionItemId") != m.end() && !m["SubscriptionItemId"].empty()) {
      subscriptionItemId = make_shared<string>(boost::any_cast<string>(m["SubscriptionItemId"]));
    }
    if (m.find("SubscriptionType") != m.end() && !m["SubscriptionType"].empty()) {
      subscriptionType = make_shared<string>(boost::any_cast<string>(m["SubscriptionType"]));
    }
    if (m.find("SuppressionStrategy") != m.end() && !m["SuppressionStrategy"].empty()) {
      suppressionStrategy = make_shared<string>(boost::any_cast<string>(m["SuppressionStrategy"]));
    }
    if (m.find("TriggerTimes") != m.end() && !m["TriggerTimes"].empty()) {
      triggerTimes = make_shared<long>(boost::any_cast<long>(m["TriggerTimes"]));
    }
  }


  virtual ~SubscriptionItem() = default;
};
class Task : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> params{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  Task() {}

  explicit Task(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~Task() = default;
};
class TaskLog : public Darabonba::Model {
public:
  shared_ptr<string> funcName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> level{};
  shared_ptr<long> lineNo{};
  shared_ptr<string> logId{};
  shared_ptr<string> message{};
  shared_ptr<string> taskId{};

  TaskLog() {}

  explicit TaskLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (funcName) {
      res["FuncName"] = boost::any(*funcName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lineNo) {
      res["LineNo"] = boost::any(*lineNo);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuncName") != m.end() && !m["FuncName"].empty()) {
      funcName = make_shared<string>(boost::any_cast<string>(m["FuncName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LineNo") != m.end() && !m["LineNo"].empty()) {
      lineNo = make_shared<long>(boost::any_cast<long>(m["LineNo"]));
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<string>(boost::any_cast<string>(m["LogId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~TaskLog() = default;
};
class TemplateInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  TemplateInput() {}

  explicit TemplateInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~TemplateInput() = default;
};
class TemplateOutput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> sample{};
  shared_ptr<string> type{};

  TemplateOutput() {}

  explicit TemplateOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~TemplateOutput() = default;
};
class Template : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> comment{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<vector<TemplateInput>> input{};
  shared_ptr<vector<TemplateOutput>> output{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  Template() {}

  explicit Template(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (input) {
      vector<boost::any> temp1;
      for(auto item1:*input){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Input"] = boost::any(temp1);
    }
    if (output) {
      vector<boost::any> temp1;
      for(auto item1:*output){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Output"] = boost::any(temp1);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(vector<boost::any>) == m["Input"].type()) {
        vector<TemplateInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Input"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TemplateInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        input = make_shared<vector<TemplateInput>>(expect1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(vector<boost::any>) == m["Output"].type()) {
        vector<TemplateOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Output"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TemplateOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        output = make_shared<vector<TemplateOutput>>(expect1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~Template() = default;
};
class TimePeriod : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> source{};
  shared_ptr<string> timePeriodDescription{};
  shared_ptr<string> timePeriodId{};
  shared_ptr<string> timePeriodName{};

  TimePeriod() {}

  explicit TimePeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (timePeriodDescription) {
      res["TimePeriodDescription"] = boost::any(*timePeriodDescription);
    }
    if (timePeriodId) {
      res["TimePeriodId"] = boost::any(*timePeriodId);
    }
    if (timePeriodName) {
      res["TimePeriodName"] = boost::any(*timePeriodName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TimePeriodDescription") != m.end() && !m["TimePeriodDescription"].empty()) {
      timePeriodDescription = make_shared<string>(boost::any_cast<string>(m["TimePeriodDescription"]));
    }
    if (m.find("TimePeriodId") != m.end() && !m["TimePeriodId"].empty()) {
      timePeriodId = make_shared<string>(boost::any_cast<string>(m["TimePeriodId"]));
    }
    if (m.find("TimePeriodName") != m.end() && !m["TimePeriodName"].empty()) {
      timePeriodName = make_shared<string>(boost::any_cast<string>(m["TimePeriodName"]));
    }
  }


  virtual ~TimePeriod() = default;
};
class ZoneTypeZoneTypeLayer : public Darabonba::Model {
public:
  shared_ptr<long> mask{};
  shared_ptr<string> name{};

  ZoneTypeZoneTypeLayer() {}

  explicit ZoneTypeZoneTypeLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<long>(boost::any_cast<long>(m["Mask"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ZoneTypeZoneTypeLayer() = default;
};
class ZoneType : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<string> zoneTypeId{};
  shared_ptr<vector<ZoneTypeZoneTypeLayer>> zoneTypeLayer{};
  shared_ptr<string> zoneTypeName{};

  ZoneType() {}

  explicit ZoneType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (zoneTypeId) {
      res["ZoneTypeId"] = boost::any(*zoneTypeId);
    }
    if (zoneTypeLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneTypeLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneTypeLayer"] = boost::any(temp1);
    }
    if (zoneTypeName) {
      res["ZoneTypeName"] = boost::any(*zoneTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ZoneTypeId") != m.end() && !m["ZoneTypeId"].empty()) {
      zoneTypeId = make_shared<string>(boost::any_cast<string>(m["ZoneTypeId"]));
    }
    if (m.find("ZoneTypeLayer") != m.end() && !m["ZoneTypeLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneTypeLayer"].type()) {
        vector<ZoneTypeZoneTypeLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneTypeLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ZoneTypeZoneTypeLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneTypeLayer = make_shared<vector<ZoneTypeZoneTypeLayer>>(expect1);
      }
    }
    if (m.find("ZoneTypeName") != m.end() && !m["ZoneTypeName"].empty()) {
      zoneTypeName = make_shared<string>(boost::any_cast<string>(m["ZoneTypeName"]));
    }
  }


  virtual ~ZoneType() = default;
};
class ApplyIPRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> businessTypeParams{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<vector<string>> deviceResourceIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipType{};
  shared_ptr<string> loopbackPort{};
  shared_ptr<string> netLocation{};
  shared_ptr<string> setupProjectId{};

  ApplyIPRequest() {}

  explicit ApplyIPRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (businessTypeParams) {
      res["BusinessTypeParams"] = boost::any(*businessTypeParams);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIds) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (loopbackPort) {
      res["LoopbackPort"] = boost::any(*loopbackPort);
    }
    if (netLocation) {
      res["NetLocation"] = boost::any(*netLocation);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("BusinessTypeParams") != m.end() && !m["BusinessTypeParams"].empty()) {
      businessTypeParams = make_shared<string>(boost::any_cast<string>(m["BusinessTypeParams"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("LoopbackPort") != m.end() && !m["LoopbackPort"].empty()) {
      loopbackPort = make_shared<string>(boost::any_cast<string>(m["LoopbackPort"]));
    }
    if (m.find("NetLocation") != m.end() && !m["NetLocation"].empty()) {
      netLocation = make_shared<string>(boost::any_cast<string>(m["NetLocation"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ApplyIPRequest() = default;
};
class ApplyIPShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> businessTypeParams{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> deviceResourceIdsShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipType{};
  shared_ptr<string> loopbackPort{};
  shared_ptr<string> netLocation{};
  shared_ptr<string> setupProjectId{};

  ApplyIPShrinkRequest() {}

  explicit ApplyIPShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (businessTypeParams) {
      res["BusinessTypeParams"] = boost::any(*businessTypeParams);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIdsShrink) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (loopbackPort) {
      res["LoopbackPort"] = boost::any(*loopbackPort);
    }
    if (netLocation) {
      res["NetLocation"] = boost::any(*netLocation);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("BusinessTypeParams") != m.end() && !m["BusinessTypeParams"].empty()) {
      businessTypeParams = make_shared<string>(boost::any_cast<string>(m["BusinessTypeParams"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      deviceResourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceResourceIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("LoopbackPort") != m.end() && !m["LoopbackPort"].empty()) {
      loopbackPort = make_shared<string>(boost::any_cast<string>(m["LoopbackPort"]));
    }
    if (m.find("NetLocation") != m.end() && !m["NetLocation"].empty()) {
      netLocation = make_shared<string>(boost::any_cast<string>(m["NetLocation"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ApplyIPShrinkRequest() = default;
};
class ApplyIPResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApplyIPResponseBody() {}

  explicit ApplyIPResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyIPResponseBody() = default;
};
class ApplyIPResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyIPResponseBody> body{};

  ApplyIPResponse() {}

  explicit ApplyIPResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyIPResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyIPResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyIPResponse() = default;
};
class AutoDutyRequest : public Darabonba::Model {
public:
  shared_ptr<string> dutyBatch{};
  shared_ptr<string> dutyName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startDate{};

  AutoDutyRequest() {}

  explicit AutoDutyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dutyBatch) {
      res["DutyBatch"] = boost::any(*dutyBatch);
    }
    if (dutyName) {
      res["DutyName"] = boost::any(*dutyName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DutyBatch") != m.end() && !m["DutyBatch"].empty()) {
      dutyBatch = make_shared<string>(boost::any_cast<string>(m["DutyBatch"]));
    }
    if (m.find("DutyName") != m.end() && !m["DutyName"].empty()) {
      dutyName = make_shared<string>(boost::any_cast<string>(m["DutyName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~AutoDutyRequest() = default;
};
class AutoDutyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AutoDutyResponseBody() {}

  explicit AutoDutyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AutoDutyResponseBody() = default;
};
class AutoDutyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AutoDutyResponseBody> body{};

  AutoDutyResponse() {}

  explicit AutoDutyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AutoDutyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AutoDutyResponseBody>(model1);
      }
    }
  }


  virtual ~AutoDutyResponse() = default;
};
class CloseEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> eventObjectId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};

  CloseEventRequest() {}

  explicit CloseEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventObjectId) {
      res["EventObjectId"] = boost::any(*eventObjectId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventObjectId") != m.end() && !m["EventObjectId"].empty()) {
      eventObjectId = make_shared<string>(boost::any_cast<string>(m["EventObjectId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CloseEventRequest() = default;
};
class CloseEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CloseEventResponseBody() {}

  explicit CloseEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloseEventResponseBody() = default;
};
class CloseEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseEventResponseBody> body{};

  CloseEventResponse() {}

  explicit CloseEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseEventResponseBody>(model1);
      }
    }
  }


  virtual ~CloseEventResponse() = default;
};
class CreateConfigurationSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<vector<vector<uint8_t>>> relatedVariate{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> vendor{};

  CreateConfigurationSpecificationRequest() {}

  explicit CreateConfigurationSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariate) {
      res["RelatedVariate"] = boost::any(*relatedVariate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      vector<vector<uint8_t>> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedVariate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedVariate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<vector<uint8_t>>(item));
        }
      }
      relatedVariate = make_shared<vector<vector<uint8_t>>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateConfigurationSpecificationRequest() = default;
};
class CreateConfigurationSpecificationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<string> relatedVariateShrink{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> vendor{};

  CreateConfigurationSpecificationShrinkRequest() {}

  explicit CreateConfigurationSpecificationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariateShrink) {
      res["RelatedVariate"] = boost::any(*relatedVariateShrink);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      relatedVariateShrink = make_shared<string>(boost::any_cast<string>(m["RelatedVariate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateConfigurationSpecificationShrinkRequest() = default;
};
class CreateConfigurationSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> requestId{};

  CreateConfigurationSpecificationResponseBody() {}

  explicit CreateConfigurationSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigurationSpecificationResponseBody() = default;
};
class CreateConfigurationSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigurationSpecificationResponseBody> body{};

  CreateConfigurationSpecificationResponse() {}

  explicit CreateConfigurationSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigurationSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigurationSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigurationSpecificationResponse() = default;
};
class CreateConfigurationVariateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> comment{};
  shared_ptr<string> formatFunction{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> variateName{};

  CreateConfigurationVariateRequest() {}

  explicit CreateConfigurationVariateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (formatFunction) {
      res["FormatFunction"] = boost::any(*formatFunction);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FormatFunction") != m.end() && !m["FormatFunction"].empty()) {
      formatFunction = make_shared<string>(boost::any_cast<string>(m["FormatFunction"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~CreateConfigurationVariateRequest() = default;
};
class CreateConfigurationVariateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> requestId{};

  CreateConfigurationVariateResponseBody() {}

  explicit CreateConfigurationVariateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigurationVariateResponseBody() = default;
};
class CreateConfigurationVariateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigurationVariateResponseBody> body{};

  CreateConfigurationVariateResponse() {}

  explicit CreateConfigurationVariateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigurationVariateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigurationVariateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigurationVariateResponse() = default;
};
class CreateDedicatedLineRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> contact{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineIp{};
  shared_ptr<string> dedicatedLineRole{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispFormId{};
  shared_ptr<string> ispId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> onlineDate{};
  shared_ptr<string> phone{};
  shared_ptr<string> physicalSpaceId{};

  CreateDedicatedLineRequest() {}

  explicit CreateDedicatedLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineIp) {
      res["DedicatedLineIp"] = boost::any(*dedicatedLineIp);
    }
    if (dedicatedLineRole) {
      res["DedicatedLineRole"] = boost::any(*dedicatedLineRole);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispFormId) {
      res["IspFormId"] = boost::any(*ispFormId);
    }
    if (ispId) {
      res["IspId"] = boost::any(*ispId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (onlineDate) {
      res["OnlineDate"] = boost::any(*onlineDate);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["Contact"]));
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineIp") != m.end() && !m["DedicatedLineIp"].empty()) {
      dedicatedLineIp = make_shared<string>(boost::any_cast<string>(m["DedicatedLineIp"]));
    }
    if (m.find("DedicatedLineRole") != m.end() && !m["DedicatedLineRole"].empty()) {
      dedicatedLineRole = make_shared<string>(boost::any_cast<string>(m["DedicatedLineRole"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspFormId") != m.end() && !m["IspFormId"].empty()) {
      ispFormId = make_shared<string>(boost::any_cast<string>(m["IspFormId"]));
    }
    if (m.find("IspId") != m.end() && !m["IspId"].empty()) {
      ispId = make_shared<string>(boost::any_cast<string>(m["IspId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OnlineDate") != m.end() && !m["OnlineDate"].empty()) {
      onlineDate = make_shared<string>(boost::any_cast<string>(m["OnlineDate"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~CreateDedicatedLineRequest() = default;
};
class CreateDedicatedLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> requestId{};

  CreateDedicatedLineResponseBody() {}

  explicit CreateDedicatedLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedLineResponseBody() = default;
};
class CreateDedicatedLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDedicatedLineResponseBody> body{};

  CreateDedicatedLineResponse() {}

  explicit CreateDedicatedLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedLineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedLineResponse() = default;
};
class CreateDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> mac{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> sn{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  CreateDeviceRequest() {}

  explicit CreateDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateDeviceRequest() = default;
};
class CreateDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> requestId{};

  CreateDeviceResponseBody() {}

  explicit CreateDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeviceResponseBody() = default;
};
class CreateDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceResponseBody> body{};

  CreateDeviceResponse() {}

  explicit CreateDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceResponse() = default;
};
class CreateDeviceFormRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accountConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> configCompare{};
  shared_ptr<bool> detailDisplay{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> relatedDeviceFormId{};
  shared_ptr<string> resourceUse{};
  shared_ptr<string> script{};
  shared_ptr<string> uniqueKey{};

  CreateDeviceFormRequest() {}

  explicit CreateDeviceFormRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (detailDisplay) {
      res["DetailDisplay"] = boost::any(*detailDisplay);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (relatedDeviceFormId) {
      res["RelatedDeviceFormId"] = boost::any(*relatedDeviceFormId);
    }
    if (resourceUse) {
      res["ResourceUse"] = boost::any(*resourceUse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<bool>(boost::any_cast<bool>(m["AccountConfig"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<bool>(boost::any_cast<bool>(m["ConfigCompare"]));
    }
    if (m.find("DetailDisplay") != m.end() && !m["DetailDisplay"].empty()) {
      detailDisplay = make_shared<bool>(boost::any_cast<bool>(m["DetailDisplay"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RelatedDeviceFormId") != m.end() && !m["RelatedDeviceFormId"].empty()) {
      relatedDeviceFormId = make_shared<string>(boost::any_cast<string>(m["RelatedDeviceFormId"]));
    }
    if (m.find("ResourceUse") != m.end() && !m["ResourceUse"].empty()) {
      resourceUse = make_shared<string>(boost::any_cast<string>(m["ResourceUse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~CreateDeviceFormRequest() = default;
};
class CreateDeviceFormResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> requestId{};

  CreateDeviceFormResponseBody() {}

  explicit CreateDeviceFormResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeviceFormResponseBody() = default;
};
class CreateDeviceFormResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceFormResponseBody> body{};

  CreateDeviceFormResponse() {}

  explicit CreateDeviceFormResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceFormResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceFormResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceFormResponse() = default;
};
class CreateDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyContent{};
  shared_ptr<string> propertyFormat{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> propertyName{};

  CreateDevicePropertyRequest() {}

  explicit CreateDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyContent) {
      res["PropertyContent"] = boost::any(*propertyContent);
    }
    if (propertyFormat) {
      res["PropertyFormat"] = boost::any(*propertyFormat);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyContent") != m.end() && !m["PropertyContent"].empty()) {
      propertyContent = make_shared<string>(boost::any_cast<string>(m["PropertyContent"]));
    }
    if (m.find("PropertyFormat") != m.end() && !m["PropertyFormat"].empty()) {
      propertyFormat = make_shared<string>(boost::any_cast<string>(m["PropertyFormat"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
  }


  virtual ~CreateDevicePropertyRequest() = default;
};
class CreateDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> requestId{};

  CreateDevicePropertyResponseBody() {}

  explicit CreateDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDevicePropertyResponseBody() = default;
};
class CreateDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDevicePropertyResponseBody> body{};

  CreateDevicePropertyResponse() {}

  explicit CreateDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDevicePropertyResponse() = default;
};
class CreateDevicesRequestDeviceParamModelList : public Darabonba::Model {
public:
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> mac{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> sn{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  CreateDevicesRequestDeviceParamModelList() {}

  explicit CreateDevicesRequestDeviceParamModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateDevicesRequestDeviceParamModelList() = default;
};
class CreateDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<vector<CreateDevicesRequestDeviceParamModelList>> deviceParamModelList{};
  shared_ptr<string> instanceId{};

  CreateDevicesRequest() {}

  explicit CreateDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceParamModelList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceParamModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceParamModelList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceParamModelList") != m.end() && !m["DeviceParamModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceParamModelList"].type()) {
        vector<CreateDevicesRequestDeviceParamModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceParamModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDevicesRequestDeviceParamModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceParamModelList = make_shared<vector<CreateDevicesRequestDeviceParamModelList>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateDevicesRequest() = default;
};
class CreateDevicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceParamModelListShrink{};
  shared_ptr<string> instanceId{};

  CreateDevicesShrinkRequest() {}

  explicit CreateDevicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceParamModelListShrink) {
      res["DeviceParamModelList"] = boost::any(*deviceParamModelListShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceParamModelList") != m.end() && !m["DeviceParamModelList"].empty()) {
      deviceParamModelListShrink = make_shared<string>(boost::any_cast<string>(m["DeviceParamModelList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateDevicesShrinkRequest() = default;
};
class CreateDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> requestId{};

  CreateDevicesResponseBody() {}

  explicit CreateDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDevicesResponseBody() = default;
};
class CreateDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDevicesResponseBody> body{};

  CreateDevicesResponse() {}

  explicit CreateDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDevicesResponse() = default;
};
class CreateEventDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};

  CreateEventDefinitionRequest() {}

  explicit CreateEventDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateEventDefinitionRequest() = default;
};
class CreateEventDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};

  CreateEventDefinitionResponseBody() {}

  explicit CreateEventDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEventDefinitionResponseBody() = default;
};
class CreateEventDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEventDefinitionResponseBody> body{};

  CreateEventDefinitionResponse() {}

  explicit CreateEventDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEventDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEventDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEventDefinitionResponse() = default;
};
class CreateLinkJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoConfirm{};
  shared_ptr<string> doubleConvertStrategy{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> singleStrategy{};

  CreateLinkJobRequest() {}

  explicit CreateLinkJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoConfirm) {
      res["AutoConfirm"] = boost::any(*autoConfirm);
    }
    if (doubleConvertStrategy) {
      res["DoubleConvertStrategy"] = boost::any(*doubleConvertStrategy);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (singleStrategy) {
      res["SingleStrategy"] = boost::any(*singleStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoConfirm") != m.end() && !m["AutoConfirm"].empty()) {
      autoConfirm = make_shared<bool>(boost::any_cast<bool>(m["AutoConfirm"]));
    }
    if (m.find("DoubleConvertStrategy") != m.end() && !m["DoubleConvertStrategy"].empty()) {
      doubleConvertStrategy = make_shared<string>(boost::any_cast<string>(m["DoubleConvertStrategy"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SingleStrategy") != m.end() && !m["SingleStrategy"].empty()) {
      singleStrategy = make_shared<string>(boost::any_cast<string>(m["SingleStrategy"]));
    }
  }


  virtual ~CreateLinkJobRequest() = default;
};
class CreateLinkJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  CreateLinkJobResponseBody() {}

  explicit CreateLinkJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLinkJobResponseBody() = default;
};
class CreateLinkJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLinkJobResponseBody> body{};

  CreateLinkJobResponse() {}

  explicit CreateLinkJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLinkJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLinkJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLinkJobResponse() = default;
};
class CreateMonitorItemRequestAlarmRuleList : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> expression{};
  shared_ptr<string> value{};
  shared_ptr<string> variable{};

  CreateMonitorItemRequestAlarmRuleList() {}

  explicit CreateMonitorItemRequestAlarmRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (variable) {
      res["Variable"] = boost::any(*variable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Variable") != m.end() && !m["Variable"].empty()) {
      variable = make_shared<string>(boost::any_cast<string>(m["Variable"]));
    }
  }


  virtual ~CreateMonitorItemRequestAlarmRuleList() = default;
};
class CreateMonitorItemRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMonitorItemRequestAlarmRuleList>> alarmRuleList{};
  shared_ptr<string> analysisCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> collectionType{};
  shared_ptr<string> config{};
  shared_ptr<string> dataItem{};
  shared_ptr<string> deviceForm{};
  shared_ptr<long> effective{};
  shared_ptr<long> execInterval{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};

  CreateMonitorItemRequest() {}

  explicit CreateMonitorItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*alarmRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmRuleList"] = boost::any(temp1);
    }
    if (analysisCode) {
      res["AnalysisCode"] = boost::any(*analysisCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (execInterval) {
      res["ExecInterval"] = boost::any(*execInterval);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmRuleList") != m.end() && !m["AlarmRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmRuleList"].type()) {
        vector<CreateMonitorItemRequestAlarmRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMonitorItemRequestAlarmRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmRuleList = make_shared<vector<CreateMonitorItemRequestAlarmRuleList>>(expect1);
      }
    }
    if (m.find("AnalysisCode") != m.end() && !m["AnalysisCode"].empty()) {
      analysisCode = make_shared<string>(boost::any_cast<string>(m["AnalysisCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<long>(boost::any_cast<long>(m["Effective"]));
    }
    if (m.find("ExecInterval") != m.end() && !m["ExecInterval"].empty()) {
      execInterval = make_shared<long>(boost::any_cast<long>(m["ExecInterval"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMonitorItemRequest() = default;
};
class CreateMonitorItemShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmRuleListShrink{};
  shared_ptr<string> analysisCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> collectionType{};
  shared_ptr<string> config{};
  shared_ptr<string> dataItem{};
  shared_ptr<string> deviceForm{};
  shared_ptr<long> effective{};
  shared_ptr<long> execInterval{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};

  CreateMonitorItemShrinkRequest() {}

  explicit CreateMonitorItemShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmRuleListShrink) {
      res["AlarmRuleList"] = boost::any(*alarmRuleListShrink);
    }
    if (analysisCode) {
      res["AnalysisCode"] = boost::any(*analysisCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (execInterval) {
      res["ExecInterval"] = boost::any(*execInterval);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmRuleList") != m.end() && !m["AlarmRuleList"].empty()) {
      alarmRuleListShrink = make_shared<string>(boost::any_cast<string>(m["AlarmRuleList"]));
    }
    if (m.find("AnalysisCode") != m.end() && !m["AnalysisCode"].empty()) {
      analysisCode = make_shared<string>(boost::any_cast<string>(m["AnalysisCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<long>(boost::any_cast<long>(m["Effective"]));
    }
    if (m.find("ExecInterval") != m.end() && !m["ExecInterval"].empty()) {
      execInterval = make_shared<long>(boost::any_cast<long>(m["ExecInterval"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMonitorItemShrinkRequest() = default;
};
class CreateMonitorItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> requestId{};

  CreateMonitorItemResponseBody() {}

  explicit CreateMonitorItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMonitorItemResponseBody() = default;
};
class CreateMonitorItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorItemResponseBody> body{};

  CreateMonitorItemResponse() {}

  explicit CreateMonitorItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorItemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorItemResponse() = default;
};
class CreateOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bootPatch{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> createTime{};
  shared_ptr<string> featurePatch{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> systemPatch{};
  shared_ptr<string> vendor{};

  CreateOsVersionRequest() {}

  explicit CreateOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootPatch) {
      res["BootPatch"] = boost::any(*bootPatch);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (featurePatch) {
      res["FeaturePatch"] = boost::any(*featurePatch);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemPatch) {
      res["SystemPatch"] = boost::any(*systemPatch);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootPatch") != m.end() && !m["BootPatch"].empty()) {
      bootPatch = make_shared<string>(boost::any_cast<string>(m["BootPatch"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FeaturePatch") != m.end() && !m["FeaturePatch"].empty()) {
      featurePatch = make_shared<string>(boost::any_cast<string>(m["FeaturePatch"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemPatch") != m.end() && !m["SystemPatch"].empty()) {
      systemPatch = make_shared<string>(boost::any_cast<string>(m["SystemPatch"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateOsVersionRequest() = default;
};
class CreateOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> osVersionId{};
  shared_ptr<string> requestId{};

  CreateOsVersionResponseBody() {}

  explicit CreateOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOsVersionResponseBody() = default;
};
class CreateOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOsVersionResponseBody> body{};

  CreateOsVersionResponse() {}

  explicit CreateOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOsVersionResponse() = default;
};
class CreatePhysicalSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> country{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> owner{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> securityDomainList{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};

  CreatePhysicalSpaceRequest() {}

  explicit CreatePhysicalSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainList) {
      res["SecurityDomainList"] = boost::any(*securityDomainList);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomainList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomainList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomainList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~CreatePhysicalSpaceRequest() = default;
};
class CreatePhysicalSpaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> country{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> owner{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<string> securityDomainListShrink{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};

  CreatePhysicalSpaceShrinkRequest() {}

  explicit CreatePhysicalSpaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainListShrink) {
      res["SecurityDomainList"] = boost::any(*securityDomainListShrink);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      securityDomainListShrink = make_shared<string>(boost::any_cast<string>(m["SecurityDomainList"]));
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~CreatePhysicalSpaceShrinkRequest() = default;
};
class CreatePhysicalSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> requestId{};

  CreatePhysicalSpaceResponseBody() {}

  explicit CreatePhysicalSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePhysicalSpaceResponseBody() = default;
};
class CreatePhysicalSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhysicalSpaceResponseBody> body{};

  CreatePhysicalSpaceResponse() {}

  explicit CreatePhysicalSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhysicalSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhysicalSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhysicalSpaceResponse() = default;
};
class CreateRealtimeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkDuplicatePolicy{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> script{};

  CreateRealtimeTaskRequest() {}

  explicit CreateRealtimeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkDuplicatePolicy) {
      res["CheckDuplicatePolicy"] = boost::any(*checkDuplicatePolicy);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckDuplicatePolicy") != m.end() && !m["CheckDuplicatePolicy"].empty()) {
      checkDuplicatePolicy = make_shared<string>(boost::any_cast<string>(m["CheckDuplicatePolicy"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~CreateRealtimeTaskRequest() = default;
};
class CreateRealtimeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateRealtimeTaskResponseBody() {}

  explicit CreateRealtimeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateRealtimeTaskResponseBody() = default;
};
class CreateRealtimeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRealtimeTaskResponseBody> body{};

  CreateRealtimeTaskResponse() {}

  explicit CreateRealtimeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRealtimeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRealtimeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRealtimeTaskResponse() = default;
};
class CreateResourceInformationRequestInformation : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> keyAttribute{};
  shared_ptr<string> keyDescription{};

  CreateResourceInformationRequestInformation() {}

  explicit CreateResourceInformationRequestInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (keyAttribute) {
      res["KeyAttribute"] = boost::any(*keyAttribute);
    }
    if (keyDescription) {
      res["KeyDescription"] = boost::any(*keyDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("KeyAttribute") != m.end() && !m["KeyAttribute"].empty()) {
      keyAttribute = make_shared<string>(boost::any_cast<string>(m["KeyAttribute"]));
    }
    if (m.find("KeyDescription") != m.end() && !m["KeyDescription"].empty()) {
      keyDescription = make_shared<string>(boost::any_cast<string>(m["KeyDescription"]));
    }
  }


  virtual ~CreateResourceInformationRequestInformation() = default;
};
class CreateResourceInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateResourceInformationRequestInformation>> information{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceType{};

  CreateResourceInformationRequest() {}

  explicit CreateResourceInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (information) {
      vector<boost::any> temp1;
      for(auto item1:*information){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Information"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Information") != m.end() && !m["Information"].empty()) {
      if (typeid(vector<boost::any>) == m["Information"].type()) {
        vector<CreateResourceInformationRequestInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Information"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResourceInformationRequestInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        information = make_shared<vector<CreateResourceInformationRequestInformation>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~CreateResourceInformationRequest() = default;
};
class CreateResourceInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceInformationId{};

  CreateResourceInformationResponseBody() {}

  explicit CreateResourceInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
  }


  virtual ~CreateResourceInformationResponseBody() = default;
};
class CreateResourceInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceInformationResponseBody> body{};

  CreateResourceInformationResponse() {}

  explicit CreateResourceInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceInformationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceInformationResponse() = default;
};
class CreateSetupProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> spaceId{};

  CreateSetupProjectRequest() {}

  explicit CreateSetupProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~CreateSetupProjectRequest() = default;
};
class CreateSetupProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> setupProjectId{};

  CreateSetupProjectResponseBody() {}

  explicit CreateSetupProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~CreateSetupProjectResponseBody() = default;
};
class CreateSetupProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSetupProjectResponseBody> body{};

  CreateSetupProjectResponse() {}

  explicit CreateSetupProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSetupProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSetupProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSetupProjectResponse() = default;
};
class CreateSpaceModelRequestSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  CreateSpaceModelRequestSort() {}

  explicit CreateSpaceModelRequestSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~CreateSpaceModelRequestSort() = default;
};
class CreateSpaceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<CreateSpaceModelRequestSort>> sort{};
  shared_ptr<string> spaceType{};

  CreateSpaceModelRequest() {}

  explicit CreateSpaceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sort) {
      vector<boost::any> temp1;
      for(auto item1:*sort){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sort"] = boost::any(temp1);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(vector<boost::any>) == m["Sort"].type()) {
        vector<CreateSpaceModelRequestSort> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sort"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSpaceModelRequestSort model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sort = make_shared<vector<CreateSpaceModelRequestSort>>(expect1);
      }
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~CreateSpaceModelRequest() = default;
};
class CreateSpaceModelShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sortShrink{};
  shared_ptr<string> spaceType{};

  CreateSpaceModelShrinkRequest() {}

  explicit CreateSpaceModelShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sortShrink) {
      res["Sort"] = boost::any(*sortShrink);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sortShrink = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~CreateSpaceModelShrinkRequest() = default;
};
class CreateSpaceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> spaceModelId{};

  CreateSpaceModelResponseBody() {}

  explicit CreateSpaceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
  }


  virtual ~CreateSpaceModelResponseBody() = default;
};
class CreateSpaceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSpaceModelResponseBody> body{};

  CreateSpaceModelResponse() {}

  explicit CreateSpaceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSpaceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSpaceModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSpaceModelResponse() = default;
};
class CreateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> params{};
  shared_ptr<string> templateId{};

  CreateTaskRequest() {}

  explicit CreateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateTaskRequest() = default;
};
class CreateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateTaskResponseBody() {}

  explicit CreateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateTaskResponseBody() = default;
};
class CreateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTaskResponseBody> body{};

  CreateTaskResponse() {}

  explicit CreateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTaskResponse() = default;
};
class CreateTimePeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> expression{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timePeriodDescription{};
  shared_ptr<string> timePeriodName{};

  CreateTimePeriodRequest() {}

  explicit CreateTimePeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timePeriodDescription) {
      res["TimePeriodDescription"] = boost::any(*timePeriodDescription);
    }
    if (timePeriodName) {
      res["TimePeriodName"] = boost::any(*timePeriodName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TimePeriodDescription") != m.end() && !m["TimePeriodDescription"].empty()) {
      timePeriodDescription = make_shared<string>(boost::any_cast<string>(m["TimePeriodDescription"]));
    }
    if (m.find("TimePeriodName") != m.end() && !m["TimePeriodName"].empty()) {
      timePeriodName = make_shared<string>(boost::any_cast<string>(m["TimePeriodName"]));
    }
  }


  virtual ~CreateTimePeriodRequest() = default;
};
class CreateTimePeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> timePeriodId{};

  CreateTimePeriodResponseBody() {}

  explicit CreateTimePeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timePeriodId) {
      res["TimePeriodId"] = boost::any(*timePeriodId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimePeriodId") != m.end() && !m["TimePeriodId"].empty()) {
      timePeriodId = make_shared<string>(boost::any_cast<string>(m["TimePeriodId"]));
    }
  }


  virtual ~CreateTimePeriodResponseBody() = default;
};
class CreateTimePeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTimePeriodResponseBody> body{};

  CreateTimePeriodResponse() {}

  explicit CreateTimePeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTimePeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTimePeriodResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTimePeriodResponse() = default;
};
class DeleteConfigurationSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> instanceId{};

  DeleteConfigurationSpecificationRequest() {}

  explicit DeleteConfigurationSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteConfigurationSpecificationRequest() = default;
};
class DeleteConfigurationSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteConfigurationSpecificationResponseBody() {}

  explicit DeleteConfigurationSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigurationSpecificationResponseBody() = default;
};
class DeleteConfigurationSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigurationSpecificationResponseBody> body{};

  DeleteConfigurationSpecificationResponse() {}

  explicit DeleteConfigurationSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigurationSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigurationSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigurationSpecificationResponse() = default;
};
class DeleteConfigurationVariateRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> instanceId{};

  DeleteConfigurationVariateRequest() {}

  explicit DeleteConfigurationVariateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteConfigurationVariateRequest() = default;
};
class DeleteConfigurationVariateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteConfigurationVariateResponseBody() {}

  explicit DeleteConfigurationVariateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigurationVariateResponseBody() = default;
};
class DeleteConfigurationVariateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigurationVariateResponseBody> body{};

  DeleteConfigurationVariateResponse() {}

  explicit DeleteConfigurationVariateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigurationVariateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigurationVariateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigurationVariateResponse() = default;
};
class DeleteDedicatedLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> instanceId{};

  DeleteDedicatedLineRequest() {}

  explicit DeleteDedicatedLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDedicatedLineRequest() = default;
};
class DeleteDedicatedLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDedicatedLineResponseBody() {}

  explicit DeleteDedicatedLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDedicatedLineResponseBody() = default;
};
class DeleteDedicatedLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDedicatedLineResponseBody> body{};

  DeleteDedicatedLineResponse() {}

  explicit DeleteDedicatedLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDedicatedLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDedicatedLineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDedicatedLineResponse() = default;
};
class DeleteDeliveryArchVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryArchVersionId{};
  shared_ptr<string> instanceId{};

  DeleteDeliveryArchVersionRequest() {}

  explicit DeleteDeliveryArchVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryArchVersionId) {
      res["DeliveryArchVersionId"] = boost::any(*deliveryArchVersionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryArchVersionId") != m.end() && !m["DeliveryArchVersionId"].empty()) {
      deliveryArchVersionId = make_shared<string>(boost::any_cast<string>(m["DeliveryArchVersionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDeliveryArchVersionRequest() = default;
};
class DeleteDeliveryArchVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeliveryArchVersionResponseBody() {}

  explicit DeleteDeliveryArchVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeliveryArchVersionResponseBody() = default;
};
class DeleteDeliveryArchVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeliveryArchVersionResponseBody> body{};

  DeleteDeliveryArchVersionResponse() {}

  explicit DeleteDeliveryArchVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeliveryArchVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeliveryArchVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeliveryArchVersionResponse() = default;
};
class DeleteDeliveryProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryProjectId{};
  shared_ptr<string> instanceId{};

  DeleteDeliveryProjectRequest() {}

  explicit DeleteDeliveryProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryProjectId) {
      res["DeliveryProjectId"] = boost::any(*deliveryProjectId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryProjectId") != m.end() && !m["DeliveryProjectId"].empty()) {
      deliveryProjectId = make_shared<string>(boost::any_cast<string>(m["DeliveryProjectId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDeliveryProjectRequest() = default;
};
class DeleteDeliveryProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeliveryProjectResponseBody() {}

  explicit DeleteDeliveryProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeliveryProjectResponseBody() = default;
};
class DeleteDeliveryProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeliveryProjectResponseBody> body{};

  DeleteDeliveryProjectResponse() {}

  explicit DeleteDeliveryProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeliveryProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeliveryProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeliveryProjectResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeviceResponseBody() {}

  explicit DeleteDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeviceResponseBody() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceResponseBody> body{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class DeleteDeviceFormRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};

  DeleteDeviceFormRequest() {}

  explicit DeleteDeviceFormRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDeviceFormRequest() = default;
};
class DeleteDeviceFormResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeviceFormResponseBody() {}

  explicit DeleteDeviceFormResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeviceFormResponseBody() = default;
};
class DeleteDeviceFormResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceFormResponseBody> body{};

  DeleteDeviceFormResponse() {}

  explicit DeleteDeviceFormResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceFormResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceFormResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceFormResponse() = default;
};
class DeleteDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> instanceId{};

  DeleteDevicePropertyRequest() {}

  explicit DeleteDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDevicePropertyRequest() = default;
};
class DeleteDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDevicePropertyResponseBody() {}

  explicit DeleteDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDevicePropertyResponseBody() = default;
};
class DeleteDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDevicePropertyResponseBody> body{};

  DeleteDevicePropertyResponse() {}

  explicit DeleteDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDevicePropertyResponse() = default;
};
class DeleteDeviceResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> instanceId{};

  DeleteDeviceResourceRequest() {}

  explicit DeleteDeviceResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDeviceResourceRequest() = default;
};
class DeleteDeviceResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeviceResourceResponseBody() {}

  explicit DeleteDeviceResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeviceResourceResponseBody() = default;
};
class DeleteDeviceResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceResourceResponseBody> body{};

  DeleteDeviceResourceResponse() {}

  explicit DeleteDeviceResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResourceResponse() = default;
};
class DeleteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> instanceId{};

  DeleteDevicesRequest() {}

  explicit DeleteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDevicesRequest() = default;
};
class DeleteDevicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIdsShrink{};
  shared_ptr<string> instanceId{};

  DeleteDevicesShrinkRequest() {}

  explicit DeleteDevicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIdsShrink) {
      res["DeviceIds"] = boost::any(*deviceIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDevicesShrinkRequest() = default;
};
class DeleteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDevicesResponseBody() {}

  explicit DeleteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDevicesResponseBody() = default;
};
class DeleteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDevicesResponseBody> body{};

  DeleteDevicesResponse() {}

  explicit DeleteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDevicesResponse() = default;
};
class DeleteEventDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> instanceId{};

  DeleteEventDefinitionRequest() {}

  explicit DeleteEventDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteEventDefinitionRequest() = default;
};
class DeleteEventDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEventDefinitionResponseBody() {}

  explicit DeleteEventDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEventDefinitionResponseBody() = default;
};
class DeleteEventDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventDefinitionResponseBody> body{};

  DeleteEventDefinitionResponse() {}

  explicit DeleteEventDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventDefinitionResponse() = default;
};
class DeleteInspectionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  DeleteInspectionTaskRequest() {}

  explicit DeleteInspectionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteInspectionTaskRequest() = default;
};
class DeleteInspectionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInspectionTaskResponseBody() {}

  explicit DeleteInspectionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInspectionTaskResponseBody() = default;
};
class DeleteInspectionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInspectionTaskResponseBody> body{};

  DeleteInspectionTaskResponse() {}

  explicit DeleteInspectionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInspectionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInspectionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInspectionTaskResponse() = default;
};
class DeleteOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> osVersionId{};

  DeleteOsVersionRequest() {}

  explicit DeleteOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
  }


  virtual ~DeleteOsVersionRequest() = default;
};
class DeleteOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOsVersionResponseBody() {}

  explicit DeleteOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOsVersionResponseBody() = default;
};
class DeleteOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOsVersionResponseBody> body{};

  DeleteOsVersionResponse() {}

  explicit DeleteOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOsVersionResponse() = default;
};
class DeletePhysicalSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> physicalSpaceId{};

  DeletePhysicalSpaceRequest() {}

  explicit DeletePhysicalSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~DeletePhysicalSpaceRequest() = default;
};
class DeletePhysicalSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePhysicalSpaceResponseBody() {}

  explicit DeletePhysicalSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePhysicalSpaceResponseBody() = default;
};
class DeletePhysicalSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePhysicalSpaceResponseBody> body{};

  DeletePhysicalSpaceResponse() {}

  explicit DeletePhysicalSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhysicalSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhysicalSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhysicalSpaceResponse() = default;
};
class DeleteResourceInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceInformationId{};

  DeleteResourceInformationRequest() {}

  explicit DeleteResourceInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
  }


  virtual ~DeleteResourceInformationRequest() = default;
};
class DeleteResourceInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteResourceInformationResponseBody() {}

  explicit DeleteResourceInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteResourceInformationResponseBody() = default;
};
class DeleteResourceInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceInformationResponseBody> body{};

  DeleteResourceInformationResponse() {}

  explicit DeleteResourceInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceInformationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceInformationResponse() = default;
};
class DeleteSetupProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};

  DeleteSetupProjectRequest() {}

  explicit DeleteSetupProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~DeleteSetupProjectRequest() = default;
};
class DeleteSetupProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSetupProjectResponseBody() {}

  explicit DeleteSetupProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSetupProjectResponseBody() = default;
};
class DeleteSetupProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSetupProjectResponseBody> body{};

  DeleteSetupProjectResponse() {}

  explicit DeleteSetupProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSetupProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSetupProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSetupProjectResponse() = default;
};
class DeleteSpaceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> spaceModelId{};

  DeleteSpaceModelRequest() {}

  explicit DeleteSpaceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
  }


  virtual ~DeleteSpaceModelRequest() = default;
};
class DeleteSpaceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSpaceModelResponseBody() {}

  explicit DeleteSpaceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSpaceModelResponseBody() = default;
};
class DeleteSpaceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSpaceModelResponseBody> body{};

  DeleteSpaceModelResponse() {}

  explicit DeleteSpaceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSpaceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSpaceModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSpaceModelResponse() = default;
};
class DisableNotificationRequestList : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventObjectId{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> type{};

  DisableNotificationRequestList() {}

  explicit DisableNotificationRequestList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventObjectId) {
      res["EventObjectId"] = boost::any(*eventObjectId);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventObjectId") != m.end() && !m["EventObjectId"].empty()) {
      eventObjectId = make_shared<string>(boost::any_cast<string>(m["EventObjectId"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DisableNotificationRequestList() = default;
};
class DisableNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> expiryTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DisableNotificationRequestList>> list{};
  shared_ptr<string> reason{};

  DisableNotificationRequest() {}

  explicit DisableNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<string>(boost::any_cast<string>(m["ExpiryTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DisableNotificationRequestList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisableNotificationRequestList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DisableNotificationRequestList>>(expect1);
      }
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DisableNotificationRequest() = default;
};
class DisableNotificationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> expiryTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> listShrink{};
  shared_ptr<string> reason{};

  DisableNotificationShrinkRequest() {}

  explicit DisableNotificationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listShrink) {
      res["List"] = boost::any(*listShrink);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<string>(boost::any_cast<string>(m["ExpiryTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      listShrink = make_shared<string>(boost::any_cast<string>(m["List"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DisableNotificationShrinkRequest() = default;
};
class DisableNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableNotificationResponseBody() {}

  explicit DisableNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableNotificationResponseBody() = default;
};
class DisableNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableNotificationResponseBody> body{};

  DisableNotificationResponse() {}

  explicit DisableNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~DisableNotificationResponse() = default;
};
class DownloadDeviceResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<vector<string>> deviceResourceIds{};
  shared_ptr<string> downloadType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};

  DownloadDeviceResourceRequest() {}

  explicit DownloadDeviceResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIds) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIds);
    }
    if (downloadType) {
      res["DownloadType"] = boost::any(*downloadType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DownloadType") != m.end() && !m["DownloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["DownloadType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~DownloadDeviceResourceRequest() = default;
};
class DownloadDeviceResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> deviceResourceIdsShrink{};
  shared_ptr<string> downloadType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};

  DownloadDeviceResourceShrinkRequest() {}

  explicit DownloadDeviceResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIdsShrink) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIdsShrink);
    }
    if (downloadType) {
      res["DownloadType"] = boost::any(*downloadType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      deviceResourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceResourceIds"]));
    }
    if (m.find("DownloadType") != m.end() && !m["DownloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["DownloadType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~DownloadDeviceResourceShrinkRequest() = default;
};
class DownloadDeviceResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> requestId{};

  DownloadDeviceResourceResponseBody() {}

  explicit DownloadDeviceResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DownloadDeviceResourceResponseBody() = default;
};
class DownloadDeviceResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadDeviceResourceResponseBody> body{};

  DownloadDeviceResourceResponse() {}

  explicit DownloadDeviceResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadDeviceResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadDeviceResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadDeviceResourceResponse() = default;
};
class EnableNotificationRequestList : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventObjectId{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> type{};

  EnableNotificationRequestList() {}

  explicit EnableNotificationRequestList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventObjectId) {
      res["EventObjectId"] = boost::any(*eventObjectId);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventObjectId") != m.end() && !m["EventObjectId"].empty()) {
      eventObjectId = make_shared<string>(boost::any_cast<string>(m["EventObjectId"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~EnableNotificationRequestList() = default;
};
class EnableNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<EnableNotificationRequestList>> list{};

  EnableNotificationRequest() {}

  explicit EnableNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<EnableNotificationRequestList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableNotificationRequestList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<EnableNotificationRequestList>>(expect1);
      }
    }
  }


  virtual ~EnableNotificationRequest() = default;
};
class EnableNotificationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> listShrink{};

  EnableNotificationShrinkRequest() {}

  explicit EnableNotificationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listShrink) {
      res["List"] = boost::any(*listShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      listShrink = make_shared<string>(boost::any_cast<string>(m["List"]));
    }
  }


  virtual ~EnableNotificationShrinkRequest() = default;
};
class EnableNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableNotificationResponseBody() {}

  explicit EnableNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableNotificationResponseBody() = default;
};
class EnableNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableNotificationResponseBody> body{};

  EnableNotificationResponse() {}

  explicit EnableNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~EnableNotificationResponse() = default;
};
class GetAlarmStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> type{};

  GetAlarmStatusRequest() {}

  explicit GetAlarmStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlarmStatusRequest() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusAggregateData : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataDescription{};
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> aggregateDataName{};
  shared_ptr<string> aggregateMode{};
  shared_ptr<string> dataItem{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> isAllDevice{};
  shared_ptr<string> monitorItemId{};

  GetAlarmStatusResponseBodyAlarmStatusAggregateData() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusAggregateData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataDescription) {
      res["AggregateDataDescription"] = boost::any(*aggregateDataDescription);
    }
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (aggregateDataName) {
      res["AggregateDataName"] = boost::any(*aggregateDataName);
    }
    if (aggregateMode) {
      res["AggregateMode"] = boost::any(*aggregateMode);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (isAllDevice) {
      res["IsAllDevice"] = boost::any(*isAllDevice);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataDescription") != m.end() && !m["AggregateDataDescription"].empty()) {
      aggregateDataDescription = make_shared<string>(boost::any_cast<string>(m["AggregateDataDescription"]));
    }
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AggregateDataName") != m.end() && !m["AggregateDataName"].empty()) {
      aggregateDataName = make_shared<string>(boost::any_cast<string>(m["AggregateDataName"]));
    }
    if (m.find("AggregateMode") != m.end() && !m["AggregateMode"].empty()) {
      aggregateMode = make_shared<string>(boost::any_cast<string>(m["AggregateMode"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("IsAllDevice") != m.end() && !m["IsAllDevice"].empty()) {
      isAllDevice = make_shared<long>(boost::any_cast<long>(m["IsAllDevice"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusAggregateData() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusDedicatedLine : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineName{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> portName{};
  shared_ptr<string> space{};

  GetAlarmStatusResponseBodyAlarmStatusDedicatedLine() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusDedicatedLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineName) {
      res["DedicatedLineName"] = boost::any(*dedicatedLineName);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineName") != m.end() && !m["DedicatedLineName"].empty()) {
      dedicatedLineName = make_shared<string>(boost::any_cast<string>(m["DedicatedLineName"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusDedicatedLine() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> collectionType{};
  shared_ptr<string> deviceForm{};
  shared_ptr<long> effective{};
  shared_ptr<string> execInterval{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> monitorItemName{};
  shared_ptr<string> securityDomain{};

  GetAlarmStatusResponseBodyAlarmStatusMonitorItem() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (execInterval) {
      res["ExecInterval"] = boost::any(*execInterval);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<long>(boost::any_cast<long>(m["Effective"]));
    }
    if (m.find("ExecInterval") != m.end() && !m["ExecInterval"].empty()) {
      execInterval = make_shared<string>(boost::any_cast<string>(m["ExecInterval"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusMonitorItem() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch : public Darabonba::Model {
public:
  shared_ptr<string> expiryTime{};
  shared_ptr<string> reason{};

  GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<string>(boost::any_cast<string>(m["ExpiryTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice : public Darabonba::Model {
public:
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> securityDomain{};

  GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> portName{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice> resourceDevice{};

  GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (resourceDevice) {
      res["ResourceDevice"] = resourceDevice ? boost::any(resourceDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("ResourceDevice") != m.end() && !m["ResourceDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDevice"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDevice"]));
        resourceDevice = make_shared<GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortListResourceDevice>(model1);
      }
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusPortCollection : public Darabonba::Model {
public:
  shared_ptr<string> portCollectionDescription{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> portCollectionName{};
  shared_ptr<vector<GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList>> portList{};

  GetAlarmStatusResponseBodyAlarmStatusPortCollection() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusPortCollection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portCollectionDescription) {
      res["PortCollectionDescription"] = boost::any(*portCollectionDescription);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (portCollectionName) {
      res["PortCollectionName"] = boost::any(*portCollectionName);
    }
    if (portList) {
      vector<boost::any> temp1;
      for(auto item1:*portList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortCollectionDescription") != m.end() && !m["PortCollectionDescription"].empty()) {
      portCollectionDescription = make_shared<string>(boost::any_cast<string>(m["PortCollectionDescription"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("PortCollectionName") != m.end() && !m["PortCollectionName"].empty()) {
      portCollectionName = make_shared<string>(boost::any_cast<string>(m["PortCollectionName"]));
    }
    if (m.find("PortList") != m.end() && !m["PortList"].empty()) {
      if (typeid(vector<boost::any>) == m["PortList"].type()) {
        vector<GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portList = make_shared<vector<GetAlarmStatusResponseBodyAlarmStatusPortCollectionPortList>>(expect1);
      }
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusPortCollection() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusResourceApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> domain{};
  shared_ptr<string> port{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};

  GetAlarmStatusResponseBodyAlarmStatusResourceApp() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusResourceApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusResourceApp() = default;
};
class GetAlarmStatusResponseBodyAlarmStatusResourceDevice : public Darabonba::Model {
public:
  shared_ptr<string> deviceForm{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> model{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> sn{};
  shared_ptr<string> space{};
  shared_ptr<string> status{};
  shared_ptr<string> vendor{};

  GetAlarmStatusResponseBodyAlarmStatusResourceDevice() {}

  explicit GetAlarmStatusResponseBodyAlarmStatusResourceDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatusResourceDevice() = default;
};
class GetAlarmStatusResponseBodyAlarmStatus : public Darabonba::Model {
public:
  shared_ptr<string> abnormalDataItem{};
  shared_ptr<string> agentIp{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusAggregateData> aggregateData{};
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> alarmRule{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> appId{};
  shared_ptr<string> collectionTime{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusDedicatedLine> dedicatedLine{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> firstAbnormalTime{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusMonitorItem> monitorItem{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch> notificationSwitch{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusPortCollection> portCollection{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> receiveTime{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusResourceApp> resourceApp{};
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatusResourceDevice> resourceDevice{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> uniqueKey{};

  GetAlarmStatusResponseBodyAlarmStatus() {}

  explicit GetAlarmStatusResponseBodyAlarmStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalDataItem) {
      res["AbnormalDataItem"] = boost::any(*abnormalDataItem);
    }
    if (agentIp) {
      res["AgentIp"] = boost::any(*agentIp);
    }
    if (aggregateData) {
      res["AggregateData"] = aggregateData ? boost::any(aggregateData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (alarmRule) {
      res["AlarmRule"] = boost::any(*alarmRule);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (collectionTime) {
      res["CollectionTime"] = boost::any(*collectionTime);
    }
    if (dedicatedLine) {
      res["DedicatedLine"] = dedicatedLine ? boost::any(dedicatedLine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (firstAbnormalTime) {
      res["FirstAbnormalTime"] = boost::any(*firstAbnormalTime);
    }
    if (monitorItem) {
      res["MonitorItem"] = monitorItem ? boost::any(monitorItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (notificationSwitch) {
      res["NotificationSwitch"] = notificationSwitch ? boost::any(notificationSwitch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (portCollection) {
      res["PortCollection"] = portCollection ? boost::any(portCollection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (resourceApp) {
      res["ResourceApp"] = resourceApp ? boost::any(resourceApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceDevice) {
      res["ResourceDevice"] = resourceDevice ? boost::any(resourceDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalDataItem") != m.end() && !m["AbnormalDataItem"].empty()) {
      abnormalDataItem = make_shared<string>(boost::any_cast<string>(m["AbnormalDataItem"]));
    }
    if (m.find("AgentIp") != m.end() && !m["AgentIp"].empty()) {
      agentIp = make_shared<string>(boost::any_cast<string>(m["AgentIp"]));
    }
    if (m.find("AggregateData") != m.end() && !m["AggregateData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AggregateData"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusAggregateData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AggregateData"]));
        aggregateData = make_shared<GetAlarmStatusResponseBodyAlarmStatusAggregateData>(model1);
      }
    }
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AlarmRule") != m.end() && !m["AlarmRule"].empty()) {
      alarmRule = make_shared<string>(boost::any_cast<string>(m["AlarmRule"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CollectionTime") != m.end() && !m["CollectionTime"].empty()) {
      collectionTime = make_shared<string>(boost::any_cast<string>(m["CollectionTime"]));
    }
    if (m.find("DedicatedLine") != m.end() && !m["DedicatedLine"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedLine"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusDedicatedLine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedLine"]));
        dedicatedLine = make_shared<GetAlarmStatusResponseBodyAlarmStatusDedicatedLine>(model1);
      }
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("FirstAbnormalTime") != m.end() && !m["FirstAbnormalTime"].empty()) {
      firstAbnormalTime = make_shared<string>(boost::any_cast<string>(m["FirstAbnormalTime"]));
    }
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorItem"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusMonitorItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorItem"]));
        monitorItem = make_shared<GetAlarmStatusResponseBodyAlarmStatusMonitorItem>(model1);
      }
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NotificationSwitch") != m.end() && !m["NotificationSwitch"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSwitch"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSwitch"]));
        notificationSwitch = make_shared<GetAlarmStatusResponseBodyAlarmStatusNotificationSwitch>(model1);
      }
    }
    if (m.find("PortCollection") != m.end() && !m["PortCollection"].empty()) {
      if (typeid(map<string, boost::any>) == m["PortCollection"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusPortCollection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PortCollection"]));
        portCollection = make_shared<GetAlarmStatusResponseBodyAlarmStatusPortCollection>(model1);
      }
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("ResourceApp") != m.end() && !m["ResourceApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceApp"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusResourceApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceApp"]));
        resourceApp = make_shared<GetAlarmStatusResponseBodyAlarmStatusResourceApp>(model1);
      }
    }
    if (m.find("ResourceDevice") != m.end() && !m["ResourceDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDevice"].type()) {
        GetAlarmStatusResponseBodyAlarmStatusResourceDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDevice"]));
        resourceDevice = make_shared<GetAlarmStatusResponseBodyAlarmStatusResourceDevice>(model1);
      }
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~GetAlarmStatusResponseBodyAlarmStatus() = default;
};
class GetAlarmStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlarmStatusResponseBodyAlarmStatus> alarmStatus{};
  shared_ptr<string> requestId{};

  GetAlarmStatusResponseBody() {}

  explicit GetAlarmStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = alarmStatus ? boost::any(alarmStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmStatus"].type()) {
        GetAlarmStatusResponseBodyAlarmStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmStatus"]));
        alarmStatus = make_shared<GetAlarmStatusResponseBodyAlarmStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlarmStatusResponseBody() = default;
};
class GetAlarmStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlarmStatusResponseBody> body{};

  GetAlarmStatusResponse() {}

  explicit GetAlarmStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlarmStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlarmStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlarmStatusResponse() = default;
};
class GetConfigurationSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> instanceId{};

  GetConfigurationSpecificationRequest() {}

  explicit GetConfigurationSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetConfigurationSpecificationRequest() = default;
};
class GetConfigurationSpecificationResponseBodyConfigurationSpecification : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> mode{};
  shared_ptr<vector<string>> relatedVariate{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendor{};

  GetConfigurationSpecificationResponseBodyConfigurationSpecification() {}

  explicit GetConfigurationSpecificationResponseBodyConfigurationSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (relatedVariate) {
      res["RelatedVariate"] = boost::any(*relatedVariate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedVariate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedVariate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedVariate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetConfigurationSpecificationResponseBodyConfigurationSpecification() = default;
};
class GetConfigurationSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigurationSpecificationResponseBodyConfigurationSpecification> configurationSpecification{};
  shared_ptr<string> requestId{};

  GetConfigurationSpecificationResponseBody() {}

  explicit GetConfigurationSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationSpecification) {
      res["ConfigurationSpecification"] = configurationSpecification ? boost::any(configurationSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationSpecification") != m.end() && !m["ConfigurationSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigurationSpecification"].type()) {
        GetConfigurationSpecificationResponseBodyConfigurationSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigurationSpecification"]));
        configurationSpecification = make_shared<GetConfigurationSpecificationResponseBodyConfigurationSpecification>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigurationSpecificationResponseBody() = default;
};
class GetConfigurationSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigurationSpecificationResponseBody> body{};

  GetConfigurationSpecificationResponse() {}

  explicit GetConfigurationSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigurationSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigurationSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigurationSpecificationResponse() = default;
};
class GetConfigurationVariateRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> instanceId{};

  GetConfigurationVariateRequest() {}

  explicit GetConfigurationVariateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetConfigurationVariateRequest() = default;
};
class GetConfigurationVariateResponseBodyConfigurationVariate : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> formatFunction{};
  shared_ptr<string> variateName{};

  GetConfigurationVariateResponseBodyConfigurationVariate() {}

  explicit GetConfigurationVariateResponseBodyConfigurationVariate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (formatFunction) {
      res["FormatFunction"] = boost::any(*formatFunction);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FormatFunction") != m.end() && !m["FormatFunction"].empty()) {
      formatFunction = make_shared<string>(boost::any_cast<string>(m["FormatFunction"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~GetConfigurationVariateResponseBodyConfigurationVariate() = default;
};
class GetConfigurationVariateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigurationVariateResponseBodyConfigurationVariate> configurationVariate{};
  shared_ptr<string> requestId{};

  GetConfigurationVariateResponseBody() {}

  explicit GetConfigurationVariateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationVariate) {
      res["ConfigurationVariate"] = configurationVariate ? boost::any(configurationVariate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationVariate") != m.end() && !m["ConfigurationVariate"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigurationVariate"].type()) {
        GetConfigurationVariateResponseBodyConfigurationVariate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigurationVariate"]));
        configurationVariate = make_shared<GetConfigurationVariateResponseBodyConfigurationVariate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigurationVariateResponseBody() = default;
};
class GetConfigurationVariateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigurationVariateResponseBody> body{};

  GetConfigurationVariateResponse() {}

  explicit GetConfigurationVariateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigurationVariateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigurationVariateResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigurationVariateResponse() = default;
};
class GetDedicatedLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> instanceId{};

  GetDedicatedLineRequest() {}

  explicit GetDedicatedLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDedicatedLineRequest() = default;
};
class GetDedicatedLineResponseBodyDedicatedLine : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> dedicatedLineIp{};
  shared_ptr<string> dedicatedLineRole{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> isp{};
  shared_ptr<string> physicalSpaceId{};

  GetDedicatedLineResponseBodyDedicatedLine() {}

  explicit GetDedicatedLineResponseBodyDedicatedLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (dedicatedLineIp) {
      res["DedicatedLineIp"] = boost::any(*dedicatedLineIp);
    }
    if (dedicatedLineRole) {
      res["DedicatedLineRole"] = boost::any(*dedicatedLineRole);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DedicatedLineIp") != m.end() && !m["DedicatedLineIp"].empty()) {
      dedicatedLineIp = make_shared<string>(boost::any_cast<string>(m["DedicatedLineIp"]));
    }
    if (m.find("DedicatedLineRole") != m.end() && !m["DedicatedLineRole"].empty()) {
      dedicatedLineRole = make_shared<string>(boost::any_cast<string>(m["DedicatedLineRole"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~GetDedicatedLineResponseBodyDedicatedLine() = default;
};
class GetDedicatedLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDedicatedLineResponseBodyDedicatedLine> dedicatedLine{};
  shared_ptr<string> requestId{};

  GetDedicatedLineResponseBody() {}

  explicit GetDedicatedLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLine) {
      res["DedicatedLine"] = dedicatedLine ? boost::any(dedicatedLine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLine") != m.end() && !m["DedicatedLine"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedLine"].type()) {
        GetDedicatedLineResponseBodyDedicatedLine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedLine"]));
        dedicatedLine = make_shared<GetDedicatedLineResponseBodyDedicatedLine>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDedicatedLineResponseBody() = default;
};
class GetDedicatedLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDedicatedLineResponseBody> body{};

  GetDedicatedLineResponse() {}

  explicit GetDedicatedLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDedicatedLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDedicatedLineResponseBody>(model1);
      }
    }
  }


  virtual ~GetDedicatedLineResponse() = default;
};
class GetDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};

  GetDeviceRequest() {}

  explicit GetDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDeviceRequest() = default;
};
class GetDeviceResponseBodyDevice : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> mac{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> sn{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  GetDeviceResponseBodyDevice() {}

  explicit GetDeviceResponseBodyDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetDeviceResponseBodyDevice() = default;
};
class GetDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeviceResponseBodyDevice> device{};
  shared_ptr<string> requestId{};

  GetDeviceResponseBody() {}

  explicit GetDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = device ? boost::any(device->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(map<string, boost::any>) == m["Device"].type()) {
        GetDeviceResponseBodyDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Device"]));
        device = make_shared<GetDeviceResponseBodyDevice>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceResponseBody() = default;
};
class GetDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceResponseBody> body{};

  GetDeviceResponse() {}

  explicit GetDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceResponse() = default;
};
class GetDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};

  GetDeviceConfigRequest() {}

  explicit GetDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDeviceConfigRequest() = default;
};
class GetDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceConfig{};
  shared_ptr<string> requestId{};

  GetDeviceConfigResponseBody() {}

  explicit GetDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceConfig) {
      res["DeviceConfig"] = boost::any(*deviceConfig);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceConfig") != m.end() && !m["DeviceConfig"].empty()) {
      deviceConfig = make_shared<string>(boost::any_cast<string>(m["DeviceConfig"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceConfigResponseBody() = default;
};
class GetDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceConfigResponseBody> body{};

  GetDeviceConfigResponse() {}

  explicit GetDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceConfigResponse() = default;
};
class GetDeviceConfigDateRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};

  GetDeviceConfigDateRequest() {}

  explicit GetDeviceConfigDateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDeviceConfigDateRequest() = default;
};
class GetDeviceConfigDateResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceConfigDate{};
  shared_ptr<string> requestId{};

  GetDeviceConfigDateResponseBody() {}

  explicit GetDeviceConfigDateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceConfigDate) {
      res["DeviceConfigDate"] = boost::any(*deviceConfigDate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceConfigDate") != m.end() && !m["DeviceConfigDate"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceConfigDate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceConfigDate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceConfigDate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceConfigDateResponseBody() = default;
};
class GetDeviceConfigDateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceConfigDateResponseBody> body{};

  GetDeviceConfigDateResponse() {}

  explicit GetDeviceConfigDateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceConfigDateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceConfigDateResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceConfigDateResponse() = default;
};
class GetDeviceConfigDiffRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> endDate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startDate{};

  GetDeviceConfigDiffRequest() {}

  explicit GetDeviceConfigDiffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~GetDeviceConfigDiffRequest() = default;
};
class GetDeviceConfigDiffResponseBodyDeviceConfigDiff : public Darabonba::Model {
public:
  shared_ptr<string> extractDiff{};
  shared_ptr<string> totalDiff{};

  GetDeviceConfigDiffResponseBodyDeviceConfigDiff() {}

  explicit GetDeviceConfigDiffResponseBodyDeviceConfigDiff(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractDiff) {
      res["ExtractDiff"] = boost::any(*extractDiff);
    }
    if (totalDiff) {
      res["TotalDiff"] = boost::any(*totalDiff);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractDiff") != m.end() && !m["ExtractDiff"].empty()) {
      extractDiff = make_shared<string>(boost::any_cast<string>(m["ExtractDiff"]));
    }
    if (m.find("TotalDiff") != m.end() && !m["TotalDiff"].empty()) {
      totalDiff = make_shared<string>(boost::any_cast<string>(m["TotalDiff"]));
    }
  }


  virtual ~GetDeviceConfigDiffResponseBodyDeviceConfigDiff() = default;
};
class GetDeviceConfigDiffResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeviceConfigDiffResponseBodyDeviceConfigDiff> deviceConfigDiff{};
  shared_ptr<string> requestId{};

  GetDeviceConfigDiffResponseBody() {}

  explicit GetDeviceConfigDiffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceConfigDiff) {
      res["DeviceConfigDiff"] = deviceConfigDiff ? boost::any(deviceConfigDiff->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceConfigDiff") != m.end() && !m["DeviceConfigDiff"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceConfigDiff"].type()) {
        GetDeviceConfigDiffResponseBodyDeviceConfigDiff model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceConfigDiff"]));
        deviceConfigDiff = make_shared<GetDeviceConfigDiffResponseBodyDeviceConfigDiff>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceConfigDiffResponseBody() = default;
};
class GetDeviceConfigDiffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceConfigDiffResponseBody> body{};

  GetDeviceConfigDiffResponse() {}

  explicit GetDeviceConfigDiffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceConfigDiffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceConfigDiffResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceConfigDiffResponse() = default;
};
class GetDeviceFormRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};

  GetDeviceFormRequest() {}

  explicit GetDeviceFormRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDeviceFormRequest() = default;
};
class GetDeviceFormResponseBodyDeviceFormAttributeList : public Darabonba::Model {
public:
  shared_ptr<bool> attributeBuiltIn{};
  shared_ptr<string> attributeFormat{};
  shared_ptr<bool> attributeFuzzyQuery{};
  shared_ptr<string> attributeKey{};
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributePlaceholder{};
  shared_ptr<bool> attributeQuery{};
  shared_ptr<string> attributeReference{};
  shared_ptr<bool> attributeRequirement{};
  shared_ptr<long> attributeSequence{};
  shared_ptr<bool> attributeTableDisplay{};
  shared_ptr<string> attributeType{};
  shared_ptr<bool> attributeUniqueness{};

  GetDeviceFormResponseBodyDeviceFormAttributeList() {}

  explicit GetDeviceFormResponseBodyDeviceFormAttributeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeBuiltIn) {
      res["AttributeBuiltIn"] = boost::any(*attributeBuiltIn);
    }
    if (attributeFormat) {
      res["AttributeFormat"] = boost::any(*attributeFormat);
    }
    if (attributeFuzzyQuery) {
      res["AttributeFuzzyQuery"] = boost::any(*attributeFuzzyQuery);
    }
    if (attributeKey) {
      res["AttributeKey"] = boost::any(*attributeKey);
    }
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributePlaceholder) {
      res["AttributePlaceholder"] = boost::any(*attributePlaceholder);
    }
    if (attributeQuery) {
      res["AttributeQuery"] = boost::any(*attributeQuery);
    }
    if (attributeReference) {
      res["AttributeReference"] = boost::any(*attributeReference);
    }
    if (attributeRequirement) {
      res["AttributeRequirement"] = boost::any(*attributeRequirement);
    }
    if (attributeSequence) {
      res["AttributeSequence"] = boost::any(*attributeSequence);
    }
    if (attributeTableDisplay) {
      res["AttributeTableDisplay"] = boost::any(*attributeTableDisplay);
    }
    if (attributeType) {
      res["AttributeType"] = boost::any(*attributeType);
    }
    if (attributeUniqueness) {
      res["AttributeUniqueness"] = boost::any(*attributeUniqueness);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeBuiltIn") != m.end() && !m["AttributeBuiltIn"].empty()) {
      attributeBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["AttributeBuiltIn"]));
    }
    if (m.find("AttributeFormat") != m.end() && !m["AttributeFormat"].empty()) {
      attributeFormat = make_shared<string>(boost::any_cast<string>(m["AttributeFormat"]));
    }
    if (m.find("AttributeFuzzyQuery") != m.end() && !m["AttributeFuzzyQuery"].empty()) {
      attributeFuzzyQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeFuzzyQuery"]));
    }
    if (m.find("AttributeKey") != m.end() && !m["AttributeKey"].empty()) {
      attributeKey = make_shared<string>(boost::any_cast<string>(m["AttributeKey"]));
    }
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributePlaceholder") != m.end() && !m["AttributePlaceholder"].empty()) {
      attributePlaceholder = make_shared<string>(boost::any_cast<string>(m["AttributePlaceholder"]));
    }
    if (m.find("AttributeQuery") != m.end() && !m["AttributeQuery"].empty()) {
      attributeQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeQuery"]));
    }
    if (m.find("AttributeReference") != m.end() && !m["AttributeReference"].empty()) {
      attributeReference = make_shared<string>(boost::any_cast<string>(m["AttributeReference"]));
    }
    if (m.find("AttributeRequirement") != m.end() && !m["AttributeRequirement"].empty()) {
      attributeRequirement = make_shared<bool>(boost::any_cast<bool>(m["AttributeRequirement"]));
    }
    if (m.find("AttributeSequence") != m.end() && !m["AttributeSequence"].empty()) {
      attributeSequence = make_shared<long>(boost::any_cast<long>(m["AttributeSequence"]));
    }
    if (m.find("AttributeTableDisplay") != m.end() && !m["AttributeTableDisplay"].empty()) {
      attributeTableDisplay = make_shared<bool>(boost::any_cast<bool>(m["AttributeTableDisplay"]));
    }
    if (m.find("AttributeType") != m.end() && !m["AttributeType"].empty()) {
      attributeType = make_shared<string>(boost::any_cast<string>(m["AttributeType"]));
    }
    if (m.find("AttributeUniqueness") != m.end() && !m["AttributeUniqueness"].empty()) {
      attributeUniqueness = make_shared<bool>(boost::any_cast<bool>(m["AttributeUniqueness"]));
    }
  }


  virtual ~GetDeviceFormResponseBodyDeviceFormAttributeList() = default;
};
class GetDeviceFormResponseBodyDeviceForm : public Darabonba::Model {
public:
  shared_ptr<bool> accountConfig{};
  shared_ptr<vector<GetDeviceFormResponseBodyDeviceFormAttributeList>> attributeList{};
  shared_ptr<bool> configCompare{};
  shared_ptr<bool> detailDisplay{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<bool> formBuiltIn{};
  shared_ptr<string> resourceUse{};
  shared_ptr<string> script{};
  shared_ptr<string> uniqueKey{};

  GetDeviceFormResponseBodyDeviceForm() {}

  explicit GetDeviceFormResponseBodyDeviceForm(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (attributeList) {
      vector<boost::any> temp1;
      for(auto item1:*attributeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeList"] = boost::any(temp1);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (detailDisplay) {
      res["DetailDisplay"] = boost::any(*detailDisplay);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (formBuiltIn) {
      res["FormBuiltIn"] = boost::any(*formBuiltIn);
    }
    if (resourceUse) {
      res["ResourceUse"] = boost::any(*resourceUse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<bool>(boost::any_cast<bool>(m["AccountConfig"]));
    }
    if (m.find("AttributeList") != m.end() && !m["AttributeList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeList"].type()) {
        vector<GetDeviceFormResponseBodyDeviceFormAttributeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeviceFormResponseBodyDeviceFormAttributeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeList = make_shared<vector<GetDeviceFormResponseBodyDeviceFormAttributeList>>(expect1);
      }
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<bool>(boost::any_cast<bool>(m["ConfigCompare"]));
    }
    if (m.find("DetailDisplay") != m.end() && !m["DetailDisplay"].empty()) {
      detailDisplay = make_shared<bool>(boost::any_cast<bool>(m["DetailDisplay"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("FormBuiltIn") != m.end() && !m["FormBuiltIn"].empty()) {
      formBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["FormBuiltIn"]));
    }
    if (m.find("ResourceUse") != m.end() && !m["ResourceUse"].empty()) {
      resourceUse = make_shared<string>(boost::any_cast<string>(m["ResourceUse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~GetDeviceFormResponseBodyDeviceForm() = default;
};
class GetDeviceFormResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeviceFormResponseBodyDeviceForm> deviceForm{};
  shared_ptr<string> requestId{};

  GetDeviceFormResponseBody() {}

  explicit GetDeviceFormResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceForm) {
      res["DeviceForm"] = deviceForm ? boost::any(deviceForm->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceForm"].type()) {
        GetDeviceFormResponseBodyDeviceForm model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceForm"]));
        deviceForm = make_shared<GetDeviceFormResponseBodyDeviceForm>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceFormResponseBody() = default;
};
class GetDeviceFormResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceFormResponseBody> body{};

  GetDeviceFormResponse() {}

  explicit GetDeviceFormResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceFormResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceFormResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceFormResponse() = default;
};
class GetDeviceOpLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  GetDeviceOpLogRequest() {}

  explicit GetDeviceOpLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~GetDeviceOpLogRequest() = default;
};
class GetDeviceOpLogResponseBodyOperationLogs : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> gmtModifiedTime{};
  shared_ptr<string> keyword{};
  shared_ptr<string> newValue{};
  shared_ptr<string> oldValue{};
  shared_ptr<string> operator_{};

  GetDeviceOpLogResponseBodyOperationLogs() {}

  explicit GetDeviceOpLogResponseBodyOperationLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (gmtModifiedTime) {
      res["GmtModifiedTime"] = boost::any(*gmtModifiedTime);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (oldValue) {
      res["OldValue"] = boost::any(*oldValue);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GmtModifiedTime") != m.end() && !m["GmtModifiedTime"].empty()) {
      gmtModifiedTime = make_shared<string>(boost::any_cast<string>(m["GmtModifiedTime"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("OldValue") != m.end() && !m["OldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["OldValue"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
  }


  virtual ~GetDeviceOpLogResponseBodyOperationLogs() = default;
};
class GetDeviceOpLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<vector<GetDeviceOpLogResponseBodyOperationLogs>> operationLogs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetDeviceOpLogResponseBody() {}

  explicit GetDeviceOpLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (operationLogs) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("OperationLogs") != m.end() && !m["OperationLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogs"].type()) {
        vector<GetDeviceOpLogResponseBodyOperationLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeviceOpLogResponseBodyOperationLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogs = make_shared<vector<GetDeviceOpLogResponseBodyOperationLogs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetDeviceOpLogResponseBody() = default;
};
class GetDeviceOpLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceOpLogResponseBody> body{};

  GetDeviceOpLogResponse() {}

  explicit GetDeviceOpLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceOpLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceOpLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceOpLogResponse() = default;
};
class GetDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyKey{};

  GetDevicePropertyRequest() {}

  explicit GetDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
  }


  virtual ~GetDevicePropertyRequest() = default;
};
class GetDevicePropertyResponseBodyDeviceProperty : public Darabonba::Model {
public:
  shared_ptr<bool> builtIn{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> propertyContent{};
  shared_ptr<string> propertyFormat{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> propertyName{};

  GetDevicePropertyResponseBodyDeviceProperty() {}

  explicit GetDevicePropertyResponseBodyDeviceProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (builtIn) {
      res["BuiltIn"] = boost::any(*builtIn);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (propertyContent) {
      res["PropertyContent"] = boost::any(*propertyContent);
    }
    if (propertyFormat) {
      res["PropertyFormat"] = boost::any(*propertyFormat);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuiltIn") != m.end() && !m["BuiltIn"].empty()) {
      builtIn = make_shared<bool>(boost::any_cast<bool>(m["BuiltIn"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("PropertyContent") != m.end() && !m["PropertyContent"].empty()) {
      propertyContent = make_shared<string>(boost::any_cast<string>(m["PropertyContent"]));
    }
    if (m.find("PropertyFormat") != m.end() && !m["PropertyFormat"].empty()) {
      propertyFormat = make_shared<string>(boost::any_cast<string>(m["PropertyFormat"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
  }


  virtual ~GetDevicePropertyResponseBodyDeviceProperty() = default;
};
class GetDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDevicePropertyResponseBodyDeviceProperty> deviceProperty{};
  shared_ptr<string> requestId{};

  GetDevicePropertyResponseBody() {}

  explicit GetDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceProperty) {
      res["DeviceProperty"] = deviceProperty ? boost::any(deviceProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceProperty") != m.end() && !m["DeviceProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceProperty"].type()) {
        GetDevicePropertyResponseBodyDeviceProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceProperty"]));
        deviceProperty = make_shared<GetDevicePropertyResponseBodyDeviceProperty>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDevicePropertyResponseBody() = default;
};
class GetDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDevicePropertyResponseBody> body{};

  GetDevicePropertyResponse() {}

  explicit GetDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~GetDevicePropertyResponse() = default;
};
class GetDeviceResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> instanceId{};

  GetDeviceResourceRequest() {}

  explicit GetDeviceResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDeviceResourceRequest() = default;
};
class GetDeviceResourceResponseBodyDeviceResource : public Darabonba::Model {
public:
  shared_ptr<string> blockNumber{};
  shared_ptr<string> business{};
  shared_ptr<string> config{};
  shared_ptr<string> configTaskStatus{};
  shared_ptr<string> deliveryIp{};
  shared_ptr<string> deviceNum{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> generateConfig{};
  shared_ptr<string> hostName{};
  shared_ptr<string> interConnection{};
  shared_ptr<string> location{};
  shared_ptr<string> loopback{};
  shared_ptr<string> managerIp{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> sn{};
  shared_ptr<bool> stack{};
  shared_ptr<string> vendor{};

  GetDeviceResourceResponseBodyDeviceResource() {}

  explicit GetDeviceResourceResponseBodyDeviceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockNumber) {
      res["BlockNumber"] = boost::any(*blockNumber);
    }
    if (business) {
      res["Business"] = boost::any(*business);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (configTaskStatus) {
      res["ConfigTaskStatus"] = boost::any(*configTaskStatus);
    }
    if (deliveryIp) {
      res["DeliveryIp"] = boost::any(*deliveryIp);
    }
    if (deviceNum) {
      res["DeviceNum"] = boost::any(*deviceNum);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (generateConfig) {
      res["GenerateConfig"] = boost::any(*generateConfig);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (interConnection) {
      res["InterConnection"] = boost::any(*interConnection);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (loopback) {
      res["Loopback"] = boost::any(*loopback);
    }
    if (managerIp) {
      res["ManagerIp"] = boost::any(*managerIp);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (stack) {
      res["Stack"] = boost::any(*stack);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockNumber") != m.end() && !m["BlockNumber"].empty()) {
      blockNumber = make_shared<string>(boost::any_cast<string>(m["BlockNumber"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      business = make_shared<string>(boost::any_cast<string>(m["Business"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ConfigTaskStatus") != m.end() && !m["ConfigTaskStatus"].empty()) {
      configTaskStatus = make_shared<string>(boost::any_cast<string>(m["ConfigTaskStatus"]));
    }
    if (m.find("DeliveryIp") != m.end() && !m["DeliveryIp"].empty()) {
      deliveryIp = make_shared<string>(boost::any_cast<string>(m["DeliveryIp"]));
    }
    if (m.find("DeviceNum") != m.end() && !m["DeviceNum"].empty()) {
      deviceNum = make_shared<string>(boost::any_cast<string>(m["DeviceNum"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("GenerateConfig") != m.end() && !m["GenerateConfig"].empty()) {
      generateConfig = make_shared<string>(boost::any_cast<string>(m["GenerateConfig"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InterConnection") != m.end() && !m["InterConnection"].empty()) {
      interConnection = make_shared<string>(boost::any_cast<string>(m["InterConnection"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Loopback") != m.end() && !m["Loopback"].empty()) {
      loopback = make_shared<string>(boost::any_cast<string>(m["Loopback"]));
    }
    if (m.find("ManagerIp") != m.end() && !m["ManagerIp"].empty()) {
      managerIp = make_shared<string>(boost::any_cast<string>(m["ManagerIp"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("Stack") != m.end() && !m["Stack"].empty()) {
      stack = make_shared<bool>(boost::any_cast<bool>(m["Stack"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetDeviceResourceResponseBodyDeviceResource() = default;
};
class GetDeviceResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeviceResourceResponseBodyDeviceResource> deviceResource{};
  shared_ptr<string> requestId{};

  GetDeviceResourceResponseBody() {}

  explicit GetDeviceResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResource) {
      res["DeviceResource"] = deviceResource ? boost::any(deviceResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResource") != m.end() && !m["DeviceResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceResource"].type()) {
        GetDeviceResourceResponseBodyDeviceResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceResource"]));
        deviceResource = make_shared<GetDeviceResourceResponseBodyDeviceResource>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceResourceResponseBody() = default;
};
class GetDeviceResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceResourceResponseBody> body{};

  GetDeviceResourceResponse() {}

  explicit GetDeviceResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceResourceResponse() = default;
};
class GetInspectionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> taskId{};

  GetInspectionTaskRequest() {}

  explicit GetInspectionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetInspectionTaskRequest() = default;
};
class GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules : public Darabonba::Model {
public:
  shared_ptr<string> actualValue{};
  shared_ptr<string> expression{};
  shared_ptr<string> level{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules() {}

  explicit GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualValue) {
      res["ActualValue"] = boost::any(*actualValue);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualValue") != m.end() && !m["ActualValue"].empty()) {
      actualValue = make_shared<string>(boost::any_cast<string>(m["ActualValue"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules() = default;
};
class GetInspectionTaskResponseBodyInspectionTask : public Darabonba::Model {
public:
  shared_ptr<string> deviceDisplay{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> executionBeginTime{};
  shared_ptr<string> executionEndTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> IP{};
  shared_ptr<vector<GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules>> inspectionAlarmRules{};
  shared_ptr<string> inspectionResult{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<vector<string>> model{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> space{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> vendor{};

  GetInspectionTaskResponseBodyInspectionTask() {}

  explicit GetInspectionTaskResponseBodyInspectionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceDisplay) {
      res["DeviceDisplay"] = boost::any(*deviceDisplay);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (executionBeginTime) {
      res["ExecutionBeginTime"] = boost::any(*executionBeginTime);
    }
    if (executionEndTime) {
      res["ExecutionEndTime"] = boost::any(*executionEndTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (inspectionAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionAlarmRules"] = boost::any(temp1);
    }
    if (inspectionResult) {
      res["InspectionResult"] = boost::any(*inspectionResult);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceDisplay") != m.end() && !m["DeviceDisplay"].empty()) {
      deviceDisplay = make_shared<string>(boost::any_cast<string>(m["DeviceDisplay"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ExecutionBeginTime") != m.end() && !m["ExecutionBeginTime"].empty()) {
      executionBeginTime = make_shared<string>(boost::any_cast<string>(m["ExecutionBeginTime"]));
    }
    if (m.find("ExecutionEndTime") != m.end() && !m["ExecutionEndTime"].empty()) {
      executionEndTime = make_shared<string>(boost::any_cast<string>(m["ExecutionEndTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InspectionAlarmRules") != m.end() && !m["InspectionAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionAlarmRules"].type()) {
        vector<GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionAlarmRules = make_shared<vector<GetInspectionTaskResponseBodyInspectionTaskInspectionAlarmRules>>(expect1);
      }
    }
    if (m.find("InspectionResult") != m.end() && !m["InspectionResult"].empty()) {
      inspectionResult = make_shared<string>(boost::any_cast<string>(m["InspectionResult"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Model"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      model = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetInspectionTaskResponseBodyInspectionTask() = default;
};
class GetInspectionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInspectionTaskResponseBodyInspectionTask> inspectionTask{};
  shared_ptr<string> requestId{};

  GetInspectionTaskResponseBody() {}

  explicit GetInspectionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionTask) {
      res["InspectionTask"] = inspectionTask ? boost::any(inspectionTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionTask") != m.end() && !m["InspectionTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["InspectionTask"].type()) {
        GetInspectionTaskResponseBodyInspectionTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InspectionTask"]));
        inspectionTask = make_shared<GetInspectionTaskResponseBodyInspectionTask>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInspectionTaskResponseBody() = default;
};
class GetInspectionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInspectionTaskResponseBody> body{};

  GetInspectionTaskResponse() {}

  explicit GetInspectionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInspectionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInspectionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetInspectionTaskResponse() = default;
};
class GetMonitorItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorItemId{};

  GetMonitorItemRequest() {}

  explicit GetMonitorItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
  }


  virtual ~GetMonitorItemRequest() = default;
};
class GetMonitorItemResponseBodyMonitorItemAlarmRuleList : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> expression{};
  shared_ptr<string> value{};
  shared_ptr<string> variable{};

  GetMonitorItemResponseBodyMonitorItemAlarmRuleList() {}

  explicit GetMonitorItemResponseBodyMonitorItemAlarmRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (variable) {
      res["Variable"] = boost::any(*variable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Variable") != m.end() && !m["Variable"].empty()) {
      variable = make_shared<string>(boost::any_cast<string>(m["Variable"]));
    }
  }


  virtual ~GetMonitorItemResponseBodyMonitorItemAlarmRuleList() = default;
};
class GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> expression{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> value{};
  shared_ptr<string> variable{};

  GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList() {}

  explicit GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (variable) {
      res["Variable"] = boost::any(*variable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Variable") != m.end() && !m["Variable"].empty()) {
      variable = make_shared<string>(boost::any_cast<string>(m["Variable"]));
    }
  }


  virtual ~GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList() = default;
};
class GetMonitorItemResponseBodyMonitorItem : public Darabonba::Model {
public:
  shared_ptr<vector<GetMonitorItemResponseBodyMonitorItemAlarmRuleList>> alarmRuleList{};
  shared_ptr<string> analysisCode{};
  shared_ptr<string> collectionType{};
  shared_ptr<string> config{};
  shared_ptr<string> createTime{};
  shared_ptr<string> dataItem{};
  shared_ptr<string> deviceForm{};
  shared_ptr<long> effective{};
  shared_ptr<long> execInterval{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> monitorItemName{};
  shared_ptr<vector<GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList>> personalizedAlarmRuleList{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  GetMonitorItemResponseBodyMonitorItem() {}

  explicit GetMonitorItemResponseBodyMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*alarmRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmRuleList"] = boost::any(temp1);
    }
    if (analysisCode) {
      res["AnalysisCode"] = boost::any(*analysisCode);
    }
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (effective) {
      res["Effective"] = boost::any(*effective);
    }
    if (execInterval) {
      res["ExecInterval"] = boost::any(*execInterval);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    if (personalizedAlarmRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*personalizedAlarmRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PersonalizedAlarmRuleList"] = boost::any(temp1);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmRuleList") != m.end() && !m["AlarmRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmRuleList"].type()) {
        vector<GetMonitorItemResponseBodyMonitorItemAlarmRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMonitorItemResponseBodyMonitorItemAlarmRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmRuleList = make_shared<vector<GetMonitorItemResponseBodyMonitorItemAlarmRuleList>>(expect1);
      }
    }
    if (m.find("AnalysisCode") != m.end() && !m["AnalysisCode"].empty()) {
      analysisCode = make_shared<string>(boost::any_cast<string>(m["AnalysisCode"]));
    }
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("Effective") != m.end() && !m["Effective"].empty()) {
      effective = make_shared<long>(boost::any_cast<long>(m["Effective"]));
    }
    if (m.find("ExecInterval") != m.end() && !m["ExecInterval"].empty()) {
      execInterval = make_shared<long>(boost::any_cast<long>(m["ExecInterval"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
    if (m.find("PersonalizedAlarmRuleList") != m.end() && !m["PersonalizedAlarmRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["PersonalizedAlarmRuleList"].type()) {
        vector<GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PersonalizedAlarmRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        personalizedAlarmRuleList = make_shared<vector<GetMonitorItemResponseBodyMonitorItemPersonalizedAlarmRuleList>>(expect1);
      }
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetMonitorItemResponseBodyMonitorItem() = default;
};
class GetMonitorItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMonitorItemResponseBodyMonitorItem> monitorItem{};
  shared_ptr<string> requestId{};

  GetMonitorItemResponseBody() {}

  explicit GetMonitorItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      res["MonitorItem"] = monitorItem ? boost::any(monitorItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorItem"].type()) {
        GetMonitorItemResponseBodyMonitorItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorItem"]));
        monitorItem = make_shared<GetMonitorItemResponseBodyMonitorItem>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMonitorItemResponseBody() = default;
};
class GetMonitorItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMonitorItemResponseBody> body{};

  GetMonitorItemResponse() {}

  explicit GetMonitorItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMonitorItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMonitorItemResponseBody>(model1);
      }
    }
  }


  virtual ~GetMonitorItemResponse() = default;
};
class GetOsDownloadPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> osVersionId{};

  GetOsDownloadPathRequest() {}

  explicit GetOsDownloadPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
  }


  virtual ~GetOsDownloadPathRequest() = default;
};
class GetOsDownloadPathResponseBodyOsVersion : public Darabonba::Model {
public:
  shared_ptr<string> downloadPath{};

  GetOsDownloadPathResponseBodyOsVersion() {}

  explicit GetOsDownloadPathResponseBodyOsVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = boost::any(*downloadPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      downloadPath = make_shared<string>(boost::any_cast<string>(m["DownloadPath"]));
    }
  }


  virtual ~GetOsDownloadPathResponseBodyOsVersion() = default;
};
class GetOsDownloadPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOsDownloadPathResponseBodyOsVersion> osVersion{};
  shared_ptr<string> requestId{};

  GetOsDownloadPathResponseBody() {}

  explicit GetOsDownloadPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osVersion) {
      res["OsVersion"] = osVersion ? boost::any(osVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["OsVersion"].type()) {
        GetOsDownloadPathResponseBodyOsVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OsVersion"]));
        osVersion = make_shared<GetOsDownloadPathResponseBodyOsVersion>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOsDownloadPathResponseBody() = default;
};
class GetOsDownloadPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOsDownloadPathResponseBody> body{};

  GetOsDownloadPathResponse() {}

  explicit GetOsDownloadPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOsDownloadPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOsDownloadPathResponseBody>(model1);
      }
    }
  }


  virtual ~GetOsDownloadPathResponse() = default;
};
class GetOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> osVersionId{};

  GetOsVersionRequest() {}

  explicit GetOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
  }


  virtual ~GetOsVersionRequest() = default;
};
class GetOsVersionResponseBodyOsVersion : public Darabonba::Model {
public:
  shared_ptr<string> downloadPath{};

  GetOsVersionResponseBodyOsVersion() {}

  explicit GetOsVersionResponseBodyOsVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = boost::any(*downloadPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      downloadPath = make_shared<string>(boost::any_cast<string>(m["DownloadPath"]));
    }
  }


  virtual ~GetOsVersionResponseBodyOsVersion() = default;
};
class GetOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetOsVersionResponseBodyOsVersion>> osVersion{};
  shared_ptr<string> requestId{};

  GetOsVersionResponseBody() {}

  explicit GetOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osVersion) {
      vector<boost::any> temp1;
      for(auto item1:*osVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OsVersion"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["OsVersion"].type()) {
        vector<GetOsVersionResponseBodyOsVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OsVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOsVersionResponseBodyOsVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        osVersion = make_shared<vector<GetOsVersionResponseBodyOsVersion>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOsVersionResponseBody() = default;
};
class GetOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOsVersionResponseBody> body{};

  GetOsVersionResponse() {}

  explicit GetOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetOsVersionResponse() = default;
};
class GetOssPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};

  GetOssPolicyRequest() {}

  explicit GetOssPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOssPolicyRequest() = default;
};
class GetOssPolicyResponseBodyOssPolicy : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> directory{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetOssPolicyResponseBodyOssPolicy() {}

  explicit GetOssPolicyResponseBodyOssPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetOssPolicyResponseBodyOssPolicy() = default;
};
class GetOssPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOssPolicyResponseBodyOssPolicy> ossPolicy{};
  shared_ptr<string> requestId{};

  GetOssPolicyResponseBody() {}

  explicit GetOssPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossPolicy) {
      res["OssPolicy"] = ossPolicy ? boost::any(ossPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssPolicy") != m.end() && !m["OssPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssPolicy"].type()) {
        GetOssPolicyResponseBodyOssPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssPolicy"]));
        ossPolicy = make_shared<GetOssPolicyResponseBodyOssPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOssPolicyResponseBody() = default;
};
class GetOssPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOssPolicyResponseBody> body{};

  GetOssPolicyResponse() {}

  explicit GetOssPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOssPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOssPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GetOssPolicyResponse() = default;
};
class GetPhysicalSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> physicalSpaceId{};

  GetPhysicalSpaceRequest() {}

  explicit GetPhysicalSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~GetPhysicalSpaceRequest() = default;
};
class GetPhysicalSpaceResponseBodyPhysicalSpace : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> owner{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> securityDomainList{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};

  GetPhysicalSpaceResponseBodyPhysicalSpace() {}

  explicit GetPhysicalSpaceResponseBodyPhysicalSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainList) {
      res["SecurityDomainList"] = boost::any(*securityDomainList);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomainList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomainList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomainList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~GetPhysicalSpaceResponseBodyPhysicalSpace() = default;
};
class GetPhysicalSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPhysicalSpaceResponseBodyPhysicalSpace> physicalSpace{};
  shared_ptr<string> requestId{};

  GetPhysicalSpaceResponseBody() {}

  explicit GetPhysicalSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalSpace) {
      res["PhysicalSpace"] = physicalSpace ? boost::any(physicalSpace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalSpace") != m.end() && !m["PhysicalSpace"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhysicalSpace"].type()) {
        GetPhysicalSpaceResponseBodyPhysicalSpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhysicalSpace"]));
        physicalSpace = make_shared<GetPhysicalSpaceResponseBodyPhysicalSpace>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPhysicalSpaceResponseBody() = default;
};
class GetPhysicalSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalSpaceResponseBody> body{};

  GetPhysicalSpaceResponse() {}

  explicit GetPhysicalSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalSpaceResponse() = default;
};
class GetPhysicalSpaceTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> topoType{};

  GetPhysicalSpaceTopoRequest() {}

  explicit GetPhysicalSpaceTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (topoType) {
      res["TopoType"] = boost::any(*topoType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("TopoType") != m.end() && !m["TopoType"].empty()) {
      topoType = make_shared<string>(boost::any_cast<string>(m["TopoType"]));
    }
  }


  virtual ~GetPhysicalSpaceTopoRequest() = default;
};
class GetPhysicalSpaceTopoResponseBodyTopoDataDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceRole{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};

  GetPhysicalSpaceTopoResponseBodyTopoDataDevices() {}

  explicit GetPhysicalSpaceTopoResponseBodyTopoDataDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceRole) {
      res["DeviceRole"] = boost::any(*deviceRole);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceRole") != m.end() && !m["DeviceRole"].empty()) {
      deviceRole = make_shared<string>(boost::any_cast<string>(m["DeviceRole"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~GetPhysicalSpaceTopoResponseBodyTopoDataDevices() = default;
};
class GetPhysicalSpaceTopoResponseBodyTopoDataLinks : public Darabonba::Model {
public:
  shared_ptr<string> sourceDeviceId{};
  shared_ptr<string> sourceDeviceName{};
  shared_ptr<string> sourcePort{};
  shared_ptr<string> targetDeviceId{};
  shared_ptr<string> targetDeviceName{};
  shared_ptr<string> targetPort{};

  GetPhysicalSpaceTopoResponseBodyTopoDataLinks() {}

  explicit GetPhysicalSpaceTopoResponseBodyTopoDataLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceDeviceId) {
      res["SourceDeviceId"] = boost::any(*sourceDeviceId);
    }
    if (sourceDeviceName) {
      res["SourceDeviceName"] = boost::any(*sourceDeviceName);
    }
    if (sourcePort) {
      res["SourcePort"] = boost::any(*sourcePort);
    }
    if (targetDeviceId) {
      res["TargetDeviceId"] = boost::any(*targetDeviceId);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceDeviceId") != m.end() && !m["SourceDeviceId"].empty()) {
      sourceDeviceId = make_shared<string>(boost::any_cast<string>(m["SourceDeviceId"]));
    }
    if (m.find("SourceDeviceName") != m.end() && !m["SourceDeviceName"].empty()) {
      sourceDeviceName = make_shared<string>(boost::any_cast<string>(m["SourceDeviceName"]));
    }
    if (m.find("SourcePort") != m.end() && !m["SourcePort"].empty()) {
      sourcePort = make_shared<string>(boost::any_cast<string>(m["SourcePort"]));
    }
    if (m.find("TargetDeviceId") != m.end() && !m["TargetDeviceId"].empty()) {
      targetDeviceId = make_shared<string>(boost::any_cast<string>(m["TargetDeviceId"]));
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      targetDeviceName = make_shared<string>(boost::any_cast<string>(m["TargetDeviceName"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<string>(boost::any_cast<string>(m["TargetPort"]));
    }
  }


  virtual ~GetPhysicalSpaceTopoResponseBodyTopoDataLinks() = default;
};
class GetPhysicalSpaceTopoResponseBodyTopoData : public Darabonba::Model {
public:
  shared_ptr<vector<GetPhysicalSpaceTopoResponseBodyTopoDataDevices>> devices{};
  shared_ptr<vector<GetPhysicalSpaceTopoResponseBodyTopoDataLinks>> links{};
  shared_ptr<string> updateTime{};

  GetPhysicalSpaceTopoResponseBodyTopoData() {}

  explicit GetPhysicalSpaceTopoResponseBodyTopoData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (links) {
      vector<boost::any> temp1;
      for(auto item1:*links){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Links"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<GetPhysicalSpaceTopoResponseBodyTopoDataDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPhysicalSpaceTopoResponseBodyTopoDataDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<GetPhysicalSpaceTopoResponseBodyTopoDataDevices>>(expect1);
      }
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      if (typeid(vector<boost::any>) == m["Links"].type()) {
        vector<GetPhysicalSpaceTopoResponseBodyTopoDataLinks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Links"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPhysicalSpaceTopoResponseBodyTopoDataLinks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        links = make_shared<vector<GetPhysicalSpaceTopoResponseBodyTopoDataLinks>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetPhysicalSpaceTopoResponseBodyTopoData() = default;
};
class GetPhysicalSpaceTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetPhysicalSpaceTopoResponseBodyTopoData> topoData{};

  GetPhysicalSpaceTopoResponseBody() {}

  explicit GetPhysicalSpaceTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topoData) {
      res["TopoData"] = topoData ? boost::any(topoData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TopoData") != m.end() && !m["TopoData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopoData"].type()) {
        GetPhysicalSpaceTopoResponseBodyTopoData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopoData"]));
        topoData = make_shared<GetPhysicalSpaceTopoResponseBodyTopoData>(model1);
      }
    }
  }


  virtual ~GetPhysicalSpaceTopoResponseBody() = default;
};
class GetPhysicalSpaceTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalSpaceTopoResponseBody> body{};

  GetPhysicalSpaceTopoResponse() {}

  explicit GetPhysicalSpaceTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalSpaceTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalSpaceTopoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalSpaceTopoResponse() = default;
};
class GetRealtimeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  GetRealtimeTaskRequest() {}

  explicit GetRealtimeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetRealtimeTaskRequest() = default;
};
class GetRealtimeTaskResponseBodyInspectionTask : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> inspectionMessage{};
  shared_ptr<string> inspectionResult{};
  shared_ptr<string> taskStatus{};

  GetRealtimeTaskResponseBodyInspectionTask() {}

  explicit GetRealtimeTaskResponseBodyInspectionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (inspectionMessage) {
      res["InspectionMessage"] = boost::any(*inspectionMessage);
    }
    if (inspectionResult) {
      res["InspectionResult"] = boost::any(*inspectionResult);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InspectionMessage") != m.end() && !m["InspectionMessage"].empty()) {
      inspectionMessage = make_shared<string>(boost::any_cast<string>(m["InspectionMessage"]));
    }
    if (m.find("InspectionResult") != m.end() && !m["InspectionResult"].empty()) {
      inspectionResult = make_shared<string>(boost::any_cast<string>(m["InspectionResult"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GetRealtimeTaskResponseBodyInspectionTask() = default;
};
class GetRealtimeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRealtimeTaskResponseBodyInspectionTask> inspectionTask{};
  shared_ptr<string> requestId{};

  GetRealtimeTaskResponseBody() {}

  explicit GetRealtimeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionTask) {
      res["InspectionTask"] = inspectionTask ? boost::any(inspectionTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionTask") != m.end() && !m["InspectionTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["InspectionTask"].type()) {
        GetRealtimeTaskResponseBodyInspectionTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InspectionTask"]));
        inspectionTask = make_shared<GetRealtimeTaskResponseBodyInspectionTask>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeTaskResponseBody() = default;
};
class GetRealtimeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeTaskResponseBody> body{};

  GetRealtimeTaskResponse() {}

  explicit GetRealtimeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeTaskResponse() = default;
};
class GetScheduleWorkerRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scheduleWorkerId{};

  GetScheduleWorkerRequest() {}

  explicit GetScheduleWorkerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scheduleWorkerId) {
      res["ScheduleWorkerId"] = boost::any(*scheduleWorkerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScheduleWorkerId") != m.end() && !m["ScheduleWorkerId"].empty()) {
      scheduleWorkerId = make_shared<string>(boost::any_cast<string>(m["ScheduleWorkerId"]));
    }
  }


  virtual ~GetScheduleWorkerRequest() = default;
};
class GetScheduleWorkerResponseBodyScheduleWorker : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> scheduleWorkerId{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> workerContact{};
  shared_ptr<string> workerId{};
  shared_ptr<string> workerName{};

  GetScheduleWorkerResponseBodyScheduleWorker() {}

  explicit GetScheduleWorkerResponseBodyScheduleWorker(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (scheduleWorkerId) {
      res["ScheduleWorkerId"] = boost::any(*scheduleWorkerId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workerContact) {
      res["WorkerContact"] = boost::any(*workerContact);
    }
    if (workerId) {
      res["WorkerId"] = boost::any(*workerId);
    }
    if (workerName) {
      res["WorkerName"] = boost::any(*workerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ScheduleWorkerId") != m.end() && !m["ScheduleWorkerId"].empty()) {
      scheduleWorkerId = make_shared<string>(boost::any_cast<string>(m["ScheduleWorkerId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("WorkerContact") != m.end() && !m["WorkerContact"].empty()) {
      workerContact = make_shared<string>(boost::any_cast<string>(m["WorkerContact"]));
    }
    if (m.find("WorkerId") != m.end() && !m["WorkerId"].empty()) {
      workerId = make_shared<string>(boost::any_cast<string>(m["WorkerId"]));
    }
    if (m.find("WorkerName") != m.end() && !m["WorkerName"].empty()) {
      workerName = make_shared<string>(boost::any_cast<string>(m["WorkerName"]));
    }
  }


  virtual ~GetScheduleWorkerResponseBodyScheduleWorker() = default;
};
class GetScheduleWorkerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetScheduleWorkerResponseBodyScheduleWorker> scheduleWorker{};

  GetScheduleWorkerResponseBody() {}

  explicit GetScheduleWorkerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleWorker) {
      res["ScheduleWorker"] = scheduleWorker ? boost::any(scheduleWorker->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleWorker") != m.end() && !m["ScheduleWorker"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleWorker"].type()) {
        GetScheduleWorkerResponseBodyScheduleWorker model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleWorker"]));
        scheduleWorker = make_shared<GetScheduleWorkerResponseBodyScheduleWorker>(model1);
      }
    }
  }


  virtual ~GetScheduleWorkerResponseBody() = default;
};
class GetScheduleWorkerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetScheduleWorkerResponseBody> body{};

  GetScheduleWorkerResponse() {}

  explicit GetScheduleWorkerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScheduleWorkerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScheduleWorkerResponseBody>(model1);
      }
    }
  }


  virtual ~GetScheduleWorkerResponse() = default;
};
class GetSetupProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};

  GetSetupProjectRequest() {}

  explicit GetSetupProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~GetSetupProjectRequest() = default;
};
class GetSetupProjectResponseBodySetupProjectPackages : public Darabonba::Model {
public:
  shared_ptr<string> deviceNumber{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> vendor{};

  GetSetupProjectResponseBodySetupProjectPackages() {}

  explicit GetSetupProjectResponseBodySetupProjectPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<string>(boost::any_cast<string>(m["DeviceNumber"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~GetSetupProjectResponseBodySetupProjectPackages() = default;
};
class GetSetupProjectResponseBodySetupProject : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> nodes{};
  shared_ptr<vector<GetSetupProjectResponseBodySetupProjectPackages>> packages{};
  shared_ptr<string> progress{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};

  GetSetupProjectResponseBodySetupProject() {}

  explicit GetSetupProjectResponseBodySetupProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (nodes) {
      res["Nodes"] = boost::any(*nodes);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      nodes = make_shared<string>(boost::any_cast<string>(m["Nodes"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<GetSetupProjectResponseBodySetupProjectPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSetupProjectResponseBodySetupProjectPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<GetSetupProjectResponseBodySetupProjectPackages>>(expect1);
      }
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~GetSetupProjectResponseBodySetupProject() = default;
};
class GetSetupProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSetupProjectResponseBodySetupProject> setupProject{};

  GetSetupProjectResponseBody() {}

  explicit GetSetupProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (setupProject) {
      res["SetupProject"] = setupProject ? boost::any(setupProject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SetupProject") != m.end() && !m["SetupProject"].empty()) {
      if (typeid(map<string, boost::any>) == m["SetupProject"].type()) {
        GetSetupProjectResponseBodySetupProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SetupProject"]));
        setupProject = make_shared<GetSetupProjectResponseBodySetupProject>(model1);
      }
    }
  }


  virtual ~GetSetupProjectResponseBody() = default;
};
class GetSetupProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSetupProjectResponseBody> body{};

  GetSetupProjectResponse() {}

  explicit GetSetupProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSetupProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSetupProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetSetupProjectResponse() = default;
};
class GetSpaceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> spaceModelId{};

  GetSpaceModelRequest() {}

  explicit GetSpaceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
  }


  virtual ~GetSpaceModelRequest() = default;
};
class GetSpaceModelResponseBodySpaceModelSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  GetSpaceModelResponseBodySpaceModelSort() {}

  explicit GetSpaceModelResponseBodySpaceModelSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~GetSpaceModelResponseBodySpaceModelSort() = default;
};
class GetSpaceModelResponseBodySpaceModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<vector<GetSpaceModelResponseBodySpaceModelSort>> sort{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  GetSpaceModelResponseBodySpaceModel() {}

  explicit GetSpaceModelResponseBodySpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (sort) {
      vector<boost::any> temp1;
      for(auto item1:*sort){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sort"] = boost::any(temp1);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(vector<boost::any>) == m["Sort"].type()) {
        vector<GetSpaceModelResponseBodySpaceModelSort> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sort"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpaceModelResponseBodySpaceModelSort model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sort = make_shared<vector<GetSpaceModelResponseBodySpaceModelSort>>(expect1);
      }
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetSpaceModelResponseBodySpaceModel() = default;
};
class GetSpaceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSpaceModelResponseBodySpaceModel> spaceModel{};

  GetSpaceModelResponseBody() {}

  explicit GetSpaceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceModel) {
      res["SpaceModel"] = spaceModel ? boost::any(spaceModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceModel") != m.end() && !m["SpaceModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpaceModel"].type()) {
        GetSpaceModelResponseBodySpaceModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpaceModel"]));
        spaceModel = make_shared<GetSpaceModelResponseBodySpaceModel>(model1);
      }
    }
  }


  virtual ~GetSpaceModelResponseBody() = default;
};
class GetSpaceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpaceModelResponseBody> body{};

  GetSpaceModelResponse() {}

  explicit GetSpaceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpaceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpaceModelResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpaceModelResponse() = default;
};
class GetSpaceModelInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> operateType{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceType{};

  GetSpaceModelInstanceRequest() {}

  explicit GetSpaceModelInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~GetSpaceModelInstanceRequest() = default;
};
class GetSpaceModelInstanceResponseBodySpaceModel : public Darabonba::Model {
public:
  shared_ptr<string> instance{};

  GetSpaceModelInstanceResponseBodySpaceModel() {}

  explicit GetSpaceModelInstanceResponseBodySpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
  }


  virtual ~GetSpaceModelInstanceResponseBodySpaceModel() = default;
};
class GetSpaceModelInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSpaceModelInstanceResponseBodySpaceModel> spaceModel{};

  GetSpaceModelInstanceResponseBody() {}

  explicit GetSpaceModelInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceModel) {
      res["SpaceModel"] = spaceModel ? boost::any(spaceModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceModel") != m.end() && !m["SpaceModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpaceModel"].type()) {
        GetSpaceModelInstanceResponseBodySpaceModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpaceModel"]));
        spaceModel = make_shared<GetSpaceModelInstanceResponseBodySpaceModel>(model1);
      }
    }
  }


  virtual ~GetSpaceModelInstanceResponseBody() = default;
};
class GetSpaceModelInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpaceModelInstanceResponseBody> body{};

  GetSpaceModelInstanceResponse() {}

  explicit GetSpaceModelInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpaceModelInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpaceModelInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpaceModelInstanceResponse() = default;
};
class GetSpaceModelSortRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> operateType{};
  shared_ptr<string> spaceType{};

  GetSpaceModelSortRequest() {}

  explicit GetSpaceModelSortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~GetSpaceModelSortRequest() = default;
};
class GetSpaceModelSortResponseBodySpaceModel : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  GetSpaceModelSortResponseBodySpaceModel() {}

  explicit GetSpaceModelSortResponseBodySpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~GetSpaceModelSortResponseBodySpaceModel() = default;
};
class GetSpaceModelSortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSpaceModelSortResponseBodySpaceModel>> spaceModel{};

  GetSpaceModelSortResponseBody() {}

  explicit GetSpaceModelSortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceModel) {
      vector<boost::any> temp1;
      for(auto item1:*spaceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpaceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceModel") != m.end() && !m["SpaceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["SpaceModel"].type()) {
        vector<GetSpaceModelSortResponseBodySpaceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpaceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpaceModelSortResponseBodySpaceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spaceModel = make_shared<vector<GetSpaceModelSortResponseBodySpaceModel>>(expect1);
      }
    }
  }


  virtual ~GetSpaceModelSortResponseBody() = default;
};
class GetSpaceModelSortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpaceModelSortResponseBody> body{};

  GetSpaceModelSortResponse() {}

  explicit GetSpaceModelSortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpaceModelSortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpaceModelSortResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpaceModelSortResponse() = default;
};
class GetTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  GetTaskRequest() {}

  explicit GetTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetTaskRequest() = default;
};
class GetTaskResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> params{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> updateTime{};

  GetTaskResponseBodyTask() {}

  explicit GetTaskResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetTaskResponseBodyTask() = default;
};
class GetTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTaskResponseBodyTask> task{};

  GetTaskResponseBody() {}

  explicit GetTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetTaskResponseBodyTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetTaskResponseBodyTask>(model1);
      }
    }
  }


  virtual ~GetTaskResponseBody() = default;
};
class GetTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskResponseBody> body{};

  GetTaskResponse() {}

  explicit GetTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskResponse() = default;
};
class ListAlarmStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataName{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> dedicatedLineName{};
  shared_ptr<string> deviceForm{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> domain{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> manufacturer{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> model{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> portCollectionName{};
  shared_ptr<string> province{};
  shared_ptr<string> region{};
  shared_ptr<string> role{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> space{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> uniqueKey{};

  ListAlarmStatusRequest() {}

  explicit ListAlarmStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataName) {
      res["AggregateDataName"] = boost::any(*aggregateDataName);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (dedicatedLineName) {
      res["DedicatedLineName"] = boost::any(*dedicatedLineName);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (portCollectionName) {
      res["PortCollectionName"] = boost::any(*portCollectionName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataName") != m.end() && !m["AggregateDataName"].empty()) {
      aggregateDataName = make_shared<string>(boost::any_cast<string>(m["AggregateDataName"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DedicatedLineName") != m.end() && !m["DedicatedLineName"].empty()) {
      dedicatedLineName = make_shared<string>(boost::any_cast<string>(m["DedicatedLineName"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("PortCollectionName") != m.end() && !m["PortCollectionName"].empty()) {
      portCollectionName = make_shared<string>(boost::any_cast<string>(m["PortCollectionName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~ListAlarmStatusRequest() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusAggregateData : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataName{};
  shared_ptr<string> dataItem{};

  ListAlarmStatusResponseBodyAlarmStatusAggregateData() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusAggregateData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataName) {
      res["AggregateDataName"] = boost::any(*aggregateDataName);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataName") != m.end() && !m["AggregateDataName"].empty()) {
      aggregateDataName = make_shared<string>(boost::any_cast<string>(m["AggregateDataName"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusAggregateData() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusDedicatedLine : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedLineName{};
  shared_ptr<string> physicalSpace{};

  ListAlarmStatusResponseBodyAlarmStatusDedicatedLine() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusDedicatedLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLineName) {
      res["DedicatedLineName"] = boost::any(*dedicatedLineName);
    }
    if (physicalSpace) {
      res["PhysicalSpace"] = boost::any(*physicalSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLineName") != m.end() && !m["DedicatedLineName"].empty()) {
      dedicatedLineName = make_shared<string>(boost::any_cast<string>(m["DedicatedLineName"]));
    }
    if (m.find("PhysicalSpace") != m.end() && !m["PhysicalSpace"].empty()) {
      physicalSpace = make_shared<string>(boost::any_cast<string>(m["PhysicalSpace"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusDedicatedLine() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> collectionType{};
  shared_ptr<string> monitorItemDescription{};
  shared_ptr<string> monitorItemName{};

  ListAlarmStatusResponseBodyAlarmStatusMonitorItem() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectionType) {
      res["CollectionType"] = boost::any(*collectionType);
    }
    if (monitorItemDescription) {
      res["MonitorItemDescription"] = boost::any(*monitorItemDescription);
    }
    if (monitorItemName) {
      res["MonitorItemName"] = boost::any(*monitorItemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollectionType") != m.end() && !m["CollectionType"].empty()) {
      collectionType = make_shared<string>(boost::any_cast<string>(m["CollectionType"]));
    }
    if (m.find("MonitorItemDescription") != m.end() && !m["MonitorItemDescription"].empty()) {
      monitorItemDescription = make_shared<string>(boost::any_cast<string>(m["MonitorItemDescription"]));
    }
    if (m.find("MonitorItemName") != m.end() && !m["MonitorItemName"].empty()) {
      monitorItemName = make_shared<string>(boost::any_cast<string>(m["MonitorItemName"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusMonitorItem() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch : public Darabonba::Model {
public:
  shared_ptr<string> expiryTime{};
  shared_ptr<string> reason{};

  ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<string>(boost::any_cast<string>(m["ExpiryTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusPortCollection : public Darabonba::Model {
public:
  shared_ptr<string> portCollectionName{};

  ListAlarmStatusResponseBodyAlarmStatusPortCollection() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusPortCollection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portCollectionName) {
      res["PortCollectionName"] = boost::any(*portCollectionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortCollectionName") != m.end() && !m["PortCollectionName"].empty()) {
      portCollectionName = make_shared<string>(boost::any_cast<string>(m["PortCollectionName"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusPortCollection() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusResourceApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> domain{};
  shared_ptr<string> port{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};

  ListAlarmStatusResponseBodyAlarmStatusResourceApp() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusResourceApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusResourceApp() = default;
};
class ListAlarmStatusResponseBodyAlarmStatusResourceDevice : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> deviceForm{};
  shared_ptr<string> hostName{};
  shared_ptr<string> physicalSpace{};

  ListAlarmStatusResponseBodyAlarmStatusResourceDevice() {}

  explicit ListAlarmStatusResponseBodyAlarmStatusResourceDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (deviceForm) {
      res["DeviceForm"] = boost::any(*deviceForm);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (physicalSpace) {
      res["PhysicalSpace"] = boost::any(*physicalSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("DeviceForm") != m.end() && !m["DeviceForm"].empty()) {
      deviceForm = make_shared<string>(boost::any_cast<string>(m["DeviceForm"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("PhysicalSpace") != m.end() && !m["PhysicalSpace"].empty()) {
      physicalSpace = make_shared<string>(boost::any_cast<string>(m["PhysicalSpace"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatusResourceDevice() = default;
};
class ListAlarmStatusResponseBodyAlarmStatus : public Darabonba::Model {
public:
  shared_ptr<string> abnormalDataItem{};
  shared_ptr<string> agentIp{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusAggregateData> aggregateData{};
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> alarmRule{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> appId{};
  shared_ptr<string> collectionTime{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusDedicatedLine> dedicatedLine{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> firstAbnormalTime{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusMonitorItem> monitorItem{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch> notificationSwitch{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusPortCollection> portCollection{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> receiveTime{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusResourceApp> resourceApp{};
  shared_ptr<ListAlarmStatusResponseBodyAlarmStatusResourceDevice> resourceDevice{};
  shared_ptr<string> responseCode{};
  shared_ptr<string> result{};
  shared_ptr<string> uniqueKey{};

  ListAlarmStatusResponseBodyAlarmStatus() {}

  explicit ListAlarmStatusResponseBodyAlarmStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalDataItem) {
      res["AbnormalDataItem"] = boost::any(*abnormalDataItem);
    }
    if (agentIp) {
      res["AgentIp"] = boost::any(*agentIp);
    }
    if (aggregateData) {
      res["AggregateData"] = aggregateData ? boost::any(aggregateData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (alarmRule) {
      res["AlarmRule"] = boost::any(*alarmRule);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (collectionTime) {
      res["CollectionTime"] = boost::any(*collectionTime);
    }
    if (dedicatedLine) {
      res["DedicatedLine"] = dedicatedLine ? boost::any(dedicatedLine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (firstAbnormalTime) {
      res["FirstAbnormalTime"] = boost::any(*firstAbnormalTime);
    }
    if (monitorItem) {
      res["MonitorItem"] = monitorItem ? boost::any(monitorItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (notificationSwitch) {
      res["NotificationSwitch"] = notificationSwitch ? boost::any(notificationSwitch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (portCollection) {
      res["PortCollection"] = portCollection ? boost::any(portCollection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (resourceApp) {
      res["ResourceApp"] = resourceApp ? boost::any(resourceApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceDevice) {
      res["ResourceDevice"] = resourceDevice ? boost::any(resourceDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (responseCode) {
      res["ResponseCode"] = boost::any(*responseCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalDataItem") != m.end() && !m["AbnormalDataItem"].empty()) {
      abnormalDataItem = make_shared<string>(boost::any_cast<string>(m["AbnormalDataItem"]));
    }
    if (m.find("AgentIp") != m.end() && !m["AgentIp"].empty()) {
      agentIp = make_shared<string>(boost::any_cast<string>(m["AgentIp"]));
    }
    if (m.find("AggregateData") != m.end() && !m["AggregateData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AggregateData"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusAggregateData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AggregateData"]));
        aggregateData = make_shared<ListAlarmStatusResponseBodyAlarmStatusAggregateData>(model1);
      }
    }
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AlarmRule") != m.end() && !m["AlarmRule"].empty()) {
      alarmRule = make_shared<string>(boost::any_cast<string>(m["AlarmRule"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CollectionTime") != m.end() && !m["CollectionTime"].empty()) {
      collectionTime = make_shared<string>(boost::any_cast<string>(m["CollectionTime"]));
    }
    if (m.find("DedicatedLine") != m.end() && !m["DedicatedLine"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedLine"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusDedicatedLine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedLine"]));
        dedicatedLine = make_shared<ListAlarmStatusResponseBodyAlarmStatusDedicatedLine>(model1);
      }
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("FirstAbnormalTime") != m.end() && !m["FirstAbnormalTime"].empty()) {
      firstAbnormalTime = make_shared<string>(boost::any_cast<string>(m["FirstAbnormalTime"]));
    }
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorItem"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusMonitorItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorItem"]));
        monitorItem = make_shared<ListAlarmStatusResponseBodyAlarmStatusMonitorItem>(model1);
      }
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NotificationSwitch") != m.end() && !m["NotificationSwitch"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSwitch"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSwitch"]));
        notificationSwitch = make_shared<ListAlarmStatusResponseBodyAlarmStatusNotificationSwitch>(model1);
      }
    }
    if (m.find("PortCollection") != m.end() && !m["PortCollection"].empty()) {
      if (typeid(map<string, boost::any>) == m["PortCollection"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusPortCollection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PortCollection"]));
        portCollection = make_shared<ListAlarmStatusResponseBodyAlarmStatusPortCollection>(model1);
      }
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("ResourceApp") != m.end() && !m["ResourceApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceApp"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusResourceApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceApp"]));
        resourceApp = make_shared<ListAlarmStatusResponseBodyAlarmStatusResourceApp>(model1);
      }
    }
    if (m.find("ResourceDevice") != m.end() && !m["ResourceDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDevice"].type()) {
        ListAlarmStatusResponseBodyAlarmStatusResourceDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDevice"]));
        resourceDevice = make_shared<ListAlarmStatusResponseBodyAlarmStatusResourceDevice>(model1);
      }
    }
    if (m.find("ResponseCode") != m.end() && !m["ResponseCode"].empty()) {
      responseCode = make_shared<string>(boost::any_cast<string>(m["ResponseCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyAlarmStatus() = default;
};
class ListAlarmStatusResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> status{};

  ListAlarmStatusResponseBodyStatistics() {}

  explicit ListAlarmStatusResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlarmStatusResponseBodyStatistics() = default;
};
class ListAlarmStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlarmStatusResponseBodyAlarmStatus>> alarmStatus{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAlarmStatusResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalCount{};

  ListAlarmStatusResponseBody() {}

  explicit ListAlarmStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      vector<boost::any> temp1;
      for(auto item1:*alarmStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmStatus"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmStatus"].type()) {
        vector<ListAlarmStatusResponseBodyAlarmStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlarmStatusResponseBodyAlarmStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmStatus = make_shared<vector<ListAlarmStatusResponseBodyAlarmStatus>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<ListAlarmStatusResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlarmStatusResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<ListAlarmStatusResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlarmStatusResponseBody() = default;
};
class ListAlarmStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlarmStatusResponseBody> body{};

  ListAlarmStatusResponse() {}

  explicit ListAlarmStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlarmStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlarmStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlarmStatusResponse() = default;
};
class ListAlarmStatusHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<long> start{};
  shared_ptr<string> type{};

  ListAlarmStatusHistoriesRequest() {}

  explicit ListAlarmStatusHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlarmStatusHistoriesRequest() = default;
};
class ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<string> value{};

  ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories() {}

  explicit ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories() = default;
};
class ListAlarmStatusHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories>> alarmStatusHistories{};
  shared_ptr<string> requestId{};

  ListAlarmStatusHistoriesResponseBody() {}

  explicit ListAlarmStatusHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatusHistories) {
      vector<boost::any> temp1;
      for(auto item1:*alarmStatusHistories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmStatusHistories"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatusHistories") != m.end() && !m["AlarmStatusHistories"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmStatusHistories"].type()) {
        vector<ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmStatusHistories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmStatusHistories = make_shared<vector<ListAlarmStatusHistoriesResponseBodyAlarmStatusHistories>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlarmStatusHistoriesResponseBody() = default;
};
class ListAlarmStatusHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlarmStatusHistoriesResponseBody> body{};

  ListAlarmStatusHistoriesResponse() {}

  explicit ListAlarmStatusHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlarmStatusHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlarmStatusHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlarmStatusHistoriesResponse() = default;
};
class ListAlarmStatusStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> type{};

  ListAlarmStatusStatisticsRequest() {}

  explicit ListAlarmStatusStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlarmStatusStatisticsRequest() = default;
};
class ListAlarmStatusStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceId{};

  ListAlarmStatusStatisticsResponseBodyStatistics() {}

  explicit ListAlarmStatusStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListAlarmStatusStatisticsResponseBodyStatistics() = default;
};
class ListAlarmStatusStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAlarmStatusStatisticsResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalCount{};

  ListAlarmStatusStatisticsResponseBody() {}

  explicit ListAlarmStatusStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<ListAlarmStatusStatisticsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlarmStatusStatisticsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<ListAlarmStatusStatisticsResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlarmStatusStatisticsResponseBody() = default;
};
class ListAlarmStatusStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlarmStatusStatisticsResponseBody> body{};

  ListAlarmStatusStatisticsResponse() {}

  explicit ListAlarmStatusStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlarmStatusStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlarmStatusStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlarmStatusStatisticsResponse() = default;
};
class ListArchitectureAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> role{};
  shared_ptr<string> vendor{};

  ListArchitectureAttributeRequest() {}

  explicit ListArchitectureAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListArchitectureAttributeRequest() = default;
};
class ListArchitectureAttributeResponseBodyArchitecture : public Darabonba::Model {
public:
  shared_ptr<vector<string>> model{};
  shared_ptr<vector<string>> role{};
  shared_ptr<vector<string>> vendor{};

  ListArchitectureAttributeResponseBodyArchitecture() {}

  explicit ListArchitectureAttributeResponseBodyArchitecture(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Model"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      model = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Role"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      role = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vendor"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vendor"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vendor = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListArchitectureAttributeResponseBodyArchitecture() = default;
};
class ListArchitectureAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListArchitectureAttributeResponseBodyArchitecture>> architecture{};
  shared_ptr<string> requestId{};

  ListArchitectureAttributeResponseBody() {}

  explicit ListArchitectureAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      vector<boost::any> temp1;
      for(auto item1:*architecture){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Architecture"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      if (typeid(vector<boost::any>) == m["Architecture"].type()) {
        vector<ListArchitectureAttributeResponseBodyArchitecture> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Architecture"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListArchitectureAttributeResponseBodyArchitecture model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        architecture = make_shared<vector<ListArchitectureAttributeResponseBodyArchitecture>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListArchitectureAttributeResponseBody() = default;
};
class ListArchitectureAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListArchitectureAttributeResponseBody> body{};

  ListArchitectureAttributeResponse() {}

  explicit ListArchitectureAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListArchitectureAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListArchitectureAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ListArchitectureAttributeResponse() = default;
};
class ListConfigurationSpecificationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> model{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> vendor{};

  ListConfigurationSpecificationsRequest() {}

  explicit ListConfigurationSpecificationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListConfigurationSpecificationsRequest() = default;
};
class ListConfigurationSpecificationsResponseBodyConfigurationSpecification : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> model{};
  shared_ptr<vector<string>> relatedVariate{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendor{};

  ListConfigurationSpecificationsResponseBodyConfigurationSpecification() {}

  explicit ListConfigurationSpecificationsResponseBodyConfigurationSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariate) {
      res["RelatedVariate"] = boost::any(*relatedVariate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedVariate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedVariate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedVariate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListConfigurationSpecificationsResponseBodyConfigurationSpecification() = default;
};
class ListConfigurationSpecificationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigurationSpecificationsResponseBodyConfigurationSpecification>> configurationSpecification{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListConfigurationSpecificationsResponseBody() {}

  explicit ListConfigurationSpecificationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationSpecification) {
      vector<boost::any> temp1;
      for(auto item1:*configurationSpecification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigurationSpecification"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationSpecification") != m.end() && !m["ConfigurationSpecification"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigurationSpecification"].type()) {
        vector<ListConfigurationSpecificationsResponseBodyConfigurationSpecification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigurationSpecification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigurationSpecificationsResponseBodyConfigurationSpecification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configurationSpecification = make_shared<vector<ListConfigurationSpecificationsResponseBodyConfigurationSpecification>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConfigurationSpecificationsResponseBody() = default;
};
class ListConfigurationSpecificationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigurationSpecificationsResponseBody> body{};

  ListConfigurationSpecificationsResponse() {}

  explicit ListConfigurationSpecificationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigurationSpecificationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigurationSpecificationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigurationSpecificationsResponse() = default;
};
class ListConfigurationVariateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> variateName{};

  ListConfigurationVariateRequest() {}

  explicit ListConfigurationVariateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~ListConfigurationVariateRequest() = default;
};
class ListConfigurationVariateResponseBodyConfigurationVariate : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> formatFunction{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variateName{};

  ListConfigurationVariateResponseBodyConfigurationVariate() {}

  explicit ListConfigurationVariateResponseBodyConfigurationVariate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (formatFunction) {
      res["FormatFunction"] = boost::any(*formatFunction);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FormatFunction") != m.end() && !m["FormatFunction"].empty()) {
      formatFunction = make_shared<string>(boost::any_cast<string>(m["FormatFunction"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~ListConfigurationVariateResponseBodyConfigurationVariate() = default;
};
class ListConfigurationVariateResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigurationVariateResponseBodyConfigurationVariate>> configurationVariate{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListConfigurationVariateResponseBody() {}

  explicit ListConfigurationVariateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationVariate) {
      vector<boost::any> temp1;
      for(auto item1:*configurationVariate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigurationVariate"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationVariate") != m.end() && !m["ConfigurationVariate"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigurationVariate"].type()) {
        vector<ListConfigurationVariateResponseBodyConfigurationVariate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigurationVariate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigurationVariateResponseBodyConfigurationVariate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configurationVariate = make_shared<vector<ListConfigurationVariateResponseBodyConfigurationVariate>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConfigurationVariateResponseBody() = default;
};
class ListConfigurationVariateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigurationVariateResponseBody> body{};

  ListConfigurationVariateResponse() {}

  explicit ListConfigurationVariateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigurationVariateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigurationVariateResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigurationVariateResponse() = default;
};
class ListConnectionPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureIterationId{};
  shared_ptr<string> connectionPolicyId{};
  shared_ptr<string> downlinkArchitectureDeviceId{};
  shared_ptr<string> downlinkArchitectureModuleId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> uplinkArchitectureDeviceId{};
  shared_ptr<string> uplinkArchitectureModuleId{};

  ListConnectionPoliciesRequest() {}

  explicit ListConnectionPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureIterationId) {
      res["ArchitectureIterationId"] = boost::any(*architectureIterationId);
    }
    if (connectionPolicyId) {
      res["ConnectionPolicyId"] = boost::any(*connectionPolicyId);
    }
    if (downlinkArchitectureDeviceId) {
      res["DownlinkArchitectureDeviceId"] = boost::any(*downlinkArchitectureDeviceId);
    }
    if (downlinkArchitectureModuleId) {
      res["DownlinkArchitectureModuleId"] = boost::any(*downlinkArchitectureModuleId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (uplinkArchitectureDeviceId) {
      res["UplinkArchitectureDeviceId"] = boost::any(*uplinkArchitectureDeviceId);
    }
    if (uplinkArchitectureModuleId) {
      res["UplinkArchitectureModuleId"] = boost::any(*uplinkArchitectureModuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureIterationId") != m.end() && !m["ArchitectureIterationId"].empty()) {
      architectureIterationId = make_shared<string>(boost::any_cast<string>(m["ArchitectureIterationId"]));
    }
    if (m.find("ConnectionPolicyId") != m.end() && !m["ConnectionPolicyId"].empty()) {
      connectionPolicyId = make_shared<string>(boost::any_cast<string>(m["ConnectionPolicyId"]));
    }
    if (m.find("DownlinkArchitectureDeviceId") != m.end() && !m["DownlinkArchitectureDeviceId"].empty()) {
      downlinkArchitectureDeviceId = make_shared<string>(boost::any_cast<string>(m["DownlinkArchitectureDeviceId"]));
    }
    if (m.find("DownlinkArchitectureModuleId") != m.end() && !m["DownlinkArchitectureModuleId"].empty()) {
      downlinkArchitectureModuleId = make_shared<string>(boost::any_cast<string>(m["DownlinkArchitectureModuleId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("UplinkArchitectureDeviceId") != m.end() && !m["UplinkArchitectureDeviceId"].empty()) {
      uplinkArchitectureDeviceId = make_shared<string>(boost::any_cast<string>(m["UplinkArchitectureDeviceId"]));
    }
    if (m.find("UplinkArchitectureModuleId") != m.end() && !m["UplinkArchitectureModuleId"].empty()) {
      uplinkArchitectureModuleId = make_shared<string>(boost::any_cast<string>(m["UplinkArchitectureModuleId"]));
    }
  }


  virtual ~ListConnectionPoliciesRequest() = default;
};
class ListConnectionPoliciesResponseBodyConnectionPolicy : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> architectureIterationId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> downlinkArchitectureDeviceId{};
  shared_ptr<string> downlinkArchitectureModuleId{};
  shared_ptr<string> id{};
  shared_ptr<long> linkCount{};
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uplinkArchitectureDeviceId{};
  shared_ptr<string> uplinkArchitectureModuleId{};

  ListConnectionPoliciesResponseBodyConnectionPolicy() {}

  explicit ListConnectionPoliciesResponseBodyConnectionPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (architectureIterationId) {
      res["ArchitectureIterationId"] = boost::any(*architectureIterationId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downlinkArchitectureDeviceId) {
      res["DownlinkArchitectureDeviceId"] = boost::any(*downlinkArchitectureDeviceId);
    }
    if (downlinkArchitectureModuleId) {
      res["DownlinkArchitectureModuleId"] = boost::any(*downlinkArchitectureModuleId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkCount) {
      res["LinkCount"] = boost::any(*linkCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uplinkArchitectureDeviceId) {
      res["UplinkArchitectureDeviceId"] = boost::any(*uplinkArchitectureDeviceId);
    }
    if (uplinkArchitectureModuleId) {
      res["UplinkArchitectureModuleId"] = boost::any(*uplinkArchitectureModuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("ArchitectureIterationId") != m.end() && !m["ArchitectureIterationId"].empty()) {
      architectureIterationId = make_shared<string>(boost::any_cast<string>(m["ArchitectureIterationId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DownlinkArchitectureDeviceId") != m.end() && !m["DownlinkArchitectureDeviceId"].empty()) {
      downlinkArchitectureDeviceId = make_shared<string>(boost::any_cast<string>(m["DownlinkArchitectureDeviceId"]));
    }
    if (m.find("DownlinkArchitectureModuleId") != m.end() && !m["DownlinkArchitectureModuleId"].empty()) {
      downlinkArchitectureModuleId = make_shared<string>(boost::any_cast<string>(m["DownlinkArchitectureModuleId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkCount") != m.end() && !m["LinkCount"].empty()) {
      linkCount = make_shared<long>(boost::any_cast<long>(m["LinkCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UplinkArchitectureDeviceId") != m.end() && !m["UplinkArchitectureDeviceId"].empty()) {
      uplinkArchitectureDeviceId = make_shared<string>(boost::any_cast<string>(m["UplinkArchitectureDeviceId"]));
    }
    if (m.find("UplinkArchitectureModuleId") != m.end() && !m["UplinkArchitectureModuleId"].empty()) {
      uplinkArchitectureModuleId = make_shared<string>(boost::any_cast<string>(m["UplinkArchitectureModuleId"]));
    }
  }


  virtual ~ListConnectionPoliciesResponseBodyConnectionPolicy() = default;
};
class ListConnectionPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConnectionPoliciesResponseBodyConnectionPolicy>> connectionPolicy{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListConnectionPoliciesResponseBody() {}

  explicit ListConnectionPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*connectionPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConnectionPolicy"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionPolicy") != m.end() && !m["ConnectionPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["ConnectionPolicy"].type()) {
        vector<ListConnectionPoliciesResponseBodyConnectionPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConnectionPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConnectionPoliciesResponseBodyConnectionPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connectionPolicy = make_shared<vector<ListConnectionPoliciesResponseBodyConnectionPolicy>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConnectionPoliciesResponseBody() = default;
};
class ListConnectionPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConnectionPoliciesResponseBody> body{};

  ListConnectionPoliciesResponse() {}

  explicit ListConnectionPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConnectionPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConnectionPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConnectionPoliciesResponse() = default;
};
class ListDedicatedLinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineIp{};
  shared_ptr<string> dedicatedLineRole{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispFormId{};
  shared_ptr<string> ispId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> keywords{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> onlineDate{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> spaceName{};

  ListDedicatedLinesRequest() {}

  explicit ListDedicatedLinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineIp) {
      res["DedicatedLineIp"] = boost::any(*dedicatedLineIp);
    }
    if (dedicatedLineRole) {
      res["DedicatedLineRole"] = boost::any(*dedicatedLineRole);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispFormId) {
      res["IspFormId"] = boost::any(*ispFormId);
    }
    if (ispId) {
      res["IspId"] = boost::any(*ispId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (onlineDate) {
      res["OnlineDate"] = boost::any(*onlineDate);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineIp") != m.end() && !m["DedicatedLineIp"].empty()) {
      dedicatedLineIp = make_shared<string>(boost::any_cast<string>(m["DedicatedLineIp"]));
    }
    if (m.find("DedicatedLineRole") != m.end() && !m["DedicatedLineRole"].empty()) {
      dedicatedLineRole = make_shared<string>(boost::any_cast<string>(m["DedicatedLineRole"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspFormId") != m.end() && !m["IspFormId"].empty()) {
      ispFormId = make_shared<string>(boost::any_cast<string>(m["IspFormId"]));
    }
    if (m.find("IspId") != m.end() && !m["IspId"].empty()) {
      ispId = make_shared<string>(boost::any_cast<string>(m["IspId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OnlineDate") != m.end() && !m["OnlineDate"].empty()) {
      onlineDate = make_shared<string>(boost::any_cast<string>(m["OnlineDate"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
  }


  virtual ~ListDedicatedLinesRequest() = default;
};
class ListDedicatedLinesResponseBodyDedicatedLinesContact : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> email{};
  shared_ptr<string> name{};
  shared_ptr<string> phone{};

  ListDedicatedLinesResponseBodyDedicatedLinesContact() {}

  explicit ListDedicatedLinesResponseBodyDedicatedLinesContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListDedicatedLinesResponseBodyDedicatedLinesContact() = default;
};
class ListDedicatedLinesResponseBodyDedicatedLines : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<vector<ListDedicatedLinesResponseBodyDedicatedLinesContact>> contact{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> dedicatedLineIp{};
  shared_ptr<string> dedicatedLineRole{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> ext{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispFormId{};
  shared_ptr<string> ispFormName{};
  shared_ptr<string> ispId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> onlineDate{};
  shared_ptr<string> phone{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> spaceName{};

  ListDedicatedLinesResponseBodyDedicatedLines() {}

  explicit ListDedicatedLinesResponseBodyDedicatedLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (contact) {
      vector<boost::any> temp1;
      for(auto item1:*contact){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contact"] = boost::any(temp1);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (dedicatedLineIp) {
      res["DedicatedLineIp"] = boost::any(*dedicatedLineIp);
    }
    if (dedicatedLineRole) {
      res["DedicatedLineRole"] = boost::any(*dedicatedLineRole);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispFormId) {
      res["IspFormId"] = boost::any(*ispFormId);
    }
    if (ispFormName) {
      res["IspFormName"] = boost::any(*ispFormName);
    }
    if (ispId) {
      res["IspId"] = boost::any(*ispId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (onlineDate) {
      res["OnlineDate"] = boost::any(*onlineDate);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<ListDedicatedLinesResponseBodyDedicatedLinesContact> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contact"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDedicatedLinesResponseBodyDedicatedLinesContact model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contact = make_shared<vector<ListDedicatedLinesResponseBodyDedicatedLinesContact>>(expect1);
      }
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DedicatedLineIp") != m.end() && !m["DedicatedLineIp"].empty()) {
      dedicatedLineIp = make_shared<string>(boost::any_cast<string>(m["DedicatedLineIp"]));
    }
    if (m.find("DedicatedLineRole") != m.end() && !m["DedicatedLineRole"].empty()) {
      dedicatedLineRole = make_shared<string>(boost::any_cast<string>(m["DedicatedLineRole"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspFormId") != m.end() && !m["IspFormId"].empty()) {
      ispFormId = make_shared<string>(boost::any_cast<string>(m["IspFormId"]));
    }
    if (m.find("IspFormName") != m.end() && !m["IspFormName"].empty()) {
      ispFormName = make_shared<string>(boost::any_cast<string>(m["IspFormName"]));
    }
    if (m.find("IspId") != m.end() && !m["IspId"].empty()) {
      ispId = make_shared<string>(boost::any_cast<string>(m["IspId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OnlineDate") != m.end() && !m["OnlineDate"].empty()) {
      onlineDate = make_shared<string>(boost::any_cast<string>(m["OnlineDate"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
  }


  virtual ~ListDedicatedLinesResponseBodyDedicatedLines() = default;
};
class ListDedicatedLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDedicatedLinesResponseBodyDedicatedLines>> dedicatedLines{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDedicatedLinesResponseBody() {}

  explicit ListDedicatedLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedLines) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedLines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedLines"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedLines") != m.end() && !m["DedicatedLines"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedLines"].type()) {
        vector<ListDedicatedLinesResponseBodyDedicatedLines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedLines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDedicatedLinesResponseBodyDedicatedLines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedLines = make_shared<vector<ListDedicatedLinesResponseBodyDedicatedLines>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDedicatedLinesResponseBody() = default;
};
class ListDedicatedLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDedicatedLinesResponseBody> body{};

  ListDedicatedLinesResponse() {}

  explicit ListDedicatedLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDedicatedLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDedicatedLinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDedicatedLinesResponse() = default;
};
class ListDeviceFormsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListDeviceFormsRequest() {}

  explicit ListDeviceFormsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListDeviceFormsRequest() = default;
};
class ListDeviceFormsResponseBodyDeviceFormsAttributeList : public Darabonba::Model {
public:
  shared_ptr<bool> attributeBuiltIn{};
  shared_ptr<string> attributeContent{};
  shared_ptr<string> attributeFormat{};
  shared_ptr<bool> attributeFuzzyQuery{};
  shared_ptr<string> attributeKey{};
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributePlaceholder{};
  shared_ptr<bool> attributeQuery{};
  shared_ptr<string> attributeReference{};
  shared_ptr<bool> attributeRequirement{};
  shared_ptr<long> attributeSequence{};
  shared_ptr<bool> attributeTableDisplay{};
  shared_ptr<string> attributeType{};
  shared_ptr<bool> attributeUniqueness{};

  ListDeviceFormsResponseBodyDeviceFormsAttributeList() {}

  explicit ListDeviceFormsResponseBodyDeviceFormsAttributeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeBuiltIn) {
      res["AttributeBuiltIn"] = boost::any(*attributeBuiltIn);
    }
    if (attributeContent) {
      res["AttributeContent"] = boost::any(*attributeContent);
    }
    if (attributeFormat) {
      res["AttributeFormat"] = boost::any(*attributeFormat);
    }
    if (attributeFuzzyQuery) {
      res["AttributeFuzzyQuery"] = boost::any(*attributeFuzzyQuery);
    }
    if (attributeKey) {
      res["AttributeKey"] = boost::any(*attributeKey);
    }
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributePlaceholder) {
      res["AttributePlaceholder"] = boost::any(*attributePlaceholder);
    }
    if (attributeQuery) {
      res["AttributeQuery"] = boost::any(*attributeQuery);
    }
    if (attributeReference) {
      res["AttributeReference"] = boost::any(*attributeReference);
    }
    if (attributeRequirement) {
      res["AttributeRequirement"] = boost::any(*attributeRequirement);
    }
    if (attributeSequence) {
      res["AttributeSequence"] = boost::any(*attributeSequence);
    }
    if (attributeTableDisplay) {
      res["AttributeTableDisplay"] = boost::any(*attributeTableDisplay);
    }
    if (attributeType) {
      res["AttributeType"] = boost::any(*attributeType);
    }
    if (attributeUniqueness) {
      res["AttributeUniqueness"] = boost::any(*attributeUniqueness);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeBuiltIn") != m.end() && !m["AttributeBuiltIn"].empty()) {
      attributeBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["AttributeBuiltIn"]));
    }
    if (m.find("AttributeContent") != m.end() && !m["AttributeContent"].empty()) {
      attributeContent = make_shared<string>(boost::any_cast<string>(m["AttributeContent"]));
    }
    if (m.find("AttributeFormat") != m.end() && !m["AttributeFormat"].empty()) {
      attributeFormat = make_shared<string>(boost::any_cast<string>(m["AttributeFormat"]));
    }
    if (m.find("AttributeFuzzyQuery") != m.end() && !m["AttributeFuzzyQuery"].empty()) {
      attributeFuzzyQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeFuzzyQuery"]));
    }
    if (m.find("AttributeKey") != m.end() && !m["AttributeKey"].empty()) {
      attributeKey = make_shared<string>(boost::any_cast<string>(m["AttributeKey"]));
    }
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributePlaceholder") != m.end() && !m["AttributePlaceholder"].empty()) {
      attributePlaceholder = make_shared<string>(boost::any_cast<string>(m["AttributePlaceholder"]));
    }
    if (m.find("AttributeQuery") != m.end() && !m["AttributeQuery"].empty()) {
      attributeQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeQuery"]));
    }
    if (m.find("AttributeReference") != m.end() && !m["AttributeReference"].empty()) {
      attributeReference = make_shared<string>(boost::any_cast<string>(m["AttributeReference"]));
    }
    if (m.find("AttributeRequirement") != m.end() && !m["AttributeRequirement"].empty()) {
      attributeRequirement = make_shared<bool>(boost::any_cast<bool>(m["AttributeRequirement"]));
    }
    if (m.find("AttributeSequence") != m.end() && !m["AttributeSequence"].empty()) {
      attributeSequence = make_shared<long>(boost::any_cast<long>(m["AttributeSequence"]));
    }
    if (m.find("AttributeTableDisplay") != m.end() && !m["AttributeTableDisplay"].empty()) {
      attributeTableDisplay = make_shared<bool>(boost::any_cast<bool>(m["AttributeTableDisplay"]));
    }
    if (m.find("AttributeType") != m.end() && !m["AttributeType"].empty()) {
      attributeType = make_shared<string>(boost::any_cast<string>(m["AttributeType"]));
    }
    if (m.find("AttributeUniqueness") != m.end() && !m["AttributeUniqueness"].empty()) {
      attributeUniqueness = make_shared<bool>(boost::any_cast<bool>(m["AttributeUniqueness"]));
    }
  }


  virtual ~ListDeviceFormsResponseBodyDeviceFormsAttributeList() = default;
};
class ListDeviceFormsResponseBodyDeviceForms : public Darabonba::Model {
public:
  shared_ptr<bool> accountConfig{};
  shared_ptr<vector<ListDeviceFormsResponseBodyDeviceFormsAttributeList>> attributeList{};
  shared_ptr<bool> configCompare{};
  shared_ptr<bool> detailDisplay{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<bool> formBuiltIn{};
  shared_ptr<string> relatedDeviceFormId{};
  shared_ptr<string> resourceUse{};
  shared_ptr<string> script{};
  shared_ptr<string> uniqueKey{};

  ListDeviceFormsResponseBodyDeviceForms() {}

  explicit ListDeviceFormsResponseBodyDeviceForms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (attributeList) {
      vector<boost::any> temp1;
      for(auto item1:*attributeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeList"] = boost::any(temp1);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (detailDisplay) {
      res["DetailDisplay"] = boost::any(*detailDisplay);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (formBuiltIn) {
      res["FormBuiltIn"] = boost::any(*formBuiltIn);
    }
    if (relatedDeviceFormId) {
      res["RelatedDeviceFormId"] = boost::any(*relatedDeviceFormId);
    }
    if (resourceUse) {
      res["ResourceUse"] = boost::any(*resourceUse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<bool>(boost::any_cast<bool>(m["AccountConfig"]));
    }
    if (m.find("AttributeList") != m.end() && !m["AttributeList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeList"].type()) {
        vector<ListDeviceFormsResponseBodyDeviceFormsAttributeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceFormsResponseBodyDeviceFormsAttributeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeList = make_shared<vector<ListDeviceFormsResponseBodyDeviceFormsAttributeList>>(expect1);
      }
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<bool>(boost::any_cast<bool>(m["ConfigCompare"]));
    }
    if (m.find("DetailDisplay") != m.end() && !m["DetailDisplay"].empty()) {
      detailDisplay = make_shared<bool>(boost::any_cast<bool>(m["DetailDisplay"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("FormBuiltIn") != m.end() && !m["FormBuiltIn"].empty()) {
      formBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["FormBuiltIn"]));
    }
    if (m.find("RelatedDeviceFormId") != m.end() && !m["RelatedDeviceFormId"].empty()) {
      relatedDeviceFormId = make_shared<string>(boost::any_cast<string>(m["RelatedDeviceFormId"]));
    }
    if (m.find("ResourceUse") != m.end() && !m["ResourceUse"].empty()) {
      resourceUse = make_shared<string>(boost::any_cast<string>(m["ResourceUse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~ListDeviceFormsResponseBodyDeviceForms() = default;
};
class ListDeviceFormsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceFormsResponseBodyDeviceForms>> deviceForms{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDeviceFormsResponseBody() {}

  explicit ListDeviceFormsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceForms) {
      vector<boost::any> temp1;
      for(auto item1:*deviceForms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceForms"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceForms") != m.end() && !m["DeviceForms"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceForms"].type()) {
        vector<ListDeviceFormsResponseBodyDeviceForms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceForms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceFormsResponseBodyDeviceForms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceForms = make_shared<vector<ListDeviceFormsResponseBodyDeviceForms>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDeviceFormsResponseBody() = default;
};
class ListDeviceFormsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeviceFormsResponseBody> body{};

  ListDeviceFormsResponse() {}

  explicit ListDeviceFormsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceFormsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceFormsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceFormsResponse() = default;
};
class ListDevicePropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListDevicePropertiesRequest() {}

  explicit ListDevicePropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListDevicePropertiesRequest() = default;
};
class ListDevicePropertiesResponseBodyDeviceProperties : public Darabonba::Model {
public:
  shared_ptr<bool> builtIn{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> propertyContent{};
  shared_ptr<string> propertyFormat{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> propertyName{};

  ListDevicePropertiesResponseBodyDeviceProperties() {}

  explicit ListDevicePropertiesResponseBodyDeviceProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (builtIn) {
      res["BuiltIn"] = boost::any(*builtIn);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (propertyContent) {
      res["PropertyContent"] = boost::any(*propertyContent);
    }
    if (propertyFormat) {
      res["PropertyFormat"] = boost::any(*propertyFormat);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuiltIn") != m.end() && !m["BuiltIn"].empty()) {
      builtIn = make_shared<bool>(boost::any_cast<bool>(m["BuiltIn"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("PropertyContent") != m.end() && !m["PropertyContent"].empty()) {
      propertyContent = make_shared<string>(boost::any_cast<string>(m["PropertyContent"]));
    }
    if (m.find("PropertyFormat") != m.end() && !m["PropertyFormat"].empty()) {
      propertyFormat = make_shared<string>(boost::any_cast<string>(m["PropertyFormat"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
  }


  virtual ~ListDevicePropertiesResponseBodyDeviceProperties() = default;
};
class ListDevicePropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDevicePropertiesResponseBodyDeviceProperties>> deviceProperties{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDevicePropertiesResponseBody() {}

  explicit ListDevicePropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceProperties) {
      vector<boost::any> temp1;
      for(auto item1:*deviceProperties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceProperties"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceProperties") != m.end() && !m["DeviceProperties"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceProperties"].type()) {
        vector<ListDevicePropertiesResponseBodyDeviceProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceProperties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDevicePropertiesResponseBodyDeviceProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceProperties = make_shared<vector<ListDevicePropertiesResponseBodyDeviceProperties>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDevicePropertiesResponseBody() = default;
};
class ListDevicePropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDevicePropertiesResponseBody> body{};

  ListDevicePropertiesResponse() {}

  explicit ListDevicePropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDevicePropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDevicePropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDevicePropertiesResponse() = default;
};
class ListDeviceResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> listType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> setupProjectId{};

  ListDeviceResourcesRequest() {}

  explicit ListDeviceResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listType) {
      res["ListType"] = boost::any(*listType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ListType") != m.end() && !m["ListType"].empty()) {
      listType = make_shared<string>(boost::any_cast<string>(m["ListType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ListDeviceResourcesRequest() = default;
};
class ListDeviceResourcesResponseBodyDeviceResource : public Darabonba::Model {
public:
  shared_ptr<string> blockNumber{};
  shared_ptr<string> business{};
  shared_ptr<string> config{};
  shared_ptr<string> configTaskId{};
  shared_ptr<string> configTaskStatus{};
  shared_ptr<string> deliveryIp{};
  shared_ptr<string> deviceNumber{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> generateConfig{};
  shared_ptr<string> hostName{};
  shared_ptr<string> interConnection{};
  shared_ptr<string> location{};
  shared_ptr<string> loopback{};
  shared_ptr<string> managerIp{};
  shared_ptr<string> model{};
  shared_ptr<string> params{};
  shared_ptr<string> role{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> sn{};
  shared_ptr<string> specification{};
  shared_ptr<bool> stack{};
  shared_ptr<string> vendor{};

  ListDeviceResourcesResponseBodyDeviceResource() {}

  explicit ListDeviceResourcesResponseBodyDeviceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockNumber) {
      res["BlockNumber"] = boost::any(*blockNumber);
    }
    if (business) {
      res["Business"] = boost::any(*business);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (configTaskId) {
      res["ConfigTaskId"] = boost::any(*configTaskId);
    }
    if (configTaskStatus) {
      res["ConfigTaskStatus"] = boost::any(*configTaskStatus);
    }
    if (deliveryIp) {
      res["DeliveryIp"] = boost::any(*deliveryIp);
    }
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (generateConfig) {
      res["GenerateConfig"] = boost::any(*generateConfig);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (interConnection) {
      res["InterConnection"] = boost::any(*interConnection);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (loopback) {
      res["Loopback"] = boost::any(*loopback);
    }
    if (managerIp) {
      res["ManagerIp"] = boost::any(*managerIp);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (stack) {
      res["Stack"] = boost::any(*stack);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockNumber") != m.end() && !m["BlockNumber"].empty()) {
      blockNumber = make_shared<string>(boost::any_cast<string>(m["BlockNumber"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      business = make_shared<string>(boost::any_cast<string>(m["Business"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ConfigTaskId") != m.end() && !m["ConfigTaskId"].empty()) {
      configTaskId = make_shared<string>(boost::any_cast<string>(m["ConfigTaskId"]));
    }
    if (m.find("ConfigTaskStatus") != m.end() && !m["ConfigTaskStatus"].empty()) {
      configTaskStatus = make_shared<string>(boost::any_cast<string>(m["ConfigTaskStatus"]));
    }
    if (m.find("DeliveryIp") != m.end() && !m["DeliveryIp"].empty()) {
      deliveryIp = make_shared<string>(boost::any_cast<string>(m["DeliveryIp"]));
    }
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<string>(boost::any_cast<string>(m["DeviceNumber"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("GenerateConfig") != m.end() && !m["GenerateConfig"].empty()) {
      generateConfig = make_shared<string>(boost::any_cast<string>(m["GenerateConfig"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InterConnection") != m.end() && !m["InterConnection"].empty()) {
      interConnection = make_shared<string>(boost::any_cast<string>(m["InterConnection"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Loopback") != m.end() && !m["Loopback"].empty()) {
      loopback = make_shared<string>(boost::any_cast<string>(m["Loopback"]));
    }
    if (m.find("ManagerIp") != m.end() && !m["ManagerIp"].empty()) {
      managerIp = make_shared<string>(boost::any_cast<string>(m["ManagerIp"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Stack") != m.end() && !m["Stack"].empty()) {
      stack = make_shared<bool>(boost::any_cast<bool>(m["Stack"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListDeviceResourcesResponseBodyDeviceResource() = default;
};
class ListDeviceResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceResourcesResponseBodyDeviceResource>> deviceResource{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDeviceResourcesResponseBody() {}

  explicit ListDeviceResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResource) {
      vector<boost::any> temp1;
      for(auto item1:*deviceResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceResource"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResource") != m.end() && !m["DeviceResource"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceResource"].type()) {
        vector<ListDeviceResourcesResponseBodyDeviceResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceResourcesResponseBodyDeviceResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceResource = make_shared<vector<ListDeviceResourcesResponseBodyDeviceResource>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDeviceResourcesResponseBody() = default;
};
class ListDeviceResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeviceResourcesResponseBody> body{};

  ListDeviceResourcesResponse() {}

  explicit ListDeviceResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceResourcesResponse() = default;
};
class ListDeviceValuesRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeGroup{};
  shared_ptr<string> attributeKeyword{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> instanceId{};

  ListDeviceValuesRequest() {}

  explicit ListDeviceValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeGroup) {
      res["AttributeGroup"] = boost::any(*attributeGroup);
    }
    if (attributeKeyword) {
      res["AttributeKeyword"] = boost::any(*attributeKeyword);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeGroup") != m.end() && !m["AttributeGroup"].empty()) {
      attributeGroup = make_shared<string>(boost::any_cast<string>(m["AttributeGroup"]));
    }
    if (m.find("AttributeKeyword") != m.end() && !m["AttributeKeyword"].empty()) {
      attributeKeyword = make_shared<string>(boost::any_cast<string>(m["AttributeKeyword"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListDeviceValuesRequest() = default;
};
class ListDeviceValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceValues{};
  shared_ptr<string> requestId{};

  ListDeviceValuesResponseBody() {}

  explicit ListDeviceValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceValues) {
      res["DeviceValues"] = boost::any(*deviceValues);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceValues") != m.end() && !m["DeviceValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceValues = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeviceValuesResponseBody() = default;
};
class ListDeviceValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeviceValuesResponseBody> body{};

  ListDeviceValuesResponse() {}

  explicit ListDeviceValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceValuesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceValuesResponse() = default;
};
class ListDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> calculateAmount{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> extAttributes{};
  shared_ptr<vector<string>> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> ip{};
  shared_ptr<string> keyword{};
  shared_ptr<vector<string>> mac{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> model{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<vector<string>> physicalSpaceIds{};
  shared_ptr<vector<string>> securityDomain{};
  shared_ptr<vector<string>> serviceStatus{};
  shared_ptr<vector<string>> sn{};
  shared_ptr<vector<string>> vendor{};

  ListDevicesRequest() {}

  explicit ListDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calculateAmount) {
      res["CalculateAmount"] = boost::any(*calculateAmount);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceIds) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIds);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalculateAmount") != m.end() && !m["CalculateAmount"].empty()) {
      calculateAmount = make_shared<bool>(boost::any_cast<bool>(m["CalculateAmount"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Mac"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Mac"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mac = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Model"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      model = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalSpaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalSpaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalSpaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomain"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomain"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomain = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vendor"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vendor"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vendor = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDevicesRequest() = default;
};
class ListDevicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> calculateAmount{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> deviceIdsShrink{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> hostNameShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipShrink{};
  shared_ptr<string> keyword{};
  shared_ptr<string> macShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> modelShrink{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceIdsShrink{};
  shared_ptr<string> securityDomainShrink{};
  shared_ptr<string> serviceStatusShrink{};
  shared_ptr<string> snShrink{};
  shared_ptr<string> vendorShrink{};

  ListDevicesShrinkRequest() {}

  explicit ListDevicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calculateAmount) {
      res["CalculateAmount"] = boost::any(*calculateAmount);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (deviceIdsShrink) {
      res["DeviceIds"] = boost::any(*deviceIdsShrink);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostNameShrink) {
      res["HostName"] = boost::any(*hostNameShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipShrink) {
      res["Ip"] = boost::any(*ipShrink);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (macShrink) {
      res["Mac"] = boost::any(*macShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (modelShrink) {
      res["Model"] = boost::any(*modelShrink);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceIdsShrink) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIdsShrink);
    }
    if (securityDomainShrink) {
      res["SecurityDomain"] = boost::any(*securityDomainShrink);
    }
    if (serviceStatusShrink) {
      res["ServiceStatus"] = boost::any(*serviceStatusShrink);
    }
    if (snShrink) {
      res["Sn"] = boost::any(*snShrink);
    }
    if (vendorShrink) {
      res["Vendor"] = boost::any(*vendorShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalculateAmount") != m.end() && !m["CalculateAmount"].empty()) {
      calculateAmount = make_shared<bool>(boost::any_cast<bool>(m["CalculateAmount"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostNameShrink = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ipShrink = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      macShrink = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      modelShrink = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      physicalSpaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceIds"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomainShrink = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatusShrink = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      snShrink = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendorShrink = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListDevicesShrinkRequest() = default;
};
class ListDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> deviceFormName{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> mac{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> sn{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  ListDevicesResponseBodyDevices() {}

  explicit ListDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (deviceFormName) {
      res["DeviceFormName"] = boost::any(*deviceFormName);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("DeviceFormName") != m.end() && !m["DeviceFormName"].empty()) {
      deviceFormName = make_shared<string>(boost::any_cast<string>(m["DeviceFormName"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListDevicesResponseBodyDevices() = default;
};
class ListDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> amountDetail{};
  shared_ptr<long> amountUsed{};
  shared_ptr<vector<ListDevicesResponseBodyDevices>> devices{};
  shared_ptr<long> iotCoefficient{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> networkCoefficient{};
  shared_ptr<long> networkMaintenanceCoefficient{};
  shared_ptr<long> nextToken{};
  shared_ptr<long> otherCoefficient{};
  shared_ptr<string> requestId{};
  shared_ptr<long> serverCoefficient{};
  shared_ptr<long> serverMaintenanceCoefficient{};
  shared_ptr<long> totalCount{};

  ListDevicesResponseBody() {}

  explicit ListDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountDetail) {
      res["AmountDetail"] = boost::any(*amountDetail);
    }
    if (amountUsed) {
      res["AmountUsed"] = boost::any(*amountUsed);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (iotCoefficient) {
      res["IotCoefficient"] = boost::any(*iotCoefficient);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkCoefficient) {
      res["NetworkCoefficient"] = boost::any(*networkCoefficient);
    }
    if (networkMaintenanceCoefficient) {
      res["NetworkMaintenanceCoefficient"] = boost::any(*networkMaintenanceCoefficient);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (otherCoefficient) {
      res["OtherCoefficient"] = boost::any(*otherCoefficient);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serverCoefficient) {
      res["ServerCoefficient"] = boost::any(*serverCoefficient);
    }
    if (serverMaintenanceCoefficient) {
      res["ServerMaintenanceCoefficient"] = boost::any(*serverMaintenanceCoefficient);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmountDetail") != m.end() && !m["AmountDetail"].empty()) {
      amountDetail = make_shared<string>(boost::any_cast<string>(m["AmountDetail"]));
    }
    if (m.find("AmountUsed") != m.end() && !m["AmountUsed"].empty()) {
      amountUsed = make_shared<long>(boost::any_cast<long>(m["AmountUsed"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<ListDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<ListDevicesResponseBodyDevices>>(expect1);
      }
    }
    if (m.find("IotCoefficient") != m.end() && !m["IotCoefficient"].empty()) {
      iotCoefficient = make_shared<long>(boost::any_cast<long>(m["IotCoefficient"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkCoefficient") != m.end() && !m["NetworkCoefficient"].empty()) {
      networkCoefficient = make_shared<long>(boost::any_cast<long>(m["NetworkCoefficient"]));
    }
    if (m.find("NetworkMaintenanceCoefficient") != m.end() && !m["NetworkMaintenanceCoefficient"].empty()) {
      networkMaintenanceCoefficient = make_shared<long>(boost::any_cast<long>(m["NetworkMaintenanceCoefficient"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("OtherCoefficient") != m.end() && !m["OtherCoefficient"].empty()) {
      otherCoefficient = make_shared<long>(boost::any_cast<long>(m["OtherCoefficient"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServerCoefficient") != m.end() && !m["ServerCoefficient"].empty()) {
      serverCoefficient = make_shared<long>(boost::any_cast<long>(m["ServerCoefficient"]));
    }
    if (m.find("ServerMaintenanceCoefficient") != m.end() && !m["ServerMaintenanceCoefficient"].empty()) {
      serverMaintenanceCoefficient = make_shared<long>(boost::any_cast<long>(m["ServerMaintenanceCoefficient"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDevicesResponseBody() = default;
};
class ListDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDevicesResponseBody> body{};

  ListDevicesResponse() {}

  explicit ListDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDevicesResponse() = default;
};
class ListEventDefinitionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListEventDefinitionsRequest() {}

  explicit ListEventDefinitionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListEventDefinitionsRequest() = default;
};
class ListEventDefinitionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<EventDefinition>> eventDefinitions{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEventDefinitionsResponseBody() {}

  explicit ListEventDefinitionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventDefinitions) {
      vector<boost::any> temp1;
      for(auto item1:*eventDefinitions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventDefinitions"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventDefinitions") != m.end() && !m["EventDefinitions"].empty()) {
      if (typeid(vector<boost::any>) == m["EventDefinitions"].type()) {
        vector<EventDefinition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventDefinitions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EventDefinition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventDefinitions = make_shared<vector<EventDefinition>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEventDefinitionsResponseBody() = default;
};
class ListEventDefinitionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventDefinitionsResponseBody> body{};

  ListEventDefinitionsResponse() {}

  explicit ListEventDefinitionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventDefinitionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventDefinitionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventDefinitionsResponse() = default;
};
class ListEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};

  ListEventsRequest() {}

  explicit ListEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~ListEventsRequest() = default;
};
class ListEventsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> status{};

  ListEventsResponseBodyStatistics() {}

  explicit ListEventsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListEventsResponseBodyStatistics() = default;
};
class ListEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Event>> events{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListEventsResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalCount{};

  ListEventsResponseBody() {}

  explicit ListEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Events"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<Event> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Event model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<Event>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<ListEventsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<ListEventsResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEventsResponseBody() = default;
};
class ListEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventsResponseBody> body{};

  ListEventsResponse() {}

  explicit ListEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventsResponse() = default;
};
class ListInspectionDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appState{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> model{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> vendor{};

  ListInspectionDevicesRequest() {}

  explicit ListInspectionDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appState) {
      res["AppState"] = boost::any(*appState);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppState") != m.end() && !m["AppState"].empty()) {
      appState = make_shared<string>(boost::any_cast<string>(m["AppState"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Model"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      model = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionDevicesRequest() = default;
};
class ListInspectionDevicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appState{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> modelShrink{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> vendor{};

  ListInspectionDevicesShrinkRequest() {}

  explicit ListInspectionDevicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appState) {
      res["AppState"] = boost::any(*appState);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modelShrink) {
      res["Model"] = boost::any(*modelShrink);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppState") != m.end() && !m["AppState"].empty()) {
      appState = make_shared<string>(boost::any_cast<string>(m["AppState"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      modelShrink = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionDevicesShrinkRequest() = default;
};
class ListInspectionDevicesResponseBodyInspectionScripts : public Darabonba::Model {
public:
  shared_ptr<string> appState{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> hostName{};
  shared_ptr<string> manageIp{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> vendor{};

  ListInspectionDevicesResponseBodyInspectionScripts() {}

  explicit ListInspectionDevicesResponseBodyInspectionScripts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appState) {
      res["AppState"] = boost::any(*appState);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (manageIp) {
      res["ManageIp"] = boost::any(*manageIp);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppState") != m.end() && !m["AppState"].empty()) {
      appState = make_shared<string>(boost::any_cast<string>(m["AppState"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ManageIp") != m.end() && !m["ManageIp"].empty()) {
      manageIp = make_shared<string>(boost::any_cast<string>(m["ManageIp"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionDevicesResponseBodyInspectionScripts() = default;
};
class ListInspectionDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInspectionDevicesResponseBodyInspectionScripts>> inspectionScripts{};
  shared_ptr<string> requestId{};

  ListInspectionDevicesResponseBody() {}

  explicit ListInspectionDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionScripts) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionScripts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionScripts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionScripts") != m.end() && !m["InspectionScripts"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionScripts"].type()) {
        vector<ListInspectionDevicesResponseBodyInspectionScripts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionScripts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionDevicesResponseBodyInspectionScripts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionScripts = make_shared<vector<ListInspectionDevicesResponseBodyInspectionScripts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInspectionDevicesResponseBody() = default;
};
class ListInspectionDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInspectionDevicesResponseBody> body{};

  ListInspectionDevicesResponse() {}

  explicit ListInspectionDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInspectionDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInspectionDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInspectionDevicesResponse() = default;
};
class ListInspectionTaskReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> inspectionItemId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> vendor{};

  ListInspectionTaskReportsRequest() {}

  explicit ListInspectionTaskReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionItemId) {
      res["InspectionItemId"] = boost::any(*inspectionItemId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionItemId") != m.end() && !m["InspectionItemId"].empty()) {
      inspectionItemId = make_shared<string>(boost::any_cast<string>(m["InspectionItemId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionTaskReportsRequest() = default;
};
class ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic : public Darabonba::Model {
public:
  shared_ptr<long> criticalNumber{};
  shared_ptr<string> inspectionItem{};
  shared_ptr<string> model{};
  shared_ptr<string> vendor{};
  shared_ptr<long> warningNumber{};

  ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic() {}

  explicit ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criticalNumber) {
      res["CriticalNumber"] = boost::any(*criticalNumber);
    }
    if (inspectionItem) {
      res["InspectionItem"] = boost::any(*inspectionItem);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (warningNumber) {
      res["WarningNumber"] = boost::any(*warningNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriticalNumber") != m.end() && !m["CriticalNumber"].empty()) {
      criticalNumber = make_shared<long>(boost::any_cast<long>(m["CriticalNumber"]));
    }
    if (m.find("InspectionItem") != m.end() && !m["InspectionItem"].empty()) {
      inspectionItem = make_shared<string>(boost::any_cast<string>(m["InspectionItem"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
    if (m.find("WarningNumber") != m.end() && !m["WarningNumber"].empty()) {
      warningNumber = make_shared<long>(boost::any_cast<long>(m["WarningNumber"]));
    }
  }


  virtual ~ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic() = default;
};
class ListInspectionTaskReportsResponseBodyInspectionTask : public Darabonba::Model {
public:
  shared_ptr<long> actualDeviceNumber{};
  shared_ptr<long> alarmNumber{};
  shared_ptr<vector<ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic>> alarmStatistic{};
  shared_ptr<long> criticalNumber{};
  shared_ptr<string> criticalRate{};
  shared_ptr<string> deviceRate{};
  shared_ptr<string> failureStatistic{};
  shared_ptr<long> failureTaskNumber{};
  shared_ptr<string> failureTaskRate{};
  shared_ptr<long> normalNumber{};
  shared_ptr<string> normalRate{};
  shared_ptr<long> runningTaskNumber{};
  shared_ptr<string> runningTaskRate{};
  shared_ptr<long> successTaskNumber{};
  shared_ptr<string> successTaskRate{};
  shared_ptr<long> taskNumber{};
  shared_ptr<long> totalDeviceNumber{};
  shared_ptr<long> warningNumber{};
  shared_ptr<string> warningRate{};

  ListInspectionTaskReportsResponseBodyInspectionTask() {}

  explicit ListInspectionTaskReportsResponseBodyInspectionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualDeviceNumber) {
      res["ActualDeviceNumber"] = boost::any(*actualDeviceNumber);
    }
    if (alarmNumber) {
      res["AlarmNumber"] = boost::any(*alarmNumber);
    }
    if (alarmStatistic) {
      vector<boost::any> temp1;
      for(auto item1:*alarmStatistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmStatistic"] = boost::any(temp1);
    }
    if (criticalNumber) {
      res["CriticalNumber"] = boost::any(*criticalNumber);
    }
    if (criticalRate) {
      res["CriticalRate"] = boost::any(*criticalRate);
    }
    if (deviceRate) {
      res["DeviceRate"] = boost::any(*deviceRate);
    }
    if (failureStatistic) {
      res["FailureStatistic"] = boost::any(*failureStatistic);
    }
    if (failureTaskNumber) {
      res["FailureTaskNumber"] = boost::any(*failureTaskNumber);
    }
    if (failureTaskRate) {
      res["FailureTaskRate"] = boost::any(*failureTaskRate);
    }
    if (normalNumber) {
      res["NormalNumber"] = boost::any(*normalNumber);
    }
    if (normalRate) {
      res["NormalRate"] = boost::any(*normalRate);
    }
    if (runningTaskNumber) {
      res["RunningTaskNumber"] = boost::any(*runningTaskNumber);
    }
    if (runningTaskRate) {
      res["RunningTaskRate"] = boost::any(*runningTaskRate);
    }
    if (successTaskNumber) {
      res["SuccessTaskNumber"] = boost::any(*successTaskNumber);
    }
    if (successTaskRate) {
      res["SuccessTaskRate"] = boost::any(*successTaskRate);
    }
    if (taskNumber) {
      res["TaskNumber"] = boost::any(*taskNumber);
    }
    if (totalDeviceNumber) {
      res["TotalDeviceNumber"] = boost::any(*totalDeviceNumber);
    }
    if (warningNumber) {
      res["WarningNumber"] = boost::any(*warningNumber);
    }
    if (warningRate) {
      res["WarningRate"] = boost::any(*warningRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualDeviceNumber") != m.end() && !m["ActualDeviceNumber"].empty()) {
      actualDeviceNumber = make_shared<long>(boost::any_cast<long>(m["ActualDeviceNumber"]));
    }
    if (m.find("AlarmNumber") != m.end() && !m["AlarmNumber"].empty()) {
      alarmNumber = make_shared<long>(boost::any_cast<long>(m["AlarmNumber"]));
    }
    if (m.find("AlarmStatistic") != m.end() && !m["AlarmStatistic"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmStatistic"].type()) {
        vector<ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmStatistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmStatistic = make_shared<vector<ListInspectionTaskReportsResponseBodyInspectionTaskAlarmStatistic>>(expect1);
      }
    }
    if (m.find("CriticalNumber") != m.end() && !m["CriticalNumber"].empty()) {
      criticalNumber = make_shared<long>(boost::any_cast<long>(m["CriticalNumber"]));
    }
    if (m.find("CriticalRate") != m.end() && !m["CriticalRate"].empty()) {
      criticalRate = make_shared<string>(boost::any_cast<string>(m["CriticalRate"]));
    }
    if (m.find("DeviceRate") != m.end() && !m["DeviceRate"].empty()) {
      deviceRate = make_shared<string>(boost::any_cast<string>(m["DeviceRate"]));
    }
    if (m.find("FailureStatistic") != m.end() && !m["FailureStatistic"].empty()) {
      failureStatistic = make_shared<string>(boost::any_cast<string>(m["FailureStatistic"]));
    }
    if (m.find("FailureTaskNumber") != m.end() && !m["FailureTaskNumber"].empty()) {
      failureTaskNumber = make_shared<long>(boost::any_cast<long>(m["FailureTaskNumber"]));
    }
    if (m.find("FailureTaskRate") != m.end() && !m["FailureTaskRate"].empty()) {
      failureTaskRate = make_shared<string>(boost::any_cast<string>(m["FailureTaskRate"]));
    }
    if (m.find("NormalNumber") != m.end() && !m["NormalNumber"].empty()) {
      normalNumber = make_shared<long>(boost::any_cast<long>(m["NormalNumber"]));
    }
    if (m.find("NormalRate") != m.end() && !m["NormalRate"].empty()) {
      normalRate = make_shared<string>(boost::any_cast<string>(m["NormalRate"]));
    }
    if (m.find("RunningTaskNumber") != m.end() && !m["RunningTaskNumber"].empty()) {
      runningTaskNumber = make_shared<long>(boost::any_cast<long>(m["RunningTaskNumber"]));
    }
    if (m.find("RunningTaskRate") != m.end() && !m["RunningTaskRate"].empty()) {
      runningTaskRate = make_shared<string>(boost::any_cast<string>(m["RunningTaskRate"]));
    }
    if (m.find("SuccessTaskNumber") != m.end() && !m["SuccessTaskNumber"].empty()) {
      successTaskNumber = make_shared<long>(boost::any_cast<long>(m["SuccessTaskNumber"]));
    }
    if (m.find("SuccessTaskRate") != m.end() && !m["SuccessTaskRate"].empty()) {
      successTaskRate = make_shared<string>(boost::any_cast<string>(m["SuccessTaskRate"]));
    }
    if (m.find("TaskNumber") != m.end() && !m["TaskNumber"].empty()) {
      taskNumber = make_shared<long>(boost::any_cast<long>(m["TaskNumber"]));
    }
    if (m.find("TotalDeviceNumber") != m.end() && !m["TotalDeviceNumber"].empty()) {
      totalDeviceNumber = make_shared<long>(boost::any_cast<long>(m["TotalDeviceNumber"]));
    }
    if (m.find("WarningNumber") != m.end() && !m["WarningNumber"].empty()) {
      warningNumber = make_shared<long>(boost::any_cast<long>(m["WarningNumber"]));
    }
    if (m.find("WarningRate") != m.end() && !m["WarningRate"].empty()) {
      warningRate = make_shared<string>(boost::any_cast<string>(m["WarningRate"]));
    }
  }


  virtual ~ListInspectionTaskReportsResponseBodyInspectionTask() = default;
};
class ListInspectionTaskReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInspectionTaskReportsResponseBodyInspectionTask>> inspectionTask{};
  shared_ptr<string> requestId{};

  ListInspectionTaskReportsResponseBody() {}

  explicit ListInspectionTaskReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionTask) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionTask"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionTask") != m.end() && !m["InspectionTask"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionTask"].type()) {
        vector<ListInspectionTaskReportsResponseBodyInspectionTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionTaskReportsResponseBodyInspectionTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionTask = make_shared<vector<ListInspectionTaskReportsResponseBodyInspectionTask>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInspectionTaskReportsResponseBody() = default;
};
class ListInspectionTaskReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInspectionTaskReportsResponseBody> body{};

  ListInspectionTaskReportsResponse() {}

  explicit ListInspectionTaskReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInspectionTaskReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInspectionTaskReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListInspectionTaskReportsResponse() = default;
};
class ListInspectionTasksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alarmStatus{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> hostName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> model{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> vendor{};

  ListInspectionTasksRequest() {}

  explicit ListInspectionTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlarmStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlarmStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alarmStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionTasksRequest() = default;
};
class ListInspectionTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatusShrink{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> hostName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> model{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> role{};
  shared_ptr<string> space{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> vendor{};

  ListInspectionTasksShrinkRequest() {}

  explicit ListInspectionTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatusShrink) {
      res["AlarmStatus"] = boost::any(*alarmStatusShrink);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatusShrink = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionTasksShrinkRequest() = default;
};
class ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules : public Darabonba::Model {
public:
  shared_ptr<string> actualValue{};
  shared_ptr<string> alarmExpression{};
  shared_ptr<string> alarmLevel{};
  shared_ptr<string> alarmOperator{};
  shared_ptr<string> alarmValue{};

  ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules() {}

  explicit ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualValue) {
      res["ActualValue"] = boost::any(*actualValue);
    }
    if (alarmExpression) {
      res["AlarmExpression"] = boost::any(*alarmExpression);
    }
    if (alarmLevel) {
      res["AlarmLevel"] = boost::any(*alarmLevel);
    }
    if (alarmOperator) {
      res["AlarmOperator"] = boost::any(*alarmOperator);
    }
    if (alarmValue) {
      res["AlarmValue"] = boost::any(*alarmValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualValue") != m.end() && !m["ActualValue"].empty()) {
      actualValue = make_shared<string>(boost::any_cast<string>(m["ActualValue"]));
    }
    if (m.find("AlarmExpression") != m.end() && !m["AlarmExpression"].empty()) {
      alarmExpression = make_shared<string>(boost::any_cast<string>(m["AlarmExpression"]));
    }
    if (m.find("AlarmLevel") != m.end() && !m["AlarmLevel"].empty()) {
      alarmLevel = make_shared<string>(boost::any_cast<string>(m["AlarmLevel"]));
    }
    if (m.find("AlarmOperator") != m.end() && !m["AlarmOperator"].empty()) {
      alarmOperator = make_shared<string>(boost::any_cast<string>(m["AlarmOperator"]));
    }
    if (m.find("AlarmValue") != m.end() && !m["AlarmValue"].empty()) {
      alarmValue = make_shared<string>(boost::any_cast<string>(m["AlarmValue"]));
    }
  }


  virtual ~ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules() = default;
};
class ListInspectionTasksResponseBodyInspectionTasks : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> executionBeginTime{};
  shared_ptr<string> executionEndTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> IP{};
  shared_ptr<vector<ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules>> inspectionAlarmRules{};
  shared_ptr<string> inspectionMessage{};
  shared_ptr<string> inspectionResult{};
  shared_ptr<bool> isInspectionResultTruncation{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<vector<string>> model{};
  shared_ptr<string> role{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> space{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> vendor{};

  ListInspectionTasksResponseBodyInspectionTasks() {}

  explicit ListInspectionTasksResponseBodyInspectionTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (executionBeginTime) {
      res["ExecutionBeginTime"] = boost::any(*executionBeginTime);
    }
    if (executionEndTime) {
      res["ExecutionEndTime"] = boost::any(*executionEndTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (inspectionAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionAlarmRules"] = boost::any(temp1);
    }
    if (inspectionMessage) {
      res["InspectionMessage"] = boost::any(*inspectionMessage);
    }
    if (inspectionResult) {
      res["InspectionResult"] = boost::any(*inspectionResult);
    }
    if (isInspectionResultTruncation) {
      res["IsInspectionResultTruncation"] = boost::any(*isInspectionResultTruncation);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ExecutionBeginTime") != m.end() && !m["ExecutionBeginTime"].empty()) {
      executionBeginTime = make_shared<string>(boost::any_cast<string>(m["ExecutionBeginTime"]));
    }
    if (m.find("ExecutionEndTime") != m.end() && !m["ExecutionEndTime"].empty()) {
      executionEndTime = make_shared<string>(boost::any_cast<string>(m["ExecutionEndTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InspectionAlarmRules") != m.end() && !m["InspectionAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionAlarmRules"].type()) {
        vector<ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionAlarmRules = make_shared<vector<ListInspectionTasksResponseBodyInspectionTasksInspectionAlarmRules>>(expect1);
      }
    }
    if (m.find("InspectionMessage") != m.end() && !m["InspectionMessage"].empty()) {
      inspectionMessage = make_shared<string>(boost::any_cast<string>(m["InspectionMessage"]));
    }
    if (m.find("InspectionResult") != m.end() && !m["InspectionResult"].empty()) {
      inspectionResult = make_shared<string>(boost::any_cast<string>(m["InspectionResult"]));
    }
    if (m.find("IsInspectionResultTruncation") != m.end() && !m["IsInspectionResultTruncation"].empty()) {
      isInspectionResultTruncation = make_shared<bool>(boost::any_cast<bool>(m["IsInspectionResultTruncation"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Model"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      model = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["Space"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListInspectionTasksResponseBodyInspectionTasks() = default;
};
class ListInspectionTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInspectionTasksResponseBodyInspectionTasks>> inspectionTasks{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListInspectionTasksResponseBody() {}

  explicit ListInspectionTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionTasks) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionTasks"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionTasks") != m.end() && !m["InspectionTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionTasks"].type()) {
        vector<ListInspectionTasksResponseBodyInspectionTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionTasksResponseBodyInspectionTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionTasks = make_shared<vector<ListInspectionTasksResponseBodyInspectionTasks>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInspectionTasksResponseBody() = default;
};
class ListInspectionTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInspectionTasksResponseBody> body{};

  ListInspectionTasksResponse() {}

  explicit ListInspectionTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInspectionTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInspectionTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListInspectionTasksResponse() = default;
};
class ListInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> instanceDeviceMaxCount{};
  shared_ptr<string> instanceEndDate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceOpenDate{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> instanceStatus{};

  ListInstancesResponseBodyInstances() {}

  explicit ListInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDeviceMaxCount) {
      res["InstanceDeviceMaxCount"] = boost::any(*instanceDeviceMaxCount);
    }
    if (instanceEndDate) {
      res["InstanceEndDate"] = boost::any(*instanceEndDate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceOpenDate) {
      res["InstanceOpenDate"] = boost::any(*instanceOpenDate);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDeviceMaxCount") != m.end() && !m["InstanceDeviceMaxCount"].empty()) {
      instanceDeviceMaxCount = make_shared<string>(boost::any_cast<string>(m["InstanceDeviceMaxCount"]));
    }
    if (m.find("InstanceEndDate") != m.end() && !m["InstanceEndDate"].empty()) {
      instanceEndDate = make_shared<string>(boost::any_cast<string>(m["InstanceEndDate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceOpenDate") != m.end() && !m["InstanceOpenDate"].empty()) {
      instanceOpenDate = make_shared<string>(boost::any_cast<string>(m["InstanceOpenDate"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstances() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListIpBlocksRequest : public Darabonba::Model {
public:
  shared_ptr<bool> bottomNode{};
  shared_ptr<string> category{};
  shared_ptr<map<string, boost::any>> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> ipBlockCode{};
  shared_ptr<vector<string>> ipList{};
  shared_ptr<bool> leafNode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> netBusiness{};
  shared_ptr<string> netType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> status{};
  shared_ptr<string> subNetBusiness{};
  shared_ptr<bool> topParent{};
  shared_ptr<bool> treeType{};
  shared_ptr<string> zoneName{};

  ListIpBlocksRequest() {}

  explicit ListIpBlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bottomNode) {
      res["BottomNode"] = boost::any(*bottomNode);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipBlockCode) {
      res["IpBlockCode"] = boost::any(*ipBlockCode);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (leafNode) {
      res["LeafNode"] = boost::any(*leafNode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (netBusiness) {
      res["NetBusiness"] = boost::any(*netBusiness);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subNetBusiness) {
      res["SubNetBusiness"] = boost::any(*subNetBusiness);
    }
    if (topParent) {
      res["TopParent"] = boost::any(*topParent);
    }
    if (treeType) {
      res["TreeType"] = boost::any(*treeType);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BottomNode") != m.end() && !m["BottomNode"].empty()) {
      bottomNode = make_shared<bool>(boost::any_cast<bool>(m["BottomNode"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtAttributes"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extAttributes = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpBlockCode") != m.end() && !m["IpBlockCode"].empty()) {
      ipBlockCode = make_shared<string>(boost::any_cast<string>(m["IpBlockCode"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LeafNode") != m.end() && !m["LeafNode"].empty()) {
      leafNode = make_shared<bool>(boost::any_cast<bool>(m["LeafNode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetBusiness") != m.end() && !m["NetBusiness"].empty()) {
      netBusiness = make_shared<string>(boost::any_cast<string>(m["NetBusiness"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubNetBusiness") != m.end() && !m["SubNetBusiness"].empty()) {
      subNetBusiness = make_shared<string>(boost::any_cast<string>(m["SubNetBusiness"]));
    }
    if (m.find("TopParent") != m.end() && !m["TopParent"].empty()) {
      topParent = make_shared<bool>(boost::any_cast<bool>(m["TopParent"]));
    }
    if (m.find("TreeType") != m.end() && !m["TreeType"].empty()) {
      treeType = make_shared<bool>(boost::any_cast<bool>(m["TreeType"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~ListIpBlocksRequest() = default;
};
class ListIpBlocksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> bottomNode{};
  shared_ptr<string> category{};
  shared_ptr<string> extAttributesShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> ipBlockCode{};
  shared_ptr<string> ipListShrink{};
  shared_ptr<bool> leafNode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> netBusiness{};
  shared_ptr<string> netType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> status{};
  shared_ptr<string> subNetBusiness{};
  shared_ptr<bool> topParent{};
  shared_ptr<bool> treeType{};
  shared_ptr<string> zoneName{};

  ListIpBlocksShrinkRequest() {}

  explicit ListIpBlocksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bottomNode) {
      res["BottomNode"] = boost::any(*bottomNode);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (extAttributesShrink) {
      res["ExtAttributes"] = boost::any(*extAttributesShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipBlockCode) {
      res["IpBlockCode"] = boost::any(*ipBlockCode);
    }
    if (ipListShrink) {
      res["IpList"] = boost::any(*ipListShrink);
    }
    if (leafNode) {
      res["LeafNode"] = boost::any(*leafNode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (netBusiness) {
      res["NetBusiness"] = boost::any(*netBusiness);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subNetBusiness) {
      res["SubNetBusiness"] = boost::any(*subNetBusiness);
    }
    if (topParent) {
      res["TopParent"] = boost::any(*topParent);
    }
    if (treeType) {
      res["TreeType"] = boost::any(*treeType);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BottomNode") != m.end() && !m["BottomNode"].empty()) {
      bottomNode = make_shared<bool>(boost::any_cast<bool>(m["BottomNode"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributesShrink = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpBlockCode") != m.end() && !m["IpBlockCode"].empty()) {
      ipBlockCode = make_shared<string>(boost::any_cast<string>(m["IpBlockCode"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipListShrink = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("LeafNode") != m.end() && !m["LeafNode"].empty()) {
      leafNode = make_shared<bool>(boost::any_cast<bool>(m["LeafNode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetBusiness") != m.end() && !m["NetBusiness"].empty()) {
      netBusiness = make_shared<string>(boost::any_cast<string>(m["NetBusiness"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubNetBusiness") != m.end() && !m["SubNetBusiness"].empty()) {
      subNetBusiness = make_shared<string>(boost::any_cast<string>(m["SubNetBusiness"]));
    }
    if (m.find("TopParent") != m.end() && !m["TopParent"].empty()) {
      topParent = make_shared<bool>(boost::any_cast<bool>(m["TopParent"]));
    }
    if (m.find("TreeType") != m.end() && !m["TreeType"].empty()) {
      treeType = make_shared<bool>(boost::any_cast<bool>(m["TreeType"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~ListIpBlocksShrinkRequest() = default;
};
class ListIpBlocksResponseBodyIpBlockTasksIpList : public Darabonba::Model {
public:
  shared_ptr<string> devId{};
  shared_ptr<string> devName{};
  shared_ptr<string> ip{};
  shared_ptr<string> origin{};
  shared_ptr<string> ping{};

  ListIpBlocksResponseBodyIpBlockTasksIpList() {}

  explicit ListIpBlocksResponseBodyIpBlockTasksIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devId) {
      res["DevId"] = boost::any(*devId);
    }
    if (devName) {
      res["DevName"] = boost::any(*devName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (ping) {
      res["Ping"] = boost::any(*ping);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevId") != m.end() && !m["DevId"].empty()) {
      devId = make_shared<string>(boost::any_cast<string>(m["DevId"]));
    }
    if (m.find("DevName") != m.end() && !m["DevName"].empty()) {
      devName = make_shared<string>(boost::any_cast<string>(m["DevName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("Ping") != m.end() && !m["Ping"].empty()) {
      ping = make_shared<string>(boost::any_cast<string>(m["Ping"]));
    }
  }


  virtual ~ListIpBlocksResponseBodyIpBlockTasksIpList() = default;
};
class ListIpBlocksResponseBodyIpBlockTasks : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtModifiedTime{};
  shared_ptr<string> ip{};
  shared_ptr<vector<ListIpBlocksResponseBodyIpBlockTasksIpList>> ipList{};
  shared_ptr<string> msg{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<long> totalIpCount{};

  ListIpBlocksResponseBodyIpBlockTasks() {}

  explicit ListIpBlocksResponseBodyIpBlockTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtModifiedTime) {
      res["GmtModifiedTime"] = boost::any(*gmtModifiedTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipList) {
      vector<boost::any> temp1;
      for(auto item1:*ipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpList"] = boost::any(temp1);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalIpCount) {
      res["TotalIpCount"] = boost::any(*totalIpCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtModifiedTime") != m.end() && !m["GmtModifiedTime"].empty()) {
      gmtModifiedTime = make_shared<string>(boost::any_cast<string>(m["GmtModifiedTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<ListIpBlocksResponseBodyIpBlockTasksIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpBlocksResponseBodyIpBlockTasksIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipList = make_shared<vector<ListIpBlocksResponseBodyIpBlockTasksIpList>>(expect1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TotalIpCount") != m.end() && !m["TotalIpCount"].empty()) {
      totalIpCount = make_shared<long>(boost::any_cast<long>(m["TotalIpCount"]));
    }
  }


  virtual ~ListIpBlocksResponseBodyIpBlockTasks() = default;
};
class ListIpBlocksResponseBodyIpBlockZoneLayer : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListIpBlocksResponseBodyIpBlockZoneLayer() {}

  explicit ListIpBlocksResponseBodyIpBlockZoneLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIpBlocksResponseBodyIpBlockZoneLayer() = default;
};
class ListIpBlocksResponseBodyIpBlock : public Darabonba::Model {
public:
  shared_ptr<string> abbr{};
  shared_ptr<string> application{};
  shared_ptr<string> backupDeviceName{};
  shared_ptr<string> businessTypeId{};
  shared_ptr<string> businessTypeName{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceName{};
  shared_ptr<map<string, boost::any>> extAttributes{};
  shared_ptr<string> ipBlockCode{};
  shared_ptr<string> ipBlockId{};
  shared_ptr<vector<string>> ipBlocks{};
  shared_ptr<long> isLock{};
  shared_ptr<string> limitZoneTypes{};
  shared_ptr<string> netBusiness{};
  shared_ptr<string> netType{};
  shared_ptr<string> ownership{};
  shared_ptr<string> parentId{};
  shared_ptr<vector<string>> queryIpList{};
  shared_ptr<double> splitRate{};
  shared_ptr<string> status{};
  shared_ptr<string> subBusinessTypeName{};
  shared_ptr<vector<ListIpBlocksResponseBodyIpBlockTasks>> tasks{};
  shared_ptr<vector<ListIpBlocksResponseBodyIpBlockZoneLayer>> zoneLayer{};
  shared_ptr<string> zoneName{};

  ListIpBlocksResponseBodyIpBlock() {}

  explicit ListIpBlocksResponseBodyIpBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbr) {
      res["Abbr"] = boost::any(*abbr);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (backupDeviceName) {
      res["BackupDeviceName"] = boost::any(*backupDeviceName);
    }
    if (businessTypeId) {
      res["BusinessTypeId"] = boost::any(*businessTypeId);
    }
    if (businessTypeName) {
      res["BusinessTypeName"] = boost::any(*businessTypeName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (ipBlockCode) {
      res["IpBlockCode"] = boost::any(*ipBlockCode);
    }
    if (ipBlockId) {
      res["IpBlockId"] = boost::any(*ipBlockId);
    }
    if (ipBlocks) {
      res["IpBlocks"] = boost::any(*ipBlocks);
    }
    if (isLock) {
      res["IsLock"] = boost::any(*isLock);
    }
    if (limitZoneTypes) {
      res["LimitZoneTypes"] = boost::any(*limitZoneTypes);
    }
    if (netBusiness) {
      res["NetBusiness"] = boost::any(*netBusiness);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (ownership) {
      res["Ownership"] = boost::any(*ownership);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (queryIpList) {
      res["QueryIpList"] = boost::any(*queryIpList);
    }
    if (splitRate) {
      res["SplitRate"] = boost::any(*splitRate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subBusinessTypeName) {
      res["SubBusinessTypeName"] = boost::any(*subBusinessTypeName);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (zoneLayer) {
      vector<boost::any> temp1;
      for(auto item1:*zoneLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneLayer"] = boost::any(temp1);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbr") != m.end() && !m["Abbr"].empty()) {
      abbr = make_shared<string>(boost::any_cast<string>(m["Abbr"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("BackupDeviceName") != m.end() && !m["BackupDeviceName"].empty()) {
      backupDeviceName = make_shared<string>(boost::any_cast<string>(m["BackupDeviceName"]));
    }
    if (m.find("BusinessTypeId") != m.end() && !m["BusinessTypeId"].empty()) {
      businessTypeId = make_shared<string>(boost::any_cast<string>(m["BusinessTypeId"]));
    }
    if (m.find("BusinessTypeName") != m.end() && !m["BusinessTypeName"].empty()) {
      businessTypeName = make_shared<string>(boost::any_cast<string>(m["BusinessTypeName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtAttributes"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extAttributes = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IpBlockCode") != m.end() && !m["IpBlockCode"].empty()) {
      ipBlockCode = make_shared<string>(boost::any_cast<string>(m["IpBlockCode"]));
    }
    if (m.find("IpBlockId") != m.end() && !m["IpBlockId"].empty()) {
      ipBlockId = make_shared<string>(boost::any_cast<string>(m["IpBlockId"]));
    }
    if (m.find("IpBlocks") != m.end() && !m["IpBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsLock") != m.end() && !m["IsLock"].empty()) {
      isLock = make_shared<long>(boost::any_cast<long>(m["IsLock"]));
    }
    if (m.find("LimitZoneTypes") != m.end() && !m["LimitZoneTypes"].empty()) {
      limitZoneTypes = make_shared<string>(boost::any_cast<string>(m["LimitZoneTypes"]));
    }
    if (m.find("NetBusiness") != m.end() && !m["NetBusiness"].empty()) {
      netBusiness = make_shared<string>(boost::any_cast<string>(m["NetBusiness"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("Ownership") != m.end() && !m["Ownership"].empty()) {
      ownership = make_shared<string>(boost::any_cast<string>(m["Ownership"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("QueryIpList") != m.end() && !m["QueryIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueryIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueryIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queryIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SplitRate") != m.end() && !m["SplitRate"].empty()) {
      splitRate = make_shared<double>(boost::any_cast<double>(m["SplitRate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubBusinessTypeName") != m.end() && !m["SubBusinessTypeName"].empty()) {
      subBusinessTypeName = make_shared<string>(boost::any_cast<string>(m["SubBusinessTypeName"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListIpBlocksResponseBodyIpBlockTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpBlocksResponseBodyIpBlockTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListIpBlocksResponseBodyIpBlockTasks>>(expect1);
      }
    }
    if (m.find("ZoneLayer") != m.end() && !m["ZoneLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneLayer"].type()) {
        vector<ListIpBlocksResponseBodyIpBlockZoneLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpBlocksResponseBodyIpBlockZoneLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneLayer = make_shared<vector<ListIpBlocksResponseBodyIpBlockZoneLayer>>(expect1);
      }
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~ListIpBlocksResponseBodyIpBlock() = default;
};
class ListIpBlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIpBlocksResponseBodyIpBlock>> ipBlock{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIpBlocksResponseBody() {}

  explicit ListIpBlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipBlock) {
      vector<boost::any> temp1;
      for(auto item1:*ipBlock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpBlock"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpBlock") != m.end() && !m["IpBlock"].empty()) {
      if (typeid(vector<boost::any>) == m["IpBlock"].type()) {
        vector<ListIpBlocksResponseBodyIpBlock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpBlock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpBlocksResponseBodyIpBlock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipBlock = make_shared<vector<ListIpBlocksResponseBodyIpBlock>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIpBlocksResponseBody() = default;
};
class ListIpBlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIpBlocksResponseBody> body{};

  ListIpBlocksResponse() {}

  explicit ListIpBlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIpBlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIpBlocksResponseBody>(model1);
      }
    }
  }


  virtual ~ListIpBlocksResponse() = default;
};
class ListLinksRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceNameA{};
  shared_ptr<string> deviceNameB{};
  shared_ptr<string> ipA{};
  shared_ptr<string> ipB{};
  shared_ptr<string> linkName{};
  shared_ptr<string> linkNo{};
  shared_ptr<string> linkStatus{};
  shared_ptr<string> linkType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> portA{};
  shared_ptr<string> portB{};

  ListLinksRequest() {}

  explicit ListLinksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNameA) {
      res["DeviceNameA"] = boost::any(*deviceNameA);
    }
    if (deviceNameB) {
      res["DeviceNameB"] = boost::any(*deviceNameB);
    }
    if (ipA) {
      res["IpA"] = boost::any(*ipA);
    }
    if (ipB) {
      res["IpB"] = boost::any(*ipB);
    }
    if (linkName) {
      res["LinkName"] = boost::any(*linkName);
    }
    if (linkNo) {
      res["LinkNo"] = boost::any(*linkNo);
    }
    if (linkStatus) {
      res["LinkStatus"] = boost::any(*linkStatus);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (portA) {
      res["PortA"] = boost::any(*portA);
    }
    if (portB) {
      res["PortB"] = boost::any(*portB);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNameA") != m.end() && !m["DeviceNameA"].empty()) {
      deviceNameA = make_shared<string>(boost::any_cast<string>(m["DeviceNameA"]));
    }
    if (m.find("DeviceNameB") != m.end() && !m["DeviceNameB"].empty()) {
      deviceNameB = make_shared<string>(boost::any_cast<string>(m["DeviceNameB"]));
    }
    if (m.find("IpA") != m.end() && !m["IpA"].empty()) {
      ipA = make_shared<string>(boost::any_cast<string>(m["IpA"]));
    }
    if (m.find("IpB") != m.end() && !m["IpB"].empty()) {
      ipB = make_shared<string>(boost::any_cast<string>(m["IpB"]));
    }
    if (m.find("LinkName") != m.end() && !m["LinkName"].empty()) {
      linkName = make_shared<string>(boost::any_cast<string>(m["LinkName"]));
    }
    if (m.find("LinkNo") != m.end() && !m["LinkNo"].empty()) {
      linkNo = make_shared<string>(boost::any_cast<string>(m["LinkNo"]));
    }
    if (m.find("LinkStatus") != m.end() && !m["LinkStatus"].empty()) {
      linkStatus = make_shared<string>(boost::any_cast<string>(m["LinkStatus"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<string>(boost::any_cast<string>(m["LinkType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PortA") != m.end() && !m["PortA"].empty()) {
      portA = make_shared<string>(boost::any_cast<string>(m["PortA"]));
    }
    if (m.find("PortB") != m.end() && !m["PortB"].empty()) {
      portB = make_shared<string>(boost::any_cast<string>(m["PortB"]));
    }
  }


  virtual ~ListLinksRequest() = default;
};
class ListLinksResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> deviceNameA{};
  shared_ptr<string> deviceNameB{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> idxA{};
  shared_ptr<string> idxB{};
  shared_ptr<string> ipA{};
  shared_ptr<string> ipB{};
  shared_ptr<string> jobId{};
  shared_ptr<string> linkName{};
  shared_ptr<string> linkNo{};
  shared_ptr<string> linkStatus{};
  shared_ptr<string> linkType{};
  shared_ptr<string> message{};
  shared_ptr<string> portA{};
  shared_ptr<string> portB{};
  shared_ptr<string> portDescA{};
  shared_ptr<string> portDescB{};
  shared_ptr<string> portStatusA{};
  shared_ptr<string> portStatusB{};
  shared_ptr<string> portTypeA{};
  shared_ptr<string> portTypeB{};
  shared_ptr<string> regionId{};

  ListLinksResponseBodyContent() {}

  explicit ListLinksResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNameA) {
      res["DeviceNameA"] = boost::any(*deviceNameA);
    }
    if (deviceNameB) {
      res["DeviceNameB"] = boost::any(*deviceNameB);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (idxA) {
      res["IdxA"] = boost::any(*idxA);
    }
    if (idxB) {
      res["IdxB"] = boost::any(*idxB);
    }
    if (ipA) {
      res["IpA"] = boost::any(*ipA);
    }
    if (ipB) {
      res["IpB"] = boost::any(*ipB);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (linkName) {
      res["LinkName"] = boost::any(*linkName);
    }
    if (linkNo) {
      res["LinkNo"] = boost::any(*linkNo);
    }
    if (linkStatus) {
      res["LinkStatus"] = boost::any(*linkStatus);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (portA) {
      res["PortA"] = boost::any(*portA);
    }
    if (portB) {
      res["PortB"] = boost::any(*portB);
    }
    if (portDescA) {
      res["PortDescA"] = boost::any(*portDescA);
    }
    if (portDescB) {
      res["PortDescB"] = boost::any(*portDescB);
    }
    if (portStatusA) {
      res["PortStatusA"] = boost::any(*portStatusA);
    }
    if (portStatusB) {
      res["PortStatusB"] = boost::any(*portStatusB);
    }
    if (portTypeA) {
      res["PortTypeA"] = boost::any(*portTypeA);
    }
    if (portTypeB) {
      res["PortTypeB"] = boost::any(*portTypeB);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNameA") != m.end() && !m["DeviceNameA"].empty()) {
      deviceNameA = make_shared<string>(boost::any_cast<string>(m["DeviceNameA"]));
    }
    if (m.find("DeviceNameB") != m.end() && !m["DeviceNameB"].empty()) {
      deviceNameB = make_shared<string>(boost::any_cast<string>(m["DeviceNameB"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IdxA") != m.end() && !m["IdxA"].empty()) {
      idxA = make_shared<string>(boost::any_cast<string>(m["IdxA"]));
    }
    if (m.find("IdxB") != m.end() && !m["IdxB"].empty()) {
      idxB = make_shared<string>(boost::any_cast<string>(m["IdxB"]));
    }
    if (m.find("IpA") != m.end() && !m["IpA"].empty()) {
      ipA = make_shared<string>(boost::any_cast<string>(m["IpA"]));
    }
    if (m.find("IpB") != m.end() && !m["IpB"].empty()) {
      ipB = make_shared<string>(boost::any_cast<string>(m["IpB"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LinkName") != m.end() && !m["LinkName"].empty()) {
      linkName = make_shared<string>(boost::any_cast<string>(m["LinkName"]));
    }
    if (m.find("LinkNo") != m.end() && !m["LinkNo"].empty()) {
      linkNo = make_shared<string>(boost::any_cast<string>(m["LinkNo"]));
    }
    if (m.find("LinkStatus") != m.end() && !m["LinkStatus"].empty()) {
      linkStatus = make_shared<string>(boost::any_cast<string>(m["LinkStatus"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<string>(boost::any_cast<string>(m["LinkType"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PortA") != m.end() && !m["PortA"].empty()) {
      portA = make_shared<string>(boost::any_cast<string>(m["PortA"]));
    }
    if (m.find("PortB") != m.end() && !m["PortB"].empty()) {
      portB = make_shared<string>(boost::any_cast<string>(m["PortB"]));
    }
    if (m.find("PortDescA") != m.end() && !m["PortDescA"].empty()) {
      portDescA = make_shared<string>(boost::any_cast<string>(m["PortDescA"]));
    }
    if (m.find("PortDescB") != m.end() && !m["PortDescB"].empty()) {
      portDescB = make_shared<string>(boost::any_cast<string>(m["PortDescB"]));
    }
    if (m.find("PortStatusA") != m.end() && !m["PortStatusA"].empty()) {
      portStatusA = make_shared<string>(boost::any_cast<string>(m["PortStatusA"]));
    }
    if (m.find("PortStatusB") != m.end() && !m["PortStatusB"].empty()) {
      portStatusB = make_shared<string>(boost::any_cast<string>(m["PortStatusB"]));
    }
    if (m.find("PortTypeA") != m.end() && !m["PortTypeA"].empty()) {
      portTypeA = make_shared<string>(boost::any_cast<string>(m["PortTypeA"]));
    }
    if (m.find("PortTypeB") != m.end() && !m["PortTypeB"].empty()) {
      portTypeB = make_shared<string>(boost::any_cast<string>(m["PortTypeB"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListLinksResponseBodyContent() = default;
};
class ListLinksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLinksResponseBodyContent>> content{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListLinksResponseBody() {}

  explicit ListLinksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<ListLinksResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLinksResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<ListLinksResponseBodyContent>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLinksResponseBody() = default;
};
class ListLinksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLinksResponseBody> body{};

  ListLinksResponse() {}

  explicit ListLinksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLinksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLinksResponseBody>(model1);
      }
    }
  }


  virtual ~ListLinksResponse() = default;
};
class ListLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> content{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sort{};
  shared_ptr<long> start{};

  ListLogsRequest() {}

  explicit ListLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~ListLogsRequest() = default;
};
class ListLogsResponseBodyLogsResourceDevice : public Darabonba::Model {
public:
  shared_ptr<string> hostName{};
  shared_ptr<string> physicalSpace{};

  ListLogsResponseBodyLogsResourceDevice() {}

  explicit ListLogsResponseBodyLogsResourceDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (physicalSpace) {
      res["PhysicalSpace"] = boost::any(*physicalSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("PhysicalSpace") != m.end() && !m["PhysicalSpace"].empty()) {
      physicalSpace = make_shared<string>(boost::any_cast<string>(m["PhysicalSpace"]));
    }
  }


  virtual ~ListLogsResponseBodyLogsResourceDevice() = default;
};
class ListLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> alarmObject{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> alarmType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> log{};
  shared_ptr<string> receiveTime{};
  shared_ptr<ListLogsResponseBodyLogsResourceDevice> resourceDevice{};
  shared_ptr<string> time{};

  ListLogsResponseBodyLogs() {}

  explicit ListLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmObject) {
      res["AlarmObject"] = boost::any(*alarmObject);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (alarmType) {
      res["AlarmType"] = boost::any(*alarmType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (resourceDevice) {
      res["ResourceDevice"] = resourceDevice ? boost::any(resourceDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmObject") != m.end() && !m["AlarmObject"].empty()) {
      alarmObject = make_shared<string>(boost::any_cast<string>(m["AlarmObject"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AlarmType") != m.end() && !m["AlarmType"].empty()) {
      alarmType = make_shared<string>(boost::any_cast<string>(m["AlarmType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("ResourceDevice") != m.end() && !m["ResourceDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDevice"].type()) {
        ListLogsResponseBodyLogsResourceDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDevice"]));
        resourceDevice = make_shared<ListLogsResponseBodyLogsResourceDevice>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ListLogsResponseBodyLogs() = default;
};
class ListLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLogsResponseBodyLogs>> logs{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListLogsResponseBody() {}

  explicit ListLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<ListLogsResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogsResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<ListLogsResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLogsResponseBody() = default;
};
class ListLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogsResponseBody> body{};

  ListLogsResponse() {}

  explicit ListLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogsResponse() = default;
};
class ListMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> aggregationType{};
  shared_ptr<string> appId{};
  shared_ptr<string> dataItem{};
  shared_ptr<string> dataType{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> key{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<long> start{};

  ListMonitorDataRequest() {}

  explicit ListMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (aggregationType) {
      res["AggregationType"] = boost::any(*aggregationType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AggregationType") != m.end() && !m["AggregationType"].empty()) {
      aggregationType = make_shared<string>(boost::any_cast<string>(m["AggregationType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~ListMonitorDataRequest() = default;
};
class ListMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<string> dataItem{};
  shared_ptr<string> key{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> value{};

  ListMonitorDataResponseBodyMonitorData() {}

  explicit ListMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataItem) {
      res["DataItem"] = boost::any(*dataItem);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      dataItem = make_shared<string>(boost::any_cast<string>(m["DataItem"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListMonitorDataResponseBodyMonitorData() = default;
};
class ListMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMonitorDataResponseBodyMonitorData>> monitorData{};
  shared_ptr<string> requestId{};

  ListMonitorDataResponseBody() {}

  explicit ListMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorData) {
      vector<boost::any> temp1;
      for(auto item1:*monitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorData"].type()) {
        vector<ListMonitorDataResponseBodyMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMonitorDataResponseBodyMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorData = make_shared<vector<ListMonitorDataResponseBodyMonitorData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMonitorDataResponseBody() = default;
};
class ListMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMonitorDataResponseBody> body{};

  ListMonitorDataResponse() {}

  explicit ListMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~ListMonitorDataResponse() = default;
};
class ListNotificationHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> end{};
  shared_ptr<string> eventItemId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> notificationGroupId{};
  shared_ptr<string> notificationMode{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<long> start{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListNotificationHistoriesRequest() {}

  explicit ListNotificationHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (eventItemId) {
      res["EventItemId"] = boost::any(*eventItemId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (notificationGroupId) {
      res["NotificationGroupId"] = boost::any(*notificationGroupId);
    }
    if (notificationMode) {
      res["NotificationMode"] = boost::any(*notificationMode);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("EventItemId") != m.end() && !m["EventItemId"].empty()) {
      eventItemId = make_shared<string>(boost::any_cast<string>(m["EventItemId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NotificationGroupId") != m.end() && !m["NotificationGroupId"].empty()) {
      notificationGroupId = make_shared<string>(boost::any_cast<string>(m["NotificationGroupId"]));
    }
    if (m.find("NotificationMode") != m.end() && !m["NotificationMode"].empty()) {
      notificationMode = make_shared<string>(boost::any_cast<string>(m["NotificationMode"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNotificationHistoriesRequest() = default;
};
class ListNotificationHistoriesResponseBodyNotificationHistories : public Darabonba::Model {
public:
  shared_ptr<string> aggregateDataId{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> appId{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> message{};
  shared_ptr<string> monitorItemId{};
  shared_ptr<string> notificationGroupId{};
  shared_ptr<string> notificationGroupName{};
  shared_ptr<string> notificationMode{};
  shared_ptr<string> output{};
  shared_ptr<string> portCollectionId{};
  shared_ptr<string> status{};
  shared_ptr<string> time{};

  ListNotificationHistoriesResponseBodyNotificationHistories() {}

  explicit ListNotificationHistoriesResponseBodyNotificationHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateDataId) {
      res["AggregateDataId"] = boost::any(*aggregateDataId);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (monitorItemId) {
      res["MonitorItemId"] = boost::any(*monitorItemId);
    }
    if (notificationGroupId) {
      res["NotificationGroupId"] = boost::any(*notificationGroupId);
    }
    if (notificationGroupName) {
      res["NotificationGroupName"] = boost::any(*notificationGroupName);
    }
    if (notificationMode) {
      res["NotificationMode"] = boost::any(*notificationMode);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (portCollectionId) {
      res["PortCollectionId"] = boost::any(*portCollectionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateDataId") != m.end() && !m["AggregateDataId"].empty()) {
      aggregateDataId = make_shared<string>(boost::any_cast<string>(m["AggregateDataId"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MonitorItemId") != m.end() && !m["MonitorItemId"].empty()) {
      monitorItemId = make_shared<string>(boost::any_cast<string>(m["MonitorItemId"]));
    }
    if (m.find("NotificationGroupId") != m.end() && !m["NotificationGroupId"].empty()) {
      notificationGroupId = make_shared<string>(boost::any_cast<string>(m["NotificationGroupId"]));
    }
    if (m.find("NotificationGroupName") != m.end() && !m["NotificationGroupName"].empty()) {
      notificationGroupName = make_shared<string>(boost::any_cast<string>(m["NotificationGroupName"]));
    }
    if (m.find("NotificationMode") != m.end() && !m["NotificationMode"].empty()) {
      notificationMode = make_shared<string>(boost::any_cast<string>(m["NotificationMode"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("PortCollectionId") != m.end() && !m["PortCollectionId"].empty()) {
      portCollectionId = make_shared<string>(boost::any_cast<string>(m["PortCollectionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ListNotificationHistoriesResponseBodyNotificationHistories() = default;
};
class ListNotificationHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListNotificationHistoriesResponseBodyNotificationHistories>> notificationHistories{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListNotificationHistoriesResponseBody() {}

  explicit ListNotificationHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (notificationHistories) {
      vector<boost::any> temp1;
      for(auto item1:*notificationHistories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationHistories"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NotificationHistories") != m.end() && !m["NotificationHistories"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationHistories"].type()) {
        vector<ListNotificationHistoriesResponseBodyNotificationHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationHistories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationHistoriesResponseBodyNotificationHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationHistories = make_shared<vector<ListNotificationHistoriesResponseBodyNotificationHistories>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNotificationHistoriesResponseBody() = default;
};
class ListNotificationHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotificationHistoriesResponseBody> body{};

  ListNotificationHistoriesResponse() {}

  explicit ListNotificationHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotificationHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotificationHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotificationHistoriesResponse() = default;
};
class ListNotificationHistoriesStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isDedicatedLine{};
  shared_ptr<bool> isDevice{};
  shared_ptr<bool> isMonitorItem{};
  shared_ptr<bool> isPhysicalSpace{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<long> start{};
  shared_ptr<string> type{};

  ListNotificationHistoriesStatisticsRequest() {}

  explicit ListNotificationHistoriesStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isDedicatedLine) {
      res["IsDedicatedLine"] = boost::any(*isDedicatedLine);
    }
    if (isDevice) {
      res["IsDevice"] = boost::any(*isDevice);
    }
    if (isMonitorItem) {
      res["IsMonitorItem"] = boost::any(*isMonitorItem);
    }
    if (isPhysicalSpace) {
      res["IsPhysicalSpace"] = boost::any(*isPhysicalSpace);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsDedicatedLine") != m.end() && !m["IsDedicatedLine"].empty()) {
      isDedicatedLine = make_shared<bool>(boost::any_cast<bool>(m["IsDedicatedLine"]));
    }
    if (m.find("IsDevice") != m.end() && !m["IsDevice"].empty()) {
      isDevice = make_shared<bool>(boost::any_cast<bool>(m["IsDevice"]));
    }
    if (m.find("IsMonitorItem") != m.end() && !m["IsMonitorItem"].empty()) {
      isMonitorItem = make_shared<bool>(boost::any_cast<bool>(m["IsMonitorItem"]));
    }
    if (m.find("IsPhysicalSpace") != m.end() && !m["IsPhysicalSpace"].empty()) {
      isPhysicalSpace = make_shared<bool>(boost::any_cast<bool>(m["IsPhysicalSpace"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNotificationHistoriesStatisticsRequest() = default;
};
class ListNotificationHistoriesStatisticsResponseBodyQuota : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> mode{};
  shared_ptr<string> quota{};

  ListNotificationHistoriesStatisticsResponseBodyQuota() {}

  explicit ListNotificationHistoriesStatisticsResponseBodyQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<string>(boost::any_cast<string>(m["Quota"]));
    }
  }


  virtual ~ListNotificationHistoriesStatisticsResponseBodyQuota() = default;
};
class ListNotificationHistoriesStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceId{};

  ListNotificationHistoriesStatisticsResponseBodyStatistics() {}

  explicit ListNotificationHistoriesStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListNotificationHistoriesStatisticsResponseBodyStatistics() = default;
};
class ListNotificationHistoriesStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListNotificationHistoriesStatisticsResponseBodyQuota>> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNotificationHistoriesStatisticsResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalCount{};

  ListNotificationHistoriesStatisticsResponseBody() {}

  explicit ListNotificationHistoriesStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (quota) {
      vector<boost::any> temp1;
      for(auto item1:*quota){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Quota"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      if (typeid(vector<boost::any>) == m["Quota"].type()) {
        vector<ListNotificationHistoriesStatisticsResponseBodyQuota> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Quota"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationHistoriesStatisticsResponseBodyQuota model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quota = make_shared<vector<ListNotificationHistoriesStatisticsResponseBodyQuota>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<ListNotificationHistoriesStatisticsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationHistoriesStatisticsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<ListNotificationHistoriesStatisticsResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNotificationHistoriesStatisticsResponseBody() = default;
};
class ListNotificationHistoriesStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotificationHistoriesStatisticsResponseBody> body{};

  ListNotificationHistoriesStatisticsResponse() {}

  explicit ListNotificationHistoriesStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotificationHistoriesStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotificationHistoriesStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotificationHistoriesStatisticsResponse() = default;
};
class ListOsVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListOsVersionsRequest() {}

  explicit ListOsVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListOsVersionsRequest() = default;
};
class ListOsVersionsResponseBodyOsVersion : public Darabonba::Model {
public:
  shared_ptr<string> bootPatch{};
  shared_ptr<string> createTime{};
  shared_ptr<string> featurePatch{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> model{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> osVersionId{};
  shared_ptr<string> status{};
  shared_ptr<string> systemPatch{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendor{};

  ListOsVersionsResponseBodyOsVersion() {}

  explicit ListOsVersionsResponseBodyOsVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootPatch) {
      res["BootPatch"] = boost::any(*bootPatch);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (featurePatch) {
      res["FeaturePatch"] = boost::any(*featurePatch);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemPatch) {
      res["SystemPatch"] = boost::any(*systemPatch);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootPatch") != m.end() && !m["BootPatch"].empty()) {
      bootPatch = make_shared<string>(boost::any_cast<string>(m["BootPatch"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FeaturePatch") != m.end() && !m["FeaturePatch"].empty()) {
      featurePatch = make_shared<string>(boost::any_cast<string>(m["FeaturePatch"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemPatch") != m.end() && !m["SystemPatch"].empty()) {
      systemPatch = make_shared<string>(boost::any_cast<string>(m["SystemPatch"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListOsVersionsResponseBodyOsVersion() = default;
};
class ListOsVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<vector<ListOsVersionsResponseBodyOsVersion>> osVersion{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOsVersionsResponseBody() {}

  explicit ListOsVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (osVersion) {
      vector<boost::any> temp1;
      for(auto item1:*osVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OsVersion"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["OsVersion"].type()) {
        vector<ListOsVersionsResponseBodyOsVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OsVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOsVersionsResponseBodyOsVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        osVersion = make_shared<vector<ListOsVersionsResponseBodyOsVersion>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOsVersionsResponseBody() = default;
};
class ListOsVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOsVersionsResponseBody> body{};

  ListOsVersionsResponse() {}

  explicit ListOsVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOsVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOsVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOsVersionsResponse() = default;
};
class ListPhysicalSpacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> physicalSpaceIds{};
  shared_ptr<string> physicalSpaceName{};

  ListPhysicalSpacesRequest() {}

  explicit ListPhysicalSpacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceIds) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIds);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalSpaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalSpaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalSpaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
  }


  virtual ~ListPhysicalSpacesRequest() = default;
};
class ListPhysicalSpacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceIdsShrink{};
  shared_ptr<string> physicalSpaceName{};

  ListPhysicalSpacesShrinkRequest() {}

  explicit ListPhysicalSpacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceIdsShrink) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIdsShrink);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      physicalSpaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceIds"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
  }


  virtual ~ListPhysicalSpacesShrinkRequest() = default;
};
class ListPhysicalSpacesResponseBodyPhysicalSpaces : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> instance{};
  shared_ptr<string> owner{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> securityDomainList{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};

  ListPhysicalSpacesResponseBodyPhysicalSpaces() {}

  explicit ListPhysicalSpacesResponseBodyPhysicalSpaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainList) {
      res["SecurityDomainList"] = boost::any(*securityDomainList);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomainList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomainList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomainList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~ListPhysicalSpacesResponseBodyPhysicalSpaces() = default;
};
class ListPhysicalSpacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<vector<ListPhysicalSpacesResponseBodyPhysicalSpaces>> physicalSpaces{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPhysicalSpacesResponseBody() {}

  explicit ListPhysicalSpacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaces) {
      vector<boost::any> temp1;
      for(auto item1:*physicalSpaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhysicalSpaces"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaces") != m.end() && !m["PhysicalSpaces"].empty()) {
      if (typeid(vector<boost::any>) == m["PhysicalSpaces"].type()) {
        vector<ListPhysicalSpacesResponseBodyPhysicalSpaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhysicalSpaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhysicalSpacesResponseBodyPhysicalSpaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        physicalSpaces = make_shared<vector<ListPhysicalSpacesResponseBodyPhysicalSpaces>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhysicalSpacesResponseBody() = default;
};
class ListPhysicalSpacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPhysicalSpacesResponseBody> body{};

  ListPhysicalSpacesResponse() {}

  explicit ListPhysicalSpacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhysicalSpacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhysicalSpacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhysicalSpacesResponse() = default;
};
class ListRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListRegionsResponseBody() {}

  explicit ListRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRegionsResponseBody() = default;
};
class ListRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRegionsResponseBody> body{};

  ListRegionsResponse() {}

  explicit ListRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRegionsResponse() = default;
};
class ListResourceInformationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListResourceInformationsRequest() {}

  explicit ListResourceInformationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListResourceInformationsRequest() = default;
};
class ListResourceInformationsResponseBodyResourceInformationInformation : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> keyAttribute{};
  shared_ptr<string> keyDescription{};

  ListResourceInformationsResponseBodyResourceInformationInformation() {}

  explicit ListResourceInformationsResponseBodyResourceInformationInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (keyAttribute) {
      res["KeyAttribute"] = boost::any(*keyAttribute);
    }
    if (keyDescription) {
      res["KeyDescription"] = boost::any(*keyDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("KeyAttribute") != m.end() && !m["KeyAttribute"].empty()) {
      keyAttribute = make_shared<string>(boost::any_cast<string>(m["KeyAttribute"]));
    }
    if (m.find("KeyDescription") != m.end() && !m["KeyDescription"].empty()) {
      keyDescription = make_shared<string>(boost::any_cast<string>(m["KeyDescription"]));
    }
  }


  virtual ~ListResourceInformationsResponseBodyResourceInformationInformation() = default;
};
class ListResourceInformationsResponseBodyResourceInformation : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceInformationsResponseBodyResourceInformationInformation>> information{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> resourceType{};

  ListResourceInformationsResponseBodyResourceInformation() {}

  explicit ListResourceInformationsResponseBodyResourceInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (information) {
      vector<boost::any> temp1;
      for(auto item1:*information){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Information"] = boost::any(temp1);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Information") != m.end() && !m["Information"].empty()) {
      if (typeid(vector<boost::any>) == m["Information"].type()) {
        vector<ListResourceInformationsResponseBodyResourceInformationInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Information"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceInformationsResponseBodyResourceInformationInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        information = make_shared<vector<ListResourceInformationsResponseBodyResourceInformationInformation>>(expect1);
      }
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceInformationsResponseBodyResourceInformation() = default;
};
class ListResourceInformationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListResourceInformationsResponseBodyResourceInformation>> resourceInformation{};
  shared_ptr<long> totalCount{};

  ListResourceInformationsResponseBody() {}

  explicit ListResourceInformationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceInformation) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInformation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInformation"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceInformation") != m.end() && !m["ResourceInformation"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInformation"].type()) {
        vector<ListResourceInformationsResponseBodyResourceInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInformation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceInformationsResponseBodyResourceInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInformation = make_shared<vector<ListResourceInformationsResponseBodyResourceInformation>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourceInformationsResponseBody() = default;
};
class ListResourceInformationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceInformationsResponseBody> body{};

  ListResourceInformationsResponse() {}

  explicit ListResourceInformationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceInformationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceInformationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceInformationsResponse() = default;
};
class ListResourceInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};

  ListResourceInstancesRequest() {}

  explicit ListResourceInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ListResourceInstancesRequest() = default;
};
class ListResourceInstancesResponseBodyLogicResourceKeyList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> keyAttribute{};
  shared_ptr<string> keyDescription{};
  shared_ptr<string> value{};

  ListResourceInstancesResponseBodyLogicResourceKeyList() {}

  explicit ListResourceInstancesResponseBodyLogicResourceKeyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (keyAttribute) {
      res["KeyAttribute"] = boost::any(*keyAttribute);
    }
    if (keyDescription) {
      res["KeyDescription"] = boost::any(*keyDescription);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("KeyAttribute") != m.end() && !m["KeyAttribute"].empty()) {
      keyAttribute = make_shared<string>(boost::any_cast<string>(m["KeyAttribute"]));
    }
    if (m.find("KeyDescription") != m.end() && !m["KeyDescription"].empty()) {
      keyDescription = make_shared<string>(boost::any_cast<string>(m["KeyDescription"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListResourceInstancesResponseBodyLogicResourceKeyList() = default;
};
class ListResourceInstancesResponseBodyLogicResource : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceInstancesResponseBodyLogicResourceKeyList>> keyList{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceType{};

  ListResourceInstancesResponseBodyLogicResource() {}

  explicit ListResourceInstancesResponseBodyLogicResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyList) {
      vector<boost::any> temp1;
      for(auto item1:*keyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyList"] = boost::any(temp1);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyList") != m.end() && !m["KeyList"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyList"].type()) {
        vector<ListResourceInstancesResponseBodyLogicResourceKeyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceInstancesResponseBodyLogicResourceKeyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyList = make_shared<vector<ListResourceInstancesResponseBodyLogicResourceKeyList>>(expect1);
      }
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceInstancesResponseBodyLogicResource() = default;
};
class ListResourceInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceInstancesResponseBodyLogicResource>> logicResource{};
  shared_ptr<string> requestId{};

  ListResourceInstancesResponseBody() {}

  explicit ListResourceInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicResource) {
      vector<boost::any> temp1;
      for(auto item1:*logicResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogicResource"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicResource") != m.end() && !m["LogicResource"].empty()) {
      if (typeid(vector<boost::any>) == m["LogicResource"].type()) {
        vector<ListResourceInstancesResponseBodyLogicResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogicResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceInstancesResponseBodyLogicResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logicResource = make_shared<vector<ListResourceInstancesResponseBodyLogicResource>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListResourceInstancesResponseBody() = default;
};
class ListResourceInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceInstancesResponseBody> body{};

  ListResourceInstancesResponse() {}

  explicit ListResourceInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceInstancesResponse() = default;
};
class ListResourceTypesResponseBodyResourceType : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceTypeName{};

  ListResourceTypesResponseBodyResourceType() {}

  explicit ListResourceTypesResponseBodyResourceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceTypeName) {
      res["ResourceTypeName"] = boost::any(*resourceTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceTypeName") != m.end() && !m["ResourceTypeName"].empty()) {
      resourceTypeName = make_shared<string>(boost::any_cast<string>(m["ResourceTypeName"]));
    }
  }


  virtual ~ListResourceTypesResponseBodyResourceType() = default;
};
class ListResourceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListResourceTypesResponseBodyResourceType>> resourceType{};

  ListResourceTypesResponseBody() {}

  explicit ListResourceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceType) {
      vector<boost::any> temp1;
      for(auto item1:*resourceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceType"].type()) {
        vector<ListResourceTypesResponseBodyResourceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceTypesResponseBodyResourceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceType = make_shared<vector<ListResourceTypesResponseBodyResourceType>>(expect1);
      }
    }
  }


  virtual ~ListResourceTypesResponseBody() = default;
};
class ListResourceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceTypesResponseBody> body{};

  ListResourceTypesResponse() {}

  explicit ListResourceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceTypesResponse() = default;
};
class ListSetupProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> status{};

  ListSetupProjectsRequest() {}

  explicit ListSetupProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListSetupProjectsRequest() = default;
};
class ListSetupProjectsResponseBodySetupProjectPackages : public Darabonba::Model {
public:
  shared_ptr<long> deviceNumber{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> vendor{};

  ListSetupProjectsResponseBodySetupProjectPackages() {}

  explicit ListSetupProjectsResponseBodySetupProjectPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<long>(boost::any_cast<long>(m["DeviceNumber"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ListSetupProjectsResponseBodySetupProjectPackages() = default;
};
class ListSetupProjectsResponseBodySetupProject : public Darabonba::Model {
public:
  shared_ptr<string> archVersion{};
  shared_ptr<string> architectureId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nodes{};
  shared_ptr<vector<ListSetupProjectsResponseBodySetupProjectPackages>> packages{};
  shared_ptr<string> progress{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};

  ListSetupProjectsResponseBodySetupProject() {}

  explicit ListSetupProjectsResponseBodySetupProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archVersion) {
      res["ArchVersion"] = boost::any(*archVersion);
    }
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodes) {
      res["Nodes"] = boost::any(*nodes);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchVersion") != m.end() && !m["ArchVersion"].empty()) {
      archVersion = make_shared<string>(boost::any_cast<string>(m["ArchVersion"]));
    }
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      nodes = make_shared<string>(boost::any_cast<string>(m["Nodes"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<ListSetupProjectsResponseBodySetupProjectPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSetupProjectsResponseBodySetupProjectPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<ListSetupProjectsResponseBodySetupProjectPackages>>(expect1);
      }
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~ListSetupProjectsResponseBodySetupProject() = default;
};
class ListSetupProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSetupProjectsResponseBodySetupProject>> setupProject{};
  shared_ptr<long> totalCount{};

  ListSetupProjectsResponseBody() {}

  explicit ListSetupProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (setupProject) {
      vector<boost::any> temp1;
      for(auto item1:*setupProject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SetupProject"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SetupProject") != m.end() && !m["SetupProject"].empty()) {
      if (typeid(vector<boost::any>) == m["SetupProject"].type()) {
        vector<ListSetupProjectsResponseBodySetupProject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SetupProject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSetupProjectsResponseBodySetupProject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        setupProject = make_shared<vector<ListSetupProjectsResponseBodySetupProject>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSetupProjectsResponseBody() = default;
};
class ListSetupProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSetupProjectsResponseBody> body{};

  ListSetupProjectsResponse() {}

  explicit ListSetupProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSetupProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSetupProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSetupProjectsResponse() = default;
};
class ListSpaceModelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};

  ListSpaceModelsRequest() {}

  explicit ListSpaceModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListSpaceModelsRequest() = default;
};
class ListSpaceModelsResponseBodySpaceModelSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  ListSpaceModelsResponseBodySpaceModelSort() {}

  explicit ListSpaceModelsResponseBodySpaceModelSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~ListSpaceModelsResponseBodySpaceModelSort() = default;
};
class ListSpaceModelsResponseBodySpaceModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<vector<ListSpaceModelsResponseBodySpaceModelSort>> sort{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  ListSpaceModelsResponseBodySpaceModel() {}

  explicit ListSpaceModelsResponseBodySpaceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (sort) {
      vector<boost::any> temp1;
      for(auto item1:*sort){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sort"] = boost::any(temp1);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(vector<boost::any>) == m["Sort"].type()) {
        vector<ListSpaceModelsResponseBodySpaceModelSort> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sort"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSpaceModelsResponseBodySpaceModelSort model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sort = make_shared<vector<ListSpaceModelsResponseBodySpaceModelSort>>(expect1);
      }
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListSpaceModelsResponseBodySpaceModel() = default;
};
class ListSpaceModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSpaceModelsResponseBodySpaceModel>> spaceModel{};
  shared_ptr<long> totalCount{};

  ListSpaceModelsResponseBody() {}

  explicit ListSpaceModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceModel) {
      vector<boost::any> temp1;
      for(auto item1:*spaceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpaceModel"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceModel") != m.end() && !m["SpaceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["SpaceModel"].type()) {
        vector<ListSpaceModelsResponseBodySpaceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpaceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSpaceModelsResponseBodySpaceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spaceModel = make_shared<vector<ListSpaceModelsResponseBodySpaceModel>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSpaceModelsResponseBody() = default;
};
class ListSpaceModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSpaceModelsResponseBody> body{};

  ListSpaceModelsResponse() {}

  explicit ListSpaceModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSpaceModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSpaceModelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSpaceModelsResponse() = default;
};
class ListTasksHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListTasksHistoriesRequest() {}

  explicit ListTasksHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListTasksHistoriesRequest() = default;
};
class ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules : public Darabonba::Model {
public:
  shared_ptr<string> actualValue{};
  shared_ptr<string> alarmExpression{};
  shared_ptr<string> alarmLevel{};
  shared_ptr<string> alarmOperator{};
  shared_ptr<string> alarmValue{};

  ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules() {}

  explicit ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualValue) {
      res["ActualValue"] = boost::any(*actualValue);
    }
    if (alarmExpression) {
      res["AlarmExpression"] = boost::any(*alarmExpression);
    }
    if (alarmLevel) {
      res["AlarmLevel"] = boost::any(*alarmLevel);
    }
    if (alarmOperator) {
      res["AlarmOperator"] = boost::any(*alarmOperator);
    }
    if (alarmValue) {
      res["AlarmValue"] = boost::any(*alarmValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualValue") != m.end() && !m["ActualValue"].empty()) {
      actualValue = make_shared<string>(boost::any_cast<string>(m["ActualValue"]));
    }
    if (m.find("AlarmExpression") != m.end() && !m["AlarmExpression"].empty()) {
      alarmExpression = make_shared<string>(boost::any_cast<string>(m["AlarmExpression"]));
    }
    if (m.find("AlarmLevel") != m.end() && !m["AlarmLevel"].empty()) {
      alarmLevel = make_shared<string>(boost::any_cast<string>(m["AlarmLevel"]));
    }
    if (m.find("AlarmOperator") != m.end() && !m["AlarmOperator"].empty()) {
      alarmOperator = make_shared<string>(boost::any_cast<string>(m["AlarmOperator"]));
    }
    if (m.find("AlarmValue") != m.end() && !m["AlarmValue"].empty()) {
      alarmValue = make_shared<string>(boost::any_cast<string>(m["AlarmValue"]));
    }
  }


  virtual ~ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules() = default;
};
class ListTasksHistoriesResponseBodyInspectionTasks : public Darabonba::Model {
public:
  shared_ptr<string> deviceDisplay{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> executionBeginTime{};
  shared_ptr<string> executionEndTime{};
  shared_ptr<vector<ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules>> inspectionAlarmRules{};
  shared_ptr<string> inspectionResult{};
  shared_ptr<string> taskId{};

  ListTasksHistoriesResponseBodyInspectionTasks() {}

  explicit ListTasksHistoriesResponseBodyInspectionTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceDisplay) {
      res["DeviceDisplay"] = boost::any(*deviceDisplay);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (executionBeginTime) {
      res["ExecutionBeginTime"] = boost::any(*executionBeginTime);
    }
    if (executionEndTime) {
      res["ExecutionEndTime"] = boost::any(*executionEndTime);
    }
    if (inspectionAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionAlarmRules"] = boost::any(temp1);
    }
    if (inspectionResult) {
      res["InspectionResult"] = boost::any(*inspectionResult);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceDisplay") != m.end() && !m["DeviceDisplay"].empty()) {
      deviceDisplay = make_shared<string>(boost::any_cast<string>(m["DeviceDisplay"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ExecutionBeginTime") != m.end() && !m["ExecutionBeginTime"].empty()) {
      executionBeginTime = make_shared<string>(boost::any_cast<string>(m["ExecutionBeginTime"]));
    }
    if (m.find("ExecutionEndTime") != m.end() && !m["ExecutionEndTime"].empty()) {
      executionEndTime = make_shared<string>(boost::any_cast<string>(m["ExecutionEndTime"]));
    }
    if (m.find("InspectionAlarmRules") != m.end() && !m["InspectionAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionAlarmRules"].type()) {
        vector<ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionAlarmRules = make_shared<vector<ListTasksHistoriesResponseBodyInspectionTasksInspectionAlarmRules>>(expect1);
      }
    }
    if (m.find("InspectionResult") != m.end() && !m["InspectionResult"].empty()) {
      inspectionResult = make_shared<string>(boost::any_cast<string>(m["InspectionResult"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListTasksHistoriesResponseBodyInspectionTasks() = default;
};
class ListTasksHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTasksHistoriesResponseBodyInspectionTasks>> inspectionTasks{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListTasksHistoriesResponseBody() {}

  explicit ListTasksHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inspectionTasks) {
      vector<boost::any> temp1;
      for(auto item1:*inspectionTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InspectionTasks"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InspectionTasks") != m.end() && !m["InspectionTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["InspectionTasks"].type()) {
        vector<ListTasksHistoriesResponseBodyInspectionTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InspectionTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTasksHistoriesResponseBodyInspectionTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inspectionTasks = make_shared<vector<ListTasksHistoriesResponseBodyInspectionTasks>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTasksHistoriesResponseBody() = default;
};
class ListTasksHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTasksHistoriesResponseBody> body{};

  ListTasksHistoriesResponse() {}

  explicit ListTasksHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTasksHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTasksHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTasksHistoriesResponse() = default;
};
class ListTreePhysicalSpacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> physicalSpaceIds{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<bool> tree{};

  ListTreePhysicalSpacesRequest() {}

  explicit ListTreePhysicalSpacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceIds) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIds);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (tree) {
      res["Tree"] = boost::any(*tree);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhysicalSpaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhysicalSpaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      physicalSpaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Tree") != m.end() && !m["Tree"].empty()) {
      tree = make_shared<bool>(boost::any_cast<bool>(m["Tree"]));
    }
  }


  virtual ~ListTreePhysicalSpacesRequest() = default;
};
class ListTreePhysicalSpacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalSpaceIdsShrink{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<bool> tree{};

  ListTreePhysicalSpacesShrinkRequest() {}

  explicit ListTreePhysicalSpacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaceIdsShrink) {
      res["PhysicalSpaceIds"] = boost::any(*physicalSpaceIdsShrink);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (tree) {
      res["Tree"] = boost::any(*tree);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaceIds") != m.end() && !m["PhysicalSpaceIds"].empty()) {
      physicalSpaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceIds"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Tree") != m.end() && !m["Tree"].empty()) {
      tree = make_shared<bool>(boost::any_cast<bool>(m["Tree"]));
    }
  }


  virtual ~ListTreePhysicalSpacesShrinkRequest() = default;
};
class ListTreePhysicalSpacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<vector<PhysicalSpaceDto>> physicalSpaces{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListTreePhysicalSpacesResponseBody() {}

  explicit ListTreePhysicalSpacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalSpaces) {
      vector<boost::any> temp1;
      for(auto item1:*physicalSpaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhysicalSpaces"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("PhysicalSpaces") != m.end() && !m["PhysicalSpaces"].empty()) {
      if (typeid(vector<boost::any>) == m["PhysicalSpaces"].type()) {
        vector<PhysicalSpaceDto> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhysicalSpaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PhysicalSpaceDto model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        physicalSpaces = make_shared<vector<PhysicalSpaceDto>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTreePhysicalSpacesResponseBody() = default;
};
class ListTreePhysicalSpacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTreePhysicalSpacesResponseBody> body{};

  ListTreePhysicalSpacesResponse() {}

  explicit ListTreePhysicalSpacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTreePhysicalSpacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTreePhysicalSpacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTreePhysicalSpacesResponse() = default;
};
class LockSpaceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> spaceModelId{};

  LockSpaceModelRequest() {}

  explicit LockSpaceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
  }


  virtual ~LockSpaceModelRequest() = default;
};
class LockSpaceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LockSpaceModelResponseBody() {}

  explicit LockSpaceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LockSpaceModelResponseBody() = default;
};
class LockSpaceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LockSpaceModelResponseBody> body{};

  LockSpaceModelResponse() {}

  explicit LockSpaceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LockSpaceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LockSpaceModelResponseBody>(model1);
      }
    }
  }


  virtual ~LockSpaceModelResponse() = default;
};
class ReleaseIPRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<vector<string>> deviceResourceIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipType{};
  shared_ptr<string> setupProjectId{};

  ReleaseIPRequest() {}

  explicit ReleaseIPRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIds) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ReleaseIPRequest() = default;
};
class ReleaseIPShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> deviceResourceIdsShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipType{};
  shared_ptr<string> setupProjectId{};

  ReleaseIPShrinkRequest() {}

  explicit ReleaseIPShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIdsShrink) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      deviceResourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceResourceIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~ReleaseIPShrinkRequest() = default;
};
class ReleaseIPResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseIPResponseBody() {}

  explicit ReleaseIPResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseIPResponseBody() = default;
};
class ReleaseIPResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseIPResponseBody> body{};

  ReleaseIPResponse() {}

  explicit ReleaseIPResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseIPResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseIPResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseIPResponse() = default;
};
class RetryTasksRequestRetryTasks : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> scriptId{};

  RetryTasksRequestRetryTasks() {}

  explicit RetryTasksRequestRetryTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~RetryTasksRequestRetryTasks() = default;
};
class RetryTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<RetryTasksRequestRetryTasks>> retryTasks{};

  RetryTasksRequest() {}

  explicit RetryTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (retryTasks) {
      vector<boost::any> temp1;
      for(auto item1:*retryTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RetryTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RetryTasks") != m.end() && !m["RetryTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["RetryTasks"].type()) {
        vector<RetryTasksRequestRetryTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RetryTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RetryTasksRequestRetryTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        retryTasks = make_shared<vector<RetryTasksRequestRetryTasks>>(expect1);
      }
    }
  }


  virtual ~RetryTasksRequest() = default;
};
class RetryTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> retryTasksShrink{};

  RetryTasksShrinkRequest() {}

  explicit RetryTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (retryTasksShrink) {
      res["RetryTasks"] = boost::any(*retryTasksShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RetryTasks") != m.end() && !m["RetryTasks"].empty()) {
      retryTasksShrink = make_shared<string>(boost::any_cast<string>(m["RetryTasks"]));
    }
  }


  virtual ~RetryTasksShrinkRequest() = default;
};
class RetryTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RetryTasksResponseBody() {}

  explicit RetryTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetryTasksResponseBody() = default;
};
class RetryTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryTasksResponseBody> body{};

  RetryTasksResponse() {}

  explicit RetryTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryTasksResponseBody>(model1);
      }
    }
  }


  virtual ~RetryTasksResponse() = default;
};
class UpdateConfigurationSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<vector<vector<uint8_t>>> relatedVariate{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> vendor{};

  UpdateConfigurationSpecificationRequest() {}

  explicit UpdateConfigurationSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariate) {
      res["RelatedVariate"] = boost::any(*relatedVariate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      vector<vector<uint8_t>> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedVariate"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedVariate"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<vector<uint8_t>>(item));
        }
      }
      relatedVariate = make_shared<vector<vector<uint8_t>>>(toVec1);
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateConfigurationSpecificationRequest() = default;
};
class UpdateConfigurationSpecificationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> configurationSpecificationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<string> relatedVariateShrink{};
  shared_ptr<string> role{};
  shared_ptr<string> specificationContent{};
  shared_ptr<string> specificationName{};
  shared_ptr<string> vendor{};

  UpdateConfigurationSpecificationShrinkRequest() {}

  explicit UpdateConfigurationSpecificationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (configurationSpecificationId) {
      res["ConfigurationSpecificationId"] = boost::any(*configurationSpecificationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (relatedVariateShrink) {
      res["RelatedVariate"] = boost::any(*relatedVariateShrink);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (specificationContent) {
      res["SpecificationContent"] = boost::any(*specificationContent);
    }
    if (specificationName) {
      res["SpecificationName"] = boost::any(*specificationName);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ConfigurationSpecificationId") != m.end() && !m["ConfigurationSpecificationId"].empty()) {
      configurationSpecificationId = make_shared<string>(boost::any_cast<string>(m["ConfigurationSpecificationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RelatedVariate") != m.end() && !m["RelatedVariate"].empty()) {
      relatedVariateShrink = make_shared<string>(boost::any_cast<string>(m["RelatedVariate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SpecificationContent") != m.end() && !m["SpecificationContent"].empty()) {
      specificationContent = make_shared<string>(boost::any_cast<string>(m["SpecificationContent"]));
    }
    if (m.find("SpecificationName") != m.end() && !m["SpecificationName"].empty()) {
      specificationName = make_shared<string>(boost::any_cast<string>(m["SpecificationName"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateConfigurationSpecificationShrinkRequest() = default;
};
class UpdateConfigurationSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateConfigurationSpecificationResponseBody() {}

  explicit UpdateConfigurationSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigurationSpecificationResponseBody() = default;
};
class UpdateConfigurationSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigurationSpecificationResponseBody> body{};

  UpdateConfigurationSpecificationResponse() {}

  explicit UpdateConfigurationSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigurationSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigurationSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigurationSpecificationResponse() = default;
};
class UpdateConfigurationVariateRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> configurationVariateId{};
  shared_ptr<string> formatFunction{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> variateName{};

  UpdateConfigurationVariateRequest() {}

  explicit UpdateConfigurationVariateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configurationVariateId) {
      res["ConfigurationVariateId"] = boost::any(*configurationVariateId);
    }
    if (formatFunction) {
      res["FormatFunction"] = boost::any(*formatFunction);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (variateName) {
      res["VariateName"] = boost::any(*variateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigurationVariateId") != m.end() && !m["ConfigurationVariateId"].empty()) {
      configurationVariateId = make_shared<string>(boost::any_cast<string>(m["ConfigurationVariateId"]));
    }
    if (m.find("FormatFunction") != m.end() && !m["FormatFunction"].empty()) {
      formatFunction = make_shared<string>(boost::any_cast<string>(m["FormatFunction"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("VariateName") != m.end() && !m["VariateName"].empty()) {
      variateName = make_shared<string>(boost::any_cast<string>(m["VariateName"]));
    }
  }


  virtual ~UpdateConfigurationVariateRequest() = default;
};
class UpdateConfigurationVariateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateConfigurationVariateResponseBody() {}

  explicit UpdateConfigurationVariateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigurationVariateResponseBody() = default;
};
class UpdateConfigurationVariateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigurationVariateResponseBody> body{};

  UpdateConfigurationVariateResponse() {}

  explicit UpdateConfigurationVariateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigurationVariateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigurationVariateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigurationVariateResponse() = default;
};
class UpdateDedicatedLineRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> contact{};
  shared_ptr<string> dedicatedLineGateway{};
  shared_ptr<string> dedicatedLineId{};
  shared_ptr<string> dedicatedLineIp{};
  shared_ptr<string> dedicatedLineRole{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> onlineDate{};
  shared_ptr<string> phone{};
  shared_ptr<string> physicalSpaceId{};

  UpdateDedicatedLineRequest() {}

  explicit UpdateDedicatedLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    if (dedicatedLineGateway) {
      res["DedicatedLineGateway"] = boost::any(*dedicatedLineGateway);
    }
    if (dedicatedLineId) {
      res["DedicatedLineId"] = boost::any(*dedicatedLineId);
    }
    if (dedicatedLineIp) {
      res["DedicatedLineIp"] = boost::any(*dedicatedLineIp);
    }
    if (dedicatedLineRole) {
      res["DedicatedLineRole"] = boost::any(*dedicatedLineRole);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispId) {
      res["IspId"] = boost::any(*ispId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (onlineDate) {
      res["OnlineDate"] = boost::any(*onlineDate);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["Contact"]));
    }
    if (m.find("DedicatedLineGateway") != m.end() && !m["DedicatedLineGateway"].empty()) {
      dedicatedLineGateway = make_shared<string>(boost::any_cast<string>(m["DedicatedLineGateway"]));
    }
    if (m.find("DedicatedLineId") != m.end() && !m["DedicatedLineId"].empty()) {
      dedicatedLineId = make_shared<string>(boost::any_cast<string>(m["DedicatedLineId"]));
    }
    if (m.find("DedicatedLineIp") != m.end() && !m["DedicatedLineIp"].empty()) {
      dedicatedLineIp = make_shared<string>(boost::any_cast<string>(m["DedicatedLineIp"]));
    }
    if (m.find("DedicatedLineRole") != m.end() && !m["DedicatedLineRole"].empty()) {
      dedicatedLineRole = make_shared<string>(boost::any_cast<string>(m["DedicatedLineRole"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspId") != m.end() && !m["IspId"].empty()) {
      ispId = make_shared<string>(boost::any_cast<string>(m["IspId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OnlineDate") != m.end() && !m["OnlineDate"].empty()) {
      onlineDate = make_shared<string>(boost::any_cast<string>(m["OnlineDate"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
  }


  virtual ~UpdateDedicatedLineRequest() = default;
};
class UpdateDedicatedLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDedicatedLineResponseBody() {}

  explicit UpdateDedicatedLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDedicatedLineResponseBody() = default;
};
class UpdateDedicatedLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDedicatedLineResponseBody> body{};

  UpdateDedicatedLineResponse() {}

  explicit UpdateDedicatedLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDedicatedLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDedicatedLineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDedicatedLineResponse() = default;
};
class UpdateDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> mac{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> sn{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  UpdateDeviceRequest() {}

  explicit UpdateDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateDeviceRequest() = default;
};
class UpdateDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDeviceResponseBody() {}

  explicit UpdateDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDeviceResponseBody() = default;
};
class UpdateDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeviceResponseBody> body{};

  UpdateDeviceResponse() {}

  explicit UpdateDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceResponse() = default;
};
class UpdateDeviceFormRequestAttributeList : public Darabonba::Model {
public:
  shared_ptr<string> attributeFormat{};
  shared_ptr<bool> attributeFuzzyQuery{};
  shared_ptr<string> attributeKey{};
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributePlaceholder{};
  shared_ptr<bool> attributeQuery{};
  shared_ptr<string> attributeReference{};
  shared_ptr<bool> attributeRequirement{};
  shared_ptr<long> attributeSequence{};
  shared_ptr<bool> attributeTableDisplay{};
  shared_ptr<string> attributeType{};
  shared_ptr<bool> attributeUniqueness{};

  UpdateDeviceFormRequestAttributeList() {}

  explicit UpdateDeviceFormRequestAttributeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeFormat) {
      res["AttributeFormat"] = boost::any(*attributeFormat);
    }
    if (attributeFuzzyQuery) {
      res["AttributeFuzzyQuery"] = boost::any(*attributeFuzzyQuery);
    }
    if (attributeKey) {
      res["AttributeKey"] = boost::any(*attributeKey);
    }
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributePlaceholder) {
      res["AttributePlaceholder"] = boost::any(*attributePlaceholder);
    }
    if (attributeQuery) {
      res["AttributeQuery"] = boost::any(*attributeQuery);
    }
    if (attributeReference) {
      res["AttributeReference"] = boost::any(*attributeReference);
    }
    if (attributeRequirement) {
      res["AttributeRequirement"] = boost::any(*attributeRequirement);
    }
    if (attributeSequence) {
      res["AttributeSequence"] = boost::any(*attributeSequence);
    }
    if (attributeTableDisplay) {
      res["AttributeTableDisplay"] = boost::any(*attributeTableDisplay);
    }
    if (attributeType) {
      res["AttributeType"] = boost::any(*attributeType);
    }
    if (attributeUniqueness) {
      res["AttributeUniqueness"] = boost::any(*attributeUniqueness);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeFormat") != m.end() && !m["AttributeFormat"].empty()) {
      attributeFormat = make_shared<string>(boost::any_cast<string>(m["AttributeFormat"]));
    }
    if (m.find("AttributeFuzzyQuery") != m.end() && !m["AttributeFuzzyQuery"].empty()) {
      attributeFuzzyQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeFuzzyQuery"]));
    }
    if (m.find("AttributeKey") != m.end() && !m["AttributeKey"].empty()) {
      attributeKey = make_shared<string>(boost::any_cast<string>(m["AttributeKey"]));
    }
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributePlaceholder") != m.end() && !m["AttributePlaceholder"].empty()) {
      attributePlaceholder = make_shared<string>(boost::any_cast<string>(m["AttributePlaceholder"]));
    }
    if (m.find("AttributeQuery") != m.end() && !m["AttributeQuery"].empty()) {
      attributeQuery = make_shared<bool>(boost::any_cast<bool>(m["AttributeQuery"]));
    }
    if (m.find("AttributeReference") != m.end() && !m["AttributeReference"].empty()) {
      attributeReference = make_shared<string>(boost::any_cast<string>(m["AttributeReference"]));
    }
    if (m.find("AttributeRequirement") != m.end() && !m["AttributeRequirement"].empty()) {
      attributeRequirement = make_shared<bool>(boost::any_cast<bool>(m["AttributeRequirement"]));
    }
    if (m.find("AttributeSequence") != m.end() && !m["AttributeSequence"].empty()) {
      attributeSequence = make_shared<long>(boost::any_cast<long>(m["AttributeSequence"]));
    }
    if (m.find("AttributeTableDisplay") != m.end() && !m["AttributeTableDisplay"].empty()) {
      attributeTableDisplay = make_shared<bool>(boost::any_cast<bool>(m["AttributeTableDisplay"]));
    }
    if (m.find("AttributeType") != m.end() && !m["AttributeType"].empty()) {
      attributeType = make_shared<string>(boost::any_cast<string>(m["AttributeType"]));
    }
    if (m.find("AttributeUniqueness") != m.end() && !m["AttributeUniqueness"].empty()) {
      attributeUniqueness = make_shared<bool>(boost::any_cast<bool>(m["AttributeUniqueness"]));
    }
  }


  virtual ~UpdateDeviceFormRequestAttributeList() = default;
};
class UpdateDeviceFormRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accountConfig{};
  shared_ptr<vector<UpdateDeviceFormRequestAttributeList>> attributeList{};
  shared_ptr<bool> configCompare{};
  shared_ptr<bool> detailDisplay{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> relatedDeviceFormId{};
  shared_ptr<string> script{};

  UpdateDeviceFormRequest() {}

  explicit UpdateDeviceFormRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (attributeList) {
      vector<boost::any> temp1;
      for(auto item1:*attributeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeList"] = boost::any(temp1);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (detailDisplay) {
      res["DetailDisplay"] = boost::any(*detailDisplay);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (relatedDeviceFormId) {
      res["RelatedDeviceFormId"] = boost::any(*relatedDeviceFormId);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<bool>(boost::any_cast<bool>(m["AccountConfig"]));
    }
    if (m.find("AttributeList") != m.end() && !m["AttributeList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeList"].type()) {
        vector<UpdateDeviceFormRequestAttributeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDeviceFormRequestAttributeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeList = make_shared<vector<UpdateDeviceFormRequestAttributeList>>(expect1);
      }
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<bool>(boost::any_cast<bool>(m["ConfigCompare"]));
    }
    if (m.find("DetailDisplay") != m.end() && !m["DetailDisplay"].empty()) {
      detailDisplay = make_shared<bool>(boost::any_cast<bool>(m["DetailDisplay"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RelatedDeviceFormId") != m.end() && !m["RelatedDeviceFormId"].empty()) {
      relatedDeviceFormId = make_shared<string>(boost::any_cast<string>(m["RelatedDeviceFormId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~UpdateDeviceFormRequest() = default;
};
class UpdateDeviceFormShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accountConfig{};
  shared_ptr<string> attributeListShrink{};
  shared_ptr<bool> configCompare{};
  shared_ptr<bool> detailDisplay{};
  shared_ptr<string> deviceFormId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> relatedDeviceFormId{};
  shared_ptr<string> script{};

  UpdateDeviceFormShrinkRequest() {}

  explicit UpdateDeviceFormShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountConfig) {
      res["AccountConfig"] = boost::any(*accountConfig);
    }
    if (attributeListShrink) {
      res["AttributeList"] = boost::any(*attributeListShrink);
    }
    if (configCompare) {
      res["ConfigCompare"] = boost::any(*configCompare);
    }
    if (detailDisplay) {
      res["DetailDisplay"] = boost::any(*detailDisplay);
    }
    if (deviceFormId) {
      res["DeviceFormId"] = boost::any(*deviceFormId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (relatedDeviceFormId) {
      res["RelatedDeviceFormId"] = boost::any(*relatedDeviceFormId);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountConfig") != m.end() && !m["AccountConfig"].empty()) {
      accountConfig = make_shared<bool>(boost::any_cast<bool>(m["AccountConfig"]));
    }
    if (m.find("AttributeList") != m.end() && !m["AttributeList"].empty()) {
      attributeListShrink = make_shared<string>(boost::any_cast<string>(m["AttributeList"]));
    }
    if (m.find("ConfigCompare") != m.end() && !m["ConfigCompare"].empty()) {
      configCompare = make_shared<bool>(boost::any_cast<bool>(m["ConfigCompare"]));
    }
    if (m.find("DetailDisplay") != m.end() && !m["DetailDisplay"].empty()) {
      detailDisplay = make_shared<bool>(boost::any_cast<bool>(m["DetailDisplay"]));
    }
    if (m.find("DeviceFormId") != m.end() && !m["DeviceFormId"].empty()) {
      deviceFormId = make_shared<string>(boost::any_cast<string>(m["DeviceFormId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RelatedDeviceFormId") != m.end() && !m["RelatedDeviceFormId"].empty()) {
      relatedDeviceFormId = make_shared<string>(boost::any_cast<string>(m["RelatedDeviceFormId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~UpdateDeviceFormShrinkRequest() = default;
};
class UpdateDeviceFormResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDeviceFormResponseBody() {}

  explicit UpdateDeviceFormResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDeviceFormResponseBody() = default;
};
class UpdateDeviceFormResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeviceFormResponseBody> body{};

  UpdateDeviceFormResponse() {}

  explicit UpdateDeviceFormResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceFormResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceFormResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceFormResponse() = default;
};
class UpdateDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> devicePropertyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyContent{};
  shared_ptr<string> propertyFormat{};
  shared_ptr<string> propertyName{};

  UpdateDevicePropertyRequest() {}

  explicit UpdateDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devicePropertyId) {
      res["DevicePropertyId"] = boost::any(*devicePropertyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyContent) {
      res["PropertyContent"] = boost::any(*propertyContent);
    }
    if (propertyFormat) {
      res["PropertyFormat"] = boost::any(*propertyFormat);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevicePropertyId") != m.end() && !m["DevicePropertyId"].empty()) {
      devicePropertyId = make_shared<string>(boost::any_cast<string>(m["DevicePropertyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyContent") != m.end() && !m["PropertyContent"].empty()) {
      propertyContent = make_shared<string>(boost::any_cast<string>(m["PropertyContent"]));
    }
    if (m.find("PropertyFormat") != m.end() && !m["PropertyFormat"].empty()) {
      propertyFormat = make_shared<string>(boost::any_cast<string>(m["PropertyFormat"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
  }


  virtual ~UpdateDevicePropertyRequest() = default;
};
class UpdateDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDevicePropertyResponseBody() {}

  explicit UpdateDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDevicePropertyResponseBody() = default;
};
class UpdateDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDevicePropertyResponseBody> body{};

  UpdateDevicePropertyResponse() {}

  explicit UpdateDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDevicePropertyResponse() = default;
};
class UpdateDeviceResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<vector<string>> deviceResourceIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> updateType{};

  UpdateDeviceResourceRequest() {}

  explicit UpdateDeviceResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIds) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (updateType) {
      res["UpdateType"] = boost::any(*updateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("UpdateType") != m.end() && !m["UpdateType"].empty()) {
      updateType = make_shared<string>(boost::any_cast<string>(m["UpdateType"]));
    }
  }


  virtual ~UpdateDeviceResourceRequest() = default;
};
class UpdateDeviceResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> deviceResourceId{};
  shared_ptr<string> deviceResourceIdsShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> updateType{};

  UpdateDeviceResourceShrinkRequest() {}

  explicit UpdateDeviceResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (deviceResourceId) {
      res["DeviceResourceId"] = boost::any(*deviceResourceId);
    }
    if (deviceResourceIdsShrink) {
      res["DeviceResourceIds"] = boost::any(*deviceResourceIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (updateType) {
      res["UpdateType"] = boost::any(*updateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DeviceResourceId") != m.end() && !m["DeviceResourceId"].empty()) {
      deviceResourceId = make_shared<string>(boost::any_cast<string>(m["DeviceResourceId"]));
    }
    if (m.find("DeviceResourceIds") != m.end() && !m["DeviceResourceIds"].empty()) {
      deviceResourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceResourceIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("UpdateType") != m.end() && !m["UpdateType"].empty()) {
      updateType = make_shared<string>(boost::any_cast<string>(m["UpdateType"]));
    }
  }


  virtual ~UpdateDeviceResourceShrinkRequest() = default;
};
class UpdateDeviceResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDeviceResourceResponseBody() {}

  explicit UpdateDeviceResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDeviceResourceResponseBody() = default;
};
class UpdateDeviceResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeviceResourceResponseBody> body{};

  UpdateDeviceResourceResponse() {}

  explicit UpdateDeviceResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceResourceResponse() = default;
};
class UpdateDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  UpdateDevicesRequest() {}

  explicit UpdateDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateDevicesRequest() = default;
};
class UpdateDevicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIdsShrink{};
  shared_ptr<string> enablePassword{};
  shared_ptr<string> extAttributes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> loginType{};
  shared_ptr<string> loginUsername{};
  shared_ptr<string> model{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> securityDomain{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> snmpAccountType{};
  shared_ptr<string> snmpAccountVersion{};
  shared_ptr<string> snmpAuthPassphrase{};
  shared_ptr<string> snmpAuthProtocol{};
  shared_ptr<string> snmpCommunity{};
  shared_ptr<string> snmpPrivacyPassphrase{};
  shared_ptr<string> snmpPrivacyProtocol{};
  shared_ptr<string> snmpSecurityLevel{};
  shared_ptr<string> snmpUsername{};
  shared_ptr<string> vendor{};

  UpdateDevicesShrinkRequest() {}

  explicit UpdateDevicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIdsShrink) {
      res["DeviceIds"] = boost::any(*deviceIdsShrink);
    }
    if (enablePassword) {
      res["EnablePassword"] = boost::any(*enablePassword);
    }
    if (extAttributes) {
      res["ExtAttributes"] = boost::any(*extAttributes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginPassword) {
      res["LoginPassword"] = boost::any(*loginPassword);
    }
    if (loginType) {
      res["LoginType"] = boost::any(*loginType);
    }
    if (loginUsername) {
      res["LoginUsername"] = boost::any(*loginUsername);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (securityDomain) {
      res["SecurityDomain"] = boost::any(*securityDomain);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (snmpAccountType) {
      res["SnmpAccountType"] = boost::any(*snmpAccountType);
    }
    if (snmpAccountVersion) {
      res["SnmpAccountVersion"] = boost::any(*snmpAccountVersion);
    }
    if (snmpAuthPassphrase) {
      res["SnmpAuthPassphrase"] = boost::any(*snmpAuthPassphrase);
    }
    if (snmpAuthProtocol) {
      res["SnmpAuthProtocol"] = boost::any(*snmpAuthProtocol);
    }
    if (snmpCommunity) {
      res["SnmpCommunity"] = boost::any(*snmpCommunity);
    }
    if (snmpPrivacyPassphrase) {
      res["SnmpPrivacyPassphrase"] = boost::any(*snmpPrivacyPassphrase);
    }
    if (snmpPrivacyProtocol) {
      res["SnmpPrivacyProtocol"] = boost::any(*snmpPrivacyProtocol);
    }
    if (snmpSecurityLevel) {
      res["SnmpSecurityLevel"] = boost::any(*snmpSecurityLevel);
    }
    if (snmpUsername) {
      res["SnmpUsername"] = boost::any(*snmpUsername);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIdsShrink = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("EnablePassword") != m.end() && !m["EnablePassword"].empty()) {
      enablePassword = make_shared<string>(boost::any_cast<string>(m["EnablePassword"]));
    }
    if (m.find("ExtAttributes") != m.end() && !m["ExtAttributes"].empty()) {
      extAttributes = make_shared<string>(boost::any_cast<string>(m["ExtAttributes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginPassword") != m.end() && !m["LoginPassword"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["LoginPassword"]));
    }
    if (m.find("LoginType") != m.end() && !m["LoginType"].empty()) {
      loginType = make_shared<string>(boost::any_cast<string>(m["LoginType"]));
    }
    if (m.find("LoginUsername") != m.end() && !m["LoginUsername"].empty()) {
      loginUsername = make_shared<string>(boost::any_cast<string>(m["LoginUsername"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("SecurityDomain") != m.end() && !m["SecurityDomain"].empty()) {
      securityDomain = make_shared<string>(boost::any_cast<string>(m["SecurityDomain"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("SnmpAccountType") != m.end() && !m["SnmpAccountType"].empty()) {
      snmpAccountType = make_shared<string>(boost::any_cast<string>(m["SnmpAccountType"]));
    }
    if (m.find("SnmpAccountVersion") != m.end() && !m["SnmpAccountVersion"].empty()) {
      snmpAccountVersion = make_shared<string>(boost::any_cast<string>(m["SnmpAccountVersion"]));
    }
    if (m.find("SnmpAuthPassphrase") != m.end() && !m["SnmpAuthPassphrase"].empty()) {
      snmpAuthPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpAuthPassphrase"]));
    }
    if (m.find("SnmpAuthProtocol") != m.end() && !m["SnmpAuthProtocol"].empty()) {
      snmpAuthProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpAuthProtocol"]));
    }
    if (m.find("SnmpCommunity") != m.end() && !m["SnmpCommunity"].empty()) {
      snmpCommunity = make_shared<string>(boost::any_cast<string>(m["SnmpCommunity"]));
    }
    if (m.find("SnmpPrivacyPassphrase") != m.end() && !m["SnmpPrivacyPassphrase"].empty()) {
      snmpPrivacyPassphrase = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyPassphrase"]));
    }
    if (m.find("SnmpPrivacyProtocol") != m.end() && !m["SnmpPrivacyProtocol"].empty()) {
      snmpPrivacyProtocol = make_shared<string>(boost::any_cast<string>(m["SnmpPrivacyProtocol"]));
    }
    if (m.find("SnmpSecurityLevel") != m.end() && !m["SnmpSecurityLevel"].empty()) {
      snmpSecurityLevel = make_shared<string>(boost::any_cast<string>(m["SnmpSecurityLevel"]));
    }
    if (m.find("SnmpUsername") != m.end() && !m["SnmpUsername"].empty()) {
      snmpUsername = make_shared<string>(boost::any_cast<string>(m["SnmpUsername"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateDevicesShrinkRequest() = default;
};
class UpdateDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDevicesResponseBody() {}

  explicit UpdateDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDevicesResponseBody() = default;
};
class UpdateDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDevicesResponseBody> body{};

  UpdateDevicesResponse() {}

  explicit UpdateDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDevicesResponse() = default;
};
class UpdateEventDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};

  UpdateEventDefinitionRequest() {}

  explicit UpdateEventDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateEventDefinitionRequest() = default;
};
class UpdateEventDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEventDefinitionResponseBody() {}

  explicit UpdateEventDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEventDefinitionResponseBody() = default;
};
class UpdateEventDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEventDefinitionResponseBody> body{};

  UpdateEventDefinitionResponse() {}

  explicit UpdateEventDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEventDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEventDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEventDefinitionResponse() = default;
};
class UpdateInformationKeyActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> value{};

  UpdateInformationKeyActionRequest() {}

  explicit UpdateInformationKeyActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateInformationKeyActionRequest() = default;
};
class UpdateInformationKeyActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> actionMessage{};
  shared_ptr<string> requestId{};

  UpdateInformationKeyActionResponseBody() {}

  explicit UpdateInformationKeyActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionMessage) {
      res["ActionMessage"] = boost::any(*actionMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionMessage") != m.end() && !m["ActionMessage"].empty()) {
      actionMessage = make_shared<string>(boost::any_cast<string>(m["ActionMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateInformationKeyActionResponseBody() = default;
};
class UpdateInformationKeyActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInformationKeyActionResponseBody> body{};

  UpdateInformationKeyActionResponse() {}

  explicit UpdateInformationKeyActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInformationKeyActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInformationKeyActionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInformationKeyActionResponse() = default;
};
class UpdateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  UpdateInstanceRequest() {}

  explicit UpdateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~UpdateInstanceRequest() = default;
};
class UpdateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateInstanceResponseBody() {}

  explicit UpdateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateInstanceResponseBody() = default;
};
class UpdateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceResponseBody> body{};

  UpdateInstanceResponse() {}

  explicit UpdateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceResponse() = default;
};
class UpdateOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bootPatch{};
  shared_ptr<string> featurePatch{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> model{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> osVersionId{};
  shared_ptr<string> status{};
  shared_ptr<string> systemPatch{};
  shared_ptr<string> vendor{};

  UpdateOsVersionRequest() {}

  explicit UpdateOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootPatch) {
      res["BootPatch"] = boost::any(*bootPatch);
    }
    if (featurePatch) {
      res["FeaturePatch"] = boost::any(*featurePatch);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (osVersionId) {
      res["OsVersionId"] = boost::any(*osVersionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemPatch) {
      res["SystemPatch"] = boost::any(*systemPatch);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootPatch") != m.end() && !m["BootPatch"].empty()) {
      bootPatch = make_shared<string>(boost::any_cast<string>(m["BootPatch"]));
    }
    if (m.find("FeaturePatch") != m.end() && !m["FeaturePatch"].empty()) {
      featurePatch = make_shared<string>(boost::any_cast<string>(m["FeaturePatch"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("OsVersionId") != m.end() && !m["OsVersionId"].empty()) {
      osVersionId = make_shared<string>(boost::any_cast<string>(m["OsVersionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemPatch") != m.end() && !m["SystemPatch"].empty()) {
      systemPatch = make_shared<string>(boost::any_cast<string>(m["SystemPatch"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateOsVersionRequest() = default;
};
class UpdateOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsVersionResponseBody() {}

  explicit UpdateOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsVersionResponseBody() = default;
};
class UpdateOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOsVersionResponseBody> body{};

  UpdateOsVersionResponse() {}

  explicit UpdateOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsVersionResponse() = default;
};
class UpdatePhysicalSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> moveAction{};
  shared_ptr<string> owner{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> securityDomainList{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> targetUid{};

  UpdatePhysicalSpaceRequest() {}

  explicit UpdatePhysicalSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (moveAction) {
      res["MoveAction"] = boost::any(*moveAction);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainList) {
      res["SecurityDomainList"] = boost::any(*securityDomainList);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MoveAction") != m.end() && !m["MoveAction"].empty()) {
      moveAction = make_shared<string>(boost::any_cast<string>(m["MoveAction"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityDomainList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityDomainList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityDomainList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~UpdatePhysicalSpaceRequest() = default;
};
class UpdatePhysicalSpaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> moveAction{};
  shared_ptr<string> owner{};
  shared_ptr<string> parentUid{};
  shared_ptr<string> physicalSpaceId{};
  shared_ptr<string> physicalSpaceName{};
  shared_ptr<string> province{};
  shared_ptr<string> remark{};
  shared_ptr<string> securityDomainListShrink{};
  shared_ptr<string> spaceAbbreviation{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> targetUid{};

  UpdatePhysicalSpaceShrinkRequest() {}

  explicit UpdatePhysicalSpaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (moveAction) {
      res["MoveAction"] = boost::any(*moveAction);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (physicalSpaceId) {
      res["PhysicalSpaceId"] = boost::any(*physicalSpaceId);
    }
    if (physicalSpaceName) {
      res["PhysicalSpaceName"] = boost::any(*physicalSpaceName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityDomainListShrink) {
      res["SecurityDomainList"] = boost::any(*securityDomainListShrink);
    }
    if (spaceAbbreviation) {
      res["SpaceAbbreviation"] = boost::any(*spaceAbbreviation);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MoveAction") != m.end() && !m["MoveAction"].empty()) {
      moveAction = make_shared<string>(boost::any_cast<string>(m["MoveAction"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("PhysicalSpaceId") != m.end() && !m["PhysicalSpaceId"].empty()) {
      physicalSpaceId = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceId"]));
    }
    if (m.find("PhysicalSpaceName") != m.end() && !m["PhysicalSpaceName"].empty()) {
      physicalSpaceName = make_shared<string>(boost::any_cast<string>(m["PhysicalSpaceName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityDomainList") != m.end() && !m["SecurityDomainList"].empty()) {
      securityDomainListShrink = make_shared<string>(boost::any_cast<string>(m["SecurityDomainList"]));
    }
    if (m.find("SpaceAbbreviation") != m.end() && !m["SpaceAbbreviation"].empty()) {
      spaceAbbreviation = make_shared<string>(boost::any_cast<string>(m["SpaceAbbreviation"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~UpdatePhysicalSpaceShrinkRequest() = default;
};
class UpdatePhysicalSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdatePhysicalSpaceResponseBody() {}

  explicit UpdatePhysicalSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePhysicalSpaceResponseBody() = default;
};
class UpdatePhysicalSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePhysicalSpaceResponseBody> body{};

  UpdatePhysicalSpaceResponse() {}

  explicit UpdatePhysicalSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePhysicalSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePhysicalSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePhysicalSpaceResponse() = default;
};
class UpdateProjectProgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> progress{};
  shared_ptr<string> setupProjectId{};

  UpdateProjectProgressRequest() {}

  explicit UpdateProjectProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~UpdateProjectProgressRequest() = default;
};
class UpdateProjectProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProjectProgressResponseBody() {}

  explicit UpdateProjectProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProjectProgressResponseBody() = default;
};
class UpdateProjectProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectProgressResponseBody> body{};

  UpdateProjectProgressResponse() {}

  explicit UpdateProjectProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectProgressResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectProgressResponse() = default;
};
class UpdateResourceInformationRequestInformation : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> keyAction{};
  shared_ptr<string> keyAttribute{};
  shared_ptr<string> keyDescription{};
  shared_ptr<string> setupProjectId{};

  UpdateResourceInformationRequestInformation() {}

  explicit UpdateResourceInformationRequestInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyAction) {
      res["KeyAction"] = boost::any(*keyAction);
    }
    if (keyAttribute) {
      res["KeyAttribute"] = boost::any(*keyAttribute);
    }
    if (keyDescription) {
      res["KeyDescription"] = boost::any(*keyDescription);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyAction") != m.end() && !m["KeyAction"].empty()) {
      keyAction = make_shared<string>(boost::any_cast<string>(m["KeyAction"]));
    }
    if (m.find("KeyAttribute") != m.end() && !m["KeyAttribute"].empty()) {
      keyAttribute = make_shared<string>(boost::any_cast<string>(m["KeyAttribute"]));
    }
    if (m.find("KeyDescription") != m.end() && !m["KeyDescription"].empty()) {
      keyDescription = make_shared<string>(boost::any_cast<string>(m["KeyDescription"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~UpdateResourceInformationRequestInformation() = default;
};
class UpdateResourceInformationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateResourceInformationRequestInformation>> information{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> resourceType{};

  UpdateResourceInformationRequest() {}

  explicit UpdateResourceInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (information) {
      vector<boost::any> temp1;
      for(auto item1:*information){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Information"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Information") != m.end() && !m["Information"].empty()) {
      if (typeid(vector<boost::any>) == m["Information"].type()) {
        vector<UpdateResourceInformationRequestInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Information"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateResourceInformationRequestInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        information = make_shared<vector<UpdateResourceInformationRequestInformation>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UpdateResourceInformationRequest() = default;
};
class UpdateResourceInformationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> informationShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> resourceType{};

  UpdateResourceInformationShrinkRequest() {}

  explicit UpdateResourceInformationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (informationShrink) {
      res["Information"] = boost::any(*informationShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Information") != m.end() && !m["Information"].empty()) {
      informationShrink = make_shared<string>(boost::any_cast<string>(m["Information"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UpdateResourceInformationShrinkRequest() = default;
};
class UpdateResourceInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateResourceInformationResponseBody() {}

  explicit UpdateResourceInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateResourceInformationResponseBody() = default;
};
class UpdateResourceInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceInformationResponseBody> body{};

  UpdateResourceInformationResponse() {}

  explicit UpdateResourceInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceInformationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceInformationResponse() = default;
};
class UpdateResourceInstanceRequestResourceInformation : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateResourceInstanceRequestResourceInformation() {}

  explicit UpdateResourceInstanceRequestResourceInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateResourceInstanceRequestResourceInformation() = default;
};
class UpdateResourceInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<UpdateResourceInstanceRequestResourceInformation>> resourceInformation{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> setupProjectId{};

  UpdateResourceInstanceRequest() {}

  explicit UpdateResourceInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceInformation) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInformation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInformation"] = boost::any(temp1);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceInformation") != m.end() && !m["ResourceInformation"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInformation"].type()) {
        vector<UpdateResourceInstanceRequestResourceInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInformation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateResourceInstanceRequestResourceInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInformation = make_shared<vector<UpdateResourceInstanceRequestResourceInformation>>(expect1);
      }
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~UpdateResourceInstanceRequest() = default;
};
class UpdateResourceInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceInformationShrink{};
  shared_ptr<string> resourceInformationId{};
  shared_ptr<string> setupProjectId{};

  UpdateResourceInstanceShrinkRequest() {}

  explicit UpdateResourceInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceInformationShrink) {
      res["ResourceInformation"] = boost::any(*resourceInformationShrink);
    }
    if (resourceInformationId) {
      res["ResourceInformationId"] = boost::any(*resourceInformationId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceInformation") != m.end() && !m["ResourceInformation"].empty()) {
      resourceInformationShrink = make_shared<string>(boost::any_cast<string>(m["ResourceInformation"]));
    }
    if (m.find("ResourceInformationId") != m.end() && !m["ResourceInformationId"].empty()) {
      resourceInformationId = make_shared<string>(boost::any_cast<string>(m["ResourceInformationId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
  }


  virtual ~UpdateResourceInstanceShrinkRequest() = default;
};
class UpdateResourceInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateResourceInstanceResponseBody() {}

  explicit UpdateResourceInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateResourceInstanceResponseBody() = default;
};
class UpdateResourceInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceInstanceResponseBody> body{};

  UpdateResourceInstanceResponse() {}

  explicit UpdateResourceInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceInstanceResponse() = default;
};
class UpdateSetupProjectRequestPackages : public Darabonba::Model {
public:
  shared_ptr<long> deviceNumber{};
  shared_ptr<string> model{};
  shared_ptr<string> role{};
  shared_ptr<string> vendor{};

  UpdateSetupProjectRequestPackages() {}

  explicit UpdateSetupProjectRequestPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNumber) {
      res["DeviceNumber"] = boost::any(*deviceNumber);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNumber") != m.end() && !m["DeviceNumber"].empty()) {
      deviceNumber = make_shared<long>(boost::any_cast<long>(m["DeviceNumber"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~UpdateSetupProjectRequestPackages() = default;
};
class UpdateSetupProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodes{};
  shared_ptr<vector<UpdateSetupProjectRequestPackages>> packages{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> spaceId{};

  UpdateSetupProjectRequest() {}

  explicit UpdateSetupProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodes) {
      res["Nodes"] = boost::any(*nodes);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      nodes = make_shared<string>(boost::any_cast<string>(m["Nodes"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<UpdateSetupProjectRequestPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSetupProjectRequestPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<UpdateSetupProjectRequestPackages>>(expect1);
      }
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~UpdateSetupProjectRequest() = default;
};
class UpdateSetupProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> architectureId{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodes{};
  shared_ptr<string> packagesShrink{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> spaceId{};

  UpdateSetupProjectShrinkRequest() {}

  explicit UpdateSetupProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectureId) {
      res["ArchitectureId"] = boost::any(*architectureId);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodes) {
      res["Nodes"] = boost::any(*nodes);
    }
    if (packagesShrink) {
      res["Packages"] = boost::any(*packagesShrink);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchitectureId") != m.end() && !m["ArchitectureId"].empty()) {
      architectureId = make_shared<string>(boost::any_cast<string>(m["ArchitectureId"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      nodes = make_shared<string>(boost::any_cast<string>(m["Nodes"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      packagesShrink = make_shared<string>(boost::any_cast<string>(m["Packages"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~UpdateSetupProjectShrinkRequest() = default;
};
class UpdateSetupProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> setupProjectId{};
  shared_ptr<string> setupProjectName{};
  shared_ptr<string> setupProjectSpecification{};

  UpdateSetupProjectResponseBody() {}

  explicit UpdateSetupProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (setupProjectId) {
      res["SetupProjectId"] = boost::any(*setupProjectId);
    }
    if (setupProjectName) {
      res["SetupProjectName"] = boost::any(*setupProjectName);
    }
    if (setupProjectSpecification) {
      res["SetupProjectSpecification"] = boost::any(*setupProjectSpecification);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SetupProjectId") != m.end() && !m["SetupProjectId"].empty()) {
      setupProjectId = make_shared<string>(boost::any_cast<string>(m["SetupProjectId"]));
    }
    if (m.find("SetupProjectName") != m.end() && !m["SetupProjectName"].empty()) {
      setupProjectName = make_shared<string>(boost::any_cast<string>(m["SetupProjectName"]));
    }
    if (m.find("SetupProjectSpecification") != m.end() && !m["SetupProjectSpecification"].empty()) {
      setupProjectSpecification = make_shared<string>(boost::any_cast<string>(m["SetupProjectSpecification"]));
    }
  }


  virtual ~UpdateSetupProjectResponseBody() = default;
};
class UpdateSetupProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSetupProjectResponseBody> body{};

  UpdateSetupProjectResponse() {}

  explicit UpdateSetupProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSetupProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSetupProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSetupProjectResponse() = default;
};
class UpdateSpaceModelRequestSort : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> levelName{};

  UpdateSpaceModelRequestSort() {}

  explicit UpdateSpaceModelRequestSort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelName) {
      res["LevelName"] = boost::any(*levelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LevelName") != m.end() && !m["LevelName"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["LevelName"]));
    }
  }


  virtual ~UpdateSpaceModelRequestSort() = default;
};
class UpdateSpaceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<UpdateSpaceModelRequestSort>> sort{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceType{};

  UpdateSpaceModelRequest() {}

  explicit UpdateSpaceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sort) {
      vector<boost::any> temp1;
      for(auto item1:*sort){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sort"] = boost::any(temp1);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      if (typeid(vector<boost::any>) == m["Sort"].type()) {
        vector<UpdateSpaceModelRequestSort> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sort"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSpaceModelRequestSort model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sort = make_shared<vector<UpdateSpaceModelRequestSort>>(expect1);
      }
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~UpdateSpaceModelRequest() = default;
};
class UpdateSpaceModelShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> sortShrink{};
  shared_ptr<string> spaceModelId{};
  shared_ptr<string> spaceType{};

  UpdateSpaceModelShrinkRequest() {}

  explicit UpdateSpaceModelShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sortShrink) {
      res["Sort"] = boost::any(*sortShrink);
    }
    if (spaceModelId) {
      res["SpaceModelId"] = boost::any(*spaceModelId);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sortShrink = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("SpaceModelId") != m.end() && !m["SpaceModelId"].empty()) {
      spaceModelId = make_shared<string>(boost::any_cast<string>(m["SpaceModelId"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
  }


  virtual ~UpdateSpaceModelShrinkRequest() = default;
};
class UpdateSpaceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSpaceModelResponseBody() {}

  explicit UpdateSpaceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSpaceModelResponseBody() = default;
};
class UpdateSpaceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSpaceModelResponseBody> body{};

  UpdateSpaceModelResponse() {}

  explicit UpdateSpaceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSpaceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSpaceModelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSpaceModelResponse() = default;
};
class UpdateSpaceModelInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instance{};
  shared_ptr<string> spaceId{};

  UpdateSpaceModelInstanceRequest() {}

  explicit UpdateSpaceModelInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~UpdateSpaceModelInstanceRequest() = default;
};
class UpdateSpaceModelInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSpaceModelInstanceResponseBody() {}

  explicit UpdateSpaceModelInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSpaceModelInstanceResponseBody() = default;
};
class UpdateSpaceModelInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSpaceModelInstanceResponseBody> body{};

  UpdateSpaceModelInstanceResponse() {}

  explicit UpdateSpaceModelInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSpaceModelInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSpaceModelInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSpaceModelInstanceResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ApplyIPResponse applyIPWithOptions(shared_ptr<ApplyIPRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyIPResponse applyIP(shared_ptr<ApplyIPRequest> request);
  AutoDutyResponse autoDutyWithOptions(shared_ptr<AutoDutyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AutoDutyResponse autoDuty(shared_ptr<AutoDutyRequest> request);
  CloseEventResponse closeEventWithOptions(shared_ptr<CloseEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseEventResponse closeEvent(shared_ptr<CloseEventRequest> request);
  CreateConfigurationSpecificationResponse createConfigurationSpecificationWithOptions(shared_ptr<CreateConfigurationSpecificationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigurationSpecificationResponse createConfigurationSpecification(shared_ptr<CreateConfigurationSpecificationRequest> request);
  CreateConfigurationVariateResponse createConfigurationVariateWithOptions(shared_ptr<CreateConfigurationVariateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigurationVariateResponse createConfigurationVariate(shared_ptr<CreateConfigurationVariateRequest> request);
  CreateDedicatedLineResponse createDedicatedLineWithOptions(shared_ptr<CreateDedicatedLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedLineResponse createDedicatedLine(shared_ptr<CreateDedicatedLineRequest> request);
  CreateDeviceResponse createDeviceWithOptions(shared_ptr<CreateDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceResponse createDevice(shared_ptr<CreateDeviceRequest> request);
  CreateDeviceFormResponse createDeviceFormWithOptions(shared_ptr<CreateDeviceFormRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceFormResponse createDeviceForm(shared_ptr<CreateDeviceFormRequest> request);
  CreateDevicePropertyResponse createDevicePropertyWithOptions(shared_ptr<CreateDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDevicePropertyResponse createDeviceProperty(shared_ptr<CreateDevicePropertyRequest> request);
  CreateDevicesResponse createDevicesWithOptions(shared_ptr<CreateDevicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDevicesResponse createDevices(shared_ptr<CreateDevicesRequest> request);
  CreateEventDefinitionResponse createEventDefinitionWithOptions(shared_ptr<CreateEventDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEventDefinitionResponse createEventDefinition(shared_ptr<CreateEventDefinitionRequest> request);
  CreateLinkJobResponse createLinkJobWithOptions(shared_ptr<CreateLinkJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLinkJobResponse createLinkJob(shared_ptr<CreateLinkJobRequest> request);
  CreateMonitorItemResponse createMonitorItemWithOptions(shared_ptr<CreateMonitorItemRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorItemResponse createMonitorItem(shared_ptr<CreateMonitorItemRequest> request);
  CreateOsVersionResponse createOsVersionWithOptions(shared_ptr<CreateOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOsVersionResponse createOsVersion(shared_ptr<CreateOsVersionRequest> request);
  CreatePhysicalSpaceResponse createPhysicalSpaceWithOptions(shared_ptr<CreatePhysicalSpaceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhysicalSpaceResponse createPhysicalSpace(shared_ptr<CreatePhysicalSpaceRequest> request);
  CreateRealtimeTaskResponse createRealtimeTaskWithOptions(shared_ptr<CreateRealtimeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRealtimeTaskResponse createRealtimeTask(shared_ptr<CreateRealtimeTaskRequest> request);
  CreateResourceInformationResponse createResourceInformationWithOptions(shared_ptr<CreateResourceInformationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceInformationResponse createResourceInformation(shared_ptr<CreateResourceInformationRequest> request);
  CreateSetupProjectResponse createSetupProjectWithOptions(shared_ptr<CreateSetupProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSetupProjectResponse createSetupProject(shared_ptr<CreateSetupProjectRequest> request);
  CreateSpaceModelResponse createSpaceModelWithOptions(shared_ptr<CreateSpaceModelRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSpaceModelResponse createSpaceModel(shared_ptr<CreateSpaceModelRequest> request);
  CreateTaskResponse createTaskWithOptions(shared_ptr<CreateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTaskResponse createTask(shared_ptr<CreateTaskRequest> request);
  CreateTimePeriodResponse createTimePeriodWithOptions(shared_ptr<CreateTimePeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTimePeriodResponse createTimePeriod(shared_ptr<CreateTimePeriodRequest> request);
  DeleteConfigurationSpecificationResponse deleteConfigurationSpecificationWithOptions(shared_ptr<DeleteConfigurationSpecificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigurationSpecificationResponse deleteConfigurationSpecification(shared_ptr<DeleteConfigurationSpecificationRequest> request);
  DeleteConfigurationVariateResponse deleteConfigurationVariateWithOptions(shared_ptr<DeleteConfigurationVariateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigurationVariateResponse deleteConfigurationVariate(shared_ptr<DeleteConfigurationVariateRequest> request);
  DeleteDedicatedLineResponse deleteDedicatedLineWithOptions(shared_ptr<DeleteDedicatedLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDedicatedLineResponse deleteDedicatedLine(shared_ptr<DeleteDedicatedLineRequest> request);
  DeleteDeliveryArchVersionResponse deleteDeliveryArchVersionWithOptions(shared_ptr<DeleteDeliveryArchVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeliveryArchVersionResponse deleteDeliveryArchVersion(shared_ptr<DeleteDeliveryArchVersionRequest> request);
  DeleteDeliveryProjectResponse deleteDeliveryProjectWithOptions(shared_ptr<DeleteDeliveryProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeliveryProjectResponse deleteDeliveryProject(shared_ptr<DeleteDeliveryProjectRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  DeleteDeviceFormResponse deleteDeviceFormWithOptions(shared_ptr<DeleteDeviceFormRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceFormResponse deleteDeviceForm(shared_ptr<DeleteDeviceFormRequest> request);
  DeleteDevicePropertyResponse deleteDevicePropertyWithOptions(shared_ptr<DeleteDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicePropertyResponse deleteDeviceProperty(shared_ptr<DeleteDevicePropertyRequest> request);
  DeleteDeviceResourceResponse deleteDeviceResourceWithOptions(shared_ptr<DeleteDeviceResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResourceResponse deleteDeviceResource(shared_ptr<DeleteDeviceResourceRequest> request);
  DeleteDevicesResponse deleteDevicesWithOptions(shared_ptr<DeleteDevicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicesResponse deleteDevices(shared_ptr<DeleteDevicesRequest> request);
  DeleteEventDefinitionResponse deleteEventDefinitionWithOptions(shared_ptr<DeleteEventDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventDefinitionResponse deleteEventDefinition(shared_ptr<DeleteEventDefinitionRequest> request);
  DeleteInspectionTaskResponse deleteInspectionTaskWithOptions(shared_ptr<DeleteInspectionTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInspectionTaskResponse deleteInspectionTask(shared_ptr<DeleteInspectionTaskRequest> request);
  DeleteOsVersionResponse deleteOsVersionWithOptions(shared_ptr<DeleteOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOsVersionResponse deleteOsVersion(shared_ptr<DeleteOsVersionRequest> request);
  DeletePhysicalSpaceResponse deletePhysicalSpaceWithOptions(shared_ptr<DeletePhysicalSpaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhysicalSpaceResponse deletePhysicalSpace(shared_ptr<DeletePhysicalSpaceRequest> request);
  DeleteResourceInformationResponse deleteResourceInformationWithOptions(shared_ptr<DeleteResourceInformationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceInformationResponse deleteResourceInformation(shared_ptr<DeleteResourceInformationRequest> request);
  DeleteSetupProjectResponse deleteSetupProjectWithOptions(shared_ptr<DeleteSetupProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSetupProjectResponse deleteSetupProject(shared_ptr<DeleteSetupProjectRequest> request);
  DeleteSpaceModelResponse deleteSpaceModelWithOptions(shared_ptr<DeleteSpaceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSpaceModelResponse deleteSpaceModel(shared_ptr<DeleteSpaceModelRequest> request);
  DisableNotificationResponse disableNotificationWithOptions(shared_ptr<DisableNotificationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableNotificationResponse disableNotification(shared_ptr<DisableNotificationRequest> request);
  DownloadDeviceResourceResponse downloadDeviceResourceWithOptions(shared_ptr<DownloadDeviceResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadDeviceResourceResponse downloadDeviceResource(shared_ptr<DownloadDeviceResourceRequest> request);
  EnableNotificationResponse enableNotificationWithOptions(shared_ptr<EnableNotificationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableNotificationResponse enableNotification(shared_ptr<EnableNotificationRequest> request);
  GetAlarmStatusResponse getAlarmStatusWithOptions(shared_ptr<GetAlarmStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlarmStatusResponse getAlarmStatus(shared_ptr<GetAlarmStatusRequest> request);
  GetConfigurationSpecificationResponse getConfigurationSpecificationWithOptions(shared_ptr<GetConfigurationSpecificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigurationSpecificationResponse getConfigurationSpecification(shared_ptr<GetConfigurationSpecificationRequest> request);
  GetConfigurationVariateResponse getConfigurationVariateWithOptions(shared_ptr<GetConfigurationVariateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigurationVariateResponse getConfigurationVariate(shared_ptr<GetConfigurationVariateRequest> request);
  GetDedicatedLineResponse getDedicatedLineWithOptions(shared_ptr<GetDedicatedLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDedicatedLineResponse getDedicatedLine(shared_ptr<GetDedicatedLineRequest> request);
  GetDeviceResponse getDeviceWithOptions(shared_ptr<GetDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceResponse getDevice(shared_ptr<GetDeviceRequest> request);
  GetDeviceConfigResponse getDeviceConfigWithOptions(shared_ptr<GetDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceConfigResponse getDeviceConfig(shared_ptr<GetDeviceConfigRequest> request);
  GetDeviceConfigDateResponse getDeviceConfigDateWithOptions(shared_ptr<GetDeviceConfigDateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceConfigDateResponse getDeviceConfigDate(shared_ptr<GetDeviceConfigDateRequest> request);
  GetDeviceConfigDiffResponse getDeviceConfigDiffWithOptions(shared_ptr<GetDeviceConfigDiffRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceConfigDiffResponse getDeviceConfigDiff(shared_ptr<GetDeviceConfigDiffRequest> request);
  GetDeviceFormResponse getDeviceFormWithOptions(shared_ptr<GetDeviceFormRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceFormResponse getDeviceForm(shared_ptr<GetDeviceFormRequest> request);
  GetDeviceOpLogResponse getDeviceOpLogWithOptions(shared_ptr<GetDeviceOpLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceOpLogResponse getDeviceOpLog(shared_ptr<GetDeviceOpLogRequest> request);
  GetDevicePropertyResponse getDevicePropertyWithOptions(shared_ptr<GetDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDevicePropertyResponse getDeviceProperty(shared_ptr<GetDevicePropertyRequest> request);
  GetDeviceResourceResponse getDeviceResourceWithOptions(shared_ptr<GetDeviceResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceResourceResponse getDeviceResource(shared_ptr<GetDeviceResourceRequest> request);
  GetInspectionTaskResponse getInspectionTaskWithOptions(shared_ptr<GetInspectionTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInspectionTaskResponse getInspectionTask(shared_ptr<GetInspectionTaskRequest> request);
  GetMonitorItemResponse getMonitorItemWithOptions(shared_ptr<GetMonitorItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMonitorItemResponse getMonitorItem(shared_ptr<GetMonitorItemRequest> request);
  GetOsDownloadPathResponse getOsDownloadPathWithOptions(shared_ptr<GetOsDownloadPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOsDownloadPathResponse getOsDownloadPath(shared_ptr<GetOsDownloadPathRequest> request);
  GetOsVersionResponse getOsVersionWithOptions(shared_ptr<GetOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOsVersionResponse getOsVersion(shared_ptr<GetOsVersionRequest> request);
  GetOssPolicyResponse getOssPolicyWithOptions(shared_ptr<GetOssPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOssPolicyResponse getOssPolicy(shared_ptr<GetOssPolicyRequest> request);
  GetPhysicalSpaceResponse getPhysicalSpaceWithOptions(shared_ptr<GetPhysicalSpaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalSpaceResponse getPhysicalSpace(shared_ptr<GetPhysicalSpaceRequest> request);
  GetPhysicalSpaceTopoResponse getPhysicalSpaceTopoWithOptions(shared_ptr<GetPhysicalSpaceTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalSpaceTopoResponse getPhysicalSpaceTopo(shared_ptr<GetPhysicalSpaceTopoRequest> request);
  GetRealtimeTaskResponse getRealtimeTaskWithOptions(shared_ptr<GetRealtimeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeTaskResponse getRealtimeTask(shared_ptr<GetRealtimeTaskRequest> request);
  GetScheduleWorkerResponse getScheduleWorkerWithOptions(shared_ptr<GetScheduleWorkerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScheduleWorkerResponse getScheduleWorker(shared_ptr<GetScheduleWorkerRequest> request);
  GetSetupProjectResponse getSetupProjectWithOptions(shared_ptr<GetSetupProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSetupProjectResponse getSetupProject(shared_ptr<GetSetupProjectRequest> request);
  GetSpaceModelResponse getSpaceModelWithOptions(shared_ptr<GetSpaceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpaceModelResponse getSpaceModel(shared_ptr<GetSpaceModelRequest> request);
  GetSpaceModelInstanceResponse getSpaceModelInstanceWithOptions(shared_ptr<GetSpaceModelInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpaceModelInstanceResponse getSpaceModelInstance(shared_ptr<GetSpaceModelInstanceRequest> request);
  GetSpaceModelSortResponse getSpaceModelSortWithOptions(shared_ptr<GetSpaceModelSortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpaceModelSortResponse getSpaceModelSort(shared_ptr<GetSpaceModelSortRequest> request);
  GetTaskResponse getTaskWithOptions(shared_ptr<GetTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskResponse getTask(shared_ptr<GetTaskRequest> request);
  ListAlarmStatusResponse listAlarmStatusWithOptions(shared_ptr<ListAlarmStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlarmStatusResponse listAlarmStatus(shared_ptr<ListAlarmStatusRequest> request);
  ListAlarmStatusHistoriesResponse listAlarmStatusHistoriesWithOptions(shared_ptr<ListAlarmStatusHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlarmStatusHistoriesResponse listAlarmStatusHistories(shared_ptr<ListAlarmStatusHistoriesRequest> request);
  ListAlarmStatusStatisticsResponse listAlarmStatusStatisticsWithOptions(shared_ptr<ListAlarmStatusStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlarmStatusStatisticsResponse listAlarmStatusStatistics(shared_ptr<ListAlarmStatusStatisticsRequest> request);
  ListArchitectureAttributeResponse listArchitectureAttributeWithOptions(shared_ptr<ListArchitectureAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListArchitectureAttributeResponse listArchitectureAttribute(shared_ptr<ListArchitectureAttributeRequest> request);
  ListConfigurationSpecificationsResponse listConfigurationSpecificationsWithOptions(shared_ptr<ListConfigurationSpecificationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigurationSpecificationsResponse listConfigurationSpecifications(shared_ptr<ListConfigurationSpecificationsRequest> request);
  ListConfigurationVariateResponse listConfigurationVariateWithOptions(shared_ptr<ListConfigurationVariateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigurationVariateResponse listConfigurationVariate(shared_ptr<ListConfigurationVariateRequest> request);
  ListConnectionPoliciesResponse listConnectionPoliciesWithOptions(shared_ptr<ListConnectionPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConnectionPoliciesResponse listConnectionPolicies(shared_ptr<ListConnectionPoliciesRequest> request);
  ListDedicatedLinesResponse listDedicatedLinesWithOptions(shared_ptr<ListDedicatedLinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDedicatedLinesResponse listDedicatedLines(shared_ptr<ListDedicatedLinesRequest> request);
  ListDeviceFormsResponse listDeviceFormsWithOptions(shared_ptr<ListDeviceFormsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceFormsResponse listDeviceForms(shared_ptr<ListDeviceFormsRequest> request);
  ListDevicePropertiesResponse listDevicePropertiesWithOptions(shared_ptr<ListDevicePropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDevicePropertiesResponse listDeviceProperties(shared_ptr<ListDevicePropertiesRequest> request);
  ListDeviceResourcesResponse listDeviceResourcesWithOptions(shared_ptr<ListDeviceResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceResourcesResponse listDeviceResources(shared_ptr<ListDeviceResourcesRequest> request);
  ListDeviceValuesResponse listDeviceValuesWithOptions(shared_ptr<ListDeviceValuesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceValuesResponse listDeviceValues(shared_ptr<ListDeviceValuesRequest> request);
  ListDevicesResponse listDevicesWithOptions(shared_ptr<ListDevicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDevicesResponse listDevices(shared_ptr<ListDevicesRequest> request);
  ListEventDefinitionsResponse listEventDefinitionsWithOptions(shared_ptr<ListEventDefinitionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventDefinitionsResponse listEventDefinitions(shared_ptr<ListEventDefinitionsRequest> request);
  ListEventsResponse listEventsWithOptions(shared_ptr<ListEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventsResponse listEvents(shared_ptr<ListEventsRequest> request);
  ListInspectionDevicesResponse listInspectionDevicesWithOptions(shared_ptr<ListInspectionDevicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInspectionDevicesResponse listInspectionDevices(shared_ptr<ListInspectionDevicesRequest> request);
  ListInspectionTaskReportsResponse listInspectionTaskReportsWithOptions(shared_ptr<ListInspectionTaskReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInspectionTaskReportsResponse listInspectionTaskReports(shared_ptr<ListInspectionTaskReportsRequest> request);
  ListInspectionTasksResponse listInspectionTasksWithOptions(shared_ptr<ListInspectionTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInspectionTasksResponse listInspectionTasks(shared_ptr<ListInspectionTasksRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances();
  ListIpBlocksResponse listIpBlocksWithOptions(shared_ptr<ListIpBlocksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIpBlocksResponse listIpBlocks(shared_ptr<ListIpBlocksRequest> request);
  ListLinksResponse listLinksWithOptions(shared_ptr<ListLinksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLinksResponse listLinks(shared_ptr<ListLinksRequest> request);
  ListLogsResponse listLogsWithOptions(shared_ptr<ListLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogsResponse listLogs(shared_ptr<ListLogsRequest> request);
  ListMonitorDataResponse listMonitorDataWithOptions(shared_ptr<ListMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMonitorDataResponse listMonitorData(shared_ptr<ListMonitorDataRequest> request);
  ListNotificationHistoriesResponse listNotificationHistoriesWithOptions(shared_ptr<ListNotificationHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotificationHistoriesResponse listNotificationHistories(shared_ptr<ListNotificationHistoriesRequest> request);
  ListNotificationHistoriesStatisticsResponse listNotificationHistoriesStatisticsWithOptions(shared_ptr<ListNotificationHistoriesStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotificationHistoriesStatisticsResponse listNotificationHistoriesStatistics(shared_ptr<ListNotificationHistoriesStatisticsRequest> request);
  ListOsVersionsResponse listOsVersionsWithOptions(shared_ptr<ListOsVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOsVersionsResponse listOsVersions(shared_ptr<ListOsVersionsRequest> request);
  ListPhysicalSpacesResponse listPhysicalSpacesWithOptions(shared_ptr<ListPhysicalSpacesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhysicalSpacesResponse listPhysicalSpaces(shared_ptr<ListPhysicalSpacesRequest> request);
  ListRegionsResponse listRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRegionsResponse listRegions();
  ListResourceInformationsResponse listResourceInformationsWithOptions(shared_ptr<ListResourceInformationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceInformationsResponse listResourceInformations(shared_ptr<ListResourceInformationsRequest> request);
  ListResourceInstancesResponse listResourceInstancesWithOptions(shared_ptr<ListResourceInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceInstancesResponse listResourceInstances(shared_ptr<ListResourceInstancesRequest> request);
  ListResourceTypesResponse listResourceTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceTypesResponse listResourceTypes();
  ListSetupProjectsResponse listSetupProjectsWithOptions(shared_ptr<ListSetupProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSetupProjectsResponse listSetupProjects(shared_ptr<ListSetupProjectsRequest> request);
  ListSpaceModelsResponse listSpaceModelsWithOptions(shared_ptr<ListSpaceModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSpaceModelsResponse listSpaceModels(shared_ptr<ListSpaceModelsRequest> request);
  ListTasksHistoriesResponse listTasksHistoriesWithOptions(shared_ptr<ListTasksHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTasksHistoriesResponse listTasksHistories(shared_ptr<ListTasksHistoriesRequest> request);
  ListTreePhysicalSpacesResponse listTreePhysicalSpacesWithOptions(shared_ptr<ListTreePhysicalSpacesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTreePhysicalSpacesResponse listTreePhysicalSpaces(shared_ptr<ListTreePhysicalSpacesRequest> request);
  LockSpaceModelResponse lockSpaceModelWithOptions(shared_ptr<LockSpaceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LockSpaceModelResponse lockSpaceModel(shared_ptr<LockSpaceModelRequest> request);
  ReleaseIPResponse releaseIPWithOptions(shared_ptr<ReleaseIPRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseIPResponse releaseIP(shared_ptr<ReleaseIPRequest> request);
  RetryTasksResponse retryTasksWithOptions(shared_ptr<RetryTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryTasksResponse retryTasks(shared_ptr<RetryTasksRequest> request);
  UpdateConfigurationSpecificationResponse updateConfigurationSpecificationWithOptions(shared_ptr<UpdateConfigurationSpecificationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigurationSpecificationResponse updateConfigurationSpecification(shared_ptr<UpdateConfigurationSpecificationRequest> request);
  UpdateConfigurationVariateResponse updateConfigurationVariateWithOptions(shared_ptr<UpdateConfigurationVariateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigurationVariateResponse updateConfigurationVariate(shared_ptr<UpdateConfigurationVariateRequest> request);
  UpdateDedicatedLineResponse updateDedicatedLineWithOptions(shared_ptr<UpdateDedicatedLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDedicatedLineResponse updateDedicatedLine(shared_ptr<UpdateDedicatedLineRequest> request);
  UpdateDeviceResponse updateDeviceWithOptions(shared_ptr<UpdateDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceResponse updateDevice(shared_ptr<UpdateDeviceRequest> request);
  UpdateDeviceFormResponse updateDeviceFormWithOptions(shared_ptr<UpdateDeviceFormRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceFormResponse updateDeviceForm(shared_ptr<UpdateDeviceFormRequest> request);
  UpdateDevicePropertyResponse updateDevicePropertyWithOptions(shared_ptr<UpdateDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDevicePropertyResponse updateDeviceProperty(shared_ptr<UpdateDevicePropertyRequest> request);
  UpdateDeviceResourceResponse updateDeviceResourceWithOptions(shared_ptr<UpdateDeviceResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceResourceResponse updateDeviceResource(shared_ptr<UpdateDeviceResourceRequest> request);
  UpdateDevicesResponse updateDevicesWithOptions(shared_ptr<UpdateDevicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDevicesResponse updateDevices(shared_ptr<UpdateDevicesRequest> request);
  UpdateEventDefinitionResponse updateEventDefinitionWithOptions(shared_ptr<UpdateEventDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEventDefinitionResponse updateEventDefinition(shared_ptr<UpdateEventDefinitionRequest> request);
  UpdateInformationKeyActionResponse updateInformationKeyActionWithOptions(shared_ptr<UpdateInformationKeyActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInformationKeyActionResponse updateInformationKeyAction(shared_ptr<UpdateInformationKeyActionRequest> request);
  UpdateInstanceResponse updateInstanceWithOptions(shared_ptr<UpdateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceResponse updateInstance(shared_ptr<UpdateInstanceRequest> request);
  UpdateOsVersionResponse updateOsVersionWithOptions(shared_ptr<UpdateOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsVersionResponse updateOsVersion(shared_ptr<UpdateOsVersionRequest> request);
  UpdatePhysicalSpaceResponse updatePhysicalSpaceWithOptions(shared_ptr<UpdatePhysicalSpaceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePhysicalSpaceResponse updatePhysicalSpace(shared_ptr<UpdatePhysicalSpaceRequest> request);
  UpdateProjectProgressResponse updateProjectProgressWithOptions(shared_ptr<UpdateProjectProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectProgressResponse updateProjectProgress(shared_ptr<UpdateProjectProgressRequest> request);
  UpdateResourceInformationResponse updateResourceInformationWithOptions(shared_ptr<UpdateResourceInformationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceInformationResponse updateResourceInformation(shared_ptr<UpdateResourceInformationRequest> request);
  UpdateResourceInstanceResponse updateResourceInstanceWithOptions(shared_ptr<UpdateResourceInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceInstanceResponse updateResourceInstance(shared_ptr<UpdateResourceInstanceRequest> request);
  UpdateSetupProjectResponse updateSetupProjectWithOptions(shared_ptr<UpdateSetupProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSetupProjectResponse updateSetupProject(shared_ptr<UpdateSetupProjectRequest> request);
  UpdateSpaceModelResponse updateSpaceModelWithOptions(shared_ptr<UpdateSpaceModelRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSpaceModelResponse updateSpaceModel(shared_ptr<UpdateSpaceModelRequest> request);
  UpdateSpaceModelInstanceResponse updateSpaceModelInstanceWithOptions(shared_ptr<UpdateSpaceModelInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSpaceModelInstanceResponse updateSpaceModelInstance(shared_ptr<UpdateSpaceModelInstanceRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Cmn20200825

#endif
