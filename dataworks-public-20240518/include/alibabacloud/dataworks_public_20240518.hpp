// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DATAWORKS-PUBLIC20240518_H_
#define ALIBABACLOUD_DATAWORKS-PUBLIC20240518_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dataworks-public20240518 {
class DataQualityEvaluationTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskHooks() {}

  explicit DataQualityEvaluationTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskHooks() = default;
};
class DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() {}

  explicit DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() = default;
};
class DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() {}

  explicit DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() = default;
};
class DataQualityEvaluationTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  DataQualityEvaluationTaskNotificationsNotifications() {}

  explicit DataQualityEvaluationTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotifications() = default;
};
class DataQualityEvaluationTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotifications>> notifications{};

  DataQualityEvaluationTaskNotifications() {}

  explicit DataQualityEvaluationTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskNotifications() = default;
};
class DataQualityEvaluationTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskTarget() {}

  explicit DataQualityEvaluationTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskTarget() = default;
};
class DataQualityEvaluationTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskTrigger() {}

  explicit DataQualityEvaluationTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskTrigger() = default;
};
class DataQualityEvaluationTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<DataQualityEvaluationTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DataQualityEvaluationTaskNotifications>> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<DataQualityEvaluationTaskTarget> target{};
  shared_ptr<long> tenantId{};
  shared_ptr<DataQualityEvaluationTaskTrigger> trigger{};

  DataQualityEvaluationTask() {}

  explicit DataQualityEvaluationTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<DataQualityEvaluationTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<DataQualityEvaluationTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskNotifications>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityEvaluationTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityEvaluationTaskTarget>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DataQualityEvaluationTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DataQualityEvaluationTaskTrigger>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTask() = default;
};
class DataQualityEvaluationTaskInstanceTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskHooks() {}

  explicit DataQualityEvaluationTaskInstanceTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskHooks() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotifications() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotifications() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications>> notifications{};

  DataQualityEvaluationTaskInstanceTaskNotifications() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotifications() = default;
};
class DataQualityEvaluationTaskInstanceTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskTarget() {}

  explicit DataQualityEvaluationTaskInstanceTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskTarget() = default;
};
class DataQualityEvaluationTaskInstanceTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskTrigger() {}

  explicit DataQualityEvaluationTaskInstanceTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskTrigger() = default;
};
class DataQualityEvaluationTaskInstanceTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotifications>> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<DataQualityEvaluationTaskInstanceTaskTarget> target{};
  shared_ptr<long> tenantId{};
  shared_ptr<DataQualityEvaluationTaskInstanceTaskTrigger> trigger{};

  DataQualityEvaluationTaskInstanceTask() {}

  explicit DataQualityEvaluationTaskInstanceTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<DataQualityEvaluationTaskInstanceTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotifications>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityEvaluationTaskInstanceTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityEvaluationTaskInstanceTaskTarget>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DataQualityEvaluationTaskInstanceTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DataQualityEvaluationTaskInstanceTaskTrigger>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTask() = default;
};
class DataQualityEvaluationTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> status{};
  shared_ptr<DataQualityEvaluationTaskInstanceTask> task{};

  DataQualityEvaluationTaskInstance() {}

  explicit DataQualityEvaluationTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        DataQualityEvaluationTaskInstanceTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<DataQualityEvaluationTaskInstanceTask>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstance() = default;
};
class DataQualityResultDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkedValue{};
  shared_ptr<string> referencedValue{};
  shared_ptr<string> status{};

  DataQualityResultDetails() {}

  explicit DataQualityResultDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkedValue) {
      res["CheckedValue"] = boost::any(*checkedValue);
    }
    if (referencedValue) {
      res["ReferencedValue"] = boost::any(*referencedValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckedValue") != m.end() && !m["CheckedValue"].empty()) {
      checkedValue = make_shared<string>(boost::any_cast<string>(m["CheckedValue"]));
    }
    if (m.find("ReferencedValue") != m.end() && !m["ReferencedValue"].empty()) {
      referencedValue = make_shared<string>(boost::any_cast<string>(m["ReferencedValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DataQualityResultDetails() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsCritical() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsCritical() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsExpected() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsExpected() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsWarned() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsWarned() = default;
};
class DataQualityResultRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsWarned> warned{};

  DataQualityResultRuleCheckingConfigThresholds() {}

  explicit DataQualityResultRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DataQualityResultRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<DataQualityResultRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<DataQualityResultRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholds() = default;
};
class DataQualityResultRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  DataQualityResultRuleCheckingConfig() {}

  explicit DataQualityResultRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        DataQualityResultRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<DataQualityResultRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfig() = default;
};
class DataQualityResultRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  DataQualityResultRuleErrorHandlers() {}

  explicit DataQualityResultRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleErrorHandlers() = default;
};
class DataQualityResultRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  DataQualityResultRuleSamplingConfig() {}

  explicit DataQualityResultRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityResultRuleSamplingConfig() = default;
};
class DataQualityResultRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityResultRuleTarget() {}

  explicit DataQualityResultRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleTarget() = default;
};
class DataQualityResultRule : public Darabonba::Model {
public:
  shared_ptr<DataQualityResultRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<DataQualityResultRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityResultRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<DataQualityResultRuleTarget> target{};
  shared_ptr<string> templateCode{};
  shared_ptr<long> tenantId{};

  DataQualityResultRule() {}

  explicit DataQualityResultRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityResultRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityResultRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<DataQualityResultRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityResultRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<DataQualityResultRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityResultRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityResultRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityResultRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityResultRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~DataQualityResultRule() = default;
};
class DataQualityResult : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityResultDetails>> details{};
  shared_ptr<long> id{};
  shared_ptr<DataQualityResultRule> rule{};
  shared_ptr<string> sample{};
  shared_ptr<string> status{};
  shared_ptr<long> taskInstanceId{};

  DataQualityResult() {}

  explicit DataQualityResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DataQualityResultDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityResultDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DataQualityResultDetails>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        DataQualityResultRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<DataQualityResultRule>(model1);
      }
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~DataQualityResult() = default;
};
class DataQualityRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsCritical() {}

  explicit DataQualityRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsCritical() = default;
};
class DataQualityRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsExpected() {}

  explicit DataQualityRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsExpected() = default;
};
class DataQualityRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsWarned() {}

  explicit DataQualityRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsWarned() = default;
};
class DataQualityRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<DataQualityRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<DataQualityRuleCheckingConfigThresholdsWarned> warned{};

  DataQualityRuleCheckingConfigThresholds() {}

  explicit DataQualityRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DataQualityRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DataQualityRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        DataQualityRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<DataQualityRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        DataQualityRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<DataQualityRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholds() = default;
};
class DataQualityRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<DataQualityRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  DataQualityRuleCheckingConfig() {}

  explicit DataQualityRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        DataQualityRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<DataQualityRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfig() = default;
};
class DataQualityRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  DataQualityRuleErrorHandlers() {}

  explicit DataQualityRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleErrorHandlers() = default;
};
class DataQualityRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  DataQualityRuleSamplingConfig() {}

  explicit DataQualityRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityRuleSamplingConfig() = default;
};
class DataQualityRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityRuleTarget() {}

  explicit DataQualityRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleTarget() = default;
};
class DataQualityRule : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<DataQualityRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<DataQualityRuleTarget> target{};
  shared_ptr<string> templateCode{};
  shared_ptr<long> tenantId{};

  DataQualityRule() {}

  explicit DataQualityRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<DataQualityRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<DataQualityRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~DataQualityRule() = default;
};
class DataQualityRuleTemplateCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  DataQualityRuleTemplateCheckingConfig() {}

  explicit DataQualityRuleTemplateCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleTemplateCheckingConfig() = default;
};
class DataQualityRuleTemplateSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  DataQualityRuleTemplateSamplingConfig() {}

  explicit DataQualityRuleTemplateSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityRuleTemplateSamplingConfig() = default;
};
class DataQualityRuleTemplate : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleTemplateCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityRuleTemplateSamplingConfig> samplingConfig{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> visibleScope{};

  DataQualityRuleTemplate() {}

  explicit DataQualityRuleTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityRuleTemplateCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityRuleTemplateCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityRuleTemplateSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityRuleTemplateSamplingConfig>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~DataQualityRuleTemplate() = default;
};
class SuccessInfoValue : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  SuccessInfoValue() {}

  explicit SuccessInfoValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SuccessInfoValue() = default;
};
class AbolishDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  AbolishDeploymentRequest() {}

  explicit AbolishDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AbolishDeploymentRequest() = default;
};
class AbolishDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AbolishDeploymentResponseBody() {}

  explicit AbolishDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AbolishDeploymentResponseBody() = default;
};
class AbolishDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbolishDeploymentResponseBody> body{};

  AbolishDeploymentResponse() {}

  explicit AbolishDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishDeploymentResponse() = default;
};
class AssociateProjectToResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupId{};

  AssociateProjectToResourceGroupRequest() {}

  explicit AssociateProjectToResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AssociateProjectToResourceGroupRequest() = default;
};
class AssociateProjectToResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AssociateProjectToResourceGroupResponseBody() {}

  explicit AssociateProjectToResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AssociateProjectToResourceGroupResponseBody() = default;
};
class AssociateProjectToResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateProjectToResourceGroupResponseBody> body{};

  AssociateProjectToResourceGroupResponse() {}

  explicit AssociateProjectToResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateProjectToResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateProjectToResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateProjectToResourceGroupResponse() = default;
};
class AttachDataQualityRulesToEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<vector<long>> dataQualityRuleIds{};
  shared_ptr<long> projectId{};

  AttachDataQualityRulesToEvaluationTaskRequest() {}

  explicit AttachDataQualityRulesToEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIds) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DataQualityRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataQualityRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dataQualityRuleIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskRequest() = default;
};
class AttachDataQualityRulesToEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> dataQualityRuleIdsShrink{};
  shared_ptr<long> projectId{};

  AttachDataQualityRulesToEvaluationTaskShrinkRequest() {}

  explicit AttachDataQualityRulesToEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIdsShrink) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      dataQualityRuleIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRuleIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskShrinkRequest() = default;
};
class AttachDataQualityRulesToEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AttachDataQualityRulesToEvaluationTaskResponseBody() {}

  explicit AttachDataQualityRulesToEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskResponseBody() = default;
};
class AttachDataQualityRulesToEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDataQualityRulesToEvaluationTaskResponseBody> body{};

  AttachDataQualityRulesToEvaluationTaskResponse() {}

  explicit AttachDataQualityRulesToEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDataQualityRulesToEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDataQualityRulesToEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskResponse() = default;
};
class BatchUpdateTasksRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  BatchUpdateTasksRequestTasksDataSource() {}

  explicit BatchUpdateTasksRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksDataSource() = default;
};
class BatchUpdateTasksRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  BatchUpdateTasksRequestTasksRuntimeResource() {}

  explicit BatchUpdateTasksRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksRuntimeResource() = default;
};
class BatchUpdateTasksRequestTasksTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  BatchUpdateTasksRequestTasksTags() {}

  explicit BatchUpdateTasksRequestTasksTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksTags() = default;
};
class BatchUpdateTasksRequestTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  BatchUpdateTasksRequestTasksTrigger() {}

  explicit BatchUpdateTasksRequestTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksTrigger() = default;
};
class BatchUpdateTasksRequestTasks : public Darabonba::Model {
public:
  shared_ptr<BatchUpdateTasksRequestTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<BatchUpdateTasksRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<vector<BatchUpdateTasksRequestTasksTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<BatchUpdateTasksRequestTasksTrigger> trigger{};

  BatchUpdateTasksRequestTasks() {}

  explicit BatchUpdateTasksRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        BatchUpdateTasksRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<BatchUpdateTasksRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        BatchUpdateTasksRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<BatchUpdateTasksRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<BatchUpdateTasksRequestTasksTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateTasksRequestTasksTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<BatchUpdateTasksRequestTasksTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        BatchUpdateTasksRequestTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<BatchUpdateTasksRequestTasksTrigger>(model1);
      }
    }
  }


  virtual ~BatchUpdateTasksRequestTasks() = default;
};
class BatchUpdateTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<BatchUpdateTasksRequestTasks>> tasks{};

  BatchUpdateTasksRequest() {}

  explicit BatchUpdateTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<BatchUpdateTasksRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateTasksRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<BatchUpdateTasksRequestTasks>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateTasksRequest() = default;
};
class BatchUpdateTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> tasksShrink{};

  BatchUpdateTasksShrinkRequest() {}

  explicit BatchUpdateTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
  }


  virtual ~BatchUpdateTasksShrinkRequest() = default;
};
class BatchUpdateTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  BatchUpdateTasksResponseBody() {}

  explicit BatchUpdateTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateTasksResponseBody() = default;
};
class BatchUpdateTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateTasksResponseBody> body{};

  BatchUpdateTasksResponse() {}

  explicit BatchUpdateTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateTasksResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateTasksResponse() = default;
};
class CloneDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> cloneDataSourceName{};
  shared_ptr<long> id{};

  CloneDataSourceRequest() {}

  explicit CloneDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloneDataSourceName) {
      res["CloneDataSourceName"] = boost::any(*cloneDataSourceName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloneDataSourceName") != m.end() && !m["CloneDataSourceName"].empty()) {
      cloneDataSourceName = make_shared<string>(boost::any_cast<string>(m["CloneDataSourceName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CloneDataSourceRequest() = default;
};
class CloneDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CloneDataSourceResponseBody() {}

  explicit CloneDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneDataSourceResponseBody() = default;
};
class CloneDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneDataSourceResponseBody> body{};

  CloneDataSourceResponse() {}

  explicit CloneDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CloneDataSourceResponse() = default;
};
class CreateAlertRuleRequestNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateAlertRuleRequestNotificationReceivers() {}

  explicit CreateAlertRuleRequestNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAlertRuleRequestNotificationReceivers() = default;
};
class CreateAlertRuleRequestNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<CreateAlertRuleRequestNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  CreateAlertRuleRequestNotification() {}

  explicit CreateAlertRuleRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<CreateAlertRuleRequestNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlertRuleRequestNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<CreateAlertRuleRequestNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~CreateAlertRuleRequestNotification() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  CreateAlertRuleRequestTriggerConditionExtensionError() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionError() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  CreateAlertRuleRequestTriggerConditionExtensionTimeout() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionTimeout() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  CreateAlertRuleRequestTriggerConditionExtensionUnFinished() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionUnFinished() = default;
};
class CreateAlertRuleRequestTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionError> error{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionUnFinished> unFinished{};

  CreateAlertRuleRequestTriggerConditionExtension() {}

  explicit CreateAlertRuleRequestTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<CreateAlertRuleRequestTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<CreateAlertRuleRequestTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<CreateAlertRuleRequestTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtension() = default;
};
class CreateAlertRuleRequestTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  CreateAlertRuleRequestTriggerConditionTarget() {}

  explicit CreateAlertRuleRequestTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionTarget() = default;
};
class CreateAlertRuleRequestTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtension> extension{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  CreateAlertRuleRequestTriggerCondition() {}

  explicit CreateAlertRuleRequestTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        CreateAlertRuleRequestTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<CreateAlertRuleRequestTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateAlertRuleRequestTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateAlertRuleRequestTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerCondition() = default;
};
class CreateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> name{};
  shared_ptr<CreateAlertRuleRequestNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<CreateAlertRuleRequestTriggerCondition> triggerCondition{};

  CreateAlertRuleRequest() {}

  explicit CreateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        CreateAlertRuleRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<CreateAlertRuleRequestNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        CreateAlertRuleRequestTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<CreateAlertRuleRequestTriggerCondition>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleRequest() = default;
};
class CreateAlertRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> triggerConditionShrink{};

  CreateAlertRuleShrinkRequest() {}

  explicit CreateAlertRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerConditionShrink) {
      res["TriggerCondition"] = boost::any(*triggerConditionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      triggerConditionShrink = make_shared<string>(boost::any_cast<string>(m["TriggerCondition"]));
    }
  }


  virtual ~CreateAlertRuleShrinkRequest() = default;
};
class CreateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateAlertRuleResponseBody() {}

  explicit CreateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertRuleResponseBody() = default;
};
class CreateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertRuleResponseBody> body{};

  CreateAlertRuleResponse() {}

  explicit CreateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleResponse() = default;
};
class CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels() {}

  explicit CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels() = default;
};
class CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() {}

  explicit CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() = default;
};
class CreateDIAlarmRuleRequestNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>> notificationReceivers{};

  CreateDIAlarmRuleRequestNotificationSettings() {}

  explicit CreateDIAlarmRuleRequestNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettings() = default;
};
class CreateDIAlarmRuleRequestTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  CreateDIAlarmRuleRequestTriggerConditions() {}

  explicit CreateDIAlarmRuleRequestTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~CreateDIAlarmRuleRequestTriggerConditions() = default;
};
class CreateDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<CreateDIAlarmRuleRequestNotificationSettings> notificationSettings{};
  shared_ptr<vector<CreateDIAlarmRuleRequestTriggerConditions>> triggerConditions{};

  CreateDIAlarmRuleRequest() {}

  explicit CreateDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        CreateDIAlarmRuleRequestNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<CreateDIAlarmRuleRequestNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<CreateDIAlarmRuleRequestTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<CreateDIAlarmRuleRequestTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleRequest() = default;
};
class CreateDIAlarmRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationSettingsShrink{};
  shared_ptr<string> triggerConditionsShrink{};

  CreateDIAlarmRuleShrinkRequest() {}

  explicit CreateDIAlarmRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettingsShrink) {
      res["NotificationSettings"] = boost::any(*notificationSettingsShrink);
    }
    if (triggerConditionsShrink) {
      res["TriggerConditions"] = boost::any(*triggerConditionsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      notificationSettingsShrink = make_shared<string>(boost::any_cast<string>(m["NotificationSettings"]));
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      triggerConditionsShrink = make_shared<string>(boost::any_cast<string>(m["TriggerConditions"]));
    }
  }


  virtual ~CreateDIAlarmRuleShrinkRequest() = default;
};
class CreateDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DIAlarmRuleId{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDIAlarmRuleResponseBody() {}

  explicit CreateDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<string>(boost::any_cast<string>(m["DIAlarmRuleId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDIAlarmRuleResponseBody() = default;
};
class CreateDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDIAlarmRuleResponseBody> body{};

  CreateDIAlarmRuleResponse() {}

  explicit CreateDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleResponse() = default;
};
class CreateDIJobRequestDestinationDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};

  CreateDIJobRequestDestinationDataSourceSettings() {}

  explicit CreateDIJobRequestDestinationDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
  }


  virtual ~CreateDIJobRequestDestinationDataSourceSettings() = default;
};
class CreateDIJobRequestJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  CreateDIJobRequestJobSettingsColumnDataTypeSettings() {}

  explicit CreateDIJobRequestJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsColumnDataTypeSettings() = default;
};
class CreateDIJobRequestJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> cycleMigrationType{};
  shared_ptr<string> scheduleParameters{};

  CreateDIJobRequestJobSettingsCycleScheduleSettings() {}

  explicit CreateDIJobRequestJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleMigrationType) {
      res["CycleMigrationType"] = boost::any(*cycleMigrationType);
    }
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleMigrationType") != m.end() && !m["CycleMigrationType"].empty()) {
      cycleMigrationType = make_shared<string>(boost::any_cast<string>(m["CycleMigrationType"]));
    }
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsCycleScheduleSettings() = default;
};
class CreateDIJobRequestJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  CreateDIJobRequestJobSettingsDdlHandlingSettings() {}

  explicit CreateDIJobRequestJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsDdlHandlingSettings() = default;
};
class CreateDIJobRequestJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateDIJobRequestJobSettingsRuntimeSettings() {}

  explicit CreateDIJobRequestJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsRuntimeSettings() = default;
};
class CreateDIJobRequestJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<CreateDIJobRequestJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsRuntimeSettings>> runtimeSettings{};

  CreateDIJobRequestJobSettings() {}

  explicit CreateDIJobRequestJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        CreateDIJobRequestJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<CreateDIJobRequestJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<CreateDIJobRequestJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<CreateDIJobRequestJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequestJobSettings() = default;
};
class CreateDIJobRequestResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsOfflineResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsOfflineResourceSettings() = default;
};
class CreateDIJobRequestResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsRealtimeResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsRealtimeResourceSettings() = default;
};
class CreateDIJobRequestResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsScheduleResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsScheduleResourceSettings() = default;
};
class CreateDIJobRequestResourceSettings : public Darabonba::Model {
public:
  shared_ptr<CreateDIJobRequestResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<CreateDIJobRequestResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<CreateDIJobRequestResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  CreateDIJobRequestResourceSettings() {}

  explicit CreateDIJobRequestResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<CreateDIJobRequestResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<CreateDIJobRequestResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<CreateDIJobRequestResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~CreateDIJobRequestResourceSettings() = default;
};
class CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties : public Darabonba::Model {
public:
  shared_ptr<string> encoding{};
  shared_ptr<string> timezone{};

  CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties() {}

  explicit CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
  }


  virtual ~CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties() = default;
};
class CreateDIJobRequestSourceDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};
  shared_ptr<CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties> dataSourceProperties{};

  CreateDIJobRequestSourceDataSourceSettings() {}

  explicit CreateDIJobRequestSourceDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (dataSourceProperties) {
      res["DataSourceProperties"] = dataSourceProperties ? boost::any(dataSourceProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("DataSourceProperties") != m.end() && !m["DataSourceProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceProperties"].type()) {
        CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceProperties"]));
        dataSourceProperties = make_shared<CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties>(model1);
      }
    }
  }


  virtual ~CreateDIJobRequestSourceDataSourceSettings() = default;
};
class CreateDIJobRequestTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  CreateDIJobRequestTableMappingsSourceObjectSelectionRules() {}

  explicit CreateDIJobRequestTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~CreateDIJobRequestTableMappingsSourceObjectSelectionRules() = default;
};
class CreateDIJobRequestTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  CreateDIJobRequestTableMappingsTransformationRules() {}

  explicit CreateDIJobRequestTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~CreateDIJobRequestTableMappingsTransformationRules() = default;
};
class CreateDIJobRequestTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<CreateDIJobRequestTableMappingsTransformationRules>> transformationRules{};

  CreateDIJobRequestTableMappings() {}

  explicit CreateDIJobRequestTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<CreateDIJobRequestTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<CreateDIJobRequestTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequestTableMappings() = default;
};
class CreateDIJobRequestTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  CreateDIJobRequestTransformationRules() {}

  explicit CreateDIJobRequestTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~CreateDIJobRequestTransformationRules() = default;
};
class CreateDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<CreateDIJobRequestDestinationDataSourceSettings>> destinationDataSourceSettings{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> jobName{};
  shared_ptr<CreateDIJobRequestJobSettings> jobSettings{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDIJobRequestResourceSettings> resourceSettings{};
  shared_ptr<vector<CreateDIJobRequestSourceDataSourceSettings>> sourceDataSourceSettings{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<vector<CreateDIJobRequestTableMappings>> tableMappings{};
  shared_ptr<vector<CreateDIJobRequestTransformationRules>> transformationRules{};

  CreateDIJobRequest() {}

  explicit CreateDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*destinationDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationDataSourceSettings"] = boost::any(temp1);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDataSourceSettings"] = boost::any(temp1);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationDataSourceSettings"].type()) {
        vector<CreateDIJobRequestDestinationDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestDestinationDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationDataSourceSettings = make_shared<vector<CreateDIJobRequestDestinationDataSourceSettings>>(expect1);
      }
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        CreateDIJobRequestJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<CreateDIJobRequestJobSettings>(model1);
      }
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        CreateDIJobRequestResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<CreateDIJobRequestResourceSettings>(model1);
      }
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDataSourceSettings"].type()) {
        vector<CreateDIJobRequestSourceDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestSourceDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDataSourceSettings = make_shared<vector<CreateDIJobRequestSourceDataSourceSettings>>(expect1);
      }
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<CreateDIJobRequestTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<CreateDIJobRequestTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<CreateDIJobRequestTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<CreateDIJobRequestTransformationRules>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequest() = default;
};
class CreateDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationDataSourceSettingsShrink{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobSettingsShrink{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceSettingsShrink{};
  shared_ptr<string> sourceDataSourceSettingsShrink{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<string> tableMappingsShrink{};
  shared_ptr<string> transformationRulesShrink{};

  CreateDIJobShrinkRequest() {}

  explicit CreateDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettingsShrink) {
      res["DestinationDataSourceSettings"] = boost::any(*destinationDataSourceSettingsShrink);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettingsShrink) {
      res["JobSettings"] = boost::any(*jobSettingsShrink);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettingsShrink) {
      res["ResourceSettings"] = boost::any(*resourceSettingsShrink);
    }
    if (sourceDataSourceSettingsShrink) {
      res["SourceDataSourceSettings"] = boost::any(*sourceDataSourceSettingsShrink);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappingsShrink) {
      res["TableMappings"] = boost::any(*tableMappingsShrink);
    }
    if (transformationRulesShrink) {
      res["TransformationRules"] = boost::any(*transformationRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      destinationDataSourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceSettings"]));
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      jobSettingsShrink = make_shared<string>(boost::any_cast<string>(m["JobSettings"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      resourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["ResourceSettings"]));
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      sourceDataSourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceSettings"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      tableMappingsShrink = make_shared<string>(boost::any_cast<string>(m["TableMappings"]));
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      transformationRulesShrink = make_shared<string>(boost::any_cast<string>(m["TransformationRules"]));
    }
  }


  virtual ~CreateDIJobShrinkRequest() = default;
};
class CreateDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDIJobResponseBody() {}

  explicit CreateDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDIJobResponseBody() = default;
};
class CreateDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDIJobResponseBody> body{};

  CreateDIJobResponse() {}

  explicit CreateDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDIJobResponse() = default;
};
class CreateDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<string> valueType{};
  shared_ptr<vector<string>> values{};

  CreateDataAssetTagRequest() {}

  explicit CreateDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataAssetTagRequest() = default;
};
class CreateDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> valueType{};
  shared_ptr<string> valuesShrink{};

  CreateDataAssetTagShrinkRequest() {}

  explicit CreateDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~CreateDataAssetTagShrinkRequest() = default;
};
class CreateDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataAssetTagResponseBody() {}

  explicit CreateDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataAssetTagResponseBody() = default;
};
class CreateDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataAssetTagResponseBody> body{};

  CreateDataAssetTagResponse() {}

  explicit CreateDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataAssetTagResponse() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  CreateDataQualityEvaluationTaskRequestDataQualityRules() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRules() = default;
};
class CreateDataQualityEvaluationTaskRequestHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestHooks() {}

  explicit CreateDataQualityEvaluationTaskRequestHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestHooks() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotifications() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotifications() = default;
};
class CreateDataQualityEvaluationTaskRequestNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications>> notifications{};

  CreateDataQualityEvaluationTaskRequestNotifications() {}

  explicit CreateDataQualityEvaluationTaskRequestNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotifications() = default;
};
class CreateDataQualityEvaluationTaskRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};

  CreateDataQualityEvaluationTaskRequestTarget() {}

  explicit CreateDataQualityEvaluationTaskRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestTarget() = default;
};
class CreateDataQualityEvaluationTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestTrigger() {}

  explicit CreateDataQualityEvaluationTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestTrigger() = default;
};
class CreateDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestDataQualityRules>> dataQualityRules{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestHooks>> hooks{};
  shared_ptr<string> name{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestTarget> target{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestTrigger> trigger{};

  CreateDataQualityEvaluationTaskRequest() {}

  explicit CreateDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<CreateDataQualityEvaluationTaskRequestDataQualityRules>>(expect1);
      }
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<CreateDataQualityEvaluationTaskRequestHooks>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        CreateDataQualityEvaluationTaskRequestNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<CreateDataQualityEvaluationTaskRequestNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateDataQualityEvaluationTaskRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateDataQualityEvaluationTaskRequestTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        CreateDataQualityEvaluationTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<CreateDataQualityEvaluationTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequest() = default;
};
class CreateDataQualityEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataQualityRulesShrink{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> hooksShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> triggerShrink{};

  CreateDataQualityEvaluationTaskShrinkRequest() {}

  explicit CreateDataQualityEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRulesShrink) {
      res["DataQualityRules"] = boost::any(*dataQualityRulesShrink);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooksShrink) {
      res["Hooks"] = boost::any(*hooksShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationsShrink) {
      res["Notifications"] = boost::any(*notificationsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      dataQualityRulesShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRules"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooksShrink = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      notificationsShrink = make_shared<string>(boost::any_cast<string>(m["Notifications"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskShrinkRequest() = default;
};
class CreateDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityEvaluationTaskResponseBody() {}

  explicit CreateDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskResponseBody() = default;
};
class CreateDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityEvaluationTaskResponseBody> body{};

  CreateDataQualityEvaluationTaskResponse() {}

  explicit CreateDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskResponse() = default;
};
class CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<double> cu{};
  shared_ptr<string> resourceGroupId{};

  CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource() {}

  explicit CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<double>(boost::any_cast<double>(m["Cu"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource() = default;
};
class CreateDataQualityEvaluationTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource> runtimeResource{};

  CreateDataQualityEvaluationTaskInstanceRequest() {}

  explicit CreateDataQualityEvaluationTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceRequest() = default;
};
class CreateDataQualityEvaluationTaskInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResourceShrink{};

  CreateDataQualityEvaluationTaskInstanceShrinkRequest() {}

  explicit CreateDataQualityEvaluationTaskInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResourceShrink) {
      res["RuntimeResource"] = boost::any(*runtimeResourceShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResourceShrink = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceShrinkRequest() = default;
};
class CreateDataQualityEvaluationTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityEvaluationTaskInstanceResponseBody() {}

  explicit CreateDataQualityEvaluationTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceResponseBody() = default;
};
class CreateDataQualityEvaluationTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityEvaluationTaskInstanceResponseBody> body{};

  CreateDataQualityEvaluationTaskInstanceResponse() {}

  explicit CreateDataQualityEvaluationTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityEvaluationTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityEvaluationTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceResponse() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsCritical() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsCritical() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsExpected() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsExpected() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsWarned() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsWarned() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsCritical> critical{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsExpected> expected{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsWarned> warned{};

  CreateDataQualityRuleRequestCheckingConfigThresholds() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholds() = default;
};
class CreateDataQualityRuleRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestCheckingConfig() {}

  explicit CreateDataQualityRuleRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfig() = default;
};
class CreateDataQualityRuleRequestErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestErrorHandlers() {}

  explicit CreateDataQualityRuleRequestErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestErrorHandlers() = default;
};
class CreateDataQualityRuleRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityRuleRequestSamplingConfig() {}

  explicit CreateDataQualityRuleRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestSamplingConfig() = default;
};
class CreateDataQualityRuleRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestTarget() {}

  explicit CreateDataQualityRuleRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestTarget() = default;
};
class CreateDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<CreateDataQualityRuleRequestErrorHandlers>> errorHandlers{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityRuleRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<CreateDataQualityRuleRequestTarget> target{};
  shared_ptr<string> templateCode{};

  CreateDataQualityRuleRequest() {}

  explicit CreateDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityRuleRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityRuleRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<CreateDataQualityRuleRequestErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityRuleRequestErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<CreateDataQualityRuleRequestErrorHandlers>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityRuleRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityRuleRequestSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateDataQualityRuleRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateDataQualityRuleRequestTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityRuleRequest() = default;
};
class CreateDataQualityRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> errorHandlersShrink{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> severity{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> templateCode{};

  CreateDataQualityRuleShrinkRequest() {}

  explicit CreateDataQualityRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlersShrink) {
      res["ErrorHandlers"] = boost::any(*errorHandlersShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      errorHandlersShrink = make_shared<string>(boost::any_cast<string>(m["ErrorHandlers"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityRuleShrinkRequest() = default;
};
class CreateDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityRuleResponseBody() {}

  explicit CreateDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityRuleResponseBody() = default;
};
class CreateDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityRuleResponseBody> body{};

  CreateDataQualityRuleResponse() {}

  explicit CreateDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleResponse() = default;
};
class CreateDataQualityRuleTemplateRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  CreateDataQualityRuleTemplateRequestCheckingConfig() {}

  explicit CreateDataQualityRuleTemplateRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequestCheckingConfig() = default;
};
class CreateDataQualityRuleTemplateRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityRuleTemplateRequestSamplingConfig() {}

  explicit CreateDataQualityRuleTemplateRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequestSamplingConfig() = default;
};
class CreateDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleTemplateRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityRuleTemplateRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  CreateDataQualityRuleTemplateRequest() {}

  explicit CreateDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityRuleTemplateRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityRuleTemplateRequestCheckingConfig>(model1);
      }
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityRuleTemplateRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityRuleTemplateRequestSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequest() = default;
};
class CreateDataQualityRuleTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> visibleScope{};

  CreateDataQualityRuleTemplateShrinkRequest() {}

  explicit CreateDataQualityRuleTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateShrinkRequest() = default;
};
class CreateDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  CreateDataQualityRuleTemplateResponseBody() {}

  explicit CreateDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateResponseBody() = default;
};
class CreateDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityRuleTemplateResponseBody> body{};

  CreateDataQualityRuleTemplateResponse() {}

  explicit CreateDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleTemplateResponse() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<string>(boost::any_cast<string>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataSourceResponseBody() {}

  explicit CreateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataSourceResponseBody() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceResponseBody> body{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class CreateDataSourceSharedRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> envType{};
  shared_ptr<string> sharedUser{};
  shared_ptr<long> targetProjectId{};

  CreateDataSourceSharedRuleRequest() {}

  explicit CreateDataSourceSharedRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (sharedUser) {
      res["SharedUser"] = boost::any(*sharedUser);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("SharedUser") != m.end() && !m["SharedUser"].empty()) {
      sharedUser = make_shared<string>(boost::any_cast<string>(m["SharedUser"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~CreateDataSourceSharedRuleRequest() = default;
};
class CreateDataSourceSharedRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataSourceSharedRuleResponseBody() {}

  explicit CreateDataSourceSharedRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataSourceSharedRuleResponseBody() = default;
};
class CreateDataSourceSharedRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceSharedRuleResponseBody> body{};

  CreateDataSourceSharedRuleResponse() {}

  explicit CreateDataSourceSharedRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceSharedRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceSharedRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceSharedRuleResponse() = default;
};
class CreateDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<string>> objectIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreateDeploymentRequest() {}

  explicit CreateDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectIds) {
      res["ObjectIds"] = boost::any(*objectIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ObjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ObjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDeploymentRequest() = default;
};
class CreateDeploymentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> objectIdsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreateDeploymentShrinkRequest() {}

  explicit CreateDeploymentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectIdsShrink) {
      res["ObjectIds"] = boost::any(*objectIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      objectIdsShrink = make_shared<string>(boost::any_cast<string>(m["ObjectIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDeploymentShrinkRequest() = default;
};
class CreateDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateDeploymentResponseBody() {}

  explicit CreateDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeploymentResponseBody() = default;
};
class CreateDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeploymentResponseBody> body{};

  CreateDeploymentResponse() {}

  explicit CreateDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeploymentResponse() = default;
};
class CreateFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  CreateFunctionRequest() {}

  explicit CreateFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateFunctionRequest() = default;
};
class CreateFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateFunctionResponseBody() {}

  explicit CreateFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFunctionResponseBody() = default;
};
class CreateFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFunctionResponseBody> body{};

  CreateFunctionResponse() {}

  explicit CreateFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFunctionResponse() = default;
};
class CreateNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateNetworkRequest() {}

  explicit CreateNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateNetworkRequest() = default;
};
class CreateNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNetworkResponseBody() {}

  explicit CreateNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNetworkResponseBody() = default;
};
class CreateNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkResponseBody> body{};

  CreateNetworkResponse() {}

  explicit CreateNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkResponse() = default;
};
class CreateNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> containerId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> scene{};
  shared_ptr<string> spec{};

  CreateNodeRequest() {}

  explicit CreateNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<long>(boost::any_cast<long>(m["ContainerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateNodeRequest() = default;
};
class CreateNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateNodeResponseBody() {}

  explicit CreateNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNodeResponseBody() = default;
};
class CreateNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNodeResponseBody> body{};

  CreateNodeResponse() {}

  explicit CreateNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNodeResponse() = default;
};
class CreateProjectRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateProjectRequestAliyunResourceTags() {}

  explicit CreateProjectRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateProjectRequestAliyunResourceTags() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<CreateProjectRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> paiTaskEnabled{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<CreateProjectRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<CreateProjectRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> paiTaskEnabled{};

  CreateProjectShrinkRequest() {}

  explicit CreateProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
  }


  virtual ~CreateProjectShrinkRequest() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> requestId{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class CreateProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  CreateProjectMemberRequest() {}

  explicit CreateProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateProjectMemberRequest() = default;
};
class CreateProjectMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  CreateProjectMemberShrinkRequest() {}

  explicit CreateProjectMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateProjectMemberShrinkRequest() = default;
};
class CreateProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectMemberResponseBody() {}

  explicit CreateProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectMemberResponseBody() = default;
};
class CreateProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectMemberResponseBody> body{};

  CreateProjectMemberResponse() {}

  explicit CreateProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectMemberResponse() = default;
};
class CreateResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  CreateResourceRequest() {}

  explicit CreateResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateResourceRequest() = default;
};
class CreateResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateResourceResponseBody() {}

  explicit CreateResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateResourceResponseBody() = default;
};
class CreateResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceResponseBody> body{};

  CreateResourceResponse() {}

  explicit CreateResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceResponse() = default;
};
class CreateResourceGroupRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateResourceGroupRequestAliyunResourceTags() {}

  explicit CreateResourceGroupRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateResourceGroupRequestAliyunResourceTags() = default;
};
class CreateResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<CreateResourceGroupRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<bool> autoRenewEnabled{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<long> spec{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateResourceGroupRequest() {}

  explicit CreateResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<CreateResourceGroupRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResourceGroupRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<CreateResourceGroupRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateResourceGroupRequest() = default;
};
class CreateResourceGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<bool> autoRenewEnabled{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<long> spec{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateResourceGroupShrinkRequest() {}

  explicit CreateResourceGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateResourceGroupShrinkRequest() = default;
};
class CreateResourceGroupResponseBodyResourceGroupOrder : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> orderId{};
  shared_ptr<string> orderInstanceId{};

  CreateResourceGroupResponseBodyResourceGroupOrder() {}

  explicit CreateResourceGroupResponseBodyResourceGroupOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
  }


  virtual ~CreateResourceGroupResponseBodyResourceGroupOrder() = default;
};
class CreateResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateResourceGroupResponseBodyResourceGroupOrder> resourceGroupOrder{};
  shared_ptr<bool> success{};

  CreateResourceGroupResponseBody() {}

  explicit CreateResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupOrder) {
      res["ResourceGroupOrder"] = resourceGroupOrder ? boost::any(resourceGroupOrder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupOrder") != m.end() && !m["ResourceGroupOrder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroupOrder"].type()) {
        CreateResourceGroupResponseBodyResourceGroupOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroupOrder"]));
        resourceGroupOrder = make_shared<CreateResourceGroupResponseBodyResourceGroupOrder>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateResourceGroupResponseBody() = default;
};
class CreateResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceGroupResponseBody> body{};

  CreateResourceGroupResponse() {}

  explicit CreateResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceGroupResponse() = default;
};
class CreateRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> networkId{};

  CreateRouteRequest() {}

  explicit CreateRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
  }


  virtual ~CreateRouteRequest() = default;
};
class CreateRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateRouteResponseBody() {}

  explicit CreateRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRouteResponseBody() = default;
};
class CreateRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteResponseBody> body{};

  CreateRouteResponse() {}

  explicit CreateRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteResponse() = default;
};
class CreateWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  CreateWorkflowDefinitionRequest() {}

  explicit CreateWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateWorkflowDefinitionRequest() = default;
};
class CreateWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateWorkflowDefinitionResponseBody() {}

  explicit CreateWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWorkflowDefinitionResponseBody() = default;
};
class CreateWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkflowDefinitionResponseBody> body{};

  CreateWorkflowDefinitionResponse() {}

  explicit CreateWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkflowDefinitionResponse() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesAlert : public Darabonba::Model {
public:
  shared_ptr<string> noticeType{};
  shared_ptr<string> type{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesAlert() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesAlert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesAlert() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis : public Darabonba::Model {
public:
  shared_ptr<bool> blocked{};
  shared_ptr<bool> enabled{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blocked) {
      res["Blocked"] = boost::any(*blocked);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blocked") != m.end() && !m["Blocked"].empty()) {
      blocked = make_shared<bool>(boost::any_cast<bool>(m["Blocked"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<bool> immediately{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (immediately) {
      res["Immediately"] = boost::any(*immediately);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Immediately") != m.end() && !m["Immediately"].empty()) {
      immediately = make_shared<bool>(boost::any_cast<bool>(m["Immediately"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy() = default;
};
class CreateWorkflowInstancesRequestDefaultRunProperties : public Darabonba::Model {
public:
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesAlert> alert{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis> analysis{};
  shared_ptr<vector<long>> excludeProjectIds{};
  shared_ptr<vector<long>> excludeTaskIds{};
  shared_ptr<vector<long>> includeProjectIds{};
  shared_ptr<vector<long>> includeTaskIds{};
  shared_ptr<string> mode{};
  shared_ptr<string> order{};
  shared_ptr<long> parallelism{};
  shared_ptr<vector<long>> rootTaskIds{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy> runPolicy{};
  shared_ptr<string> runtimeResource{};

  CreateWorkflowInstancesRequestDefaultRunProperties() {}

  explicit CreateWorkflowInstancesRequestDefaultRunProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alert) {
      res["Alert"] = alert ? boost::any(alert->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (excludeProjectIds) {
      res["ExcludeProjectIds"] = boost::any(*excludeProjectIds);
    }
    if (excludeTaskIds) {
      res["ExcludeTaskIds"] = boost::any(*excludeTaskIds);
    }
    if (includeProjectIds) {
      res["IncludeProjectIds"] = boost::any(*includeProjectIds);
    }
    if (includeTaskIds) {
      res["IncludeTaskIds"] = boost::any(*includeTaskIds);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (rootTaskIds) {
      res["RootTaskIds"] = boost::any(*rootTaskIds);
    }
    if (runPolicy) {
      res["RunPolicy"] = runPolicy ? boost::any(runPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alert") != m.end() && !m["Alert"].empty()) {
      if (typeid(map<string, boost::any>) == m["Alert"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesAlert model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Alert"]));
        alert = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesAlert>(model1);
      }
    }
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis>(model1);
      }
    }
    if (m.find("ExcludeProjectIds") != m.end() && !m["ExcludeProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      excludeProjectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ExcludeTaskIds") != m.end() && !m["ExcludeTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      excludeTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IncludeProjectIds") != m.end() && !m["IncludeProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      includeProjectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IncludeTaskIds") != m.end() && !m["IncludeTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      includeTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<long>(boost::any_cast<long>(m["Parallelism"]));
    }
    if (m.find("RootTaskIds") != m.end() && !m["RootTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RootTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RootTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      rootTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RunPolicy") != m.end() && !m["RunPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunPolicy"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunPolicy"]));
        runPolicy = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunProperties() = default;
};
class CreateWorkflowInstancesRequestPeriodsBizDates : public Darabonba::Model {
public:
  shared_ptr<string> endBizDate{};
  shared_ptr<string> startBizDate{};

  CreateWorkflowInstancesRequestPeriodsBizDates() {}

  explicit CreateWorkflowInstancesRequestPeriodsBizDates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestPeriodsBizDates() = default;
};
class CreateWorkflowInstancesRequestPeriods : public Darabonba::Model {
public:
  shared_ptr<vector<CreateWorkflowInstancesRequestPeriodsBizDates>> bizDates{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  CreateWorkflowInstancesRequestPeriods() {}

  explicit CreateWorkflowInstancesRequestPeriods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDates) {
      vector<boost::any> temp1;
      for(auto item1:*bizDates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizDates"] = boost::any(temp1);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDates") != m.end() && !m["BizDates"].empty()) {
      if (typeid(vector<boost::any>) == m["BizDates"].type()) {
        vector<CreateWorkflowInstancesRequestPeriodsBizDates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizDates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWorkflowInstancesRequestPeriodsBizDates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizDates = make_shared<vector<CreateWorkflowInstancesRequestPeriodsBizDates>>(expect1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestPeriods() = default;
};
class CreateWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStartEnabled{};
  shared_ptr<string> comment{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunProperties> defaultRunProperties{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<CreateWorkflowInstancesRequestPeriods> periods{};
  shared_ptr<long> projectId{};
  shared_ptr<string> taskParameters{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};
  shared_ptr<string> workflowParameters{};

  CreateWorkflowInstancesRequest() {}

  explicit CreateWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStartEnabled) {
      res["AutoStartEnabled"] = boost::any(*autoStartEnabled);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (defaultRunProperties) {
      res["DefaultRunProperties"] = defaultRunProperties ? boost::any(defaultRunProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (periods) {
      res["Periods"] = periods ? boost::any(periods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskParameters) {
      res["TaskParameters"] = boost::any(*taskParameters);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowParameters) {
      res["WorkflowParameters"] = boost::any(*workflowParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStartEnabled") != m.end() && !m["AutoStartEnabled"].empty()) {
      autoStartEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoStartEnabled"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DefaultRunProperties") != m.end() && !m["DefaultRunProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultRunProperties"].type()) {
        CreateWorkflowInstancesRequestDefaultRunProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultRunProperties"]));
        defaultRunProperties = make_shared<CreateWorkflowInstancesRequestDefaultRunProperties>(model1);
      }
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      if (typeid(map<string, boost::any>) == m["Periods"].type()) {
        CreateWorkflowInstancesRequestPeriods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Periods"]));
        periods = make_shared<CreateWorkflowInstancesRequestPeriods>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskParameters") != m.end() && !m["TaskParameters"].empty()) {
      taskParameters = make_shared<string>(boost::any_cast<string>(m["TaskParameters"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowParameters") != m.end() && !m["WorkflowParameters"].empty()) {
      workflowParameters = make_shared<string>(boost::any_cast<string>(m["WorkflowParameters"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequest() = default;
};
class CreateWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStartEnabled{};
  shared_ptr<string> comment{};
  shared_ptr<string> defaultRunPropertiesShrink{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> periodsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> taskParameters{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};
  shared_ptr<string> workflowParameters{};

  CreateWorkflowInstancesShrinkRequest() {}

  explicit CreateWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStartEnabled) {
      res["AutoStartEnabled"] = boost::any(*autoStartEnabled);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (defaultRunPropertiesShrink) {
      res["DefaultRunProperties"] = boost::any(*defaultRunPropertiesShrink);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (periodsShrink) {
      res["Periods"] = boost::any(*periodsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskParameters) {
      res["TaskParameters"] = boost::any(*taskParameters);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowParameters) {
      res["WorkflowParameters"] = boost::any(*workflowParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStartEnabled") != m.end() && !m["AutoStartEnabled"].empty()) {
      autoStartEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoStartEnabled"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DefaultRunProperties") != m.end() && !m["DefaultRunProperties"].empty()) {
      defaultRunPropertiesShrink = make_shared<string>(boost::any_cast<string>(m["DefaultRunProperties"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      periodsShrink = make_shared<string>(boost::any_cast<string>(m["Periods"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskParameters") != m.end() && !m["TaskParameters"].empty()) {
      taskParameters = make_shared<string>(boost::any_cast<string>(m["TaskParameters"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowParameters") != m.end() && !m["WorkflowParameters"].empty()) {
      workflowParameters = make_shared<string>(boost::any_cast<string>(m["WorkflowParameters"]));
    }
  }


  virtual ~CreateWorkflowInstancesShrinkRequest() = default;
};
class CreateWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  CreateWorkflowInstancesResponseBody() {}

  explicit CreateWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWorkflowInstancesResponseBody() = default;
};
class CreateWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkflowInstancesResponseBody> body{};

  CreateWorkflowInstancesResponse() {}

  explicit CreateWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkflowInstancesResponse() = default;
};
class DeleteAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteAlertRuleRequest() {}

  explicit DeleteAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteAlertRuleRequest() = default;
};
class DeleteAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAlertRuleResponseBody() {}

  explicit DeleteAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAlertRuleResponseBody() = default;
};
class DeleteAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRuleResponseBody> body{};

  DeleteAlertRuleResponse() {}

  explicit DeleteAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRuleResponse() = default;
};
class DeleteDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};

  DeleteDIAlarmRuleRequest() {}

  explicit DeleteDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDIAlarmRuleRequest() = default;
};
class DeleteDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDIAlarmRuleResponseBody() {}

  explicit DeleteDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDIAlarmRuleResponseBody() = default;
};
class DeleteDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDIAlarmRuleResponseBody> body{};

  DeleteDIAlarmRuleResponse() {}

  explicit DeleteDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDIAlarmRuleResponse() = default;
};
class DeleteDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDIJobRequest() {}

  explicit DeleteDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDIJobRequest() = default;
};
class DeleteDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDIJobResponseBody() {}

  explicit DeleteDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDIJobResponseBody() = default;
};
class DeleteDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDIJobResponseBody> body{};

  DeleteDIJobResponse() {}

  explicit DeleteDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDIJobResponse() = default;
};
class DeleteDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> values{};

  DeleteDataAssetTagRequest() {}

  explicit DeleteDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteDataAssetTagRequest() = default;
};
class DeleteDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> valuesShrink{};

  DeleteDataAssetTagShrinkRequest() {}

  explicit DeleteDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DeleteDataAssetTagShrinkRequest() = default;
};
class DeleteDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataAssetTagResponseBody() {}

  explicit DeleteDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataAssetTagResponseBody() = default;
};
class DeleteDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataAssetTagResponseBody> body{};

  DeleteDataAssetTagResponse() {}

  explicit DeleteDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataAssetTagResponse() = default;
};
class DeleteDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDataQualityEvaluationTaskRequest() {}

  explicit DeleteDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskRequest() = default;
};
class DeleteDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityEvaluationTaskResponseBody() {}

  explicit DeleteDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskResponseBody() = default;
};
class DeleteDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityEvaluationTaskResponseBody> body{};

  DeleteDataQualityEvaluationTaskResponse() {}

  explicit DeleteDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskResponse() = default;
};
class DeleteDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDataQualityRuleRequest() {}

  explicit DeleteDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityRuleRequest() = default;
};
class DeleteDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityRuleResponseBody() {}

  explicit DeleteDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityRuleResponseBody() = default;
};
class DeleteDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityRuleResponseBody> body{};

  DeleteDataQualityRuleResponse() {}

  explicit DeleteDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityRuleResponse() = default;
};
class DeleteDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> projectId{};

  DeleteDataQualityRuleTemplateRequest() {}

  explicit DeleteDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityRuleTemplateRequest() = default;
};
class DeleteDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityRuleTemplateResponseBody() {}

  explicit DeleteDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityRuleTemplateResponseBody() = default;
};
class DeleteDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityRuleTemplateResponseBody> body{};

  DeleteDataQualityRuleTemplateResponse() {}

  explicit DeleteDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityRuleTemplateResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteDataSourceSharedRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteDataSourceSharedRuleRequest() {}

  explicit DeleteDataSourceSharedRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDataSourceSharedRuleRequest() = default;
};
class DeleteDataSourceSharedRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceSharedRuleResponseBody() {}

  explicit DeleteDataSourceSharedRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceSharedRuleResponseBody() = default;
};
class DeleteDataSourceSharedRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceSharedRuleResponseBody> body{};

  DeleteDataSourceSharedRuleResponse() {}

  explicit DeleteDataSourceSharedRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceSharedRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceSharedRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceSharedRuleResponse() = default;
};
class DeleteFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteFunctionRequest() {}

  explicit DeleteFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteFunctionRequest() = default;
};
class DeleteFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFunctionResponseBody() {}

  explicit DeleteFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFunctionResponseBody() = default;
};
class DeleteFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFunctionResponseBody> body{};

  DeleteFunctionResponse() {}

  explicit DeleteFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFunctionResponse() = default;
};
class DeleteNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteNetworkRequest() {}

  explicit DeleteNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteNetworkRequest() = default;
};
class DeleteNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNetworkResponseBody() {}

  explicit DeleteNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNetworkResponseBody() = default;
};
class DeleteNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkResponseBody> body{};

  DeleteNetworkResponse() {}

  explicit DeleteNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkResponse() = default;
};
class DeleteNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteNodeRequest() {}

  explicit DeleteNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteNodeRequest() = default;
};
class DeleteNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNodeResponseBody() {}

  explicit DeleteNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNodeResponseBody() = default;
};
class DeleteNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNodeResponseBody> body{};

  DeleteNodeResponse() {}

  explicit DeleteNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNodeResponse() = default;
};
class DeleteProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteProjectRequest() {}

  explicit DeleteProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteProjectRequest() = default;
};
class DeleteProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectResponseBody() {}

  explicit DeleteProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectResponseBody() = default;
};
class DeleteProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectResponseBody> body{};

  DeleteProjectResponse() {}

  explicit DeleteProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectResponse() = default;
};
class DeleteProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  DeleteProjectMemberRequest() {}

  explicit DeleteProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteProjectMemberRequest() = default;
};
class DeleteProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectMemberResponseBody() {}

  explicit DeleteProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectMemberResponseBody() = default;
};
class DeleteProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectMemberResponseBody> body{};

  DeleteProjectMemberResponse() {}

  explicit DeleteProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectMemberResponse() = default;
};
class DeleteResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteResourceRequest() {}

  explicit DeleteResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteResourceRequest() = default;
};
class DeleteResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteResourceResponseBody() {}

  explicit DeleteResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteResourceResponseBody() = default;
};
class DeleteResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceResponseBody> body{};

  DeleteResourceResponse() {}

  explicit DeleteResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceResponse() = default;
};
class DeleteResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteResourceGroupRequest() {}

  explicit DeleteResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteResourceGroupRequest() = default;
};
class DeleteResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteResourceGroupResponseBody() {}

  explicit DeleteResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteResourceGroupResponseBody() = default;
};
class DeleteResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceGroupResponseBody> body{};

  DeleteResourceGroupResponse() {}

  explicit DeleteResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceGroupResponse() = default;
};
class DeleteRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteRouteRequest() {}

  explicit DeleteRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteRouteRequest() = default;
};
class DeleteRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRouteResponseBody() {}

  explicit DeleteRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRouteResponseBody() = default;
};
class DeleteRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteResponseBody> body{};

  DeleteRouteResponse() {}

  explicit DeleteRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteResponse() = default;
};
class DeleteTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectEnv{};

  DeleteTaskRequest() {}

  explicit DeleteTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~DeleteTaskRequest() = default;
};
class DeleteTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTaskResponseBody() {}

  explicit DeleteTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTaskResponseBody() = default;
};
class DeleteTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskResponseBody> body{};

  DeleteTaskResponse() {}

  explicit DeleteTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskResponse() = default;
};
class DeleteWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};

  DeleteWorkflowRequest() {}

  explicit DeleteWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteWorkflowRequest() = default;
};
class DeleteWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteWorkflowResponseBody() {}

  explicit DeleteWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteWorkflowResponseBody() = default;
};
class DeleteWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkflowResponseBody> body{};

  DeleteWorkflowResponse() {}

  explicit DeleteWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkflowResponse() = default;
};
class DeleteWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteWorkflowDefinitionRequest() {}

  explicit DeleteWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteWorkflowDefinitionRequest() = default;
};
class DeleteWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteWorkflowDefinitionResponseBody() {}

  explicit DeleteWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteWorkflowDefinitionResponseBody() = default;
};
class DeleteWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkflowDefinitionResponseBody> body{};

  DeleteWorkflowDefinitionResponse() {}

  explicit DeleteWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkflowDefinitionResponse() = default;
};
class DetachDataQualityRulesFromEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<vector<long>> dataQualityRuleIds{};
  shared_ptr<long> projectId{};

  DetachDataQualityRulesFromEvaluationTaskRequest() {}

  explicit DetachDataQualityRulesFromEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIds) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DataQualityRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataQualityRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dataQualityRuleIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskRequest() = default;
};
class DetachDataQualityRulesFromEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> dataQualityRuleIdsShrink{};
  shared_ptr<long> projectId{};

  DetachDataQualityRulesFromEvaluationTaskShrinkRequest() {}

  explicit DetachDataQualityRulesFromEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIdsShrink) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      dataQualityRuleIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRuleIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskShrinkRequest() = default;
};
class DetachDataQualityRulesFromEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetachDataQualityRulesFromEvaluationTaskResponseBody() {}

  explicit DetachDataQualityRulesFromEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskResponseBody() = default;
};
class DetachDataQualityRulesFromEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDataQualityRulesFromEvaluationTaskResponseBody> body{};

  DetachDataQualityRulesFromEvaluationTaskResponse() {}

  explicit DetachDataQualityRulesFromEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDataQualityRulesFromEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDataQualityRulesFromEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskResponse() = default;
};
class DissociateProjectFromResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupId{};

  DissociateProjectFromResourceGroupRequest() {}

  explicit DissociateProjectFromResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DissociateProjectFromResourceGroupRequest() = default;
};
class DissociateProjectFromResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DissociateProjectFromResourceGroupResponseBody() {}

  explicit DissociateProjectFromResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DissociateProjectFromResourceGroupResponseBody() = default;
};
class DissociateProjectFromResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateProjectFromResourceGroupResponseBody> body{};

  DissociateProjectFromResourceGroupResponse() {}

  explicit DissociateProjectFromResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateProjectFromResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateProjectFromResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateProjectFromResourceGroupResponse() = default;
};
class ExecDeploymentStageRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  ExecDeploymentStageRequest() {}

  explicit ExecDeploymentStageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ExecDeploymentStageRequest() = default;
};
class ExecDeploymentStageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecDeploymentStageResponseBody() {}

  explicit ExecDeploymentStageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecDeploymentStageResponseBody() = default;
};
class ExecDeploymentStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecDeploymentStageResponseBody> body{};

  ExecDeploymentStageResponse() {}

  explicit ExecDeploymentStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecDeploymentStageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecDeploymentStageResponseBody>(model1);
      }
    }
  }


  virtual ~ExecDeploymentStageResponse() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ExecuteAdhocWorkflowInstanceRequestTasksDataSource() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksDataSource() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksDependencies : public Darabonba::Model {
public:
  shared_ptr<string> upstreamOutput{};

  ExecuteAdhocWorkflowInstanceRequestTasksDependencies() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksDependencies() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables>> variables{};

  ExecuteAdhocWorkflowInstanceRequestTasksInputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksInputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables>> variables{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  ExecuteAdhocWorkflowInstanceRequestTasksScript() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksScript() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasks : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksDataSource> dataSource{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies>> dependencies{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksInputs> inputs{};
  shared_ptr<string> name{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksScript> script{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};

  ExecuteAdhocWorkflowInstanceRequestTasks() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies>>(expect1);
      }
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksInputs>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksScript>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasks() = default;
};
class ExecuteAdhocWorkflowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasks>> tasks{};

  ExecuteAdhocWorkflowInstanceRequest() {}

  explicit ExecuteAdhocWorkflowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasks>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequest() = default;
};
class ExecuteAdhocWorkflowInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tasksShrink{};

  ExecuteAdhocWorkflowInstanceShrinkRequest() {}

  explicit ExecuteAdhocWorkflowInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceShrinkRequest() = default;
};
class ExecuteAdhocWorkflowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> workflowInstanceId{};

  ExecuteAdhocWorkflowInstanceResponseBody() {}

  explicit ExecuteAdhocWorkflowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceResponseBody() = default;
};
class ExecuteAdhocWorkflowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteAdhocWorkflowInstanceResponseBody> body{};

  ExecuteAdhocWorkflowInstanceResponse() {}

  explicit ExecuteAdhocWorkflowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteAdhocWorkflowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteAdhocWorkflowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceResponse() = default;
};
class GetAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetAlertRuleRequest() {}

  explicit GetAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetAlertRuleRequest() = default;
};
class GetAlertRuleResponseBodyAlertRuleNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetAlertRuleResponseBodyAlertRuleNotificationReceivers() {}

  explicit GetAlertRuleResponseBodyAlertRuleNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleNotificationReceivers() = default;
};
class GetAlertRuleResponseBodyAlertRuleNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  GetAlertRuleResponseBodyAlertRuleNotification() {}

  explicit GetAlertRuleResponseBodyAlertRuleNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRuleResponseBodyAlertRuleNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleNotification() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError> error{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished> unFinished{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension> extension{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  GetAlertRuleResponseBodyAlertRuleTriggerCondition() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerCondition() = default;
};
class GetAlertRuleResponseBodyAlertRule : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerCondition> triggerCondition{};

  GetAlertRuleResponseBodyAlertRule() {}

  explicit GetAlertRuleResponseBodyAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        GetAlertRuleResponseBodyAlertRuleNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<GetAlertRuleResponseBodyAlertRuleNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerCondition>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRule() = default;
};
class GetAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRule> alertRule{};
  shared_ptr<string> requestId{};

  GetAlertRuleResponseBody() {}

  explicit GetAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        GetAlertRuleResponseBodyAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<GetAlertRuleResponseBodyAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlertRuleResponseBody() = default;
};
class GetAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlertRuleResponseBody> body{};

  GetAlertRuleResponse() {}

  explicit GetAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponse() = default;
};
class GetCreateWorkflowInstancesResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};

  GetCreateWorkflowInstancesResultRequest() {}

  explicit GetCreateWorkflowInstancesResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
  }


  virtual ~GetCreateWorkflowInstancesResultRequest() = default;
};
class GetCreateWorkflowInstancesResultResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> failureMessage{};
  shared_ptr<string> status{};
  shared_ptr<vector<long>> workflowInstanceIds{};

  GetCreateWorkflowInstancesResultResponseBodyResult() {}

  explicit GetCreateWorkflowInstancesResultResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureMessage) {
      res["FailureMessage"] = boost::any(*failureMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (workflowInstanceIds) {
      res["WorkflowInstanceIds"] = boost::any(*workflowInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureMessage") != m.end() && !m["FailureMessage"].empty()) {
      failureMessage = make_shared<string>(boost::any_cast<string>(m["FailureMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("WorkflowInstanceIds") != m.end() && !m["WorkflowInstanceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["WorkflowInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkflowInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      workflowInstanceIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponseBodyResult() = default;
};
class GetCreateWorkflowInstancesResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetCreateWorkflowInstancesResultResponseBodyResult> result{};

  GetCreateWorkflowInstancesResultResponseBody() {}

  explicit GetCreateWorkflowInstancesResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetCreateWorkflowInstancesResultResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetCreateWorkflowInstancesResultResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponseBody() = default;
};
class GetCreateWorkflowInstancesResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCreateWorkflowInstancesResultResponseBody> body{};

  GetCreateWorkflowInstancesResultResponse() {}

  explicit GetCreateWorkflowInstancesResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCreateWorkflowInstancesResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCreateWorkflowInstancesResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponse() = default;
};
class GetDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> withDetails{};

  GetDIJobRequest() {}

  explicit GetDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (withDetails) {
      res["WithDetails"] = boost::any(*withDetails);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("WithDetails") != m.end() && !m["WithDetails"].empty()) {
      withDetails = make_shared<bool>(boost::any_cast<bool>(m["WithDetails"]));
    }
  }


  virtual ~GetDIJobRequest() = default;
};
class GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};

  GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> cycleMigrationType{};
  shared_ptr<string> scheduleParameters{};

  GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleMigrationType) {
      res["CycleMigrationType"] = boost::any(*cycleMigrationType);
    }
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleMigrationType") != m.end() && !m["CycleMigrationType"].empty()) {
      cycleMigrationType = make_shared<string>(boost::any_cast<string>(m["CycleMigrationType"]));
    }
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings>> runtimeSettings{};

  GetDIJobResponseBodyPagingInfoJobSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettings : public Darabonba::Model {
public:
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  GetDIJobResponseBodyPagingInfoResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties : public Darabonba::Model {
public:
  shared_ptr<string> encoding{};
  shared_ptr<string> timezone{};

  GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties() {}

  explicit GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties() = default;
};
class GetDIJobResponseBodyPagingInfoSourceDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};
  shared_ptr<GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties> dataSourceProperties{};

  GetDIJobResponseBodyPagingInfoSourceDataSourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoSourceDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (dataSourceProperties) {
      res["DataSourceProperties"] = dataSourceProperties ? boost::any(dataSourceProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("DataSourceProperties") != m.end() && !m["DataSourceProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceProperties"].type()) {
        GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceProperties"]));
        dataSourceProperties = make_shared<GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties>(model1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoSourceDataSourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules>> transformationRules{};

  GetDIJobResponseBodyPagingInfoTableMappings() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappings() = default;
};
class GetDIJobResponseBodyPagingInfoTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  GetDIJobResponseBodyPagingInfoTransformationRules() {}

  explicit GetDIJobResponseBodyPagingInfoTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTransformationRules() = default;
};
class GetDIJobResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<string> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings>> destinationDataSourceSettings{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<long> id{};
  shared_ptr<string> jobName{};
  shared_ptr<GetDIJobResponseBodyPagingInfoJobSettings> jobSettings{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> migrationType{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettings> resourceSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings>> sourceDataSourceSettings{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappings>> tableMappings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTransformationRules>> transformationRules{};

  GetDIJobResponseBodyPagingInfo() {}

  explicit GetDIJobResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*destinationDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationDataSourceSettings"] = boost::any(temp1);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDataSourceSettings"] = boost::any(temp1);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<string>(boost::any_cast<string>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationDataSourceSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationDataSourceSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings>>(expect1);
      }
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        GetDIJobResponseBodyPagingInfoJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<GetDIJobResponseBodyPagingInfoJobSettings>(model1);
      }
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettings>(model1);
      }
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDataSourceSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoSourceDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDataSourceSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings>>(expect1);
      }
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTransformationRules>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfo() = default;
};
class GetDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDIJobResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  GetDIJobResponseBody() {}

  explicit GetDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        GetDIJobResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<GetDIJobResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDIJobResponseBody() = default;
};
class GetDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDIJobResponseBody> body{};

  GetDIJobResponse() {}

  explicit GetDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDIJobResponse() = default;
};
class GetDIJobLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> failoverId{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> pageNumber{};

  GetDIJobLogRequest() {}

  explicit GetDIJobLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (failoverId) {
      res["FailoverId"] = boost::any(*failoverId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("FailoverId") != m.end() && !m["FailoverId"].empty()) {
      failoverId = make_shared<long>(boost::any_cast<long>(m["FailoverId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~GetDIJobLogRequest() = default;
};
class GetDIJobLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> log{};
  shared_ptr<string> requestId{};

  GetDIJobLogResponseBody() {}

  explicit GetDIJobLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDIJobLogResponseBody() = default;
};
class GetDIJobLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDIJobLogResponseBody> body{};

  GetDIJobLogResponse() {}

  explicit GetDIJobLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDIJobLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDIJobLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetDIJobLogResponse() = default;
};
class GetDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityEvaluationTaskRequest() {}

  explicit GetDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskRequest() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications>> notifications{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget> target{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger> trigger{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask() = default;
};
class GetDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask> dataQualityEvaluationTask{};
  shared_ptr<string> requestId{};

  GetDataQualityEvaluationTaskResponseBody() {}

  explicit GetDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTask) {
      res["DataQualityEvaluationTask"] = dataQualityEvaluationTask ? boost::any(dataQualityEvaluationTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTask") != m.end() && !m["DataQualityEvaluationTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityEvaluationTask"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityEvaluationTask"]));
        dataQualityEvaluationTask = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBody() = default;
};
class GetDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBody> body{};

  GetDataQualityEvaluationTaskResponse() {}

  explicit GetDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponse() = default;
};
class GetDataQualityEvaluationTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityEvaluationTaskInstanceRequest() {}

  explicit GetDataQualityEvaluationTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceRequest() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications>> notifications{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget> target{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger> trigger{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask> task{};
  shared_ptr<string> triggerContext{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerContext) {
      res["TriggerContext"] = boost::any(*triggerContext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask>(model1);
      }
    }
    if (m.find("TriggerContext") != m.end() && !m["TriggerContext"].empty()) {
      triggerContext = make_shared<string>(boost::any_cast<string>(m["TriggerContext"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance> dataQualityEvaluationTaskInstance{};
  shared_ptr<string> requestId{};

  GetDataQualityEvaluationTaskInstanceResponseBody() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskInstance) {
      res["DataQualityEvaluationTaskInstance"] = dataQualityEvaluationTaskInstance ? boost::any(dataQualityEvaluationTaskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskInstance") != m.end() && !m["DataQualityEvaluationTaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityEvaluationTaskInstance"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityEvaluationTaskInstance"]));
        dataQualityEvaluationTaskInstance = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBody() = default;
};
class GetDataQualityEvaluationTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBody> body{};

  GetDataQualityEvaluationTaskInstanceResponse() {}

  explicit GetDataQualityEvaluationTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityEvaluationTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponse() = default;
};
class GetDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityRuleRequest() {}

  explicit GetDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityRuleRequest() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned> warned{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleTarget() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleTarget() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRule : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleTarget> target{};
  shared_ptr<string> templateCode{};

  GetDataQualityRuleResponseBodyDataQualityRule() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRule() = default;
};
class GetDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRule> dataQualityRule{};
  shared_ptr<string> requestId{};

  GetDataQualityRuleResponseBody() {}

  explicit GetDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRule) {
      res["DataQualityRule"] = dataQualityRule ? boost::any(dataQualityRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRule") != m.end() && !m["DataQualityRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityRule"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityRule"]));
        dataQualityRule = make_shared<GetDataQualityRuleResponseBodyDataQualityRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBody() = default;
};
class GetDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityRuleResponseBody> body{};

  GetDataQualityRuleResponse() {}

  explicit GetDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleResponse() = default;
};
class GetDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  GetDataQualityRuleTemplateRequest() {}

  explicit GetDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateRequest() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate() = default;
};
class GetDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate> dataQualityRuleTemplate{};
  shared_ptr<string> requestId{};

  GetDataQualityRuleTemplateResponseBody() {}

  explicit GetDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRuleTemplate) {
      res["DataQualityRuleTemplate"] = dataQualityRuleTemplate ? boost::any(dataQualityRuleTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRuleTemplate") != m.end() && !m["DataQualityRuleTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityRuleTemplate"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityRuleTemplate"]));
        dataQualityRuleTemplate = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBody() = default;
};
class GetDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityRuleTemplateResponseBody> body{};

  GetDataQualityRuleTemplateResponse() {}

  explicit GetDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleTemplateResponse() = default;
};
class GetDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataSourceRequest() {}

  explicit GetDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataSourceRequest() = default;
};
class GetDataSourceResponseBodyDataSource : public Darabonba::Model {
public:
  shared_ptr<boost::any> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> qualifiedName{};
  shared_ptr<string> type{};

  GetDataSourceResponseBodyDataSource() {}

  explicit GetDataSourceResponseBodyDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataSourceResponseBodyDataSource() = default;
};
class GetDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataSourceResponseBodyDataSource> dataSource{};
  shared_ptr<string> requestId{};

  GetDataSourceResponseBody() {}

  explicit GetDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetDataSourceResponseBodyDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetDataSourceResponseBodyDataSource>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataSourceResponseBody() = default;
};
class GetDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataSourceResponseBody> body{};

  GetDataSourceResponse() {}

  explicit GetDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataSourceResponse() = default;
};
class GetDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  GetDeploymentRequest() {}

  explicit GetDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetDeploymentRequest() = default;
};
class GetDeploymentResponseBodyPipelineStages : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<long> step{};
  shared_ptr<string> type{};

  GetDeploymentResponseBodyPipelineStages() {}

  explicit GetDeploymentResponseBodyPipelineStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDeploymentResponseBodyPipelineStages() = default;
};
class GetDeploymentResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetDeploymentResponseBodyPipelineStages>> stages{};
  shared_ptr<string> status{};

  GetDeploymentResponseBodyPipeline() {}

  explicit GetDeploymentResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stages"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      if (typeid(vector<boost::any>) == m["Stages"].type()) {
        vector<GetDeploymentResponseBodyPipelineStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeploymentResponseBodyPipelineStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<GetDeploymentResponseBodyPipelineStages>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDeploymentResponseBodyPipeline() = default;
};
class GetDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeploymentResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  GetDeploymentResponseBody() {}

  explicit GetDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        GetDeploymentResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<GetDeploymentResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeploymentResponseBody() = default;
};
class GetDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeploymentResponseBody> body{};

  GetDeploymentResponse() {}

  explicit GetDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponse() = default;
};
class GetFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetFunctionRequest() {}

  explicit GetFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetFunctionRequest() = default;
};
class GetFunctionResponseBodyFunction : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  GetFunctionResponseBodyFunction() {}

  explicit GetFunctionResponseBodyFunction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~GetFunctionResponseBodyFunction() = default;
};
class GetFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFunctionResponseBodyFunction> function{};
  shared_ptr<string> requestId{};

  GetFunctionResponseBody() {}

  explicit GetFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = function ? boost::any(function->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      if (typeid(map<string, boost::any>) == m["Function"].type()) {
        GetFunctionResponseBodyFunction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Function"]));
        function = make_shared<GetFunctionResponseBodyFunction>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFunctionResponseBody() = default;
};
class GetFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFunctionResponseBody> body{};

  GetFunctionResponse() {}

  explicit GetFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~GetFunctionResponse() = default;
};
class GetJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetJobStatusRequest() {}

  explicit GetJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobStatusRequest() = default;
};
class GetJobStatusResponseBodyJobStatus : public Darabonba::Model {
public:
  shared_ptr<string> completed{};
  shared_ptr<string> createTime{};
  shared_ptr<string> error{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> status{};

  GetJobStatusResponseBodyJobStatus() {}

  explicit GetJobStatusResponseBodyJobStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<string>(boost::any_cast<string>(m["Completed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetJobStatusResponseBodyJobStatus() = default;
};
class GetJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetJobStatusResponseBodyJobStatus> jobStatus{};
  shared_ptr<string> requestId{};

  GetJobStatusResponseBody() {}

  explicit GetJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = jobStatus ? boost::any(jobStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobStatus"].type()) {
        GetJobStatusResponseBodyJobStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobStatus"]));
        jobStatus = make_shared<GetJobStatusResponseBodyJobStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetJobStatusResponseBody() = default;
};
class GetJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetJobStatusResponseBody> body{};

  GetJobStatusResponse() {}

  explicit GetJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobStatusResponse() = default;
};
class GetNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetNetworkRequest() {}

  explicit GetNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetNetworkRequest() = default;
};
class GetNetworkResponseBodyNetwork : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  GetNetworkResponseBodyNetwork() {}

  explicit GetNetworkResponseBodyNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~GetNetworkResponseBodyNetwork() = default;
};
class GetNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNetworkResponseBodyNetwork> network{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNetworkResponseBody() {}

  explicit GetNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (network) {
      res["Network"] = network ? boost::any(network->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(map<string, boost::any>) == m["Network"].type()) {
        GetNetworkResponseBodyNetwork model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Network"]));
        network = make_shared<GetNetworkResponseBodyNetwork>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNetworkResponseBody() = default;
};
class GetNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNetworkResponseBody> body{};

  GetNetworkResponse() {}

  explicit GetNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~GetNetworkResponse() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};
  shared_ptr<long> taskId{};

  GetNodeResponseBodyNode() {}

  explicit GetNodeResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~GetNodeResponseBodyNode() = default;
};
class GetNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeResponseBody() {}

  explicit GetNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        GetNodeResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<GetNodeResponseBodyNode>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNodeResponseBody() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeResponseBody> body{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class GetProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetProjectRequest() {}

  explicit GetProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetProjectRequest() = default;
};
class GetProjectResponseBodyProjectAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetProjectResponseBodyProjectAliyunResourceTags() {}

  explicit GetProjectResponseBodyProjectAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetProjectResponseBodyProjectAliyunResourceTags() = default;
};
class GetProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<GetProjectResponseBodyProjectAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  GetProjectResponseBodyProject() {}

  explicit GetProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<GetProjectResponseBodyProjectAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProjectResponseBodyProjectAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<GetProjectResponseBodyProjectAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetProjectResponseBodyProject() = default;
};
class GetProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  GetProjectResponseBody() {}

  explicit GetProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        GetProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<GetProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectResponseBody() = default;
};
class GetProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectResponseBody> body{};

  GetProjectResponse() {}

  explicit GetProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectResponse() = default;
};
class GetProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  GetProjectMemberRequest() {}

  explicit GetProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetProjectMemberRequest() = default;
};
class GetProjectMemberResponseBodyProjectMemberRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetProjectMemberResponseBodyProjectMemberRoles() {}

  explicit GetProjectMemberResponseBodyProjectMemberRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetProjectMemberResponseBodyProjectMemberRoles() = default;
};
class GetProjectMemberResponseBodyProjectMember : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetProjectMemberResponseBodyProjectMemberRoles>> roles{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  GetProjectMemberResponseBodyProjectMember() {}

  explicit GetProjectMemberResponseBodyProjectMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<GetProjectMemberResponseBodyProjectMemberRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProjectMemberResponseBodyProjectMemberRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<GetProjectMemberResponseBodyProjectMemberRoles>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetProjectMemberResponseBodyProjectMember() = default;
};
class GetProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectMemberResponseBodyProjectMember> projectMember{};
  shared_ptr<string> requestId{};

  GetProjectMemberResponseBody() {}

  explicit GetProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectMember) {
      res["ProjectMember"] = projectMember ? boost::any(projectMember->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectMember") != m.end() && !m["ProjectMember"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMember"].type()) {
        GetProjectMemberResponseBodyProjectMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMember"]));
        projectMember = make_shared<GetProjectMemberResponseBodyProjectMember>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectMemberResponseBody() = default;
};
class GetProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectMemberResponseBody> body{};

  GetProjectMemberResponse() {}

  explicit GetProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectMemberResponse() = default;
};
class GetProjectRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> projectId{};

  GetProjectRoleRequest() {}

  explicit GetProjectRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectRoleRequest() = default;
};
class GetProjectRoleResponseBodyProjectRole : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  GetProjectRoleResponseBodyProjectRole() {}

  explicit GetProjectRoleResponseBodyProjectRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetProjectRoleResponseBodyProjectRole() = default;
};
class GetProjectRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectRoleResponseBodyProjectRole> projectRole{};
  shared_ptr<string> requestId{};

  GetProjectRoleResponseBody() {}

  explicit GetProjectRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRole) {
      res["ProjectRole"] = projectRole ? boost::any(projectRole->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRole") != m.end() && !m["ProjectRole"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectRole"].type()) {
        GetProjectRoleResponseBodyProjectRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectRole"]));
        projectRole = make_shared<GetProjectRoleResponseBodyProjectRole>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectRoleResponseBody() = default;
};
class GetProjectRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectRoleResponseBody> body{};

  GetProjectRoleResponse() {}

  explicit GetProjectRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectRoleResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectRoleResponse() = default;
};
class GetResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetResourceRequest() {}

  explicit GetResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetResourceRequest() = default;
};
class GetResourceResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  GetResourceResponseBodyResource() {}

  explicit GetResourceResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~GetResourceResponseBodyResource() = default;
};
class GetResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceResponseBodyResource> resource{};

  GetResourceResponseBody() {}

  explicit GetResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        GetResourceResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<GetResourceResponseBodyResource>(model1);
      }
    }
  }


  virtual ~GetResourceResponseBody() = default;
};
class GetResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceResponseBody> body{};

  GetResourceResponse() {}

  explicit GetResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceResponse() = default;
};
class GetResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetResourceGroupRequest() {}

  explicit GetResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetResourceGroupRequest() = default;
};
class GetResourceGroupResponseBodyResourceGroupAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetResourceGroupResponseBodyResourceGroupAliyunResourceTags() {}

  explicit GetResourceGroupResponseBodyResourceGroupAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroupAliyunResourceTags() = default;
};
class GetResourceGroupResponseBodyResourceGroupSpec : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> standard{};

  GetResourceGroupResponseBodyResourceGroupSpec() {}

  explicit GetResourceGroupResponseBodyResourceGroupSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (standard) {
      res["Standard"] = boost::any(*standard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Standard") != m.end() && !m["Standard"].empty()) {
      standard = make_shared<string>(boost::any_cast<string>(m["Standard"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroupSpec() = default;
};
class GetResourceGroupResponseBodyResourceGroup : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> defaultVpcId{};
  shared_ptr<string> defaultVswitchId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<GetResourceGroupResponseBodyResourceGroupSpec> spec{};
  shared_ptr<string> status{};

  GetResourceGroupResponseBodyResourceGroup() {}

  explicit GetResourceGroupResponseBodyResourceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (defaultVpcId) {
      res["DefaultVpcId"] = boost::any(*defaultVpcId);
    }
    if (defaultVswitchId) {
      res["DefaultVswitchId"] = boost::any(*defaultVswitchId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceGroupResponseBodyResourceGroupAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DefaultVpcId") != m.end() && !m["DefaultVpcId"].empty()) {
      defaultVpcId = make_shared<string>(boost::any_cast<string>(m["DefaultVpcId"]));
    }
    if (m.find("DefaultVswitchId") != m.end() && !m["DefaultVswitchId"].empty()) {
      defaultVswitchId = make_shared<string>(boost::any_cast<string>(m["DefaultVswitchId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        GetResourceGroupResponseBodyResourceGroupSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<GetResourceGroupResponseBodyResourceGroupSpec>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroup() = default;
};
class GetResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceGroupResponseBodyResourceGroup> resourceGroup{};
  shared_ptr<bool> success{};

  GetResourceGroupResponseBody() {}

  explicit GetResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = resourceGroup ? boost::any(resourceGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroup"].type()) {
        GetResourceGroupResponseBodyResourceGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroup"]));
        resourceGroup = make_shared<GetResourceGroupResponseBodyResourceGroup>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetResourceGroupResponseBody() = default;
};
class GetResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceGroupResponseBody> body{};

  GetResourceGroupResponse() {}

  explicit GetResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceGroupResponse() = default;
};
class GetRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetRouteRequest() {}

  explicit GetRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetRouteRequest() = default;
};
class GetRouteResponseBodyRoute : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  GetRouteResponseBodyRoute() {}

  explicit GetRouteResponseBodyRoute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~GetRouteResponseBodyRoute() = default;
};
class GetRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRouteResponseBodyRoute> route{};
  shared_ptr<bool> success{};

  GetRouteResponseBody() {}

  explicit GetRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (route) {
      res["Route"] = route ? boost::any(route->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      if (typeid(map<string, boost::any>) == m["Route"].type()) {
        GetRouteResponseBodyRoute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Route"]));
        route = make_shared<GetRouteResponseBodyRoute>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRouteResponseBody() = default;
};
class GetRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRouteResponseBody> body{};

  GetRouteResponse() {}

  explicit GetRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRouteResponseBody>(model1);
      }
    }
  }


  virtual ~GetRouteResponse() = default;
};
class GetTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectEnv{};

  GetTaskRequest() {}

  explicit GetTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetTaskRequest() = default;
};
class GetTaskResponseBodyTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskResponseBodyTaskDataSource() {}

  explicit GetTaskResponseBodyTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskDataSource() = default;
};
class GetTaskResponseBodyTaskDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<string> upstreamTaskId{};

  GetTaskResponseBodyTaskDependencies() {}

  explicit GetTaskResponseBodyTaskDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<string>(boost::any_cast<string>(m["UpstreamTaskId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskDependencies() = default;
};
class GetTaskResponseBodyTaskInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskInputsVariables() {}

  explicit GetTaskResponseBodyTaskInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskInputsVariables() = default;
};
class GetTaskResponseBodyTaskInputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskInputsVariables>> variables{};

  GetTaskResponseBodyTaskInputs() {}

  explicit GetTaskResponseBodyTaskInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskResponseBodyTaskInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskResponseBodyTaskInputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskResponseBodyTaskInputs() = default;
};
class GetTaskResponseBodyTaskOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetTaskResponseBodyTaskOutputsTaskOutputs() {}

  explicit GetTaskResponseBodyTaskOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputsTaskOutputs() = default;
};
class GetTaskResponseBodyTaskOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskOutputsVariables() {}

  explicit GetTaskResponseBodyTaskOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputsVariables() = default;
};
class GetTaskResponseBodyTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<GetTaskResponseBodyTaskOutputsVariables>> variables{};

  GetTaskResponseBodyTaskOutputs() {}

  explicit GetTaskResponseBodyTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetTaskResponseBodyTaskOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetTaskResponseBodyTaskOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskResponseBodyTaskOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskResponseBodyTaskOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputs() = default;
};
class GetTaskResponseBodyTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskResponseBodyTaskRuntimeResource() {}

  explicit GetTaskResponseBodyTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskRuntimeResource() = default;
};
class GetTaskResponseBodyTaskScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  GetTaskResponseBodyTaskScript() {}

  explicit GetTaskResponseBodyTaskScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskScript() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskResponseBodyTaskSubTasksSubTasksDataSource() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksDataSource() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskSubTasksSubTasksTrigger() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksTrigger() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetTaskResponseBodyTaskSubTasksSubTasks() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasks() = default;
};
class GetTaskResponseBodyTaskSubTasks : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskSubTasksSubTasks>> subTasks{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskSubTasks() {}

  explicit GetTaskResponseBodyTaskSubTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subTasks) {
      vector<boost::any> temp1;
      for(auto item1:*subTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubTasks"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubTasks") != m.end() && !m["SubTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["SubTasks"].type()) {
        vector<GetTaskResponseBodyTaskSubTasksSubTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskSubTasksSubTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subTasks = make_shared<vector<GetTaskResponseBodyTaskSubTasksSubTasks>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasks() = default;
};
class GetTaskResponseBodyTaskTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskTags() {}

  explicit GetTaskResponseBodyTaskTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskTags() = default;
};
class GetTaskResponseBodyTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskTrigger() {}

  explicit GetTaskResponseBodyTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskTrigger() = default;
};
class GetTaskResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskResponseBodyTaskDataSource> dataSource{};
  shared_ptr<vector<GetTaskResponseBodyTaskDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<GetTaskResponseBodyTaskInputs> inputs{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<GetTaskResponseBodyTaskOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetTaskResponseBodyTaskRuntimeResource> runtimeResource{};
  shared_ptr<GetTaskResponseBodyTaskScript> script{};
  shared_ptr<GetTaskResponseBodyTaskSubTasks> subTasks{};
  shared_ptr<vector<GetTaskResponseBodyTaskTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<GetTaskResponseBodyTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetTaskResponseBodyTask() {}

  explicit GetTaskResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subTasks) {
      res["SubTasks"] = subTasks ? boost::any(subTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskResponseBodyTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskResponseBodyTaskDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<GetTaskResponseBodyTaskDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<GetTaskResponseBodyTaskDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        GetTaskResponseBodyTaskInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<GetTaskResponseBodyTaskInputs>(model1);
      }
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetTaskResponseBodyTaskOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetTaskResponseBodyTaskOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskResponseBodyTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskResponseBodyTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        GetTaskResponseBodyTaskScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<GetTaskResponseBodyTaskScript>(model1);
      }
    }
    if (m.find("SubTasks") != m.end() && !m["SubTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubTasks"].type()) {
        GetTaskResponseBodyTaskSubTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubTasks"]));
        subTasks = make_shared<GetTaskResponseBodyTaskSubTasks>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTaskResponseBodyTaskTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTaskResponseBodyTaskTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetTaskResponseBodyTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetTaskResponseBodyTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetTaskResponseBodyTask() = default;
};
class GetTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTaskResponseBodyTask> task{};

  GetTaskResponseBody() {}

  explicit GetTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetTaskResponseBodyTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetTaskResponseBodyTask>(model1);
      }
    }
  }


  virtual ~GetTaskResponseBody() = default;
};
class GetTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskResponseBody> body{};

  GetTaskResponse() {}

  explicit GetTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskResponse() = default;
};
class GetTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetTaskInstanceRequest() {}

  explicit GetTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetTaskInstanceRequest() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskInstanceResponseBodyTaskInstanceDataSource() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceDataSource() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceInputsVariables() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceInputsVariables() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceInputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables>> variables{};

  GetTaskInstanceResponseBodyTaskInstanceInputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceInputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceOutputsVariables() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputsVariables() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables>> variables{};

  GetTaskInstanceResponseBodyTaskInstanceOutputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  GetTaskInstanceResponseBodyTaskInstanceRuntime() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceRuntime() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskInstanceResponseBodyTaskInstanceRuntimeResource() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceRuntimeResource() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  GetTaskInstanceResponseBodyTaskInstanceScript() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceScript() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceTags() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceTags() = default;
};
class GetTaskInstanceResponseBodyTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceRuntime> runtime{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceScript> script{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  GetTaskInstanceResponseBodyTaskInstance() {}

  explicit GetTaskInstanceResponseBodyTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskInstanceResponseBodyTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<GetTaskInstanceResponseBodyTaskInstanceInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetTaskInstanceResponseBodyTaskInstanceOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<GetTaskInstanceResponseBodyTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskInstanceResponseBodyTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<GetTaskInstanceResponseBodyTaskInstanceScript>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstance() = default;
};
class GetTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstance> taskInstance{};

  GetTaskInstanceResponseBody() {}

  explicit GetTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        GetTaskInstanceResponseBodyTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<GetTaskInstanceResponseBodyTaskInstance>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBody() = default;
};
class GetTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskInstanceResponseBody> body{};

  GetTaskInstanceResponse() {}

  explicit GetTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceResponse() = default;
};
class GetTaskInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> runNumber{};

  GetTaskInstanceLogRequest() {}

  explicit GetTaskInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
  }


  virtual ~GetTaskInstanceLogRequest() = default;
};
class GetTaskInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskInstanceLog{};

  GetTaskInstanceLogResponseBody() {}

  explicit GetTaskInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInstanceLog) {
      res["TaskInstanceLog"] = boost::any(*taskInstanceLog);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInstanceLog") != m.end() && !m["TaskInstanceLog"].empty()) {
      taskInstanceLog = make_shared<string>(boost::any_cast<string>(m["TaskInstanceLog"]));
    }
  }


  virtual ~GetTaskInstanceLogResponseBody() = default;
};
class GetTaskInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskInstanceLogResponseBody> body{};

  GetTaskInstanceLogResponse() {}

  explicit GetTaskInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceLogResponse() = default;
};
class GetWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<long> id{};

  GetWorkflowRequest() {}

  explicit GetWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetWorkflowRequest() = default;
};
class GetWorkflowResponseBodyWorkflowDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  GetWorkflowResponseBodyWorkflowDependencies() {}

  explicit GetWorkflowResponseBodyWorkflowDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowDependencies() = default;
};
class GetWorkflowResponseBodyWorkflowOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetWorkflowResponseBodyWorkflowOutputsTaskOutputs() {}

  explicit GetWorkflowResponseBodyWorkflowOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowOutputsTaskOutputs() = default;
};
class GetWorkflowResponseBodyWorkflowOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs>> taskOutputs{};

  GetWorkflowResponseBodyWorkflowOutputs() {}

  explicit GetWorkflowResponseBodyWorkflowOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs>>(expect1);
      }
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowOutputs() = default;
};
class GetWorkflowResponseBodyWorkflowTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetWorkflowResponseBodyWorkflowTags() {}

  explicit GetWorkflowResponseBodyWorkflowTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTags() = default;
};
class GetWorkflowResponseBodyWorkflowTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetWorkflowResponseBodyWorkflowTasksDataSource() {}

  explicit GetWorkflowResponseBodyWorkflowTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasksDataSource() = default;
};
class GetWorkflowResponseBodyWorkflowTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetWorkflowResponseBodyWorkflowTasksRuntimeResource() {}

  explicit GetWorkflowResponseBodyWorkflowTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasksRuntimeResource() = default;
};
class GetWorkflowResponseBodyWorkflowTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTasksRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetWorkflowResponseBodyWorkflowTasks() {}

  explicit GetWorkflowResponseBodyWorkflowTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetWorkflowResponseBodyWorkflowTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetWorkflowResponseBodyWorkflowTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetWorkflowResponseBodyWorkflowTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetWorkflowResponseBodyWorkflowTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasks() = default;
};
class GetWorkflowResponseBodyWorkflowTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetWorkflowResponseBodyWorkflowTrigger() {}

  explicit GetWorkflowResponseBodyWorkflowTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTrigger() = default;
};
class GetWorkflowResponseBodyWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<GetWorkflowResponseBodyWorkflowOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowTags>> tags{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowTasks>> tasks{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTrigger> trigger{};

  GetWorkflowResponseBodyWorkflow() {}

  explicit GetWorkflowResponseBodyWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<GetWorkflowResponseBodyWorkflowDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<GetWorkflowResponseBodyWorkflowDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetWorkflowResponseBodyWorkflowOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetWorkflowResponseBodyWorkflowOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetWorkflowResponseBodyWorkflowTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetWorkflowResponseBodyWorkflowTags>>(expect1);
      }
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<GetWorkflowResponseBodyWorkflowTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetWorkflowResponseBodyWorkflowTasks>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetWorkflowResponseBodyWorkflowTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetWorkflowResponseBodyWorkflowTrigger>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflow() = default;
};
class GetWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowResponseBodyWorkflow> workflow{};

  GetWorkflowResponseBody() {}

  explicit GetWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflow) {
      res["Workflow"] = workflow ? boost::any(workflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Workflow") != m.end() && !m["Workflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Workflow"].type()) {
        GetWorkflowResponseBodyWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Workflow"]));
        workflow = make_shared<GetWorkflowResponseBodyWorkflow>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponseBody() = default;
};
class GetWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowResponseBody> body{};

  GetWorkflowResponse() {}

  explicit GetWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponse() = default;
};
class GetWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> includeScriptContent{};
  shared_ptr<long> projectId{};

  GetWorkflowDefinitionRequest() {}

  explicit GetWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeScriptContent) {
      res["IncludeScriptContent"] = boost::any(*includeScriptContent);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IncludeScriptContent") != m.end() && !m["IncludeScriptContent"].empty()) {
      includeScriptContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeScriptContent"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetWorkflowDefinitionRequest() = default;
};
class GetWorkflowDefinitionResponseBodyWorkflowDefinition : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};
  shared_ptr<long> workflowId{};

  GetWorkflowDefinitionResponseBodyWorkflowDefinition() {}

  explicit GetWorkflowDefinitionResponseBodyWorkflowDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowDefinitionResponseBodyWorkflowDefinition() = default;
};
class GetWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowDefinitionResponseBodyWorkflowDefinition> workflowDefinition{};

  GetWorkflowDefinitionResponseBody() {}

  explicit GetWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowDefinition) {
      res["WorkflowDefinition"] = workflowDefinition ? boost::any(workflowDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowDefinition") != m.end() && !m["WorkflowDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowDefinition"].type()) {
        GetWorkflowDefinitionResponseBodyWorkflowDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowDefinition"]));
        workflowDefinition = make_shared<GetWorkflowDefinitionResponseBodyWorkflowDefinition>(model1);
      }
    }
  }


  virtual ~GetWorkflowDefinitionResponseBody() = default;
};
class GetWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowDefinitionResponseBody> body{};

  GetWorkflowDefinitionResponse() {}

  explicit GetWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowDefinitionResponse() = default;
};
class GetWorkflowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetWorkflowInstanceRequest() {}

  explicit GetWorkflowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetWorkflowInstanceRequest() = default;
};
class GetWorkflowInstanceResponseBodyWorkflowInstance : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetWorkflowInstanceResponseBodyWorkflowInstance() {}

  explicit GetWorkflowInstanceResponseBodyWorkflowInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowInstanceResponseBodyWorkflowInstance() = default;
};
class GetWorkflowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowInstanceResponseBodyWorkflowInstance> workflowInstance{};

  GetWorkflowInstanceResponseBody() {}

  explicit GetWorkflowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowInstance) {
      res["WorkflowInstance"] = workflowInstance ? boost::any(workflowInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowInstance") != m.end() && !m["WorkflowInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowInstance"].type()) {
        GetWorkflowInstanceResponseBodyWorkflowInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowInstance"]));
        workflowInstance = make_shared<GetWorkflowInstanceResponseBodyWorkflowInstance>(model1);
      }
    }
  }


  virtual ~GetWorkflowInstanceResponseBody() = default;
};
class GetWorkflowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowInstanceResponseBody> body{};

  GetWorkflowInstanceResponse() {}

  explicit GetWorkflowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowInstanceResponse() = default;
};
class GrantMemberProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  GrantMemberProjectRolesRequest() {}

  explicit GrantMemberProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GrantMemberProjectRolesRequest() = default;
};
class GrantMemberProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  GrantMemberProjectRolesShrinkRequest() {}

  explicit GrantMemberProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GrantMemberProjectRolesShrinkRequest() = default;
};
class GrantMemberProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantMemberProjectRolesResponseBody() {}

  explicit GrantMemberProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantMemberProjectRolesResponseBody() = default;
};
class GrantMemberProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantMemberProjectRolesResponseBody> body{};

  GrantMemberProjectRolesResponse() {}

  explicit GrantMemberProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantMemberProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantMemberProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~GrantMemberProjectRolesResponse() = default;
};
class ImportWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  ImportWorkflowDefinitionRequest() {}

  explicit ImportWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ImportWorkflowDefinitionRequest() = default;
};
class ImportWorkflowDefinitionResponseBodyAsyncJob : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<long> createTime{};
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<long> progress{};
  shared_ptr<string> response{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ImportWorkflowDefinitionResponseBodyAsyncJob() {}

  explicit ImportWorkflowDefinitionResponseBodyAsyncJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (response) {
      res["Response"] = boost::any(*response);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Response") != m.end() && !m["Response"].empty()) {
      response = make_shared<string>(boost::any_cast<string>(m["Response"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ImportWorkflowDefinitionResponseBodyAsyncJob() = default;
};
class ImportWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ImportWorkflowDefinitionResponseBodyAsyncJob> asyncJob{};
  shared_ptr<string> requestId{};

  ImportWorkflowDefinitionResponseBody() {}

  explicit ImportWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncJob) {
      res["AsyncJob"] = asyncJob ? boost::any(asyncJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncJob") != m.end() && !m["AsyncJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsyncJob"].type()) {
        ImportWorkflowDefinitionResponseBodyAsyncJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsyncJob"]));
        asyncJob = make_shared<ImportWorkflowDefinitionResponseBodyAsyncJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportWorkflowDefinitionResponseBody() = default;
};
class ImportWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportWorkflowDefinitionResponseBody> body{};

  ImportWorkflowDefinitionResponse() {}

  explicit ImportWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~ImportWorkflowDefinitionResponse() = default;
};
class ListAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> receiver{};
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<vector<string>> types{};

  ListAlertRulesRequest() {}

  explicit ListAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAlertRulesRequest() = default;
};
class ListAlertRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> receiver{};
  shared_ptr<string> taskIdsShrink{};
  shared_ptr<string> typesShrink{};

  ListAlertRulesShrinkRequest() {}

  explicit ListAlertRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListAlertRulesShrinkRequest() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError> error{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished> unFinished{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension> extension{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRules : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition> triggerCondition{};

  ListAlertRulesResponseBodyPagingInfoAlertRules() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRules() = default;
};
class ListAlertRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertRulesResponseBodyPagingInfoAlertRules>> alertRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAlertRulesResponseBodyPagingInfo() {}

  explicit ListAlertRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<ListAlertRulesResponseBodyPagingInfoAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertRulesResponseBodyPagingInfoAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<ListAlertRulesResponseBodyPagingInfoAlertRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfo() = default;
};
class ListAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListAlertRulesResponseBody() {}

  explicit ListAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListAlertRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListAlertRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertRulesResponseBody() = default;
};
class ListAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertRulesResponseBody> body{};

  ListAlertRulesResponse() {}

  explicit ListAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponse() = default;
};
class ListDIAlarmRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> jobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDIAlarmRulesRequest() {}

  explicit ListDIAlarmRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDIAlarmRulesRequest() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers>> notificationReceivers{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings> notificationSettings{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions>> triggerConditions{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules>> DIJobAlarmRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIAlarmRulesResponseBodyPagingInfo() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobAlarmRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobAlarmRules") != m.end() && !m["DIJobAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobAlarmRules"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobAlarmRules = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfo() = default;
};
class ListDIAlarmRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIAlarmRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIAlarmRulesResponseBody() {}

  explicit ListDIAlarmRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIAlarmRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIAlarmRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBody() = default;
};
class ListDIAlarmRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIAlarmRulesResponseBody> body{};

  ListDIAlarmRulesResponse() {}

  explicit ListDIAlarmRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIAlarmRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIAlarmRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponse() = default;
};
class ListDIJobEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListDIJobEventsRequest() {}

  explicit ListDIJobEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobEventsRequest() = default;
};
class ListDIJobEventsResponseBodyPagingInfoDIJobEvent : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> channels{};
  shared_ptr<string> createTime{};
  shared_ptr<string> detail{};
  shared_ptr<string> dstSql{};
  shared_ptr<string> dstTable{};
  shared_ptr<string> failoverMessage{};
  shared_ptr<string> id{};
  shared_ptr<string> severity{};
  shared_ptr<string> srcSql{};
  shared_ptr<string> srcTable{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListDIJobEventsResponseBodyPagingInfoDIJobEvent() {}

  explicit ListDIJobEventsResponseBodyPagingInfoDIJobEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (dstSql) {
      res["DstSql"] = boost::any(*dstSql);
    }
    if (dstTable) {
      res["DstTable"] = boost::any(*dstTable);
    }
    if (failoverMessage) {
      res["FailoverMessage"] = boost::any(*failoverMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (srcSql) {
      res["SrcSql"] = boost::any(*srcSql);
    }
    if (srcTable) {
      res["SrcTable"] = boost::any(*srcTable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("DstSql") != m.end() && !m["DstSql"].empty()) {
      dstSql = make_shared<string>(boost::any_cast<string>(m["DstSql"]));
    }
    if (m.find("DstTable") != m.end() && !m["DstTable"].empty()) {
      dstTable = make_shared<string>(boost::any_cast<string>(m["DstTable"]));
    }
    if (m.find("FailoverMessage") != m.end() && !m["FailoverMessage"].empty()) {
      failoverMessage = make_shared<string>(boost::any_cast<string>(m["FailoverMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("SrcSql") != m.end() && !m["SrcSql"].empty()) {
      srcSql = make_shared<string>(boost::any_cast<string>(m["SrcSql"]));
    }
    if (m.find("SrcTable") != m.end() && !m["SrcTable"].empty()) {
      srcTable = make_shared<string>(boost::any_cast<string>(m["SrcTable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDIJobEventsResponseBodyPagingInfoDIJobEvent() = default;
};
class ListDIJobEventsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent>> DIJobEvent{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIJobEventsResponseBodyPagingInfo() {}

  explicit ListDIJobEventsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobEvent) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobEvent"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobEvent") != m.end() && !m["DIJobEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobEvent"].type()) {
        vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobEventsResponseBodyPagingInfoDIJobEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobEvent = make_shared<vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobEventsResponseBodyPagingInfo() = default;
};
class ListDIJobEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobEventsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobEventsResponseBody() {}

  explicit ListDIJobEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobEventsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobEventsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobEventsResponseBody() = default;
};
class ListDIJobEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobEventsResponseBody> body{};

  ListDIJobEventsResponse() {}

  explicit ListDIJobEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobEventsResponse() = default;
};
class ListDIJobMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> metricName{};
  shared_ptr<long> startTime{};

  ListDIJobMetricsRequest() {}

  explicit ListDIJobMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MetricName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MetricName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      metricName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobMetricsRequest() = default;
};
class ListDIJobMetricsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> metricNameShrink{};
  shared_ptr<long> startTime{};

  ListDIJobMetricsShrinkRequest() {}

  explicit ListDIJobMetricsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (metricNameShrink) {
      res["MetricName"] = boost::any(*metricNameShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricNameShrink = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobMetricsShrinkRequest() = default;
};
class ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<double> value{};

  ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList() {}

  explicit ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList() = default;
};
class ListDIJobMetricsResponseBodyPagingInfoJobMetrics : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList>> seriesList{};

  ListDIJobMetricsResponseBodyPagingInfoJobMetrics() {}

  explicit ListDIJobMetricsResponseBodyPagingInfoJobMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (seriesList) {
      vector<boost::any> temp1;
      for(auto item1:*seriesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeriesList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SeriesList") != m.end() && !m["SeriesList"].empty()) {
      if (typeid(vector<boost::any>) == m["SeriesList"].type()) {
        vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeriesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seriesList = make_shared<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList>>(expect1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfoJobMetrics() = default;
};
class ListDIJobMetricsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics>> jobMetrics{};

  ListDIJobMetricsResponseBodyPagingInfo() {}

  explicit ListDIJobMetricsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*jobMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobMetrics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobMetrics") != m.end() && !m["JobMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["JobMetrics"].type()) {
        vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobMetricsResponseBodyPagingInfoJobMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobMetrics = make_shared<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics>>(expect1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfo() = default;
};
class ListDIJobMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobMetricsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobMetricsResponseBody() {}

  explicit ListDIJobMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobMetricsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobMetricsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobMetricsResponseBody() = default;
};
class ListDIJobMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobMetricsResponseBody> body{};

  ListDIJobMetricsResponse() {}

  explicit ListDIJobMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponse() = default;
};
class ListDIJobRunDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceDataSourceName{};
  shared_ptr<string> sourceDatabaseName{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<string> sourceTableName{};

  ListDIJobRunDetailsRequest() {}

  explicit ListDIJobRunDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceDataSourceName) {
      res["SourceDataSourceName"] = boost::any(*sourceDataSourceName);
    }
    if (sourceDatabaseName) {
      res["SourceDatabaseName"] = boost::any(*sourceDatabaseName);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceDataSourceName") != m.end() && !m["SourceDataSourceName"].empty()) {
      sourceDataSourceName = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceName"]));
    }
    if (m.find("SourceDatabaseName") != m.end() && !m["SourceDatabaseName"].empty()) {
      sourceDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceDatabaseName"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~ListDIJobRunDetailsRequest() = default;
};
class ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos : public Darabonba::Model {
public:
  shared_ptr<string> destinationDatabaseName{};
  shared_ptr<string> destinationDatasourceName{};
  shared_ptr<string> destinationSchemaName{};
  shared_ptr<string> destinationTableName{};
  shared_ptr<string> fullMigrationErrorMessage{};
  shared_ptr<string> fullMigrationStatus{};
  shared_ptr<long> offlineErrorRecords{};
  shared_ptr<long> offlineTotalBytes{};
  shared_ptr<long> offlineTotalRecords{};
  shared_ptr<string> realtimeMigrationErrorMessage{};
  shared_ptr<string> realtimeMigrationStatus{};
  shared_ptr<string> sourceDatabaseName{};
  shared_ptr<string> sourceDatasourceName{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> structureMigrationErrorMessage{};
  shared_ptr<string> structureMigrationStatus{};

  ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos() {}

  explicit ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDatabaseName) {
      res["DestinationDatabaseName"] = boost::any(*destinationDatabaseName);
    }
    if (destinationDatasourceName) {
      res["DestinationDatasourceName"] = boost::any(*destinationDatasourceName);
    }
    if (destinationSchemaName) {
      res["DestinationSchemaName"] = boost::any(*destinationSchemaName);
    }
    if (destinationTableName) {
      res["DestinationTableName"] = boost::any(*destinationTableName);
    }
    if (fullMigrationErrorMessage) {
      res["FullMigrationErrorMessage"] = boost::any(*fullMigrationErrorMessage);
    }
    if (fullMigrationStatus) {
      res["FullMigrationStatus"] = boost::any(*fullMigrationStatus);
    }
    if (offlineErrorRecords) {
      res["OfflineErrorRecords"] = boost::any(*offlineErrorRecords);
    }
    if (offlineTotalBytes) {
      res["OfflineTotalBytes"] = boost::any(*offlineTotalBytes);
    }
    if (offlineTotalRecords) {
      res["OfflineTotalRecords"] = boost::any(*offlineTotalRecords);
    }
    if (realtimeMigrationErrorMessage) {
      res["RealtimeMigrationErrorMessage"] = boost::any(*realtimeMigrationErrorMessage);
    }
    if (realtimeMigrationStatus) {
      res["RealtimeMigrationStatus"] = boost::any(*realtimeMigrationStatus);
    }
    if (sourceDatabaseName) {
      res["SourceDatabaseName"] = boost::any(*sourceDatabaseName);
    }
    if (sourceDatasourceName) {
      res["SourceDatasourceName"] = boost::any(*sourceDatasourceName);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (structureMigrationErrorMessage) {
      res["StructureMigrationErrorMessage"] = boost::any(*structureMigrationErrorMessage);
    }
    if (structureMigrationStatus) {
      res["StructureMigrationStatus"] = boost::any(*structureMigrationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDatabaseName") != m.end() && !m["DestinationDatabaseName"].empty()) {
      destinationDatabaseName = make_shared<string>(boost::any_cast<string>(m["DestinationDatabaseName"]));
    }
    if (m.find("DestinationDatasourceName") != m.end() && !m["DestinationDatasourceName"].empty()) {
      destinationDatasourceName = make_shared<string>(boost::any_cast<string>(m["DestinationDatasourceName"]));
    }
    if (m.find("DestinationSchemaName") != m.end() && !m["DestinationSchemaName"].empty()) {
      destinationSchemaName = make_shared<string>(boost::any_cast<string>(m["DestinationSchemaName"]));
    }
    if (m.find("DestinationTableName") != m.end() && !m["DestinationTableName"].empty()) {
      destinationTableName = make_shared<string>(boost::any_cast<string>(m["DestinationTableName"]));
    }
    if (m.find("FullMigrationErrorMessage") != m.end() && !m["FullMigrationErrorMessage"].empty()) {
      fullMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["FullMigrationErrorMessage"]));
    }
    if (m.find("FullMigrationStatus") != m.end() && !m["FullMigrationStatus"].empty()) {
      fullMigrationStatus = make_shared<string>(boost::any_cast<string>(m["FullMigrationStatus"]));
    }
    if (m.find("OfflineErrorRecords") != m.end() && !m["OfflineErrorRecords"].empty()) {
      offlineErrorRecords = make_shared<long>(boost::any_cast<long>(m["OfflineErrorRecords"]));
    }
    if (m.find("OfflineTotalBytes") != m.end() && !m["OfflineTotalBytes"].empty()) {
      offlineTotalBytes = make_shared<long>(boost::any_cast<long>(m["OfflineTotalBytes"]));
    }
    if (m.find("OfflineTotalRecords") != m.end() && !m["OfflineTotalRecords"].empty()) {
      offlineTotalRecords = make_shared<long>(boost::any_cast<long>(m["OfflineTotalRecords"]));
    }
    if (m.find("RealtimeMigrationErrorMessage") != m.end() && !m["RealtimeMigrationErrorMessage"].empty()) {
      realtimeMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["RealtimeMigrationErrorMessage"]));
    }
    if (m.find("RealtimeMigrationStatus") != m.end() && !m["RealtimeMigrationStatus"].empty()) {
      realtimeMigrationStatus = make_shared<string>(boost::any_cast<string>(m["RealtimeMigrationStatus"]));
    }
    if (m.find("SourceDatabaseName") != m.end() && !m["SourceDatabaseName"].empty()) {
      sourceDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceDatabaseName"]));
    }
    if (m.find("SourceDatasourceName") != m.end() && !m["SourceDatasourceName"].empty()) {
      sourceDatasourceName = make_shared<string>(boost::any_cast<string>(m["SourceDatasourceName"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("StructureMigrationErrorMessage") != m.end() && !m["StructureMigrationErrorMessage"].empty()) {
      structureMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["StructureMigrationErrorMessage"]));
    }
    if (m.find("StructureMigrationStatus") != m.end() && !m["StructureMigrationStatus"].empty()) {
      structureMigrationStatus = make_shared<string>(boost::any_cast<string>(m["StructureMigrationStatus"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos() = default;
};
class ListDIJobRunDetailsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos>> jobRunInfos{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListDIJobRunDetailsResponseBodyPagingInfo() {}

  explicit ListDIJobRunDetailsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobRunInfos) {
      vector<boost::any> temp1;
      for(auto item1:*jobRunInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobRunInfos"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobRunInfos") != m.end() && !m["JobRunInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["JobRunInfos"].type()) {
        vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobRunInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobRunInfos = make_shared<vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBodyPagingInfo() = default;
};
class ListDIJobRunDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobRunDetailsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobRunDetailsResponseBody() {}

  explicit ListDIJobRunDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobRunDetailsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobRunDetailsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBody() = default;
};
class ListDIJobRunDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobRunDetailsResponseBody> body{};

  ListDIJobRunDetailsResponse() {}

  explicit ListDIJobRunDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobRunDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobRunDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobRunDetailsResponse() = default;
};
class ListDIJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sourceDataSourceType{};

  ListDIJobsRequest() {}

  explicit ListDIJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
  }


  virtual ~ListDIJobsRequest() = default;
};
class ListDIJobsResponseBodyPagingInfoDIJobs : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<long> id{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> migrationType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sourceDataSourceType{};

  ListDIJobsResponseBodyPagingInfoDIJobs() {}

  explicit ListDIJobsResponseBodyPagingInfoDIJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
  }


  virtual ~ListDIJobsResponseBodyPagingInfoDIJobs() = default;
};
class ListDIJobsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobsResponseBodyPagingInfoDIJobs>> DIJobs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIJobsResponseBodyPagingInfo() {}

  explicit ListDIJobsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobs) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobs") != m.end() && !m["DIJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobs"].type()) {
        vector<ListDIJobsResponseBodyPagingInfoDIJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobsResponseBodyPagingInfoDIJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobs = make_shared<vector<ListDIJobsResponseBodyPagingInfoDIJobs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobsResponseBodyPagingInfo() = default;
};
class ListDIJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobsResponseBody() {}

  explicit ListDIJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobsResponseBody() = default;
};
class ListDIJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobsResponseBody> body{};

  ListDIJobsResponse() {}

  explicit ListDIJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobsResponse() = default;
};
class ListDataAssetTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> key{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDataAssetTagsRequest() {}

  explicit ListDataAssetTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDataAssetTagsRequest() = default;
};
class ListDataAssetTagsResponseBodyPagingInfoDataAssetTags : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> valueType{};
  shared_ptr<vector<string>> values{};

  ListDataAssetTagsResponseBodyPagingInfoDataAssetTags() {}

  explicit ListDataAssetTagsResponseBodyPagingInfoDataAssetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataAssetTagsResponseBodyPagingInfoDataAssetTags() = default;
};
class ListDataAssetTagsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags>> dataAssetTags{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataAssetTagsResponseBodyPagingInfo() {}

  explicit ListDataAssetTagsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetTags) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssetTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssetTags"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetTags") != m.end() && !m["DataAssetTags"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssetTags"].type()) {
        vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssetTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetTagsResponseBodyPagingInfoDataAssetTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssetTags = make_shared<vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataAssetTagsResponseBodyPagingInfo() = default;
};
class ListDataAssetTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataAssetTagsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataAssetTagsResponseBody() {}

  explicit ListDataAssetTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataAssetTagsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataAssetTagsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataAssetTagsResponseBody() = default;
};
class ListDataAssetTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataAssetTagsResponseBody> body{};

  ListDataAssetTagsResponse() {}

  explicit ListDataAssetTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataAssetTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataAssetTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataAssetTagsResponse() = default;
};
class ListDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDataAssetsRequestTags() {}

  explicit ListDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataAssetsRequestTags() = default;
};
class ListDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListDataAssetsRequestTags>> tags{};

  ListDataAssetsRequest() {}

  explicit ListDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListDataAssetsRequest() = default;
};
class ListDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  ListDataAssetsShrinkRequest() {}

  explicit ListDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListDataAssetsShrinkRequest() = default;
};
class ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataAssetId{};
  shared_ptr<string> key{};
  shared_ptr<string> tagSource{};
  shared_ptr<string> value{};

  ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings() {}

  explicit ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataAssetId) {
      res["DataAssetId"] = boost::any(*dataAssetId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagSource) {
      res["TagSource"] = boost::any(*tagSource);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataAssetId") != m.end() && !m["DataAssetId"].empty()) {
      dataAssetId = make_shared<string>(boost::any_cast<string>(m["DataAssetId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagSource") != m.end() && !m["TagSource"].empty()) {
      tagSource = make_shared<string>(boost::any_cast<string>(m["TagSource"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings() = default;
};
class ListDataAssetsResponseBodyPagingInfoDataAssets : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings>> dataAssetTagMappings{};
  shared_ptr<string> envType{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListDataAssetsResponseBodyPagingInfoDataAssets() {}

  explicit ListDataAssetsResponseBodyPagingInfoDataAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetTagMappings) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssetTagMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssetTagMappings"] = boost::any(temp1);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetTagMappings") != m.end() && !m["DataAssetTagMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssetTagMappings"].type()) {
        vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssetTagMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssetTagMappings = make_shared<vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings>>(expect1);
      }
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfoDataAssets() = default;
};
class ListDataAssetsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetsResponseBodyPagingInfoDataAssets>> dataAssets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataAssetsResponseBodyPagingInfo() {}

  explicit ListDataAssetsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssets) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssets"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssets") != m.end() && !m["DataAssets"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssets"].type()) {
        vector<ListDataAssetsResponseBodyPagingInfoDataAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsResponseBodyPagingInfoDataAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssets = make_shared<vector<ListDataAssetsResponseBodyPagingInfoDataAssets>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfo() = default;
};
class ListDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataAssetsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataAssetsResponseBody() {}

  explicit ListDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataAssetsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataAssetsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataAssetsResponseBody() = default;
};
class ListDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataAssetsResponseBody> body{};

  ListDataAssetsResponse() {}

  explicit ListDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataAssetsResponse() = default;
};
class ListDataQualityEvaluationTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizdateFrom{};
  shared_ptr<string> bizdateTo{};
  shared_ptr<long> createTimeFrom{};
  shared_ptr<long> createTimeTo{};
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> triggerClient{};
  shared_ptr<string> triggerClientId{};

  ListDataQualityEvaluationTaskInstancesRequest() {}

  explicit ListDataQualityEvaluationTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdateFrom) {
      res["BizdateFrom"] = boost::any(*bizdateFrom);
    }
    if (bizdateTo) {
      res["BizdateTo"] = boost::any(*bizdateTo);
    }
    if (createTimeFrom) {
      res["CreateTimeFrom"] = boost::any(*createTimeFrom);
    }
    if (createTimeTo) {
      res["CreateTimeTo"] = boost::any(*createTimeTo);
    }
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (triggerClient) {
      res["TriggerClient"] = boost::any(*triggerClient);
    }
    if (triggerClientId) {
      res["TriggerClientId"] = boost::any(*triggerClientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizdateFrom") != m.end() && !m["BizdateFrom"].empty()) {
      bizdateFrom = make_shared<string>(boost::any_cast<string>(m["BizdateFrom"]));
    }
    if (m.find("BizdateTo") != m.end() && !m["BizdateTo"].empty()) {
      bizdateTo = make_shared<string>(boost::any_cast<string>(m["BizdateTo"]));
    }
    if (m.find("CreateTimeFrom") != m.end() && !m["CreateTimeFrom"].empty()) {
      createTimeFrom = make_shared<long>(boost::any_cast<long>(m["CreateTimeFrom"]));
    }
    if (m.find("CreateTimeTo") != m.end() && !m["CreateTimeTo"].empty()) {
      createTimeTo = make_shared<long>(boost::any_cast<long>(m["CreateTimeTo"]));
    }
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TriggerClient") != m.end() && !m["TriggerClient"].empty()) {
      triggerClient = make_shared<string>(boost::any_cast<string>(m["TriggerClient"]));
    }
    if (m.find("TriggerClientId") != m.end() && !m["TriggerClientId"].empty()) {
      triggerClientId = make_shared<string>(boost::any_cast<string>(m["TriggerClientId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesRequest() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers>> nofiticationReceivers{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nofiticationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*nofiticationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NofiticationReceivers"] = boost::any(temp1);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NofiticationReceivers") != m.end() && !m["NofiticationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NofiticationReceivers"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NofiticationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nofiticationReceivers = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers>>(expect1);
      }
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications>> notifications{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget> target{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger> trigger{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask> task{};
  shared_ptr<string> triggerContext{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerContext) {
      res["TriggerContext"] = boost::any(*triggerContext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask>(model1);
      }
    }
    if (m.find("TriggerContext") != m.end() && !m["TriggerContext"].empty()) {
      triggerContext = make_shared<string>(boost::any_cast<string>(m["TriggerContext"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances>> dataQualityEvaluationTaskInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityEvaluationTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityEvaluationTaskInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskInstances") != m.end() && !m["DataQualityEvaluationTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityEvaluationTaskInstances"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityEvaluationTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityEvaluationTaskInstances = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityEvaluationTaskInstancesResponseBody() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBody() = default;
};
class ListDataQualityEvaluationTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBody> body{};

  ListDataQualityEvaluationTaskInstancesResponse() {}

  explicit ListDataQualityEvaluationTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityEvaluationTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponse() = default;
};
class ListDataQualityEvaluationTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};

  ListDataQualityEvaluationTasksRequest() {}

  explicit ListDataQualityEvaluationTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksRequest() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications>> notifications{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget> target{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger> trigger{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks>> dataQualityEvaluationTasks{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfo() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTasks) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityEvaluationTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityEvaluationTasks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTasks") != m.end() && !m["DataQualityEvaluationTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityEvaluationTasks"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityEvaluationTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityEvaluationTasks = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfo() = default;
};
class ListDataQualityEvaluationTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityEvaluationTasksResponseBody() {}

  explicit ListDataQualityEvaluationTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBody() = default;
};
class ListDataQualityEvaluationTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBody> body{};

  ListDataQualityEvaluationTasksResponse() {}

  explicit ListDataQualityEvaluationTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityEvaluationTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityEvaluationTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponse() = default;
};
class ListDataQualityResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizdateFrom{};
  shared_ptr<string> bizdateTo{};
  shared_ptr<long> createTimeFrom{};
  shared_ptr<long> createTimeTo{};
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<long> dataQualityEvaluationTaskInstanceId{};
  shared_ptr<long> dataQualityRuleId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListDataQualityResultsRequest() {}

  explicit ListDataQualityResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdateFrom) {
      res["BizdateFrom"] = boost::any(*bizdateFrom);
    }
    if (bizdateTo) {
      res["BizdateTo"] = boost::any(*bizdateTo);
    }
    if (createTimeFrom) {
      res["CreateTimeFrom"] = boost::any(*createTimeFrom);
    }
    if (createTimeTo) {
      res["CreateTimeTo"] = boost::any(*createTimeTo);
    }
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityEvaluationTaskInstanceId) {
      res["DataQualityEvaluationTaskInstanceId"] = boost::any(*dataQualityEvaluationTaskInstanceId);
    }
    if (dataQualityRuleId) {
      res["DataQualityRuleId"] = boost::any(*dataQualityRuleId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizdateFrom") != m.end() && !m["BizdateFrom"].empty()) {
      bizdateFrom = make_shared<string>(boost::any_cast<string>(m["BizdateFrom"]));
    }
    if (m.find("BizdateTo") != m.end() && !m["BizdateTo"].empty()) {
      bizdateTo = make_shared<string>(boost::any_cast<string>(m["BizdateTo"]));
    }
    if (m.find("CreateTimeFrom") != m.end() && !m["CreateTimeFrom"].empty()) {
      createTimeFrom = make_shared<long>(boost::any_cast<long>(m["CreateTimeFrom"]));
    }
    if (m.find("CreateTimeTo") != m.end() && !m["CreateTimeTo"].empty()) {
      createTimeTo = make_shared<long>(boost::any_cast<long>(m["CreateTimeTo"]));
    }
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityEvaluationTaskInstanceId") != m.end() && !m["DataQualityEvaluationTaskInstanceId"].empty()) {
      dataQualityEvaluationTaskInstanceId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskInstanceId"]));
    }
    if (m.find("DataQualityRuleId") != m.end() && !m["DataQualityRuleId"].empty()) {
      dataQualityRuleId = make_shared<long>(boost::any_cast<long>(m["DataQualityRuleId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataQualityResultsRequest() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkedValue{};
  shared_ptr<string> referencedValue{};
  shared_ptr<string> status{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkedValue) {
      res["CheckedValue"] = boost::any(*checkedValue);
    }
    if (referencedValue) {
      res["ReferencedValue"] = boost::any(*referencedValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckedValue") != m.end() && !m["CheckedValue"].empty()) {
      checkedValue = make_shared<string>(boost::any_cast<string>(m["CheckedValue"]));
    }
    if (m.find("ReferencedValue") != m.end() && !m["ReferencedValue"].empty()) {
      referencedValue = make_shared<string>(boost::any_cast<string>(m["ReferencedValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned> warned{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget> target{};
  shared_ptr<string> templateCode{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResults : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails>> details{};
  shared_ptr<long> id{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule> rule{};
  shared_ptr<string> sample{};
  shared_ptr<string> status{};
  shared_ptr<long> taskInstanceId{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResults() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule>(model1);
      }
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResults() = default;
};
class ListDataQualityResultsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults>> dataQualityResults{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityResultsResponseBodyPagingInfo() {}

  explicit ListDataQualityResultsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityResults) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityResults"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityResults") != m.end() && !m["DataQualityResults"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityResults"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityResults = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfo() = default;
};
class ListDataQualityResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityResultsResponseBody() {}

  explicit ListDataQualityResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityResultsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityResultsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBody() = default;
};
class ListDataQualityResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityResultsResponseBody> body{};

  ListDataQualityResultsResponse() {}

  explicit ListDataQualityResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityResultsResponse() = default;
};
class ListDataQualityRuleTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> creationSource{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListDataQualityRuleTemplatesRequest() {}

  explicit ListDataQualityRuleTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationSource) {
      res["CreationSource"] = boost::any(*creationSource);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationSource") != m.end() && !m["CreationSource"].empty()) {
      creationSource = make_shared<string>(boost::any_cast<string>(m["CreationSource"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesRequest() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates>> dataQualityRuleTemplates{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfo() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRuleTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRuleTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRuleTemplates"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRuleTemplates") != m.end() && !m["DataQualityRuleTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRuleTemplates"].type()) {
        vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRuleTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRuleTemplates = make_shared<vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfo() = default;
};
class ListDataQualityRuleTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityRuleTemplatesResponseBody() {}

  explicit ListDataQualityRuleTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBody() = default;
};
class ListDataQualityRuleTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityRuleTemplatesResponseBody> body{};

  ListDataQualityRuleTemplatesResponse() {}

  explicit ListDataQualityRuleTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityRuleTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityRuleTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponse() = default;
};
class ListDataQualityRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};

  ListDataQualityRulesRequest() {}

  explicit ListDataQualityRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~ListDataQualityRulesRequest() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget> target{};
  shared_ptr<string> templateCode{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRules() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRules() = default;
};
class ListDataQualityRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules>> dataQualityRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityRulesResponseBodyPagingInfo() {}

  explicit ListDataQualityRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRulesResponseBodyPagingInfoDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfo() = default;
};
class ListDataQualityRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityRulesResponseBody() {}

  explicit ListDataQualityRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBody() = default;
};
class ListDataQualityRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityRulesResponseBody> body{};

  ListDataQualityRulesResponse() {}

  explicit ListDataQualityRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityRulesResponse() = default;
};
class ListDataSourceSharedRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<long> targetProjectId{};

  ListDataSourceSharedRulesRequest() {}

  explicit ListDataSourceSharedRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesRequest() = default;
};
class ListDataSourceSharedRulesResponseBodyDataSourceSharedRules : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> sharedDataSourceName{};
  shared_ptr<string> sharedUser{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<long> targetProjectId{};

  ListDataSourceSharedRulesResponseBodyDataSourceSharedRules() {}

  explicit ListDataSourceSharedRulesResponseBodyDataSourceSharedRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sharedDataSourceName) {
      res["SharedDataSourceName"] = boost::any(*sharedDataSourceName);
    }
    if (sharedUser) {
      res["SharedUser"] = boost::any(*sharedUser);
    }
    if (sourceProjectId) {
      res["SourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SharedDataSourceName") != m.end() && !m["SharedDataSourceName"].empty()) {
      sharedDataSourceName = make_shared<string>(boost::any_cast<string>(m["SharedDataSourceName"]));
    }
    if (m.find("SharedUser") != m.end() && !m["SharedUser"].empty()) {
      sharedUser = make_shared<string>(boost::any_cast<string>(m["SharedUser"]));
    }
    if (m.find("SourceProjectId") != m.end() && !m["SourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["SourceProjectId"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesResponseBodyDataSourceSharedRules() = default;
};
class ListDataSourceSharedRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules>> dataSourceSharedRules{};
  shared_ptr<string> requestId{};

  ListDataSourceSharedRulesResponseBody() {}

  explicit ListDataSourceSharedRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceSharedRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataSourceSharedRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSourceSharedRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceSharedRules") != m.end() && !m["DataSourceSharedRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSourceSharedRules"].type()) {
        vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSourceSharedRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceSharedRulesResponseBodyDataSourceSharedRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSourceSharedRules = make_shared<vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesResponseBody() = default;
};
class ListDataSourceSharedRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourceSharedRulesResponseBody> body{};

  ListDataSourceSharedRulesResponse() {}

  explicit ListDataSourceSharedRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourceSharedRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourceSharedRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourceSharedRulesResponse() = default;
};
class ListDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tags{};
  shared_ptr<vector<string>> types{};

  ListDataSourcesRequest() {}

  explicit ListDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataSourcesRequest() = default;
};
class ListDataSourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tags{};
  shared_ptr<string> typesShrink{};

  ListDataSourcesShrinkRequest() {}

  explicit ListDataSourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListDataSourcesShrinkRequest() = default;
};
class ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource : public Darabonba::Model {
public:
  shared_ptr<boost::any> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> qualifiedName{};

  ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource() {}

  explicit ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource() = default;
};
class ListDataSourcesResponseBodyPagingInfoDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource>> dataSource{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListDataSourcesResponseBodyPagingInfoDataSources() {}

  explicit ListDataSourcesResponseBodyPagingInfoDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfoDataSources() = default;
};
class ListDataSourcesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourcesResponseBodyPagingInfoDataSources>> dataSources{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataSourcesResponseBodyPagingInfo() {}

  explicit ListDataSourcesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ListDataSourcesResponseBodyPagingInfoDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseBodyPagingInfoDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ListDataSourcesResponseBodyPagingInfoDataSources>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfo() = default;
};
class ListDataSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataSourcesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataSourcesResponseBody() {}

  explicit ListDataSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataSourcesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataSourcesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataSourcesResponseBody() = default;
};
class ListDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourcesResponseBody> body{};

  ListDataSourcesResponse() {}

  explicit ListDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourcesResponse() = default;
};
class ListDeploymentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};

  ListDeploymentsRequest() {}

  explicit ListDeploymentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDeploymentsRequest() = default;
};
class ListDeploymentsResponseBodyPagingInfoDeploymentsStages : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<long> step{};
  shared_ptr<string> type{};

  ListDeploymentsResponseBodyPagingInfoDeploymentsStages() {}

  explicit ListDeploymentsResponseBodyPagingInfoDeploymentsStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDeploymentsResponseBodyPagingInfoDeploymentsStages() = default;
};
class ListDeploymentsResponseBodyPagingInfoDeployments : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListDeploymentsResponseBodyPagingInfoDeploymentsStages>> stages{};
  shared_ptr<string> status{};

  ListDeploymentsResponseBodyPagingInfoDeployments() {}

  explicit ListDeploymentsResponseBodyPagingInfoDeployments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stages"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      if (typeid(vector<boost::any>) == m["Stages"].type()) {
        vector<ListDeploymentsResponseBodyPagingInfoDeploymentsStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeploymentsResponseBodyPagingInfoDeploymentsStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<ListDeploymentsResponseBodyPagingInfoDeploymentsStages>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDeploymentsResponseBodyPagingInfoDeployments() = default;
};
class ListDeploymentsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeploymentsResponseBodyPagingInfoDeployments>> deployments{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListDeploymentsResponseBodyPagingInfo() {}

  explicit ListDeploymentsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployments) {
      vector<boost::any> temp1;
      for(auto item1:*deployments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Deployments"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deployments") != m.end() && !m["Deployments"].empty()) {
      if (typeid(vector<boost::any>) == m["Deployments"].type()) {
        vector<ListDeploymentsResponseBodyPagingInfoDeployments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Deployments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeploymentsResponseBodyPagingInfoDeployments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployments = make_shared<vector<ListDeploymentsResponseBodyPagingInfoDeployments>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDeploymentsResponseBodyPagingInfo() = default;
};
class ListDeploymentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDeploymentsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDeploymentsResponseBody() {}

  explicit ListDeploymentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDeploymentsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDeploymentsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeploymentsResponseBody() = default;
};
class ListDeploymentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeploymentsResponseBody> body{};

  ListDeploymentsResponse() {}

  explicit ListDeploymentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeploymentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeploymentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeploymentsResponse() = default;
};
class ListDownstreamTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDownstreamTaskInstancesRequest() {}

  explicit ListDownstreamTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesRequest() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime> runtime{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance> taskInstance{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance>(model1);
      }
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stepType{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances>> downstreamTaskInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};

  ListDownstreamTaskInstancesResponseBodyPagingInfo() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downstreamTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*downstreamTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownstreamTaskInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownstreamTaskInstances") != m.end() && !m["DownstreamTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DownstreamTaskInstances"].type()) {
        vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownstreamTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downstreamTaskInstances = make_shared<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfo() = default;
};
class ListDownstreamTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDownstreamTaskInstancesResponseBody() {}

  explicit ListDownstreamTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBody() = default;
};
class ListDownstreamTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDownstreamTaskInstancesResponseBody> body{};

  ListDownstreamTaskInstancesResponse() {}

  explicit ListDownstreamTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDownstreamTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDownstreamTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDownstreamTaskInstancesResponse() = default;
};
class ListDownstreamTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListDownstreamTasksRequest() {}

  explicit ListDownstreamTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListDownstreamTasksRequest() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask> task{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask>(model1);
      }
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListDownstreamTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> stepType{};
  shared_ptr<long> timeout{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListDownstreamTasksResponseBodyPagingInfoTasks() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasks() = default;
};
class ListDownstreamTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks>> downstreamTasks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListDownstreamTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListDownstreamTasksResponseBodyPagingInfo() {}

  explicit ListDownstreamTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downstreamTasks) {
      vector<boost::any> temp1;
      for(auto item1:*downstreamTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownstreamTasks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownstreamTasks") != m.end() && !m["DownstreamTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["DownstreamTasks"].type()) {
        vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownstreamTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downstreamTasks = make_shared<vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListDownstreamTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListDownstreamTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfo() = default;
};
class ListDownstreamTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDownstreamTasksResponseBody() {}

  explicit ListDownstreamTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDownstreamTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDownstreamTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBody() = default;
};
class ListDownstreamTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDownstreamTasksResponseBody> body{};

  ListDownstreamTasksResponse() {}

  explicit ListDownstreamTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDownstreamTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDownstreamTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDownstreamTasksResponse() = default;
};
class ListFunctionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListFunctionsRequest() {}

  explicit ListFunctionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsRequest() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListFunctionsResponseBodyPagingInfoFunctionsDataSource() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsDataSource() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime> runtime{};

  ListFunctionsResponseBodyPagingInfoFunctionsScript() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsScript() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctions : public Darabonba::Model {
public:
  shared_ptr<string> armResource{};
  shared_ptr<string> className{};
  shared_ptr<string> commandDescription{};
  shared_ptr<long> createTime{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsDataSource> dataSource{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> description{};
  shared_ptr<string> embeddedCode{};
  shared_ptr<string> embeddedCodeType{};
  shared_ptr<string> embeddedResourceType{};
  shared_ptr<string> exampleDescription{};
  shared_ptr<string> fileResource{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<long> projectId{};
  shared_ptr<string> returnValueDescription{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource> runtimeResource{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsScript> script{};
  shared_ptr<string> type{};

  ListFunctionsResponseBodyPagingInfoFunctions() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armResource) {
      res["ArmResource"] = boost::any(*armResource);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (commandDescription) {
      res["CommandDescription"] = boost::any(*commandDescription);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (embeddedCode) {
      res["EmbeddedCode"] = boost::any(*embeddedCode);
    }
    if (embeddedCodeType) {
      res["EmbeddedCodeType"] = boost::any(*embeddedCodeType);
    }
    if (embeddedResourceType) {
      res["EmbeddedResourceType"] = boost::any(*embeddedResourceType);
    }
    if (exampleDescription) {
      res["ExampleDescription"] = boost::any(*exampleDescription);
    }
    if (fileResource) {
      res["FileResource"] = boost::any(*fileResource);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (returnValueDescription) {
      res["ReturnValueDescription"] = boost::any(*returnValueDescription);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmResource") != m.end() && !m["ArmResource"].empty()) {
      armResource = make_shared<string>(boost::any_cast<string>(m["ArmResource"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("CommandDescription") != m.end() && !m["CommandDescription"].empty()) {
      commandDescription = make_shared<string>(boost::any_cast<string>(m["CommandDescription"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsDataSource>(model1);
      }
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EmbeddedCode") != m.end() && !m["EmbeddedCode"].empty()) {
      embeddedCode = make_shared<string>(boost::any_cast<string>(m["EmbeddedCode"]));
    }
    if (m.find("EmbeddedCodeType") != m.end() && !m["EmbeddedCodeType"].empty()) {
      embeddedCodeType = make_shared<string>(boost::any_cast<string>(m["EmbeddedCodeType"]));
    }
    if (m.find("EmbeddedResourceType") != m.end() && !m["EmbeddedResourceType"].empty()) {
      embeddedResourceType = make_shared<string>(boost::any_cast<string>(m["EmbeddedResourceType"]));
    }
    if (m.find("ExampleDescription") != m.end() && !m["ExampleDescription"].empty()) {
      exampleDescription = make_shared<string>(boost::any_cast<string>(m["ExampleDescription"]));
    }
    if (m.find("FileResource") != m.end() && !m["FileResource"].empty()) {
      fileResource = make_shared<string>(boost::any_cast<string>(m["FileResource"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ReturnValueDescription") != m.end() && !m["ReturnValueDescription"].empty()) {
      returnValueDescription = make_shared<string>(boost::any_cast<string>(m["ReturnValueDescription"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsScript>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctions() = default;
};
class ListFunctionsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListFunctionsResponseBodyPagingInfoFunctions>> functions{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFunctionsResponseBodyPagingInfo() {}

  explicit ListFunctionsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functions) {
      vector<boost::any> temp1;
      for(auto item1:*functions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Functions"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      if (typeid(vector<boost::any>) == m["Functions"].type()) {
        vector<ListFunctionsResponseBodyPagingInfoFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Functions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFunctionsResponseBodyPagingInfoFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functions = make_shared<vector<ListFunctionsResponseBodyPagingInfoFunctions>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfo() = default;
};
class ListFunctionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFunctionsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListFunctionsResponseBody() {}

  explicit ListFunctionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListFunctionsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListFunctionsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFunctionsResponseBody() = default;
};
class ListFunctionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFunctionsResponseBody> body{};

  ListFunctionsResponse() {}

  explicit ListFunctionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFunctionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFunctionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFunctionsResponse() = default;
};
class ListNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sortBy{};

  ListNetworksRequest() {}

  explicit ListNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListNetworksRequest() = default;
};
class ListNetworksResponseBodyPagingInfoNetworkList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  ListNetworksResponseBodyPagingInfoNetworkList() {}

  explicit ListNetworksResponseBodyPagingInfoNetworkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ListNetworksResponseBodyPagingInfoNetworkList() = default;
};
class ListNetworksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworksResponseBodyPagingInfoNetworkList>> networkList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListNetworksResponseBodyPagingInfo() {}

  explicit ListNetworksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkList) {
      vector<boost::any> temp1;
      for(auto item1:*networkList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkList") != m.end() && !m["NetworkList"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkList"].type()) {
        vector<ListNetworksResponseBodyPagingInfoNetworkList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworksResponseBodyPagingInfoNetworkList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkList = make_shared<vector<ListNetworksResponseBodyPagingInfoNetworkList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNetworksResponseBodyPagingInfo() = default;
};
class ListNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNetworksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListNetworksResponseBody() {}

  explicit ListNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNetworksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNetworksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListNetworksResponseBody() = default;
};
class ListNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworksResponseBody> body{};

  ListNetworksResponse() {}

  explicit ListNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworksResponse() = default;
};
class ListNodeDependenciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListNodeDependenciesRequest() {}

  explicit ListNodeDependenciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListNodeDependenciesRequest() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListNodeDependenciesResponseBodyPagingInfoNodesDataSource() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesDataSource() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables>> tables{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables>> variables{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables>> tables{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables>> variables{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime> runtime{};

  ListNodeDependenciesResponseBodyPagingInfoNodesScript() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesScript() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> instanceMode{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<long> timeout{};

  ListNodeDependenciesResponseBodyPagingInfoNodesStrategy() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesStrategy() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesTags() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesTags() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListNodeDependenciesResponseBodyPagingInfoNodesTrigger() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesTrigger() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodes : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource> runtimeResource{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesScript> script{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesStrategy> strategy{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesTrigger> trigger{};

  ListNodeDependenciesResponseBodyPagingInfoNodes() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesScript>(model1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesStrategy>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesTrigger>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodes() = default;
};
class ListNodeDependenciesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodes>> nodes{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListNodeDependenciesResponseBodyPagingInfo() {}

  explicit ListNodeDependenciesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodes>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfo() = default;
};
class ListNodeDependenciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListNodeDependenciesResponseBody() {}

  explicit ListNodeDependenciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNodeDependenciesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNodeDependenciesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBody() = default;
};
class ListNodeDependenciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodeDependenciesResponseBody> body{};

  ListNodeDependenciesResponse() {}

  explicit ListNodeDependenciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeDependenciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeDependenciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> containerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> rerunMode{};
  shared_ptr<string> scene{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<long>(boost::any_cast<long>(m["ContainerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseBodyPagingInfoNodesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListNodesResponseBodyPagingInfoNodesDataSource() {}

  explicit ListNodesResponseBodyPagingInfoNodesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesDataSource() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodesResponseBodyPagingInfoNodesInputsTables() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsTables() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodesResponseBodyPagingInfoNodesInputsVariablesNode() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsVariablesNode() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesInputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesInputsVariables() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodesResponseBodyPagingInfoNodesInputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodesResponseBodyPagingInfoNodesInputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsVariables() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsTables>> tables{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsVariables>> variables{};

  ListNodesResponseBodyPagingInfoNodesInputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodesResponseBodyPagingInfoNodesOutputsTables() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsTables() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesOutputsVariables() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsVariables() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsTables>> tables{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables>> variables{};

  ListNodesResponseBodyPagingInfoNodesOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  ListNodesResponseBodyPagingInfoNodesRuntimeResource() {}

  explicit ListNodesResponseBodyPagingInfoNodesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesRuntimeResource() = default;
};
class ListNodesResponseBodyPagingInfoNodesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListNodesResponseBodyPagingInfoNodesScriptRuntime() {}

  explicit ListNodesResponseBodyPagingInfoNodesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesScriptRuntime() = default;
};
class ListNodesResponseBodyPagingInfoNodesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesScriptRuntime> runtime{};

  ListNodesResponseBodyPagingInfoNodesScript() {}

  explicit ListNodesResponseBodyPagingInfoNodesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListNodesResponseBodyPagingInfoNodesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListNodesResponseBodyPagingInfoNodesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesScript() = default;
};
class ListNodesResponseBodyPagingInfoNodesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> instanceMode{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<long> timeout{};

  ListNodesResponseBodyPagingInfoNodesStrategy() {}

  explicit ListNodesResponseBodyPagingInfoNodesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesStrategy() = default;
};
class ListNodesResponseBodyPagingInfoNodesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesTags() {}

  explicit ListNodesResponseBodyPagingInfoNodesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesTags() = default;
};
class ListNodesResponseBodyPagingInfoNodesTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListNodesResponseBodyPagingInfoNodesTrigger() {}

  explicit ListNodesResponseBodyPagingInfoNodesTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesTrigger() = default;
};
class ListNodesResponseBodyPagingInfoNodes : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesRuntimeResource> runtimeResource{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesScript> script{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesStrategy> strategy{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesTrigger> trigger{};

  ListNodesResponseBodyPagingInfoNodes() {}

  explicit ListNodesResponseBodyPagingInfoNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListNodesResponseBodyPagingInfoNodesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListNodesResponseBodyPagingInfoNodesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ListNodesResponseBodyPagingInfoNodesInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ListNodesResponseBodyPagingInfoNodesInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ListNodesResponseBodyPagingInfoNodesOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ListNodesResponseBodyPagingInfoNodesOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListNodesResponseBodyPagingInfoNodesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListNodesResponseBodyPagingInfoNodesRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListNodesResponseBodyPagingInfoNodesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListNodesResponseBodyPagingInfoNodesScript>(model1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListNodesResponseBodyPagingInfoNodesStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListNodesResponseBodyPagingInfoNodesStrategy>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListNodesResponseBodyPagingInfoNodesTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListNodesResponseBodyPagingInfoNodesTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListNodesResponseBodyPagingInfoNodesTrigger>(model1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodes() = default;
};
class ListNodesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodes>> nodes{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListNodesResponseBodyPagingInfo() {}

  explicit ListNodesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseBodyPagingInfoNodes>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfo() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNodesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNodesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNodesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListProjectMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<vector<string>> userIds{};

  ListProjectMembersRequest() {}

  explicit ListProjectMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectMembersRequest() = default;
};
class ListProjectMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userIdsShrink{};

  ListProjectMembersShrinkRequest() {}

  explicit ListProjectMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~ListProjectMembersShrinkRequest() = default;
};
class ListProjectMembersResponseBodyPagingInfoProjectMembersRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListProjectMembersResponseBodyPagingInfoProjectMembersRoles() {}

  explicit ListProjectMembersResponseBodyPagingInfoProjectMembersRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfoProjectMembersRoles() = default;
};
class ListProjectMembersResponseBodyPagingInfoProjectMembers : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles>> roles{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  ListProjectMembersResponseBodyPagingInfoProjectMembers() {}

  explicit ListProjectMembersResponseBodyPagingInfoProjectMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyPagingInfoProjectMembersRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfoProjectMembers() = default;
};
class ListProjectMembersResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProjectMembersResponseBodyPagingInfoProjectMembers>> projectMembers{};
  shared_ptr<long> totalCount{};

  ListProjectMembersResponseBodyPagingInfo() {}

  explicit ListProjectMembersResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectMembers) {
      vector<boost::any> temp1;
      for(auto item1:*projectMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectMembers"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectMembers") != m.end() && !m["ProjectMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectMembers"].type()) {
        vector<ListProjectMembersResponseBodyPagingInfoProjectMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyPagingInfoProjectMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectMembers = make_shared<vector<ListProjectMembersResponseBodyPagingInfoProjectMembers>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfo() = default;
};
class ListProjectMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectMembersResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectMembersResponseBody() {}

  explicit ListProjectMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectMembersResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectMembersResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectMembersResponseBody() = default;
};
class ListProjectMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectMembersResponseBody> body{};

  ListProjectMembersResponse() {}

  explicit ListProjectMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponse() = default;
};
class ListProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> codes{};
  shared_ptr<vector<string>> names{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesRequest() {}

  explicit ListProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codes) {
      res["Codes"] = boost::any(*codes);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Codes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Codes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      codes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      names = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesRequest() = default;
};
class ListProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> codesShrink{};
  shared_ptr<string> namesShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesShrinkRequest() {}

  explicit ListProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codesShrink) {
      res["Codes"] = boost::any(*codesShrink);
    }
    if (namesShrink) {
      res["Names"] = boost::any(*namesShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      codesShrink = make_shared<string>(boost::any_cast<string>(m["Codes"]));
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      namesShrink = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesShrinkRequest() = default;
};
class ListProjectRolesResponseBodyPagingInfoProjectRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesResponseBodyPagingInfoProjectRoles() {}

  explicit ListProjectRolesResponseBodyPagingInfoProjectRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesResponseBodyPagingInfoProjectRoles() = default;
};
class ListProjectRolesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<vector<ListProjectRolesResponseBodyPagingInfoProjectRoles>> projectRoles{};
  shared_ptr<string> totalCount{};

  ListProjectRolesResponseBodyPagingInfo() {}

  explicit ListProjectRolesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectRoles) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoles"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ProjectRoles") != m.end() && !m["ProjectRoles"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoles"].type()) {
        vector<ListProjectRolesResponseBodyPagingInfoProjectRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectRolesResponseBodyPagingInfoProjectRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoles = make_shared<vector<ListProjectRolesResponseBodyPagingInfoProjectRoles>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectRolesResponseBodyPagingInfo() = default;
};
class ListProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectRolesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectRolesResponseBody() {}

  explicit ListProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectRolesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectRolesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectRolesResponseBody() = default;
};
class ListProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectRolesResponseBody> body{};

  ListProjectRolesResponse() {}

  explicit ListProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectRolesResponse() = default;
};
class ListProjectsRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListProjectsRequestAliyunResourceTags() {}

  explicit ListProjectsRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListProjectsRequestAliyunResourceTags() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListProjectsRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<vector<string>> names{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListProjectsRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListProjectsRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      names = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> namesShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsShrinkRequest() {}

  explicit ListProjectsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (namesShrink) {
      res["Names"] = boost::any(*namesShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      namesShrink = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsShrinkRequest() = default;
};
class ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags() {}

  explicit ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags() = default;
};
class ListProjectsResponseBodyPagingInfoProjects : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsResponseBodyPagingInfoProjects() {}

  explicit ListProjectsResponseBodyPagingInfoProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfoProjects() = default;
};
class ListProjectsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProjectsResponseBodyPagingInfoProjects>> projects{};
  shared_ptr<long> totalCount{};

  ListProjectsResponseBodyPagingInfo() {}

  explicit ListProjectsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<ListProjectsResponseBodyPagingInfoProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyPagingInfoProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<ListProjectsResponseBodyPagingInfoProjects>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfo() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListResourceGroupsRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListResourceGroupsRequestAliyunResourceTags() {}

  explicit ListResourceGroupsRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListResourceGroupsRequestAliyunResourceTags() = default;
};
class ListResourceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListResourceGroupsRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> resourceGroupTypes{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> statuses{};

  ListResourceGroupsRequest() {}

  explicit ListResourceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupTypes) {
      res["ResourceGroupTypes"] = boost::any(*resourceGroupTypes);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListResourceGroupsRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListResourceGroupsRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupTypes") != m.end() && !m["ResourceGroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceGroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceGroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceGroupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListResourceGroupsRequest() = default;
};
class ListResourceGroupsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupTypesShrink{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> statusesShrink{};

  ListResourceGroupsShrinkRequest() {}

  explicit ListResourceGroupsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupTypesShrink) {
      res["ResourceGroupTypes"] = boost::any(*resourceGroupTypesShrink);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (statusesShrink) {
      res["Statuses"] = boost::any(*statusesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupTypes") != m.end() && !m["ResourceGroupTypes"].empty()) {
      resourceGroupTypesShrink = make_shared<string>(boost::any_cast<string>(m["ResourceGroupTypes"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statusesShrink = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
  }


  virtual ~ListResourceGroupsShrinkRequest() = default;
};
class ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> standard{};

  ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec() {}

  explicit ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (standard) {
      res["Standard"] = boost::any(*standard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Standard") != m.end() && !m["Standard"].empty()) {
      standard = make_shared<string>(boost::any_cast<string>(m["Standard"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec() = default;
};
class ListResourceGroupsResponseBodyPagingInfoResourceGroupList : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> defaultVpcId{};
  shared_ptr<string> defaultVswicthId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec> spec{};
  shared_ptr<string> status{};

  ListResourceGroupsResponseBodyPagingInfoResourceGroupList() {}

  explicit ListResourceGroupsResponseBodyPagingInfoResourceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (defaultVpcId) {
      res["DefaultVpcId"] = boost::any(*defaultVpcId);
    }
    if (defaultVswicthId) {
      res["DefaultVswicthId"] = boost::any(*defaultVswicthId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DefaultVpcId") != m.end() && !m["DefaultVpcId"].empty()) {
      defaultVpcId = make_shared<string>(boost::any_cast<string>(m["DefaultVpcId"]));
    }
    if (m.find("DefaultVswicthId") != m.end() && !m["DefaultVswicthId"].empty()) {
      defaultVswicthId = make_shared<string>(boost::any_cast<string>(m["DefaultVswicthId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfoResourceGroupList() = default;
};
class ListResourceGroupsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList>> resourceGroupList{};
  shared_ptr<long> totalCount{};

  ListResourceGroupsResponseBodyPagingInfo() {}

  explicit ListResourceGroupsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceGroupList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceGroupList"].type()) {
        vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsResponseBodyPagingInfoResourceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceGroupList = make_shared<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfo() = default;
};
class ListResourceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourceGroupsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListResourceGroupsResponseBody() {}

  explicit ListResourceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListResourceGroupsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListResourceGroupsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListResourceGroupsResponseBody() = default;
};
class ListResourceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceGroupsResponseBody> body{};

  ListResourceGroupsResponse() {}

  explicit ListResourceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceGroupsResponse() = default;
};
class ListResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListResourcesRequest() {}

  explicit ListResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesRequest() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListResourcesResponseBodyPagingInfoResourcesDataSource() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesDataSource() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListResourcesResponseBodyPagingInfoResourcesScriptRuntime() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesScriptRuntime() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesScriptRuntime> runtime{};

  ListResourcesResponseBodyPagingInfoResourcesScript() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListResourcesResponseBodyPagingInfoResourcesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesScript() = default;
};
class ListResourcesResponseBodyPagingInfoResources : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesDataSource> dataSource{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesScript> script{};
  shared_ptr<string> sourcePath{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetPath{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  ListResourcesResponseBodyPagingInfoResources() {}

  explicit ListResourcesResponseBodyPagingInfoResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourcePath) {
      res["SourcePath"] = boost::any(*sourcePath);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetPath) {
      res["TargetPath"] = boost::any(*targetPath);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListResourcesResponseBodyPagingInfoResourcesDataSource>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListResourcesResponseBodyPagingInfoResourcesScript>(model1);
      }
    }
    if (m.find("SourcePath") != m.end() && !m["SourcePath"].empty()) {
      sourcePath = make_shared<string>(boost::any_cast<string>(m["SourcePath"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetPath") != m.end() && !m["TargetPath"].empty()) {
      targetPath = make_shared<string>(boost::any_cast<string>(m["TargetPath"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResources() = default;
};
class ListResourcesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListResourcesResponseBodyPagingInfoResources>> resources{};
  shared_ptr<long> totalCount{};

  ListResourcesResponseBodyPagingInfo() {}

  explicit ListResourcesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<ListResourcesResponseBodyPagingInfoResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcesResponseBodyPagingInfoResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<ListResourcesResponseBodyPagingInfoResources>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfo() = default;
};
class ListResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourcesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListResourcesResponseBody() {}

  explicit ListResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListResourcesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListResourcesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListResourcesResponseBody() = default;
};
class ListResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcesResponseBody> body{};

  ListResourcesResponse() {}

  explicit ListResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcesResponse() = default;
};
class ListRoutesRequest : public Darabonba::Model {
public:
  shared_ptr<long> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sortBy{};

  ListRoutesRequest() {}

  explicit ListRoutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListRoutesRequest() = default;
};
class ListRoutesResponseBodyPagingInfoRouteList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  ListRoutesResponseBodyPagingInfoRouteList() {}

  explicit ListRoutesResponseBodyPagingInfoRouteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListRoutesResponseBodyPagingInfoRouteList() = default;
};
class ListRoutesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListRoutesResponseBodyPagingInfoRouteList>> routeList{};
  shared_ptr<long> totalCount{};

  ListRoutesResponseBodyPagingInfo() {}

  explicit ListRoutesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (routeList) {
      vector<boost::any> temp1;
      for(auto item1:*routeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RouteList") != m.end() && !m["RouteList"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteList"].type()) {
        vector<ListRoutesResponseBodyPagingInfoRouteList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoutesResponseBodyPagingInfoRouteList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeList = make_shared<vector<ListRoutesResponseBodyPagingInfoRouteList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRoutesResponseBodyPagingInfo() = default;
};
class ListRoutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRoutesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListRoutesResponseBody() {}

  explicit ListRoutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListRoutesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListRoutesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRoutesResponseBody() = default;
};
class ListRoutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRoutesResponseBody> body{};

  ListRoutesResponse() {}

  explicit ListRoutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoutesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoutesResponse() = default;
};
class ListTaskInstanceOperationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListTaskInstanceOperationLogsRequest() {}

  explicit ListTaskInstanceOperationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsRequest() = default;
};
class ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> operationContent{};
  shared_ptr<long> operationSeq{};
  shared_ptr<long> taskInstanceId{};
  shared_ptr<string> user{};

  ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs() {}

  explicit ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (operationContent) {
      res["OperationContent"] = boost::any(*operationContent);
    }
    if (operationSeq) {
      res["OperationSeq"] = boost::any(*operationSeq);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("OperationContent") != m.end() && !m["OperationContent"].empty()) {
      operationContent = make_shared<string>(boost::any_cast<string>(m["OperationContent"]));
    }
    if (m.find("OperationSeq") != m.end() && !m["OperationSeq"].empty()) {
      operationSeq = make_shared<long>(boost::any_cast<long>(m["OperationSeq"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs() = default;
};
class ListTaskInstanceOperationLogsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs>> operationLogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTaskInstanceOperationLogsResponseBodyPagingInfo() {}

  explicit ListTaskInstanceOperationLogsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLogs) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLogs") != m.end() && !m["OperationLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogs"].type()) {
        vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogs = make_shared<vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBodyPagingInfo() = default;
};
class ListTaskInstanceOperationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskInstanceOperationLogsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskInstanceOperationLogsResponseBody() {}

  explicit ListTaskInstanceOperationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskInstanceOperationLogsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskInstanceOperationLogsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBody() = default;
};
class ListTaskInstanceOperationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskInstanceOperationLogsResponseBody> body{};

  ListTaskInstanceOperationLogsResponse() {}

  explicit ListTaskInstanceOperationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskInstanceOperationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskInstanceOperationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponse() = default;
};
class ListTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizdate{};
  shared_ptr<long> id{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> taskId{};
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};

  ListTaskInstancesRequest() {}

  explicit ListTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
  }


  virtual ~ListTaskInstancesRequest() = default;
};
class ListTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizdate{};
  shared_ptr<long> id{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskIdsShrink{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};

  ListTaskInstancesShrinkRequest() {}

  explicit ListTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
  }


  virtual ~ListTaskInstancesShrinkRequest() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};

  ListTaskInstancesResponseBodyPagingInfo() {}

  explicit ListTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfo() = default;
};
class ListTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskInstancesResponseBody() {}

  explicit ListTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBody() = default;
};
class ListTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskInstancesResponseBody> body{};

  ListTaskInstancesResponse() {}

  explicit ListTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskInstancesResponse() = default;
};
class ListTaskOperationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListTaskOperationLogsRequest() {}

  explicit ListTaskOperationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListTaskOperationLogsRequest() = default;
};
class ListTaskOperationLogsResponseBodyPagingInfoOperationLogs : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> operationContent{};
  shared_ptr<long> operationSeq{};
  shared_ptr<long> taskId{};
  shared_ptr<string> user{};

  ListTaskOperationLogsResponseBodyPagingInfoOperationLogs() {}

  explicit ListTaskOperationLogsResponseBodyPagingInfoOperationLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (operationContent) {
      res["OperationContent"] = boost::any(*operationContent);
    }
    if (operationSeq) {
      res["OperationSeq"] = boost::any(*operationSeq);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("OperationContent") != m.end() && !m["OperationContent"].empty()) {
      operationContent = make_shared<string>(boost::any_cast<string>(m["OperationContent"]));
    }
    if (m.find("OperationSeq") != m.end() && !m["OperationSeq"].empty()) {
      operationSeq = make_shared<long>(boost::any_cast<long>(m["OperationSeq"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBodyPagingInfoOperationLogs() = default;
};
class ListTaskOperationLogsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs>> operationLogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTaskOperationLogsResponseBodyPagingInfo() {}

  explicit ListTaskOperationLogsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLogs) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLogs") != m.end() && !m["OperationLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogs"].type()) {
        vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskOperationLogsResponseBodyPagingInfoOperationLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogs = make_shared<vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBodyPagingInfo() = default;
};
class ListTaskOperationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskOperationLogsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskOperationLogsResponseBody() {}

  explicit ListTaskOperationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskOperationLogsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskOperationLogsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBody() = default;
};
class ListTaskOperationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskOperationLogsResponseBody> body{};

  ListTaskOperationLogsResponse() {}

  explicit ListTaskOperationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskOperationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskOperationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskOperationLogsResponse() = default;
};
class ListTasksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};

  ListTasksRequest() {}

  explicit ListTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksRequest() = default;
};
class ListTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};

  ListTasksShrinkRequest() {}

  explicit ListTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksShrinkRequest() = default;
};
class ListTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  ListTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> scriptParameters{};
  shared_ptr<long> timeout{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListTasksResponseBodyPagingInfoTasks() {}

  explicit ListTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptParameters) {
      res["ScriptParameters"] = boost::any(*scriptParameters);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("ScriptParameters") != m.end() && !m["ScriptParameters"].empty()) {
      scriptParameters = make_shared<string>(boost::any_cast<string>(m["ScriptParameters"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasks() = default;
};
class ListTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListTasksResponseBodyPagingInfo() {}

  explicit ListTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfo() = default;
};
class ListTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTasksResponseBody() {}

  explicit ListTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTasksResponseBody() = default;
};
class ListTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTasksResponseBody> body{};

  ListTasksResponse() {}

  explicit ListTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListTasksResponse() = default;
};
class ListUpstreamTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUpstreamTaskInstancesRequest() {}

  explicit ListUpstreamTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesRequest() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stepType{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime> runtime{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance> taskInstance{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance>(model1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances>> upstreamTaskInstances{};

  ListUpstreamTaskInstancesResponseBodyPagingInfo() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (upstreamTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamTaskInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UpstreamTaskInstances") != m.end() && !m["UpstreamTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamTaskInstances"].type()) {
        vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamTaskInstances = make_shared<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfo() = default;
};
class ListUpstreamTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListUpstreamTaskInstancesResponseBody() {}

  explicit ListUpstreamTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBody() = default;
};
class ListUpstreamTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUpstreamTaskInstancesResponseBody> body{};

  ListUpstreamTaskInstancesResponse() {}

  explicit ListUpstreamTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponse() = default;
};
class ListUpstreamTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListUpstreamTasksRequest() {}

  explicit ListUpstreamTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListUpstreamTasksRequest() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListUpstreamTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> stepType{};
  shared_ptr<long> timeout{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListUpstreamTasksResponseBodyPagingInfoTasks() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasks() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask> task{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask>(model1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks() = default;
};
class ListUpstreamTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListUpstreamTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks>> upstreamTasks{};

  ListUpstreamTasksResponseBodyPagingInfo() {}

  explicit ListUpstreamTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (upstreamTasks) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListUpstreamTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListUpstreamTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UpstreamTasks") != m.end() && !m["UpstreamTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamTasks"].type()) {
        vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamTasks = make_shared<vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfo() = default;
};
class ListUpstreamTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListUpstreamTasksResponseBody() {}

  explicit ListUpstreamTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListUpstreamTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListUpstreamTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBody() = default;
};
class ListUpstreamTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUpstreamTasksResponseBody> body{};

  ListUpstreamTasksResponse() {}

  explicit ListUpstreamTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponse() = default;
};
class ListWorkflowDefinitionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListWorkflowDefinitionsRequest() {}

  explicit ListWorkflowDefinitionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowDefinitionsRequest() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime> runtime{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript> script{};
  shared_ptr<string> type{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions>> workflowDefinitions{};

  ListWorkflowDefinitionsResponseBodyPagingInfo() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflowDefinitions) {
      vector<boost::any> temp1;
      for(auto item1:*workflowDefinitions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowDefinitions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WorkflowDefinitions") != m.end() && !m["WorkflowDefinitions"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowDefinitions"].type()) {
        vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowDefinitions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowDefinitions = make_shared<vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfo() = default;
};
class ListWorkflowDefinitionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowDefinitionsResponseBody() {}

  explicit ListWorkflowDefinitionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBody() = default;
};
class ListWorkflowDefinitionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowDefinitionsResponseBody> body{};

  ListWorkflowDefinitionsResponse() {}

  explicit ListWorkflowDefinitionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowDefinitionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowDefinitionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponse() = default;
};
class ListWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesRequest() {}

  explicit ListWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesRequest() = default;
};
class ListWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesShrinkRequest() {}

  explicit ListWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesShrinkRequest() = default;
};
class ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances() {}

  explicit ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances() = default;
};
class ListWorkflowInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances>> workflowInstances{};

  ListWorkflowInstancesResponseBodyPagingInfo() {}

  explicit ListWorkflowInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflowInstances) {
      vector<boost::any> temp1;
      for(auto item1:*workflowInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WorkflowInstances") != m.end() && !m["WorkflowInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowInstances"].type()) {
        vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowInstances = make_shared<vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowInstancesResponseBodyPagingInfo() = default;
};
class ListWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowInstancesResponseBody() {}

  explicit ListWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowInstancesResponseBody() = default;
};
class ListWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowInstancesResponseBody> body{};

  ListWorkflowInstancesResponse() {}

  explicit ListWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowInstancesResponse() = default;
};
class ListWorkflowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> triggerType{};

  ListWorkflowsRequest() {}

  explicit ListWorkflowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ListWorkflowsRequest() = default;
};
class ListWorkflowsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> triggerType{};

  ListWorkflowsShrinkRequest() {}

  explicit ListWorkflowsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ListWorkflowsShrinkRequest() = default;
};
class ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger() {}

  explicit ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger() = default;
};
class ListWorkflowsResponseBodyPagingInfoWorkflows : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger> trigger{};

  ListWorkflowsResponseBodyPagingInfoWorkflows() {}

  explicit ListWorkflowsResponseBodyPagingInfoWorkflows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger>(model1);
      }
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfoWorkflows() = default;
};
class ListWorkflowsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowsResponseBodyPagingInfoWorkflows>> workflows{};

  ListWorkflowsResponseBodyPagingInfo() {}

  explicit ListWorkflowsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflows) {
      vector<boost::any> temp1;
      for(auto item1:*workflows){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Workflows"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Workflows") != m.end() && !m["Workflows"].empty()) {
      if (typeid(vector<boost::any>) == m["Workflows"].type()) {
        vector<ListWorkflowsResponseBodyPagingInfoWorkflows> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Workflows"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowsResponseBodyPagingInfoWorkflows model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflows = make_shared<vector<ListWorkflowsResponseBodyPagingInfoWorkflows>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfo() = default;
};
class ListWorkflowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowsResponseBody() {}

  explicit ListWorkflowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowsResponseBody() = default;
};
class ListWorkflowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowsResponseBody> body{};

  ListWorkflowsResponse() {}

  explicit ListWorkflowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowsResponse() = default;
};
class MoveFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveFunctionRequest() {}

  explicit MoveFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveFunctionRequest() = default;
};
class MoveFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveFunctionResponseBody() {}

  explicit MoveFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveFunctionResponseBody() = default;
};
class MoveFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveFunctionResponseBody> body{};

  MoveFunctionResponse() {}

  explicit MoveFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~MoveFunctionResponse() = default;
};
class MoveNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveNodeRequest() {}

  explicit MoveNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveNodeRequest() = default;
};
class MoveNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveNodeResponseBody() {}

  explicit MoveNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveNodeResponseBody() = default;
};
class MoveNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveNodeResponseBody> body{};

  MoveNodeResponse() {}

  explicit MoveNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveNodeResponseBody>(model1);
      }
    }
  }


  virtual ~MoveNodeResponse() = default;
};
class MoveResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveResourceRequest() {}

  explicit MoveResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveResourceRequest() = default;
};
class MoveResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveResourceResponseBody() {}

  explicit MoveResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveResourceResponseBody() = default;
};
class MoveResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveResourceResponseBody> body{};

  MoveResourceResponse() {}

  explicit MoveResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceResponse() = default;
};
class MoveWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveWorkflowDefinitionRequest() {}

  explicit MoveWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveWorkflowDefinitionRequest() = default;
};
class MoveWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveWorkflowDefinitionResponseBody() {}

  explicit MoveWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveWorkflowDefinitionResponseBody() = default;
};
class MoveWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveWorkflowDefinitionResponseBody> body{};

  MoveWorkflowDefinitionResponse() {}

  explicit MoveWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~MoveWorkflowDefinitionResponse() = default;
};
class RemoveTaskInstanceDependenciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<vector<long>> upstreamTaskInstanceIds{};

  RemoveTaskInstanceDependenciesRequest() {}

  explicit RemoveTaskInstanceDependenciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (upstreamTaskInstanceIds) {
      res["UpstreamTaskInstanceIds"] = boost::any(*upstreamTaskInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UpstreamTaskInstanceIds") != m.end() && !m["UpstreamTaskInstanceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["UpstreamTaskInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UpstreamTaskInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      upstreamTaskInstanceIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RemoveTaskInstanceDependenciesRequest() = default;
};
class RemoveTaskInstanceDependenciesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<string> upstreamTaskInstanceIdsShrink{};

  RemoveTaskInstanceDependenciesShrinkRequest() {}

  explicit RemoveTaskInstanceDependenciesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (upstreamTaskInstanceIdsShrink) {
      res["UpstreamTaskInstanceIds"] = boost::any(*upstreamTaskInstanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UpstreamTaskInstanceIds") != m.end() && !m["UpstreamTaskInstanceIds"].empty()) {
      upstreamTaskInstanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["UpstreamTaskInstanceIds"]));
    }
  }


  virtual ~RemoveTaskInstanceDependenciesShrinkRequest() = default;
};
class RemoveTaskInstanceDependenciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveTaskInstanceDependenciesResponseBody() {}

  explicit RemoveTaskInstanceDependenciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveTaskInstanceDependenciesResponseBody() = default;
};
class RemoveTaskInstanceDependenciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTaskInstanceDependenciesResponseBody> body{};

  RemoveTaskInstanceDependenciesResponse() {}

  explicit RemoveTaskInstanceDependenciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTaskInstanceDependenciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTaskInstanceDependenciesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTaskInstanceDependenciesResponse() = default;
};
class RenameFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameFunctionRequest() {}

  explicit RenameFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameFunctionRequest() = default;
};
class RenameFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  RenameFunctionResponseBody() {}

  explicit RenameFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~RenameFunctionResponseBody() = default;
};
class RenameFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameFunctionResponseBody> body{};

  RenameFunctionResponse() {}

  explicit RenameFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~RenameFunctionResponse() = default;
};
class RenameNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameNodeRequest() {}

  explicit RenameNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameNodeRequest() = default;
};
class RenameNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameNodeResponseBody() {}

  explicit RenameNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameNodeResponseBody() = default;
};
class RenameNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameNodeResponseBody> body{};

  RenameNodeResponse() {}

  explicit RenameNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameNodeResponseBody>(model1);
      }
    }
  }


  virtual ~RenameNodeResponse() = default;
};
class RenameResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameResourceRequest() {}

  explicit RenameResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameResourceRequest() = default;
};
class RenameResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameResourceResponseBody() {}

  explicit RenameResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameResourceResponseBody() = default;
};
class RenameResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameResourceResponseBody> body{};

  RenameResourceResponse() {}

  explicit RenameResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameResourceResponseBody>(model1);
      }
    }
  }


  virtual ~RenameResourceResponse() = default;
};
class RenameWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameWorkflowDefinitionRequest() {}

  explicit RenameWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameWorkflowDefinitionRequest() = default;
};
class RenameWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameWorkflowDefinitionResponseBody() {}

  explicit RenameWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameWorkflowDefinitionResponseBody() = default;
};
class RenameWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameWorkflowDefinitionResponseBody> body{};

  RenameWorkflowDefinitionResponse() {}

  explicit RenameWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~RenameWorkflowDefinitionResponse() = default;
};
class RerunTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  RerunTaskInstancesRequest() {}

  explicit RerunTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RerunTaskInstancesRequest() = default;
};
class RerunTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  RerunTaskInstancesShrinkRequest() {}

  explicit RerunTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~RerunTaskInstancesShrinkRequest() = default;
};
class RerunTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  RerunTaskInstancesResponseBody() {}

  explicit RerunTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~RerunTaskInstancesResponseBody() = default;
};
class RerunTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RerunTaskInstancesResponseBody> body{};

  RerunTaskInstancesResponse() {}

  explicit RerunTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RerunTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RerunTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RerunTaskInstancesResponse() = default;
};
class ResumeTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  ResumeTaskInstancesRequest() {}

  explicit ResumeTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ResumeTaskInstancesRequest() = default;
};
class ResumeTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  ResumeTaskInstancesShrinkRequest() {}

  explicit ResumeTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~ResumeTaskInstancesShrinkRequest() = default;
};
class ResumeTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  ResumeTaskInstancesResponseBody() {}

  explicit ResumeTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~ResumeTaskInstancesResponseBody() = default;
};
class ResumeTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeTaskInstancesResponseBody> body{};

  ResumeTaskInstancesResponse() {}

  explicit ResumeTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeTaskInstancesResponse() = default;
};
class RevokeMemberProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  RevokeMemberProjectRolesRequest() {}

  explicit RevokeMemberProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesRequest() = default;
};
class RevokeMemberProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  RevokeMemberProjectRolesShrinkRequest() {}

  explicit RevokeMemberProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesShrinkRequest() = default;
};
class RevokeMemberProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeMemberProjectRolesResponseBody() {}

  explicit RevokeMemberProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesResponseBody() = default;
};
class RevokeMemberProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeMemberProjectRolesResponseBody> body{};

  RevokeMemberProjectRolesResponse() {}

  explicit RevokeMemberProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeMemberProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeMemberProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeMemberProjectRolesResponse() = default;
};
class SetSuccessTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  SetSuccessTaskInstancesRequest() {}

  explicit SetSuccessTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SetSuccessTaskInstancesRequest() = default;
};
class SetSuccessTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  SetSuccessTaskInstancesShrinkRequest() {}

  explicit SetSuccessTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~SetSuccessTaskInstancesShrinkRequest() = default;
};
class SetSuccessTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  SetSuccessTaskInstancesResponseBody() {}

  explicit SetSuccessTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~SetSuccessTaskInstancesResponseBody() = default;
};
class SetSuccessTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetSuccessTaskInstancesResponseBody> body{};

  SetSuccessTaskInstancesResponse() {}

  explicit SetSuccessTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSuccessTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSuccessTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~SetSuccessTaskInstancesResponse() = default;
};
class StartDIJobRequestRealtimeStartSettingsFailoverSettings : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<long> upperLimit{};

  StartDIJobRequestRealtimeStartSettingsFailoverSettings() {}

  explicit StartDIJobRequestRealtimeStartSettingsFailoverSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (upperLimit) {
      res["UpperLimit"] = boost::any(*upperLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("UpperLimit") != m.end() && !m["UpperLimit"].empty()) {
      upperLimit = make_shared<long>(boost::any_cast<long>(m["UpperLimit"]));
    }
  }


  virtual ~StartDIJobRequestRealtimeStartSettingsFailoverSettings() = default;
};
class StartDIJobRequestRealtimeStartSettings : public Darabonba::Model {
public:
  shared_ptr<StartDIJobRequestRealtimeStartSettingsFailoverSettings> failoverSettings{};
  shared_ptr<long> startTime{};

  StartDIJobRequestRealtimeStartSettings() {}

  explicit StartDIJobRequestRealtimeStartSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failoverSettings) {
      res["FailoverSettings"] = failoverSettings ? boost::any(failoverSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailoverSettings") != m.end() && !m["FailoverSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailoverSettings"].type()) {
        StartDIJobRequestRealtimeStartSettingsFailoverSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailoverSettings"]));
        failoverSettings = make_shared<StartDIJobRequestRealtimeStartSettingsFailoverSettings>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~StartDIJobRequestRealtimeStartSettings() = default;
};
class StartDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<bool> forceToRerun{};
  shared_ptr<long> id{};
  shared_ptr<StartDIJobRequestRealtimeStartSettings> realtimeStartSettings{};

  StartDIJobRequest() {}

  explicit StartDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (forceToRerun) {
      res["ForceToRerun"] = boost::any(*forceToRerun);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (realtimeStartSettings) {
      res["RealtimeStartSettings"] = realtimeStartSettings ? boost::any(realtimeStartSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("ForceToRerun") != m.end() && !m["ForceToRerun"].empty()) {
      forceToRerun = make_shared<bool>(boost::any_cast<bool>(m["ForceToRerun"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RealtimeStartSettings") != m.end() && !m["RealtimeStartSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeStartSettings"].type()) {
        StartDIJobRequestRealtimeStartSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeStartSettings"]));
        realtimeStartSettings = make_shared<StartDIJobRequestRealtimeStartSettings>(model1);
      }
    }
  }


  virtual ~StartDIJobRequest() = default;
};
class StartDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<bool> forceToRerun{};
  shared_ptr<long> id{};
  shared_ptr<string> realtimeStartSettingsShrink{};

  StartDIJobShrinkRequest() {}

  explicit StartDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (forceToRerun) {
      res["ForceToRerun"] = boost::any(*forceToRerun);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (realtimeStartSettingsShrink) {
      res["RealtimeStartSettings"] = boost::any(*realtimeStartSettingsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("ForceToRerun") != m.end() && !m["ForceToRerun"].empty()) {
      forceToRerun = make_shared<bool>(boost::any_cast<bool>(m["ForceToRerun"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RealtimeStartSettings") != m.end() && !m["RealtimeStartSettings"].empty()) {
      realtimeStartSettingsShrink = make_shared<string>(boost::any_cast<string>(m["RealtimeStartSettings"]));
    }
  }


  virtual ~StartDIJobShrinkRequest() = default;
};
class StartDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartDIJobResponseBody() {}

  explicit StartDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartDIJobResponseBody() = default;
};
class StartDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDIJobResponseBody> body{};

  StartDIJobResponse() {}

  explicit StartDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartDIJobResponse() = default;
};
class StartWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StartWorkflowInstancesRequest() {}

  explicit StartWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StartWorkflowInstancesRequest() = default;
};
class StartWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StartWorkflowInstancesShrinkRequest() {}

  explicit StartWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StartWorkflowInstancesShrinkRequest() = default;
};
class StartWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StartWorkflowInstancesResponseBody() {}

  explicit StartWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StartWorkflowInstancesResponseBody() = default;
};
class StartWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartWorkflowInstancesResponseBody> body{};

  StartWorkflowInstancesResponse() {}

  explicit StartWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StartWorkflowInstancesResponse() = default;
};
class StopDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceId{};

  StopDIJobRequest() {}

  explicit StopDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
  }


  virtual ~StopDIJobRequest() = default;
};
class StopDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopDIJobResponseBody() {}

  explicit StopDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopDIJobResponseBody() = default;
};
class StopDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDIJobResponseBody> body{};

  StopDIJobResponse() {}

  explicit StopDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopDIJobResponse() = default;
};
class StopTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StopTaskInstancesRequest() {}

  explicit StopTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StopTaskInstancesRequest() = default;
};
class StopTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StopTaskInstancesShrinkRequest() {}

  explicit StopTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StopTaskInstancesShrinkRequest() = default;
};
class StopTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StopTaskInstancesResponseBody() {}

  explicit StopTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StopTaskInstancesResponseBody() = default;
};
class StopTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopTaskInstancesResponseBody> body{};

  StopTaskInstancesResponse() {}

  explicit StopTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopTaskInstancesResponse() = default;
};
class StopWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StopWorkflowInstancesRequest() {}

  explicit StopWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StopWorkflowInstancesRequest() = default;
};
class StopWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StopWorkflowInstancesShrinkRequest() {}

  explicit StopWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StopWorkflowInstancesShrinkRequest() = default;
};
class StopWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StopWorkflowInstancesResponseBody() {}

  explicit StopWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StopWorkflowInstancesResponseBody() = default;
};
class StopWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopWorkflowInstancesResponseBody> body{};

  StopWorkflowInstancesResponse() {}

  explicit StopWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopWorkflowInstancesResponse() = default;
};
class SuspendTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  SuspendTaskInstancesRequest() {}

  explicit SuspendTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SuspendTaskInstancesRequest() = default;
};
class SuspendTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  SuspendTaskInstancesShrinkRequest() {}

  explicit SuspendTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~SuspendTaskInstancesShrinkRequest() = default;
};
class SuspendTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  SuspendTaskInstancesResponseBody() {}

  explicit SuspendTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~SuspendTaskInstancesResponseBody() = default;
};
class SuspendTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendTaskInstancesResponseBody> body{};

  SuspendTaskInstancesResponse() {}

  explicit SuspendTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendTaskInstancesResponse() = default;
};
class TagDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagDataAssetsRequestTags() {}

  explicit TagDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagDataAssetsRequestTags() = default;
};
class TagDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<TagDataAssetsRequestTags>> tags{};

  TagDataAssetsRequest() {}

  explicit TagDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~TagDataAssetsRequest() = default;
};
class TagDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  TagDataAssetsShrinkRequest() {}

  explicit TagDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~TagDataAssetsShrinkRequest() = default;
};
class TagDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  TagDataAssetsResponseBody() {}

  explicit TagDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~TagDataAssetsResponseBody() = default;
};
class TagDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagDataAssetsResponseBody> body{};

  TagDataAssetsResponse() {}

  explicit TagDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~TagDataAssetsResponse() = default;
};
class TriggerSchedulerTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<long> taskId{};
  shared_ptr<long> triggerTime{};

  TriggerSchedulerTaskInstanceRequest() {}

  explicit TriggerSchedulerTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
  }


  virtual ~TriggerSchedulerTaskInstanceRequest() = default;
};
class TriggerSchedulerTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TriggerSchedulerTaskInstanceResponseBody() {}

  explicit TriggerSchedulerTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TriggerSchedulerTaskInstanceResponseBody() = default;
};
class TriggerSchedulerTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TriggerSchedulerTaskInstanceResponseBody> body{};

  TriggerSchedulerTaskInstanceResponse() {}

  explicit TriggerSchedulerTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerSchedulerTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerSchedulerTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerSchedulerTaskInstanceResponse() = default;
};
class UnTagDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UnTagDataAssetsRequestTags() {}

  explicit UnTagDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UnTagDataAssetsRequestTags() = default;
};
class UnTagDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<UnTagDataAssetsRequestTags>> tags{};

  UnTagDataAssetsRequest() {}

  explicit UnTagDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UnTagDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnTagDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UnTagDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~UnTagDataAssetsRequest() = default;
};
class UnTagDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  UnTagDataAssetsShrinkRequest() {}

  explicit UnTagDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UnTagDataAssetsShrinkRequest() = default;
};
class UnTagDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UnTagDataAssetsResponseBody() {}

  explicit UnTagDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UnTagDataAssetsResponseBody() = default;
};
class UnTagDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnTagDataAssetsResponseBody> body{};

  UnTagDataAssetsResponse() {}

  explicit UnTagDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnTagDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnTagDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~UnTagDataAssetsResponse() = default;
};
class UpdateAlertRuleRequestNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateAlertRuleRequestNotificationReceivers() {}

  explicit UpdateAlertRuleRequestNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateAlertRuleRequestNotificationReceivers() = default;
};
class UpdateAlertRuleRequestNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<UpdateAlertRuleRequestNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  UpdateAlertRuleRequestNotification() {}

  explicit UpdateAlertRuleRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<UpdateAlertRuleRequestNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAlertRuleRequestNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<UpdateAlertRuleRequestNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~UpdateAlertRuleRequestNotification() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  UpdateAlertRuleRequestTriggerConditionExtensionError() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionError() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  UpdateAlertRuleRequestTriggerConditionExtensionTimeout() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionTimeout() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  UpdateAlertRuleRequestTriggerConditionExtensionUnFinished() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionUnFinished() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionError> error{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionUnFinished> unFinished{};

  UpdateAlertRuleRequestTriggerConditionExtension() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtension() = default;
};
class UpdateAlertRuleRequestTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  UpdateAlertRuleRequestTriggerConditionTarget() {}

  explicit UpdateAlertRuleRequestTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionTarget() = default;
};
class UpdateAlertRuleRequestTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtension> extension{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  UpdateAlertRuleRequestTriggerCondition() {}

  explicit UpdateAlertRuleRequestTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<UpdateAlertRuleRequestTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        UpdateAlertRuleRequestTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<UpdateAlertRuleRequestTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerCondition() = default;
};
class UpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateAlertRuleRequestNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<UpdateAlertRuleRequestTriggerCondition> triggerCondition{};

  UpdateAlertRuleRequest() {}

  explicit UpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        UpdateAlertRuleRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<UpdateAlertRuleRequestNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        UpdateAlertRuleRequestTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<UpdateAlertRuleRequestTriggerCondition>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequest() = default;
};
class UpdateAlertRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> triggerConditionShrink{};

  UpdateAlertRuleShrinkRequest() {}

  explicit UpdateAlertRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerConditionShrink) {
      res["TriggerCondition"] = boost::any(*triggerConditionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      triggerConditionShrink = make_shared<string>(boost::any_cast<string>(m["TriggerCondition"]));
    }
  }


  virtual ~UpdateAlertRuleShrinkRequest() = default;
};
class UpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAlertRuleResponseBody() {}

  explicit UpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAlertRuleResponseBody() = default;
};
class UpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertRuleResponseBody> body{};

  UpdateAlertRuleResponse() {}

  explicit UpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleResponse() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>> notificationReceivers{};

  UpdateDIAlarmRuleRequestNotificationSettings() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettings() = default;
};
class UpdateDIAlarmRuleRequestTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  UpdateDIAlarmRuleRequestTriggerConditions() {}

  explicit UpdateDIAlarmRuleRequestTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~UpdateDIAlarmRuleRequestTriggerConditions() = default;
};
class UpdateDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDIAlarmRuleRequestNotificationSettings> notificationSettings{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestTriggerConditions>> triggerConditions{};

  UpdateDIAlarmRuleRequest() {}

  explicit UpdateDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        UpdateDIAlarmRuleRequestNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<UpdateDIAlarmRuleRequestNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<UpdateDIAlarmRuleRequestTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<UpdateDIAlarmRuleRequestTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleRequest() = default;
};
class UpdateDIAlarmRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationSettingsShrink{};
  shared_ptr<string> triggerConditionsShrink{};

  UpdateDIAlarmRuleShrinkRequest() {}

  explicit UpdateDIAlarmRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettingsShrink) {
      res["NotificationSettings"] = boost::any(*notificationSettingsShrink);
    }
    if (triggerConditionsShrink) {
      res["TriggerConditions"] = boost::any(*triggerConditionsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      notificationSettingsShrink = make_shared<string>(boost::any_cast<string>(m["NotificationSettings"]));
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      triggerConditionsShrink = make_shared<string>(boost::any_cast<string>(m["TriggerConditions"]));
    }
  }


  virtual ~UpdateDIAlarmRuleShrinkRequest() = default;
};
class UpdateDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDIAlarmRuleResponseBody() {}

  explicit UpdateDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDIAlarmRuleResponseBody() = default;
};
class UpdateDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDIAlarmRuleResponseBody> body{};

  UpdateDIAlarmRuleResponse() {}

  explicit UpdateDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleResponse() = default;
};
class UpdateDIJobRequestJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  UpdateDIJobRequestJobSettingsColumnDataTypeSettings() {}

  explicit UpdateDIJobRequestJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsColumnDataTypeSettings() = default;
};
class UpdateDIJobRequestJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> scheduleParameters{};

  UpdateDIJobRequestJobSettingsCycleScheduleSettings() {}

  explicit UpdateDIJobRequestJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsCycleScheduleSettings() = default;
};
class UpdateDIJobRequestJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  UpdateDIJobRequestJobSettingsDdlHandlingSettings() {}

  explicit UpdateDIJobRequestJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsDdlHandlingSettings() = default;
};
class UpdateDIJobRequestJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdateDIJobRequestJobSettingsRuntimeSettings() {}

  explicit UpdateDIJobRequestJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsRuntimeSettings() = default;
};
class UpdateDIJobRequestJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<UpdateDIJobRequestJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsRuntimeSettings>> runtimeSettings{};

  UpdateDIJobRequestJobSettings() {}

  explicit UpdateDIJobRequestJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        UpdateDIJobRequestJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<UpdateDIJobRequestJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<UpdateDIJobRequestJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequestJobSettings() = default;
};
class UpdateDIJobRequestResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsOfflineResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsOfflineResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsRealtimeResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsRealtimeResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsScheduleResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsScheduleResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettings : public Darabonba::Model {
public:
  shared_ptr<UpdateDIJobRequestResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<UpdateDIJobRequestResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<UpdateDIJobRequestResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  UpdateDIJobRequestResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~UpdateDIJobRequestResourceSettings() = default;
};
class UpdateDIJobRequestTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  UpdateDIJobRequestTableMappingsSourceObjectSelectionRules() {}

  explicit UpdateDIJobRequestTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~UpdateDIJobRequestTableMappingsSourceObjectSelectionRules() = default;
};
class UpdateDIJobRequestTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  UpdateDIJobRequestTableMappingsTransformationRules() {}

  explicit UpdateDIJobRequestTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~UpdateDIJobRequestTableMappingsTransformationRules() = default;
};
class UpdateDIJobRequestTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<UpdateDIJobRequestTableMappingsTransformationRules>> transformationRules{};

  UpdateDIJobRequestTableMappings() {}

  explicit UpdateDIJobRequestTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<UpdateDIJobRequestTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<UpdateDIJobRequestTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequestTableMappings() = default;
};
class UpdateDIJobRequestTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  UpdateDIJobRequestTransformationRules() {}

  explicit UpdateDIJobRequestTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~UpdateDIJobRequestTransformationRules() = default;
};
class UpdateDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<UpdateDIJobRequestJobSettings> jobSettings{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDIJobRequestResourceSettings> resourceSettings{};
  shared_ptr<vector<UpdateDIJobRequestTableMappings>> tableMappings{};
  shared_ptr<vector<UpdateDIJobRequestTransformationRules>> transformationRules{};

  UpdateDIJobRequest() {}

  explicit UpdateDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        UpdateDIJobRequestJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<UpdateDIJobRequestJobSettings>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<UpdateDIJobRequestResourceSettings>(model1);
      }
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<UpdateDIJobRequestTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<UpdateDIJobRequestTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<UpdateDIJobRequestTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<UpdateDIJobRequestTransformationRules>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequest() = default;
};
class UpdateDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> jobSettingsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceSettingsShrink{};
  shared_ptr<string> tableMappingsShrink{};
  shared_ptr<string> transformationRulesShrink{};

  UpdateDIJobShrinkRequest() {}

  explicit UpdateDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobSettingsShrink) {
      res["JobSettings"] = boost::any(*jobSettingsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettingsShrink) {
      res["ResourceSettings"] = boost::any(*resourceSettingsShrink);
    }
    if (tableMappingsShrink) {
      res["TableMappings"] = boost::any(*tableMappingsShrink);
    }
    if (transformationRulesShrink) {
      res["TransformationRules"] = boost::any(*transformationRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      jobSettingsShrink = make_shared<string>(boost::any_cast<string>(m["JobSettings"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      resourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["ResourceSettings"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      tableMappingsShrink = make_shared<string>(boost::any_cast<string>(m["TableMappings"]));
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      transformationRulesShrink = make_shared<string>(boost::any_cast<string>(m["TransformationRules"]));
    }
  }


  virtual ~UpdateDIJobShrinkRequest() = default;
};
class UpdateDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDIJobResponseBody() {}

  explicit UpdateDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDIJobResponseBody() = default;
};
class UpdateDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDIJobResponseBody> body{};

  UpdateDIJobResponse() {}

  explicit UpdateDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDIJobResponse() = default;
};
class UpdateDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<vector<string>> values{};

  UpdateDataAssetTagRequest() {}

  explicit UpdateDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataAssetTagRequest() = default;
};
class UpdateDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> valuesShrink{};

  UpdateDataAssetTagShrinkRequest() {}

  explicit UpdateDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~UpdateDataAssetTagShrinkRequest() = default;
};
class UpdateDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataAssetTagResponseBody() {}

  explicit UpdateDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataAssetTagResponseBody() = default;
};
class UpdateDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataAssetTagResponseBody> body{};

  UpdateDataAssetTagResponse() {}

  explicit UpdateDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataAssetTagResponse() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRules() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRules() = default;
};
class UpdateDataQualityEvaluationTaskRequestHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestHooks() {}

  explicit UpdateDataQualityEvaluationTaskRequestHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestHooks() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotifications() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotifications() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications>> notifications{};

  UpdateDataQualityEvaluationTaskRequestNotifications() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotifications() = default;
};
class UpdateDataQualityEvaluationTaskRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};

  UpdateDataQualityEvaluationTaskRequestTarget() {}

  explicit UpdateDataQualityEvaluationTaskRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestTarget() = default;
};
class UpdateDataQualityEvaluationTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestTrigger() {}

  explicit UpdateDataQualityEvaluationTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestTrigger() = default;
};
class UpdateDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules>> dataQualityRules{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestTarget> target{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestTrigger> trigger{};

  UpdateDataQualityEvaluationTaskRequest() {}

  explicit UpdateDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules>>(expect1);
      }
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<UpdateDataQualityEvaluationTaskRequestHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        UpdateDataQualityEvaluationTaskRequestNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<UpdateDataQualityEvaluationTaskRequestNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        UpdateDataQualityEvaluationTaskRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<UpdateDataQualityEvaluationTaskRequestTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateDataQualityEvaluationTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateDataQualityEvaluationTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequest() = default;
};
class UpdateDataQualityEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataQualityRulesShrink{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> hooksShrink{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> triggerShrink{};

  UpdateDataQualityEvaluationTaskShrinkRequest() {}

  explicit UpdateDataQualityEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRulesShrink) {
      res["DataQualityRules"] = boost::any(*dataQualityRulesShrink);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooksShrink) {
      res["Hooks"] = boost::any(*hooksShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationsShrink) {
      res["Notifications"] = boost::any(*notificationsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      dataQualityRulesShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRules"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooksShrink = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      notificationsShrink = make_shared<string>(boost::any_cast<string>(m["Notifications"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskShrinkRequest() = default;
};
class UpdateDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityEvaluationTaskResponseBody() {}

  explicit UpdateDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskResponseBody() = default;
};
class UpdateDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityEvaluationTaskResponseBody> body{};

  UpdateDataQualityEvaluationTaskResponse() {}

  explicit UpdateDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskResponse() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical> critical{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected> expected{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned> warned{};

  UpdateDataQualityRuleRequestCheckingConfigThresholds() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholds() = default;
};
class UpdateDataQualityRuleRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleRequestCheckingConfig() {}

  explicit UpdateDataQualityRuleRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfig() = default;
};
class UpdateDataQualityRuleRequestErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleRequestErrorHandlers() {}

  explicit UpdateDataQualityRuleRequestErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestErrorHandlers() = default;
};
class UpdateDataQualityRuleRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityRuleRequestSamplingConfig() {}

  explicit UpdateDataQualityRuleRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestSamplingConfig() = default;
};
class UpdateDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<UpdateDataQualityRuleRequestErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDataQualityRuleRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityRuleRequest() {}

  explicit UpdateDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityRuleRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityRuleRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<UpdateDataQualityRuleRequestErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityRuleRequestErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<UpdateDataQualityRuleRequestErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityRuleRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityRuleRequestSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequest() = default;
};
class UpdateDataQualityRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> errorHandlersShrink{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityRuleShrinkRequest() {}

  explicit UpdateDataQualityRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlersShrink) {
      res["ErrorHandlers"] = boost::any(*errorHandlersShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      errorHandlersShrink = make_shared<string>(boost::any_cast<string>(m["ErrorHandlers"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityRuleShrinkRequest() = default;
};
class UpdateDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityRuleResponseBody() {}

  explicit UpdateDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityRuleResponseBody() = default;
};
class UpdateDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityRuleResponseBody> body{};

  UpdateDataQualityRuleResponse() {}

  explicit UpdateDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleResponse() = default;
};
class UpdateDataQualityRuleTemplateRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleTemplateRequestCheckingConfig() {}

  explicit UpdateDataQualityRuleTemplateRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequestCheckingConfig() = default;
};
class UpdateDataQualityRuleTemplateRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityRuleTemplateRequestSamplingConfig() {}

  explicit UpdateDataQualityRuleTemplateRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequestSamplingConfig() = default;
};
class UpdateDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleTemplateRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDataQualityRuleTemplateRequestSamplingConfig> samplingConfig{};

  UpdateDataQualityRuleTemplateRequest() {}

  explicit UpdateDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityRuleTemplateRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityRuleTemplateRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityRuleTemplateRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityRuleTemplateRequestSamplingConfig>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequest() = default;
};
class UpdateDataQualityRuleTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};

  UpdateDataQualityRuleTemplateShrinkRequest() {}

  explicit UpdateDataQualityRuleTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateShrinkRequest() = default;
};
class UpdateDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityRuleTemplateResponseBody() {}

  explicit UpdateDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateResponseBody() = default;
};
class UpdateDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityRuleTemplateResponseBody> body{};

  UpdateDataQualityRuleTemplateResponse() {}

  explicit UpdateDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleTemplateResponse() = default;
};
class UpdateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  UpdateDataSourceRequest() {}

  explicit UpdateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<string>(boost::any_cast<string>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateDataSourceRequest() = default;
};
class UpdateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataSourceResponseBody() {}

  explicit UpdateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataSourceResponseBody() = default;
};
class UpdateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataSourceResponseBody> body{};

  UpdateDataSourceResponse() {}

  explicit UpdateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceResponse() = default;
};
class UpdateFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateFunctionRequest() {}

  explicit UpdateFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateFunctionRequest() = default;
};
class UpdateFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFunctionResponseBody() {}

  explicit UpdateFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFunctionResponseBody() = default;
};
class UpdateFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFunctionResponseBody> body{};

  UpdateFunctionResponse() {}

  explicit UpdateFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFunctionResponse() = default;
};
class UpdateNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateNodeRequest() {}

  explicit UpdateNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateNodeRequest() = default;
};
class UpdateNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNodeResponseBody() {}

  explicit UpdateNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNodeResponseBody() = default;
};
class UpdateNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNodeResponseBody> body{};

  UpdateNodeResponse() {}

  explicit UpdateNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNodeResponse() = default;
};
class UpdateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  UpdateProjectRequest() {}

  explicit UpdateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateProjectRequest() = default;
};
class UpdateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProjectResponseBody() {}

  explicit UpdateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProjectResponseBody() = default;
};
class UpdateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectResponseBody> body{};

  UpdateProjectResponse() {}

  explicit UpdateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectResponse() = default;
};
class UpdateResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateResourceRequest() {}

  explicit UpdateResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateResourceRequest() = default;
};
class UpdateResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateResourceResponseBody() {}

  explicit UpdateResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateResourceResponseBody() = default;
};
class UpdateResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceResponseBody> body{};

  UpdateResourceResponse() {}

  explicit UpdateResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceResponse() = default;
};
class UpdateResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};

  UpdateResourceGroupRequest() {}

  explicit UpdateResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateResourceGroupRequest() = default;
};
class UpdateResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateResourceGroupResponseBody() {}

  explicit UpdateResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateResourceGroupResponseBody() = default;
};
class UpdateResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceGroupResponseBody> body{};

  UpdateResourceGroupResponse() {}

  explicit UpdateResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceGroupResponse() = default;
};
class UpdateRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};

  UpdateRouteRequest() {}

  explicit UpdateRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateRouteRequest() = default;
};
class UpdateRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateRouteResponseBody() {}

  explicit UpdateRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateRouteResponseBody() = default;
};
class UpdateRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRouteResponseBody> body{};

  UpdateRouteResponse() {}

  explicit UpdateRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRouteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRouteResponse() = default;
};
class UpdateTaskRequestDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateTaskRequestDataSource() {}

  explicit UpdateTaskRequestDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateTaskRequestDataSource() = default;
};
class UpdateTaskRequestDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateTaskRequestDependencies() {}

  explicit UpdateTaskRequestDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateTaskRequestDependencies() = default;
};
class UpdateTaskRequestInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateTaskRequestInputsVariables() {}

  explicit UpdateTaskRequestInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestInputsVariables() = default;
};
class UpdateTaskRequestInputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTaskRequestInputsVariables>> variables{};

  UpdateTaskRequestInputs() {}

  explicit UpdateTaskRequestInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateTaskRequestInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateTaskRequestInputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskRequestInputs() = default;
};
class UpdateTaskRequestOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateTaskRequestOutputsTaskOutputs() {}

  explicit UpdateTaskRequestOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateTaskRequestOutputsTaskOutputs() = default;
};
class UpdateTaskRequestOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateTaskRequestOutputsVariables() {}

  explicit UpdateTaskRequestOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestOutputsVariables() = default;
};
class UpdateTaskRequestOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTaskRequestOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<UpdateTaskRequestOutputsVariables>> variables{};

  UpdateTaskRequestOutputs() {}

  explicit UpdateTaskRequestOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateTaskRequestOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateTaskRequestOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateTaskRequestOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateTaskRequestOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskRequestOutputs() = default;
};
class UpdateTaskRequestRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  UpdateTaskRequestRuntimeResource() {}

  explicit UpdateTaskRequestRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~UpdateTaskRequestRuntimeResource() = default;
};
class UpdateTaskRequestScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  UpdateTaskRequestScript() {}

  explicit UpdateTaskRequestScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~UpdateTaskRequestScript() = default;
};
class UpdateTaskRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateTaskRequestTags() {}

  explicit UpdateTaskRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestTags() = default;
};
class UpdateTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  UpdateTaskRequestTrigger() {}

  explicit UpdateTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateTaskRequestTrigger() = default;
};
class UpdateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<UpdateTaskRequestDataSource> dataSource{};
  shared_ptr<vector<UpdateTaskRequestDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<UpdateTaskRequestInputs> inputs{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<UpdateTaskRequestOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<UpdateTaskRequestRuntimeResource> runtimeResource{};
  shared_ptr<UpdateTaskRequestScript> script{};
  shared_ptr<vector<UpdateTaskRequestTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<UpdateTaskRequestTrigger> trigger{};

  UpdateTaskRequest() {}

  explicit UpdateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateTaskRequestDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateTaskRequestDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateTaskRequestDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateTaskRequestDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        UpdateTaskRequestInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<UpdateTaskRequestInputs>(model1);
      }
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateTaskRequestOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateTaskRequestOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        UpdateTaskRequestRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<UpdateTaskRequestRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        UpdateTaskRequestScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<UpdateTaskRequestScript>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateTaskRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateTaskRequestTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateTaskRequest() = default;
};
class UpdateTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> dataSourceShrink{};
  shared_ptr<string> dependenciesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputsShrink{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<string> outputsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<string> runtimeResourceShrink{};
  shared_ptr<string> scriptShrink{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerShrink{};

  UpdateTaskShrinkRequest() {}

  explicit UpdateTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSourceShrink) {
      res["DataSource"] = boost::any(*dataSourceShrink);
    }
    if (dependenciesShrink) {
      res["Dependencies"] = boost::any(*dependenciesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputsShrink) {
      res["Inputs"] = boost::any(*inputsShrink);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputsShrink) {
      res["Outputs"] = boost::any(*outputsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResourceShrink) {
      res["RuntimeResource"] = boost::any(*runtimeResourceShrink);
    }
    if (scriptShrink) {
      res["Script"] = boost::any(*scriptShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSourceShrink = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      dependenciesShrink = make_shared<string>(boost::any_cast<string>(m["Dependencies"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      inputsShrink = make_shared<string>(boost::any_cast<string>(m["Inputs"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputsShrink = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResourceShrink = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      scriptShrink = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateTaskShrinkRequest() = default;
};
class UpdateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskResponseBody() {}

  explicit UpdateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskResponseBody() = default;
};
class UpdateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskResponseBody> body{};

  UpdateTaskResponse() {}

  explicit UpdateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskResponse() = default;
};
class UpdateTaskInstancesRequestTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateTaskInstancesRequestTaskInstancesDataSource() {}

  explicit UpdateTaskInstancesRequestTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateTaskInstancesRequestTaskInstancesDataSource() = default;
};
class UpdateTaskInstancesRequestTaskInstances : public Darabonba::Model {
public:
  shared_ptr<UpdateTaskInstancesRequestTaskInstancesDataSource> dataSource{};
  shared_ptr<long> id{};
  shared_ptr<long> priority{};
  shared_ptr<string> runtimeResource{};

  UpdateTaskInstancesRequestTaskInstances() {}

  explicit UpdateTaskInstancesRequestTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateTaskInstancesRequestTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateTaskInstancesRequestTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~UpdateTaskInstancesRequestTaskInstances() = default;
};
class UpdateTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<UpdateTaskInstancesRequestTaskInstances>> taskInstances{};

  UpdateTaskInstancesRequest() {}

  explicit UpdateTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<UpdateTaskInstancesRequestTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskInstancesRequestTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<UpdateTaskInstancesRequestTaskInstances>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskInstancesRequest() = default;
};
class UpdateTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> taskInstancesShrink{};

  UpdateTaskInstancesShrinkRequest() {}

  explicit UpdateTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (taskInstancesShrink) {
      res["TaskInstances"] = boost::any(*taskInstancesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      taskInstancesShrink = make_shared<string>(boost::any_cast<string>(m["TaskInstances"]));
    }
  }


  virtual ~UpdateTaskInstancesShrinkRequest() = default;
};
class UpdateTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  UpdateTaskInstancesResponseBody() {}

  explicit UpdateTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskInstancesResponseBody() = default;
};
class UpdateTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskInstancesResponseBody> body{};

  UpdateTaskInstancesResponse() {}

  explicit UpdateTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskInstancesResponse() = default;
};
class UpdateWorkflowRequestDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateWorkflowRequestDependencies() {}

  explicit UpdateWorkflowRequestDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateWorkflowRequestDependencies() = default;
};
class UpdateWorkflowRequestOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateWorkflowRequestOutputsTaskOutputs() {}

  explicit UpdateWorkflowRequestOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateWorkflowRequestOutputsTaskOutputs() = default;
};
class UpdateWorkflowRequestOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestOutputsTaskOutputs>> taskOutputs{};

  UpdateWorkflowRequestOutputs() {}

  explicit UpdateWorkflowRequestOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateWorkflowRequestOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateWorkflowRequestOutputsTaskOutputs>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestOutputs() = default;
};
class UpdateWorkflowRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTags() {}

  explicit UpdateWorkflowRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTags() = default;
};
class UpdateWorkflowRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateWorkflowRequestTasksDataSource() {}

  explicit UpdateWorkflowRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksDataSource() = default;
};
class UpdateWorkflowRequestTasksDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateWorkflowRequestTasksDependencies() {}

  explicit UpdateWorkflowRequestTasksDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksDependencies() = default;
};
class UpdateWorkflowRequestTasksInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksInputsVariables() {}

  explicit UpdateWorkflowRequestTasksInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksInputsVariables() = default;
};
class UpdateWorkflowRequestTasksInputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestTasksInputsVariables>> variables{};

  UpdateWorkflowRequestTasksInputs() {}

  explicit UpdateWorkflowRequestTasksInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateWorkflowRequestTasksInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateWorkflowRequestTasksInputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestTasksInputs() = default;
};
class UpdateWorkflowRequestTasksOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateWorkflowRequestTasksOutputsTaskOutputs() {}

  explicit UpdateWorkflowRequestTasksOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputsTaskOutputs() = default;
};
class UpdateWorkflowRequestTasksOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksOutputsVariables() {}

  explicit UpdateWorkflowRequestTasksOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputsVariables() = default;
};
class UpdateWorkflowRequestTasksOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestTasksOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<UpdateWorkflowRequestTasksOutputsVariables>> variables{};

  UpdateWorkflowRequestTasksOutputs() {}

  explicit UpdateWorkflowRequestTasksOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateWorkflowRequestTasksOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateWorkflowRequestTasksOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateWorkflowRequestTasksOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateWorkflowRequestTasksOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputs() = default;
};
class UpdateWorkflowRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  UpdateWorkflowRequestTasksRuntimeResource() {}

  explicit UpdateWorkflowRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksRuntimeResource() = default;
};
class UpdateWorkflowRequestTasksScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  UpdateWorkflowRequestTasksScript() {}

  explicit UpdateWorkflowRequestTasksScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksScript() = default;
};
class UpdateWorkflowRequestTasksTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksTags() {}

  explicit UpdateWorkflowRequestTasksTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksTags() = default;
};
class UpdateWorkflowRequestTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> recurrence{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTasksTrigger() {}

  explicit UpdateWorkflowRequestTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksTrigger() = default;
};
class UpdateWorkflowRequestTasks : public Darabonba::Model {
public:
  shared_ptr<long> baseLineId{};
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<UpdateWorkflowRequestTasksDataSource> dataSource{};
  shared_ptr<vector<UpdateWorkflowRequestTasksDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<UpdateWorkflowRequestTasksInputs> inputs{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWorkflowRequestTasksOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<UpdateWorkflowRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<UpdateWorkflowRequestTasksScript> script{};
  shared_ptr<vector<UpdateWorkflowRequestTasksTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<UpdateWorkflowRequestTasksTrigger> trigger{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTasks() {}

  explicit UpdateWorkflowRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseLineId) {
      res["BaseLineId"] = boost::any(*baseLineId);
    }
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseLineId") != m.end() && !m["BaseLineId"].empty()) {
      baseLineId = make_shared<long>(boost::any_cast<long>(m["BaseLineId"]));
    }
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateWorkflowRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateWorkflowRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateWorkflowRequestTasksDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateWorkflowRequestTasksDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        UpdateWorkflowRequestTasksInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<UpdateWorkflowRequestTasksInputs>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateWorkflowRequestTasksOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateWorkflowRequestTasksOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        UpdateWorkflowRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<UpdateWorkflowRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        UpdateWorkflowRequestTasksScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<UpdateWorkflowRequestTasksScript>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateWorkflowRequestTasksTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateWorkflowRequestTasksTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateWorkflowRequestTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateWorkflowRequestTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasks() = default;
};
class UpdateWorkflowRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTrigger() {}

  explicit UpdateWorkflowRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTrigger() = default;
};
class UpdateWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<vector<UpdateWorkflowRequestDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWorkflowRequestOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<vector<UpdateWorkflowRequestTags>> tags{};
  shared_ptr<vector<UpdateWorkflowRequestTasks>> tasks{};
  shared_ptr<UpdateWorkflowRequestTrigger> trigger{};

  UpdateWorkflowRequest() {}

  explicit UpdateWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateWorkflowRequestDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateWorkflowRequestDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateWorkflowRequestOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateWorkflowRequestOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateWorkflowRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateWorkflowRequestTags>>(expect1);
      }
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<UpdateWorkflowRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<UpdateWorkflowRequestTasks>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateWorkflowRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateWorkflowRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowRequest() = default;
};
class UpdateWorkflowShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> dependenciesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> outputsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> tasksShrink{};
  shared_ptr<string> triggerShrink{};

  UpdateWorkflowShrinkRequest() {}

  explicit UpdateWorkflowShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dependenciesShrink) {
      res["Dependencies"] = boost::any(*dependenciesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputsShrink) {
      res["Outputs"] = boost::any(*outputsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      dependenciesShrink = make_shared<string>(boost::any_cast<string>(m["Dependencies"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputsShrink = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateWorkflowShrinkRequest() = default;
};
class UpdateWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateWorkflowResponseBody() {}

  explicit UpdateWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateWorkflowResponseBody() = default;
};
class UpdateWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkflowResponseBody> body{};

  UpdateWorkflowResponse() {}

  explicit UpdateWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowResponse() = default;
};
class UpdateWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateWorkflowDefinitionRequest() {}

  explicit UpdateWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateWorkflowDefinitionRequest() = default;
};
class UpdateWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateWorkflowDefinitionResponseBody() {}

  explicit UpdateWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateWorkflowDefinitionResponseBody() = default;
};
class UpdateWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkflowDefinitionResponseBody> body{};

  UpdateWorkflowDefinitionResponse() {}

  explicit UpdateWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowDefinitionResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishDeploymentResponse abolishDeploymentWithOptions(shared_ptr<AbolishDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishDeploymentResponse abolishDeployment(shared_ptr<AbolishDeploymentRequest> request);
  AssociateProjectToResourceGroupResponse associateProjectToResourceGroupWithOptions(shared_ptr<AssociateProjectToResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateProjectToResourceGroupResponse associateProjectToResourceGroup(shared_ptr<AssociateProjectToResourceGroupRequest> request);
  AttachDataQualityRulesToEvaluationTaskResponse attachDataQualityRulesToEvaluationTaskWithOptions(shared_ptr<AttachDataQualityRulesToEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDataQualityRulesToEvaluationTaskResponse attachDataQualityRulesToEvaluationTask(shared_ptr<AttachDataQualityRulesToEvaluationTaskRequest> request);
  BatchUpdateTasksResponse batchUpdateTasksWithOptions(shared_ptr<BatchUpdateTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateTasksResponse batchUpdateTasks(shared_ptr<BatchUpdateTasksRequest> request);
  CloneDataSourceResponse cloneDataSourceWithOptions(shared_ptr<CloneDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneDataSourceResponse cloneDataSource(shared_ptr<CloneDataSourceRequest> request);
  CreateAlertRuleResponse createAlertRuleWithOptions(shared_ptr<CreateAlertRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertRuleResponse createAlertRule(shared_ptr<CreateAlertRuleRequest> request);
  CreateDIAlarmRuleResponse createDIAlarmRuleWithOptions(shared_ptr<CreateDIAlarmRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDIAlarmRuleResponse createDIAlarmRule(shared_ptr<CreateDIAlarmRuleRequest> request);
  CreateDIJobResponse createDIJobWithOptions(shared_ptr<CreateDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDIJobResponse createDIJob(shared_ptr<CreateDIJobRequest> request);
  CreateDataAssetTagResponse createDataAssetTagWithOptions(shared_ptr<CreateDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataAssetTagResponse createDataAssetTag(shared_ptr<CreateDataAssetTagRequest> request);
  CreateDataQualityEvaluationTaskResponse createDataQualityEvaluationTaskWithOptions(shared_ptr<CreateDataQualityEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityEvaluationTaskResponse createDataQualityEvaluationTask(shared_ptr<CreateDataQualityEvaluationTaskRequest> request);
  CreateDataQualityEvaluationTaskInstanceResponse createDataQualityEvaluationTaskInstanceWithOptions(shared_ptr<CreateDataQualityEvaluationTaskInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityEvaluationTaskInstanceResponse createDataQualityEvaluationTaskInstance(shared_ptr<CreateDataQualityEvaluationTaskInstanceRequest> request);
  CreateDataQualityRuleResponse createDataQualityRuleWithOptions(shared_ptr<CreateDataQualityRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityRuleResponse createDataQualityRule(shared_ptr<CreateDataQualityRuleRequest> request);
  CreateDataQualityRuleTemplateResponse createDataQualityRuleTemplateWithOptions(shared_ptr<CreateDataQualityRuleTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityRuleTemplateResponse createDataQualityRuleTemplate(shared_ptr<CreateDataQualityRuleTemplateRequest> request);
  CreateDataSourceResponse createDataSourceWithOptions(shared_ptr<CreateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request);
  CreateDataSourceSharedRuleResponse createDataSourceSharedRuleWithOptions(shared_ptr<CreateDataSourceSharedRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceSharedRuleResponse createDataSourceSharedRule(shared_ptr<CreateDataSourceSharedRuleRequest> request);
  CreateDeploymentResponse createDeploymentWithOptions(shared_ptr<CreateDeploymentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeploymentResponse createDeployment(shared_ptr<CreateDeploymentRequest> request);
  CreateFunctionResponse createFunctionWithOptions(shared_ptr<CreateFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFunctionResponse createFunction(shared_ptr<CreateFunctionRequest> request);
  CreateNetworkResponse createNetworkWithOptions(shared_ptr<CreateNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkResponse createNetwork(shared_ptr<CreateNetworkRequest> request);
  CreateNodeResponse createNodeWithOptions(shared_ptr<CreateNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNodeResponse createNode(shared_ptr<CreateNodeRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<CreateProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<CreateProjectRequest> request);
  CreateProjectMemberResponse createProjectMemberWithOptions(shared_ptr<CreateProjectMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectMemberResponse createProjectMember(shared_ptr<CreateProjectMemberRequest> request);
  CreateResourceResponse createResourceWithOptions(shared_ptr<CreateResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceResponse createResource(shared_ptr<CreateResourceRequest> request);
  CreateResourceGroupResponse createResourceGroupWithOptions(shared_ptr<CreateResourceGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceGroupResponse createResourceGroup(shared_ptr<CreateResourceGroupRequest> request);
  CreateRouteResponse createRouteWithOptions(shared_ptr<CreateRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteResponse createRoute(shared_ptr<CreateRouteRequest> request);
  CreateWorkflowDefinitionResponse createWorkflowDefinitionWithOptions(shared_ptr<CreateWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkflowDefinitionResponse createWorkflowDefinition(shared_ptr<CreateWorkflowDefinitionRequest> request);
  CreateWorkflowInstancesResponse createWorkflowInstancesWithOptions(shared_ptr<CreateWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkflowInstancesResponse createWorkflowInstances(shared_ptr<CreateWorkflowInstancesRequest> request);
  DeleteAlertRuleResponse deleteAlertRuleWithOptions(shared_ptr<DeleteAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRuleResponse deleteAlertRule(shared_ptr<DeleteAlertRuleRequest> request);
  DeleteDIAlarmRuleResponse deleteDIAlarmRuleWithOptions(shared_ptr<DeleteDIAlarmRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDIAlarmRuleResponse deleteDIAlarmRule(shared_ptr<DeleteDIAlarmRuleRequest> request);
  DeleteDIJobResponse deleteDIJobWithOptions(shared_ptr<DeleteDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDIJobResponse deleteDIJob(shared_ptr<DeleteDIJobRequest> request);
  DeleteDataAssetTagResponse deleteDataAssetTagWithOptions(shared_ptr<DeleteDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataAssetTagResponse deleteDataAssetTag(shared_ptr<DeleteDataAssetTagRequest> request);
  DeleteDataQualityEvaluationTaskResponse deleteDataQualityEvaluationTaskWithOptions(shared_ptr<DeleteDataQualityEvaluationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityEvaluationTaskResponse deleteDataQualityEvaluationTask(shared_ptr<DeleteDataQualityEvaluationTaskRequest> request);
  DeleteDataQualityRuleResponse deleteDataQualityRuleWithOptions(shared_ptr<DeleteDataQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityRuleResponse deleteDataQualityRule(shared_ptr<DeleteDataQualityRuleRequest> request);
  DeleteDataQualityRuleTemplateResponse deleteDataQualityRuleTemplateWithOptions(shared_ptr<DeleteDataQualityRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityRuleTemplateResponse deleteDataQualityRuleTemplate(shared_ptr<DeleteDataQualityRuleTemplateRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteDataSourceSharedRuleResponse deleteDataSourceSharedRuleWithOptions(shared_ptr<DeleteDataSourceSharedRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceSharedRuleResponse deleteDataSourceSharedRule(shared_ptr<DeleteDataSourceSharedRuleRequest> request);
  DeleteFunctionResponse deleteFunctionWithOptions(shared_ptr<DeleteFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFunctionResponse deleteFunction(shared_ptr<DeleteFunctionRequest> request);
  DeleteNetworkResponse deleteNetworkWithOptions(shared_ptr<DeleteNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkResponse deleteNetwork(shared_ptr<DeleteNetworkRequest> request);
  DeleteNodeResponse deleteNodeWithOptions(shared_ptr<DeleteNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNodeResponse deleteNode(shared_ptr<DeleteNodeRequest> request);
  DeleteProjectResponse deleteProjectWithOptions(shared_ptr<DeleteProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectResponse deleteProject(shared_ptr<DeleteProjectRequest> request);
  DeleteProjectMemberResponse deleteProjectMemberWithOptions(shared_ptr<DeleteProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectMemberResponse deleteProjectMember(shared_ptr<DeleteProjectMemberRequest> request);
  DeleteResourceResponse deleteResourceWithOptions(shared_ptr<DeleteResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceResponse deleteResource(shared_ptr<DeleteResourceRequest> request);
  DeleteResourceGroupResponse deleteResourceGroupWithOptions(shared_ptr<DeleteResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceGroupResponse deleteResourceGroup(shared_ptr<DeleteResourceGroupRequest> request);
  DeleteRouteResponse deleteRouteWithOptions(shared_ptr<DeleteRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteResponse deleteRoute(shared_ptr<DeleteRouteRequest> request);
  DeleteTaskResponse deleteTaskWithOptions(shared_ptr<DeleteTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskResponse deleteTask(shared_ptr<DeleteTaskRequest> request);
  DeleteWorkflowResponse deleteWorkflowWithOptions(shared_ptr<DeleteWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkflowResponse deleteWorkflow(shared_ptr<DeleteWorkflowRequest> request);
  DeleteWorkflowDefinitionResponse deleteWorkflowDefinitionWithOptions(shared_ptr<DeleteWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkflowDefinitionResponse deleteWorkflowDefinition(shared_ptr<DeleteWorkflowDefinitionRequest> request);
  DetachDataQualityRulesFromEvaluationTaskResponse detachDataQualityRulesFromEvaluationTaskWithOptions(shared_ptr<DetachDataQualityRulesFromEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDataQualityRulesFromEvaluationTaskResponse detachDataQualityRulesFromEvaluationTask(shared_ptr<DetachDataQualityRulesFromEvaluationTaskRequest> request);
  DissociateProjectFromResourceGroupResponse dissociateProjectFromResourceGroupWithOptions(shared_ptr<DissociateProjectFromResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateProjectFromResourceGroupResponse dissociateProjectFromResourceGroup(shared_ptr<DissociateProjectFromResourceGroupRequest> request);
  ExecDeploymentStageResponse execDeploymentStageWithOptions(shared_ptr<ExecDeploymentStageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecDeploymentStageResponse execDeploymentStage(shared_ptr<ExecDeploymentStageRequest> request);
  ExecuteAdhocWorkflowInstanceResponse executeAdhocWorkflowInstanceWithOptions(shared_ptr<ExecuteAdhocWorkflowInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteAdhocWorkflowInstanceResponse executeAdhocWorkflowInstance(shared_ptr<ExecuteAdhocWorkflowInstanceRequest> request);
  GetAlertRuleResponse getAlertRuleWithOptions(shared_ptr<GetAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlertRuleResponse getAlertRule(shared_ptr<GetAlertRuleRequest> request);
  GetCreateWorkflowInstancesResultResponse getCreateWorkflowInstancesResultWithOptions(shared_ptr<GetCreateWorkflowInstancesResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCreateWorkflowInstancesResultResponse getCreateWorkflowInstancesResult(shared_ptr<GetCreateWorkflowInstancesResultRequest> request);
  GetDIJobResponse getDIJobWithOptions(shared_ptr<GetDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDIJobResponse getDIJob(shared_ptr<GetDIJobRequest> request);
  GetDIJobLogResponse getDIJobLogWithOptions(shared_ptr<GetDIJobLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDIJobLogResponse getDIJobLog(shared_ptr<GetDIJobLogRequest> request);
  GetDataQualityEvaluationTaskResponse getDataQualityEvaluationTaskWithOptions(shared_ptr<GetDataQualityEvaluationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityEvaluationTaskResponse getDataQualityEvaluationTask(shared_ptr<GetDataQualityEvaluationTaskRequest> request);
  GetDataQualityEvaluationTaskInstanceResponse getDataQualityEvaluationTaskInstanceWithOptions(shared_ptr<GetDataQualityEvaluationTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityEvaluationTaskInstanceResponse getDataQualityEvaluationTaskInstance(shared_ptr<GetDataQualityEvaluationTaskInstanceRequest> request);
  GetDataQualityRuleResponse getDataQualityRuleWithOptions(shared_ptr<GetDataQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityRuleResponse getDataQualityRule(shared_ptr<GetDataQualityRuleRequest> request);
  GetDataQualityRuleTemplateResponse getDataQualityRuleTemplateWithOptions(shared_ptr<GetDataQualityRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityRuleTemplateResponse getDataQualityRuleTemplate(shared_ptr<GetDataQualityRuleTemplateRequest> request);
  GetDataSourceResponse getDataSourceWithOptions(shared_ptr<GetDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataSourceResponse getDataSource(shared_ptr<GetDataSourceRequest> request);
  GetDeploymentResponse getDeploymentWithOptions(shared_ptr<GetDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeploymentResponse getDeployment(shared_ptr<GetDeploymentRequest> request);
  GetFunctionResponse getFunctionWithOptions(shared_ptr<GetFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFunctionResponse getFunction(shared_ptr<GetFunctionRequest> request);
  GetJobStatusResponse getJobStatusWithOptions(shared_ptr<GetJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobStatusResponse getJobStatus(shared_ptr<GetJobStatusRequest> request);
  GetNetworkResponse getNetworkWithOptions(shared_ptr<GetNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNetworkResponse getNetwork(shared_ptr<GetNetworkRequest> request);
  GetNodeResponse getNodeWithOptions(shared_ptr<GetNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request);
  GetProjectResponse getProjectWithOptions(shared_ptr<GetProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectResponse getProject(shared_ptr<GetProjectRequest> request);
  GetProjectMemberResponse getProjectMemberWithOptions(shared_ptr<GetProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectMemberResponse getProjectMember(shared_ptr<GetProjectMemberRequest> request);
  GetProjectRoleResponse getProjectRoleWithOptions(shared_ptr<GetProjectRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectRoleResponse getProjectRole(shared_ptr<GetProjectRoleRequest> request);
  GetResourceResponse getResourceWithOptions(shared_ptr<GetResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceResponse getResource(shared_ptr<GetResourceRequest> request);
  GetResourceGroupResponse getResourceGroupWithOptions(shared_ptr<GetResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceGroupResponse getResourceGroup(shared_ptr<GetResourceGroupRequest> request);
  GetRouteResponse getRouteWithOptions(shared_ptr<GetRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRouteResponse getRoute(shared_ptr<GetRouteRequest> request);
  GetTaskResponse getTaskWithOptions(shared_ptr<GetTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskResponse getTask(shared_ptr<GetTaskRequest> request);
  GetTaskInstanceResponse getTaskInstanceWithOptions(shared_ptr<GetTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskInstanceResponse getTaskInstance(shared_ptr<GetTaskInstanceRequest> request);
  GetTaskInstanceLogResponse getTaskInstanceLogWithOptions(shared_ptr<GetTaskInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskInstanceLogResponse getTaskInstanceLog(shared_ptr<GetTaskInstanceLogRequest> request);
  GetWorkflowResponse getWorkflowWithOptions(shared_ptr<GetWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowResponse getWorkflow(shared_ptr<GetWorkflowRequest> request);
  GetWorkflowDefinitionResponse getWorkflowDefinitionWithOptions(shared_ptr<GetWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowDefinitionResponse getWorkflowDefinition(shared_ptr<GetWorkflowDefinitionRequest> request);
  GetWorkflowInstanceResponse getWorkflowInstanceWithOptions(shared_ptr<GetWorkflowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowInstanceResponse getWorkflowInstance(shared_ptr<GetWorkflowInstanceRequest> request);
  GrantMemberProjectRolesResponse grantMemberProjectRolesWithOptions(shared_ptr<GrantMemberProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantMemberProjectRolesResponse grantMemberProjectRoles(shared_ptr<GrantMemberProjectRolesRequest> request);
  ImportWorkflowDefinitionResponse importWorkflowDefinitionWithOptions(shared_ptr<ImportWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportWorkflowDefinitionResponse importWorkflowDefinition(shared_ptr<ImportWorkflowDefinitionRequest> request);
  ListAlertRulesResponse listAlertRulesWithOptions(shared_ptr<ListAlertRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertRulesResponse listAlertRules(shared_ptr<ListAlertRulesRequest> request);
  ListDIAlarmRulesResponse listDIAlarmRulesWithOptions(shared_ptr<ListDIAlarmRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIAlarmRulesResponse listDIAlarmRules(shared_ptr<ListDIAlarmRulesRequest> request);
  ListDIJobEventsResponse listDIJobEventsWithOptions(shared_ptr<ListDIJobEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobEventsResponse listDIJobEvents(shared_ptr<ListDIJobEventsRequest> request);
  ListDIJobMetricsResponse listDIJobMetricsWithOptions(shared_ptr<ListDIJobMetricsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobMetricsResponse listDIJobMetrics(shared_ptr<ListDIJobMetricsRequest> request);
  ListDIJobRunDetailsResponse listDIJobRunDetailsWithOptions(shared_ptr<ListDIJobRunDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobRunDetailsResponse listDIJobRunDetails(shared_ptr<ListDIJobRunDetailsRequest> request);
  ListDIJobsResponse listDIJobsWithOptions(shared_ptr<ListDIJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobsResponse listDIJobs(shared_ptr<ListDIJobsRequest> request);
  ListDataAssetTagsResponse listDataAssetTagsWithOptions(shared_ptr<ListDataAssetTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataAssetTagsResponse listDataAssetTags(shared_ptr<ListDataAssetTagsRequest> request);
  ListDataAssetsResponse listDataAssetsWithOptions(shared_ptr<ListDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataAssetsResponse listDataAssets(shared_ptr<ListDataAssetsRequest> request);
  ListDataQualityEvaluationTaskInstancesResponse listDataQualityEvaluationTaskInstancesWithOptions(shared_ptr<ListDataQualityEvaluationTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityEvaluationTaskInstancesResponse listDataQualityEvaluationTaskInstances(shared_ptr<ListDataQualityEvaluationTaskInstancesRequest> request);
  ListDataQualityEvaluationTasksResponse listDataQualityEvaluationTasksWithOptions(shared_ptr<ListDataQualityEvaluationTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityEvaluationTasksResponse listDataQualityEvaluationTasks(shared_ptr<ListDataQualityEvaluationTasksRequest> request);
  ListDataQualityResultsResponse listDataQualityResultsWithOptions(shared_ptr<ListDataQualityResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityResultsResponse listDataQualityResults(shared_ptr<ListDataQualityResultsRequest> request);
  ListDataQualityRuleTemplatesResponse listDataQualityRuleTemplatesWithOptions(shared_ptr<ListDataQualityRuleTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityRuleTemplatesResponse listDataQualityRuleTemplates(shared_ptr<ListDataQualityRuleTemplatesRequest> request);
  ListDataQualityRulesResponse listDataQualityRulesWithOptions(shared_ptr<ListDataQualityRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityRulesResponse listDataQualityRules(shared_ptr<ListDataQualityRulesRequest> request);
  ListDataSourceSharedRulesResponse listDataSourceSharedRulesWithOptions(shared_ptr<ListDataSourceSharedRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourceSharedRulesResponse listDataSourceSharedRules(shared_ptr<ListDataSourceSharedRulesRequest> request);
  ListDataSourcesResponse listDataSourcesWithOptions(shared_ptr<ListDataSourcesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourcesResponse listDataSources(shared_ptr<ListDataSourcesRequest> request);
  ListDeploymentsResponse listDeploymentsWithOptions(shared_ptr<ListDeploymentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeploymentsResponse listDeployments(shared_ptr<ListDeploymentsRequest> request);
  ListDownstreamTaskInstancesResponse listDownstreamTaskInstancesWithOptions(shared_ptr<ListDownstreamTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDownstreamTaskInstancesResponse listDownstreamTaskInstances(shared_ptr<ListDownstreamTaskInstancesRequest> request);
  ListDownstreamTasksResponse listDownstreamTasksWithOptions(shared_ptr<ListDownstreamTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDownstreamTasksResponse listDownstreamTasks(shared_ptr<ListDownstreamTasksRequest> request);
  ListFunctionsResponse listFunctionsWithOptions(shared_ptr<ListFunctionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFunctionsResponse listFunctions(shared_ptr<ListFunctionsRequest> request);
  ListNetworksResponse listNetworksWithOptions(shared_ptr<ListNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworksResponse listNetworks(shared_ptr<ListNetworksRequest> request);
  ListNodeDependenciesResponse listNodeDependenciesWithOptions(shared_ptr<ListNodeDependenciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeDependenciesResponse listNodeDependencies(shared_ptr<ListNodeDependenciesRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListProjectMembersResponse listProjectMembersWithOptions(shared_ptr<ListProjectMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectMembersResponse listProjectMembers(shared_ptr<ListProjectMembersRequest> request);
  ListProjectRolesResponse listProjectRolesWithOptions(shared_ptr<ListProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectRolesResponse listProjectRoles(shared_ptr<ListProjectRolesRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<ListProjectsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request);
  ListResourceGroupsResponse listResourceGroupsWithOptions(shared_ptr<ListResourceGroupsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupsResponse listResourceGroups(shared_ptr<ListResourceGroupsRequest> request);
  ListResourcesResponse listResourcesWithOptions(shared_ptr<ListResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcesResponse listResources(shared_ptr<ListResourcesRequest> request);
  ListRoutesResponse listRoutesWithOptions(shared_ptr<ListRoutesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoutesResponse listRoutes(shared_ptr<ListRoutesRequest> request);
  ListTaskInstanceOperationLogsResponse listTaskInstanceOperationLogsWithOptions(shared_ptr<ListTaskInstanceOperationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskInstanceOperationLogsResponse listTaskInstanceOperationLogs(shared_ptr<ListTaskInstanceOperationLogsRequest> request);
  ListTaskInstancesResponse listTaskInstancesWithOptions(shared_ptr<ListTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskInstancesResponse listTaskInstances(shared_ptr<ListTaskInstancesRequest> request);
  ListTaskOperationLogsResponse listTaskOperationLogsWithOptions(shared_ptr<ListTaskOperationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskOperationLogsResponse listTaskOperationLogs(shared_ptr<ListTaskOperationLogsRequest> request);
  ListTasksResponse listTasksWithOptions(shared_ptr<ListTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTasksResponse listTasks(shared_ptr<ListTasksRequest> request);
  ListUpstreamTaskInstancesResponse listUpstreamTaskInstancesWithOptions(shared_ptr<ListUpstreamTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamTaskInstancesResponse listUpstreamTaskInstances(shared_ptr<ListUpstreamTaskInstancesRequest> request);
  ListUpstreamTasksResponse listUpstreamTasksWithOptions(shared_ptr<ListUpstreamTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamTasksResponse listUpstreamTasks(shared_ptr<ListUpstreamTasksRequest> request);
  ListWorkflowDefinitionsResponse listWorkflowDefinitionsWithOptions(shared_ptr<ListWorkflowDefinitionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowDefinitionsResponse listWorkflowDefinitions(shared_ptr<ListWorkflowDefinitionsRequest> request);
  ListWorkflowInstancesResponse listWorkflowInstancesWithOptions(shared_ptr<ListWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowInstancesResponse listWorkflowInstances(shared_ptr<ListWorkflowInstancesRequest> request);
  ListWorkflowsResponse listWorkflowsWithOptions(shared_ptr<ListWorkflowsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowsResponse listWorkflows(shared_ptr<ListWorkflowsRequest> request);
  MoveFunctionResponse moveFunctionWithOptions(shared_ptr<MoveFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveFunctionResponse moveFunction(shared_ptr<MoveFunctionRequest> request);
  MoveNodeResponse moveNodeWithOptions(shared_ptr<MoveNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveNodeResponse moveNode(shared_ptr<MoveNodeRequest> request);
  MoveResourceResponse moveResourceWithOptions(shared_ptr<MoveResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceResponse moveResource(shared_ptr<MoveResourceRequest> request);
  MoveWorkflowDefinitionResponse moveWorkflowDefinitionWithOptions(shared_ptr<MoveWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveWorkflowDefinitionResponse moveWorkflowDefinition(shared_ptr<MoveWorkflowDefinitionRequest> request);
  RemoveTaskInstanceDependenciesResponse removeTaskInstanceDependenciesWithOptions(shared_ptr<RemoveTaskInstanceDependenciesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTaskInstanceDependenciesResponse removeTaskInstanceDependencies(shared_ptr<RemoveTaskInstanceDependenciesRequest> request);
  RenameFunctionResponse renameFunctionWithOptions(shared_ptr<RenameFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameFunctionResponse renameFunction(shared_ptr<RenameFunctionRequest> request);
  RenameNodeResponse renameNodeWithOptions(shared_ptr<RenameNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameNodeResponse renameNode(shared_ptr<RenameNodeRequest> request);
  RenameResourceResponse renameResourceWithOptions(shared_ptr<RenameResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameResourceResponse renameResource(shared_ptr<RenameResourceRequest> request);
  RenameWorkflowDefinitionResponse renameWorkflowDefinitionWithOptions(shared_ptr<RenameWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameWorkflowDefinitionResponse renameWorkflowDefinition(shared_ptr<RenameWorkflowDefinitionRequest> request);
  RerunTaskInstancesResponse rerunTaskInstancesWithOptions(shared_ptr<RerunTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RerunTaskInstancesResponse rerunTaskInstances(shared_ptr<RerunTaskInstancesRequest> request);
  ResumeTaskInstancesResponse resumeTaskInstancesWithOptions(shared_ptr<ResumeTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeTaskInstancesResponse resumeTaskInstances(shared_ptr<ResumeTaskInstancesRequest> request);
  RevokeMemberProjectRolesResponse revokeMemberProjectRolesWithOptions(shared_ptr<RevokeMemberProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeMemberProjectRolesResponse revokeMemberProjectRoles(shared_ptr<RevokeMemberProjectRolesRequest> request);
  SetSuccessTaskInstancesResponse setSuccessTaskInstancesWithOptions(shared_ptr<SetSuccessTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSuccessTaskInstancesResponse setSuccessTaskInstances(shared_ptr<SetSuccessTaskInstancesRequest> request);
  StartDIJobResponse startDIJobWithOptions(shared_ptr<StartDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDIJobResponse startDIJob(shared_ptr<StartDIJobRequest> request);
  StartWorkflowInstancesResponse startWorkflowInstancesWithOptions(shared_ptr<StartWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartWorkflowInstancesResponse startWorkflowInstances(shared_ptr<StartWorkflowInstancesRequest> request);
  StopDIJobResponse stopDIJobWithOptions(shared_ptr<StopDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDIJobResponse stopDIJob(shared_ptr<StopDIJobRequest> request);
  StopTaskInstancesResponse stopTaskInstancesWithOptions(shared_ptr<StopTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopTaskInstancesResponse stopTaskInstances(shared_ptr<StopTaskInstancesRequest> request);
  StopWorkflowInstancesResponse stopWorkflowInstancesWithOptions(shared_ptr<StopWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopWorkflowInstancesResponse stopWorkflowInstances(shared_ptr<StopWorkflowInstancesRequest> request);
  SuspendTaskInstancesResponse suspendTaskInstancesWithOptions(shared_ptr<SuspendTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendTaskInstancesResponse suspendTaskInstances(shared_ptr<SuspendTaskInstancesRequest> request);
  TagDataAssetsResponse tagDataAssetsWithOptions(shared_ptr<TagDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagDataAssetsResponse tagDataAssets(shared_ptr<TagDataAssetsRequest> request);
  TriggerSchedulerTaskInstanceResponse triggerSchedulerTaskInstanceWithOptions(shared_ptr<TriggerSchedulerTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerSchedulerTaskInstanceResponse triggerSchedulerTaskInstance(shared_ptr<TriggerSchedulerTaskInstanceRequest> request);
  UnTagDataAssetsResponse unTagDataAssetsWithOptions(shared_ptr<UnTagDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnTagDataAssetsResponse unTagDataAssets(shared_ptr<UnTagDataAssetsRequest> request);
  UpdateAlertRuleResponse updateAlertRuleWithOptions(shared_ptr<UpdateAlertRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertRuleResponse updateAlertRule(shared_ptr<UpdateAlertRuleRequest> request);
  UpdateDIAlarmRuleResponse updateDIAlarmRuleWithOptions(shared_ptr<UpdateDIAlarmRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDIAlarmRuleResponse updateDIAlarmRule(shared_ptr<UpdateDIAlarmRuleRequest> request);
  UpdateDIJobResponse updateDIJobWithOptions(shared_ptr<UpdateDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDIJobResponse updateDIJob(shared_ptr<UpdateDIJobRequest> request);
  UpdateDataAssetTagResponse updateDataAssetTagWithOptions(shared_ptr<UpdateDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataAssetTagResponse updateDataAssetTag(shared_ptr<UpdateDataAssetTagRequest> request);
  UpdateDataQualityEvaluationTaskResponse updateDataQualityEvaluationTaskWithOptions(shared_ptr<UpdateDataQualityEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityEvaluationTaskResponse updateDataQualityEvaluationTask(shared_ptr<UpdateDataQualityEvaluationTaskRequest> request);
  UpdateDataQualityRuleResponse updateDataQualityRuleWithOptions(shared_ptr<UpdateDataQualityRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityRuleResponse updateDataQualityRule(shared_ptr<UpdateDataQualityRuleRequest> request);
  UpdateDataQualityRuleTemplateResponse updateDataQualityRuleTemplateWithOptions(shared_ptr<UpdateDataQualityRuleTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityRuleTemplateResponse updateDataQualityRuleTemplate(shared_ptr<UpdateDataQualityRuleTemplateRequest> request);
  UpdateDataSourceResponse updateDataSourceWithOptions(shared_ptr<UpdateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceResponse updateDataSource(shared_ptr<UpdateDataSourceRequest> request);
  UpdateFunctionResponse updateFunctionWithOptions(shared_ptr<UpdateFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFunctionResponse updateFunction(shared_ptr<UpdateFunctionRequest> request);
  UpdateNodeResponse updateNodeWithOptions(shared_ptr<UpdateNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeResponse updateNode(shared_ptr<UpdateNodeRequest> request);
  UpdateProjectResponse updateProjectWithOptions(shared_ptr<UpdateProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectResponse updateProject(shared_ptr<UpdateProjectRequest> request);
  UpdateResourceResponse updateResourceWithOptions(shared_ptr<UpdateResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceResponse updateResource(shared_ptr<UpdateResourceRequest> request);
  UpdateResourceGroupResponse updateResourceGroupWithOptions(shared_ptr<UpdateResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceGroupResponse updateResourceGroup(shared_ptr<UpdateResourceGroupRequest> request);
  UpdateRouteResponse updateRouteWithOptions(shared_ptr<UpdateRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRouteResponse updateRoute(shared_ptr<UpdateRouteRequest> request);
  UpdateTaskResponse updateTaskWithOptions(shared_ptr<UpdateTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskResponse updateTask(shared_ptr<UpdateTaskRequest> request);
  UpdateTaskInstancesResponse updateTaskInstancesWithOptions(shared_ptr<UpdateTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskInstancesResponse updateTaskInstances(shared_ptr<UpdateTaskInstancesRequest> request);
  UpdateWorkflowResponse updateWorkflowWithOptions(shared_ptr<UpdateWorkflowRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkflowResponse updateWorkflow(shared_ptr<UpdateWorkflowRequest> request);
  UpdateWorkflowDefinitionResponse updateWorkflowDefinitionWithOptions(shared_ptr<UpdateWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkflowDefinitionResponse updateWorkflowDefinition(shared_ptr<UpdateWorkflowDefinitionRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dataworks-public20240518

#endif
