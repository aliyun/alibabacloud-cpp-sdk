// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DATAWORKS-PUBLIC20240518_H_
#define ALIBABACLOUD_DATAWORKS-PUBLIC20240518_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dataworks-public20240518 {
class Catalog : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> type{};

  Catalog() {}

  explicit Catalog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~Catalog() = default;
};
class ColumnBusinessMetadata : public Darabonba::Model {
public:
  shared_ptr<string> description{};

  ColumnBusinessMetadata() {}

  explicit ColumnBusinessMetadata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ColumnBusinessMetadata() = default;
};
class Column : public Darabonba::Model {
public:
  shared_ptr<ColumnBusinessMetadata> businessMetadata{};
  shared_ptr<string> comment{};
  shared_ptr<bool> foreignKey{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<bool> partitionKey{};
  shared_ptr<long> position{};
  shared_ptr<bool> primaryKey{};
  shared_ptr<string> tableId{};
  shared_ptr<string> type{};

  Column() {}

  explicit Column(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMetadata) {
      res["BusinessMetadata"] = businessMetadata ? boost::any(businessMetadata->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (foreignKey) {
      res["ForeignKey"] = boost::any(*foreignKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (partitionKey) {
      res["PartitionKey"] = boost::any(*partitionKey);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMetadata") != m.end() && !m["BusinessMetadata"].empty()) {
      if (typeid(map<string, boost::any>) == m["BusinessMetadata"].type()) {
        ColumnBusinessMetadata model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BusinessMetadata"]));
        businessMetadata = make_shared<ColumnBusinessMetadata>(model1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ForeignKey") != m.end() && !m["ForeignKey"].empty()) {
      foreignKey = make_shared<bool>(boost::any_cast<bool>(m["ForeignKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PartitionKey") != m.end() && !m["PartitionKey"].empty()) {
      partitionKey = make_shared<bool>(boost::any_cast<bool>(m["PartitionKey"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<bool>(boost::any_cast<bool>(m["PrimaryKey"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~Column() = default;
};
class CrawlerTypeSupportedEntityTypes : public Darabonba::Model {
public:
  shared_ptr<bool> optional{};
  shared_ptr<string> parentSubType{};
  shared_ptr<string> subType{};
  shared_ptr<string> type{};

  CrawlerTypeSupportedEntityTypes() {}

  explicit CrawlerTypeSupportedEntityTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (parentSubType) {
      res["ParentSubType"] = boost::any(*parentSubType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<bool>(boost::any_cast<bool>(m["Optional"]));
    }
    if (m.find("ParentSubType") != m.end() && !m["ParentSubType"].empty()) {
      parentSubType = make_shared<string>(boost::any_cast<string>(m["ParentSubType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CrawlerTypeSupportedEntityTypes() = default;
};
class CrawlerType : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<CrawlerTypeSupportedEntityTypes>> supportedEntityTypes{};
  shared_ptr<string> type{};

  CrawlerType() {}

  explicit CrawlerType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (supportedEntityTypes) {
      vector<boost::any> temp1;
      for(auto item1:*supportedEntityTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedEntityTypes"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("SupportedEntityTypes") != m.end() && !m["SupportedEntityTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedEntityTypes"].type()) {
        vector<CrawlerTypeSupportedEntityTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedEntityTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CrawlerTypeSupportedEntityTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedEntityTypes = make_shared<vector<CrawlerTypeSupportedEntityTypes>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CrawlerType() = default;
};
class DataQualityEvaluationTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskHooks() {}

  explicit DataQualityEvaluationTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskHooks() = default;
};
class DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() {}

  explicit DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() = default;
};
class DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() {}

  explicit DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() = default;
};
class DataQualityEvaluationTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  DataQualityEvaluationTaskNotificationsNotifications() {}

  explicit DataQualityEvaluationTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskNotificationsNotifications() = default;
};
class DataQualityEvaluationTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<DataQualityEvaluationTaskNotificationsNotifications>> notifications{};

  DataQualityEvaluationTaskNotifications() {}

  explicit DataQualityEvaluationTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskNotifications() = default;
};
class DataQualityEvaluationTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskTarget() {}

  explicit DataQualityEvaluationTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskTarget() = default;
};
class DataQualityEvaluationTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskTrigger() {}

  explicit DataQualityEvaluationTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskTrigger() = default;
};
class DataQualityEvaluationTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<DataQualityEvaluationTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DataQualityEvaluationTaskNotifications>> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<DataQualityEvaluationTaskTarget> target{};
  shared_ptr<long> tenantId{};
  shared_ptr<DataQualityEvaluationTaskTrigger> trigger{};

  DataQualityEvaluationTask() {}

  explicit DataQualityEvaluationTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<DataQualityEvaluationTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<DataQualityEvaluationTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskNotifications>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityEvaluationTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityEvaluationTaskTarget>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DataQualityEvaluationTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DataQualityEvaluationTaskTrigger>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTask() = default;
};
class DataQualityEvaluationTaskInstanceTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskHooks() {}

  explicit DataQualityEvaluationTaskInstanceTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskHooks() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  DataQualityEvaluationTaskInstanceTaskNotificationsNotifications() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotificationsNotifications() = default;
};
class DataQualityEvaluationTaskInstanceTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications>> notifications{};

  DataQualityEvaluationTaskInstanceTaskNotifications() {}

  explicit DataQualityEvaluationTaskInstanceTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskNotifications() = default;
};
class DataQualityEvaluationTaskInstanceTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskTarget() {}

  explicit DataQualityEvaluationTaskInstanceTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskTarget() = default;
};
class DataQualityEvaluationTaskInstanceTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  DataQualityEvaluationTaskInstanceTaskTrigger() {}

  explicit DataQualityEvaluationTaskInstanceTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTaskTrigger() = default;
};
class DataQualityEvaluationTaskInstanceTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DataQualityEvaluationTaskInstanceTaskNotifications>> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<DataQualityEvaluationTaskInstanceTaskTarget> target{};
  shared_ptr<long> tenantId{};
  shared_ptr<DataQualityEvaluationTaskInstanceTaskTrigger> trigger{};

  DataQualityEvaluationTaskInstanceTask() {}

  explicit DataQualityEvaluationTaskInstanceTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<DataQualityEvaluationTaskInstanceTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<DataQualityEvaluationTaskInstanceTaskNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityEvaluationTaskInstanceTaskNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<DataQualityEvaluationTaskInstanceTaskNotifications>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityEvaluationTaskInstanceTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityEvaluationTaskInstanceTaskTarget>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DataQualityEvaluationTaskInstanceTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DataQualityEvaluationTaskInstanceTaskTrigger>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstanceTask() = default;
};
class DataQualityEvaluationTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> status{};
  shared_ptr<DataQualityEvaluationTaskInstanceTask> task{};

  DataQualityEvaluationTaskInstance() {}

  explicit DataQualityEvaluationTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        DataQualityEvaluationTaskInstanceTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<DataQualityEvaluationTaskInstanceTask>(model1);
      }
    }
  }


  virtual ~DataQualityEvaluationTaskInstance() = default;
};
class DataQualityResultDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkedValue{};
  shared_ptr<string> referencedValue{};
  shared_ptr<string> status{};

  DataQualityResultDetails() {}

  explicit DataQualityResultDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkedValue) {
      res["CheckedValue"] = boost::any(*checkedValue);
    }
    if (referencedValue) {
      res["ReferencedValue"] = boost::any(*referencedValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckedValue") != m.end() && !m["CheckedValue"].empty()) {
      checkedValue = make_shared<string>(boost::any_cast<string>(m["CheckedValue"]));
    }
    if (m.find("ReferencedValue") != m.end() && !m["ReferencedValue"].empty()) {
      referencedValue = make_shared<string>(boost::any_cast<string>(m["ReferencedValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DataQualityResultDetails() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsCritical() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsCritical() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsExpected() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsExpected() = default;
};
class DataQualityResultRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityResultRuleCheckingConfigThresholdsWarned() {}

  explicit DataQualityResultRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholdsWarned() = default;
};
class DataQualityResultRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholdsWarned> warned{};

  DataQualityResultRuleCheckingConfigThresholds() {}

  explicit DataQualityResultRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DataQualityResultRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<DataQualityResultRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        DataQualityResultRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<DataQualityResultRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~DataQualityResultRuleCheckingConfigThresholds() = default;
};
class DataQualityResultRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<DataQualityResultRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  DataQualityResultRuleCheckingConfig() {}

  explicit DataQualityResultRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        DataQualityResultRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<DataQualityResultRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleCheckingConfig() = default;
};
class DataQualityResultRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  DataQualityResultRuleErrorHandlers() {}

  explicit DataQualityResultRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleErrorHandlers() = default;
};
class DataQualityResultRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  DataQualityResultRuleSamplingConfig() {}

  explicit DataQualityResultRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityResultRuleSamplingConfig() = default;
};
class DataQualityResultRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityResultRuleTarget() {}

  explicit DataQualityResultRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityResultRuleTarget() = default;
};
class DataQualityResultRule : public Darabonba::Model {
public:
  shared_ptr<DataQualityResultRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<DataQualityResultRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityResultRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<DataQualityResultRuleTarget> target{};
  shared_ptr<string> templateCode{};
  shared_ptr<long> tenantId{};

  DataQualityResultRule() {}

  explicit DataQualityResultRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityResultRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityResultRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<DataQualityResultRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityResultRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<DataQualityResultRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityResultRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityResultRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityResultRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityResultRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~DataQualityResultRule() = default;
};
class DataQualityResult : public Darabonba::Model {
public:
  shared_ptr<vector<DataQualityResultDetails>> details{};
  shared_ptr<long> id{};
  shared_ptr<DataQualityResultRule> rule{};
  shared_ptr<string> sample{};
  shared_ptr<string> status{};
  shared_ptr<long> taskInstanceId{};

  DataQualityResult() {}

  explicit DataQualityResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DataQualityResultDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityResultDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DataQualityResultDetails>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        DataQualityResultRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<DataQualityResultRule>(model1);
      }
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~DataQualityResult() = default;
};
class DataQualityRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsCritical() {}

  explicit DataQualityRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsCritical() = default;
};
class DataQualityRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsExpected() {}

  explicit DataQualityRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsExpected() = default;
};
class DataQualityRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DataQualityRuleCheckingConfigThresholdsWarned() {}

  explicit DataQualityRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholdsWarned() = default;
};
class DataQualityRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<DataQualityRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<DataQualityRuleCheckingConfigThresholdsWarned> warned{};

  DataQualityRuleCheckingConfigThresholds() {}

  explicit DataQualityRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DataQualityRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DataQualityRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        DataQualityRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<DataQualityRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        DataQualityRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<DataQualityRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~DataQualityRuleCheckingConfigThresholds() = default;
};
class DataQualityRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<DataQualityRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  DataQualityRuleCheckingConfig() {}

  explicit DataQualityRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        DataQualityRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<DataQualityRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleCheckingConfig() = default;
};
class DataQualityRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  DataQualityRuleErrorHandlers() {}

  explicit DataQualityRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleErrorHandlers() = default;
};
class DataQualityRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  DataQualityRuleSamplingConfig() {}

  explicit DataQualityRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityRuleSamplingConfig() = default;
};
class DataQualityRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  DataQualityRuleTarget() {}

  explicit DataQualityRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleTarget() = default;
};
class DataQualityRule : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<DataQualityRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<DataQualityRuleTarget> target{};
  shared_ptr<string> templateCode{};
  shared_ptr<long> tenantId{};

  DataQualityRule() {}

  explicit DataQualityRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<DataQualityRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataQualityRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<DataQualityRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        DataQualityRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<DataQualityRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~DataQualityRule() = default;
};
class DataQualityRuleTemplateCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  DataQualityRuleTemplateCheckingConfig() {}

  explicit DataQualityRuleTemplateCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DataQualityRuleTemplateCheckingConfig() = default;
};
class DataQualityRuleTemplateSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  DataQualityRuleTemplateSamplingConfig() {}

  explicit DataQualityRuleTemplateSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~DataQualityRuleTemplateSamplingConfig() = default;
};
class DataQualityRuleTemplate : public Darabonba::Model {
public:
  shared_ptr<DataQualityRuleTemplateCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<DataQualityRuleTemplateSamplingConfig> samplingConfig{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> visibleScope{};

  DataQualityRuleTemplate() {}

  explicit DataQualityRuleTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        DataQualityRuleTemplateCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<DataQualityRuleTemplateCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        DataQualityRuleTemplateSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<DataQualityRuleTemplateSamplingConfig>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~DataQualityRuleTemplate() = default;
};
class Database : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> locationUri{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentMetaEntityId{};

  Database() {}

  explicit Database(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (locationUri) {
      res["LocationUri"] = boost::any(*locationUri);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LocationUri") != m.end() && !m["LocationUri"].empty()) {
      locationUri = make_shared<string>(boost::any_cast<string>(m["LocationUri"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
  }


  virtual ~Database() = default;
};
class LineageEntity : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> attributes{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  LineageEntity() {}

  explicit LineageEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Attributes"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      attributes = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~LineageEntity() = default;
};
class LineageTask : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> attributes{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  LineageTask() {}

  explicit LineageTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Attributes"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      attributes = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~LineageTask() = default;
};
class LineageRelationship : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<LineageEntity> dstEntity{};
  shared_ptr<string> id{};
  shared_ptr<LineageEntity> srcEntity{};
  shared_ptr<LineageTask> task{};

  LineageRelationship() {}

  explicit LineageRelationship(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dstEntity) {
      res["DstEntity"] = dstEntity ? boost::any(dstEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (srcEntity) {
      res["SrcEntity"] = srcEntity ? boost::any(srcEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DstEntity") != m.end() && !m["DstEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstEntity"]));
        dstEntity = make_shared<LineageEntity>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SrcEntity") != m.end() && !m["SrcEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcEntity"]));
        srcEntity = make_shared<LineageEntity>(model1);
      }
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        LineageTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<LineageTask>(model1);
      }
    }
  }


  virtual ~LineageRelationship() = default;
};
class Partition : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<long> recordCount{};
  shared_ptr<string> tableId{};

  Partition() {}

  explicit Partition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
  }


  virtual ~Partition() = default;
};
class Schema : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> type{};

  Schema() {}

  explicit Schema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~Schema() = default;
};
class TableBusinessMetadataCategories : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  TableBusinessMetadataCategories() {}

  explicit TableBusinessMetadataCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~TableBusinessMetadataCategories() = default;
};
class TableBusinessMetadataExtension : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<long> favorCount{};
  shared_ptr<long> projectId{};
  shared_ptr<long> readCount{};
  shared_ptr<long> viewCount{};

  TableBusinessMetadataExtension() {}

  explicit TableBusinessMetadataExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (favorCount) {
      res["FavorCount"] = boost::any(*favorCount);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (readCount) {
      res["ReadCount"] = boost::any(*readCount);
    }
    if (viewCount) {
      res["ViewCount"] = boost::any(*viewCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FavorCount") != m.end() && !m["FavorCount"].empty()) {
      favorCount = make_shared<long>(boost::any_cast<long>(m["FavorCount"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ReadCount") != m.end() && !m["ReadCount"].empty()) {
      readCount = make_shared<long>(boost::any_cast<long>(m["ReadCount"]));
    }
    if (m.find("ViewCount") != m.end() && !m["ViewCount"].empty()) {
      viewCount = make_shared<long>(boost::any_cast<long>(m["ViewCount"]));
    }
  }


  virtual ~TableBusinessMetadataExtension() = default;
};
class TableBusinessMetadataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TableBusinessMetadataTags() {}

  explicit TableBusinessMetadataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TableBusinessMetadataTags() = default;
};
class TableBusinessMetadataUpstreamTasks : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  TableBusinessMetadataUpstreamTasks() {}

  explicit TableBusinessMetadataUpstreamTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~TableBusinessMetadataUpstreamTasks() = default;
};
class TableBusinessMetadata : public Darabonba::Model {
public:
  shared_ptr<vector<vector<undefined>>> categories{};
  shared_ptr<TableBusinessMetadataExtension> extension{};
  shared_ptr<string> readme{};
  shared_ptr<vector<TableBusinessMetadataTags>> tags{};
  shared_ptr<vector<TableBusinessMetadataUpstreamTasks>> upstreamTasks{};

  TableBusinessMetadata() {}

  explicit TableBusinessMetadata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["Categories"] = boost::any(temp1);
    }
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readme) {
      res["Readme"] = boost::any(*readme);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (upstreamTasks) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        categories = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        TableBusinessMetadataExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<TableBusinessMetadataExtension>(model1);
      }
    }
    if (m.find("Readme") != m.end() && !m["Readme"].empty()) {
      readme = make_shared<string>(boost::any_cast<string>(m["Readme"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TableBusinessMetadataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TableBusinessMetadataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TableBusinessMetadataTags>>(expect1);
      }
    }
    if (m.find("UpstreamTasks") != m.end() && !m["UpstreamTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamTasks"].type()) {
        vector<TableBusinessMetadataUpstreamTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TableBusinessMetadataUpstreamTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamTasks = make_shared<vector<TableBusinessMetadataUpstreamTasks>>(expect1);
      }
    }
  }


  virtual ~TableBusinessMetadata() = default;
};
class TableTechnicalMetadata : public Darabonba::Model {
public:
  shared_ptr<bool> compressed{};
  shared_ptr<string> inputFormat{};
  shared_ptr<string> location{};
  shared_ptr<string> outputFormat{};
  shared_ptr<string> owner{};
  shared_ptr<map<string, string>> parameters{};
  shared_ptr<string> serializationLibrary{};

  TableTechnicalMetadata() {}

  explicit TableTechnicalMetadata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressed) {
      res["Compressed"] = boost::any(*compressed);
    }
    if (inputFormat) {
      res["InputFormat"] = boost::any(*inputFormat);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (outputFormat) {
      res["OutputFormat"] = boost::any(*outputFormat);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (serializationLibrary) {
      res["SerializationLibrary"] = boost::any(*serializationLibrary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compressed") != m.end() && !m["Compressed"].empty()) {
      compressed = make_shared<bool>(boost::any_cast<bool>(m["Compressed"]));
    }
    if (m.find("InputFormat") != m.end() && !m["InputFormat"].empty()) {
      inputFormat = make_shared<string>(boost::any_cast<string>(m["InputFormat"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OutputFormat") != m.end() && !m["OutputFormat"].empty()) {
      outputFormat = make_shared<string>(boost::any_cast<string>(m["OutputFormat"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Parameters"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("SerializationLibrary") != m.end() && !m["SerializationLibrary"].empty()) {
      serializationLibrary = make_shared<string>(boost::any_cast<string>(m["SerializationLibrary"]));
    }
  }


  virtual ~TableTechnicalMetadata() = default;
};
class Table : public Darabonba::Model {
public:
  shared_ptr<TableBusinessMetadata> businessMetadata{};
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<vector<string>> partitionKeys{};
  shared_ptr<string> tableType{};
  shared_ptr<TableTechnicalMetadata> technicalMetadata{};

  Table() {}

  explicit Table(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMetadata) {
      res["BusinessMetadata"] = businessMetadata ? boost::any(businessMetadata->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (partitionKeys) {
      res["PartitionKeys"] = boost::any(*partitionKeys);
    }
    if (tableType) {
      res["TableType"] = boost::any(*tableType);
    }
    if (technicalMetadata) {
      res["TechnicalMetadata"] = technicalMetadata ? boost::any(technicalMetadata->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMetadata") != m.end() && !m["BusinessMetadata"].empty()) {
      if (typeid(map<string, boost::any>) == m["BusinessMetadata"].type()) {
        TableBusinessMetadata model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BusinessMetadata"]));
        businessMetadata = make_shared<TableBusinessMetadata>(model1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("PartitionKeys") != m.end() && !m["PartitionKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PartitionKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PartitionKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      partitionKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TableType") != m.end() && !m["TableType"].empty()) {
      tableType = make_shared<string>(boost::any_cast<string>(m["TableType"]));
    }
    if (m.find("TechnicalMetadata") != m.end() && !m["TechnicalMetadata"].empty()) {
      if (typeid(map<string, boost::any>) == m["TechnicalMetadata"].type()) {
        TableTechnicalMetadata model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TechnicalMetadata"]));
        technicalMetadata = make_shared<TableTechnicalMetadata>(model1);
      }
    }
  }


  virtual ~Table() = default;
};
class SuccessInfoValue : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  SuccessInfoValue() {}

  explicit SuccessInfoValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SuccessInfoValue() = default;
};
class AbolishPipelineRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  AbolishPipelineRunRequest() {}

  explicit AbolishPipelineRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AbolishPipelineRunRequest() = default;
};
class AbolishPipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AbolishPipelineRunResponseBody() {}

  explicit AbolishPipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AbolishPipelineRunResponseBody() = default;
};
class AbolishPipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbolishPipelineRunResponseBody> body{};

  AbolishPipelineRunResponse() {}

  explicit AbolishPipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishPipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishPipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishPipelineRunResponse() = default;
};
class AddEntityIntoMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> metaCollectionId{};
  shared_ptr<string> remark{};

  AddEntityIntoMetaCollectionRequest() {}

  explicit AddEntityIntoMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metaCollectionId) {
      res["MetaCollectionId"] = boost::any(*metaCollectionId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetaCollectionId") != m.end() && !m["MetaCollectionId"].empty()) {
      metaCollectionId = make_shared<string>(boost::any_cast<string>(m["MetaCollectionId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~AddEntityIntoMetaCollectionRequest() = default;
};
class AddEntityIntoMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddEntityIntoMetaCollectionResponseBody() {}

  explicit AddEntityIntoMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEntityIntoMetaCollectionResponseBody() = default;
};
class AddEntityIntoMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEntityIntoMetaCollectionResponseBody> body{};

  AddEntityIntoMetaCollectionResponse() {}

  explicit AddEntityIntoMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEntityIntoMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEntityIntoMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~AddEntityIntoMetaCollectionResponse() = default;
};
class AssociateProjectToResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupId{};

  AssociateProjectToResourceGroupRequest() {}

  explicit AssociateProjectToResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AssociateProjectToResourceGroupRequest() = default;
};
class AssociateProjectToResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AssociateProjectToResourceGroupResponseBody() {}

  explicit AssociateProjectToResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AssociateProjectToResourceGroupResponseBody() = default;
};
class AssociateProjectToResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateProjectToResourceGroupResponseBody> body{};

  AssociateProjectToResourceGroupResponse() {}

  explicit AssociateProjectToResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateProjectToResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateProjectToResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateProjectToResourceGroupResponse() = default;
};
class AttachDataQualityRulesToEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<vector<long>> dataQualityRuleIds{};
  shared_ptr<long> projectId{};

  AttachDataQualityRulesToEvaluationTaskRequest() {}

  explicit AttachDataQualityRulesToEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIds) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DataQualityRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataQualityRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dataQualityRuleIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskRequest() = default;
};
class AttachDataQualityRulesToEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> dataQualityRuleIdsShrink{};
  shared_ptr<long> projectId{};

  AttachDataQualityRulesToEvaluationTaskShrinkRequest() {}

  explicit AttachDataQualityRulesToEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIdsShrink) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      dataQualityRuleIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRuleIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskShrinkRequest() = default;
};
class AttachDataQualityRulesToEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AttachDataQualityRulesToEvaluationTaskResponseBody() {}

  explicit AttachDataQualityRulesToEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskResponseBody() = default;
};
class AttachDataQualityRulesToEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDataQualityRulesToEvaluationTaskResponseBody> body{};

  AttachDataQualityRulesToEvaluationTaskResponse() {}

  explicit AttachDataQualityRulesToEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDataQualityRulesToEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDataQualityRulesToEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDataQualityRulesToEvaluationTaskResponse() = default;
};
class BatchUpdateTasksRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  BatchUpdateTasksRequestTasksDataSource() {}

  explicit BatchUpdateTasksRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksDataSource() = default;
};
class BatchUpdateTasksRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  BatchUpdateTasksRequestTasksRuntimeResource() {}

  explicit BatchUpdateTasksRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksRuntimeResource() = default;
};
class BatchUpdateTasksRequestTasksTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  BatchUpdateTasksRequestTasksTags() {}

  explicit BatchUpdateTasksRequestTasksTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksTags() = default;
};
class BatchUpdateTasksRequestTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  BatchUpdateTasksRequestTasksTrigger() {}

  explicit BatchUpdateTasksRequestTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BatchUpdateTasksRequestTasksTrigger() = default;
};
class BatchUpdateTasksRequestTasks : public Darabonba::Model {
public:
  shared_ptr<BatchUpdateTasksRequestTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<BatchUpdateTasksRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<vector<BatchUpdateTasksRequestTasksTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<BatchUpdateTasksRequestTasksTrigger> trigger{};

  BatchUpdateTasksRequestTasks() {}

  explicit BatchUpdateTasksRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        BatchUpdateTasksRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<BatchUpdateTasksRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        BatchUpdateTasksRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<BatchUpdateTasksRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<BatchUpdateTasksRequestTasksTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateTasksRequestTasksTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<BatchUpdateTasksRequestTasksTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        BatchUpdateTasksRequestTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<BatchUpdateTasksRequestTasksTrigger>(model1);
      }
    }
  }


  virtual ~BatchUpdateTasksRequestTasks() = default;
};
class BatchUpdateTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<BatchUpdateTasksRequestTasks>> tasks{};

  BatchUpdateTasksRequest() {}

  explicit BatchUpdateTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<BatchUpdateTasksRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateTasksRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<BatchUpdateTasksRequestTasks>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateTasksRequest() = default;
};
class BatchUpdateTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> tasksShrink{};

  BatchUpdateTasksShrinkRequest() {}

  explicit BatchUpdateTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
  }


  virtual ~BatchUpdateTasksShrinkRequest() = default;
};
class BatchUpdateTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  BatchUpdateTasksResponseBody() {}

  explicit BatchUpdateTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateTasksResponseBody() = default;
};
class BatchUpdateTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateTasksResponseBody> body{};

  BatchUpdateTasksResponse() {}

  explicit BatchUpdateTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateTasksResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateTasksResponse() = default;
};
class CloneDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> cloneDataSourceName{};
  shared_ptr<long> id{};

  CloneDataSourceRequest() {}

  explicit CloneDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloneDataSourceName) {
      res["CloneDataSourceName"] = boost::any(*cloneDataSourceName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloneDataSourceName") != m.end() && !m["CloneDataSourceName"].empty()) {
      cloneDataSourceName = make_shared<string>(boost::any_cast<string>(m["CloneDataSourceName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CloneDataSourceRequest() = default;
};
class CloneDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CloneDataSourceResponseBody() {}

  explicit CloneDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneDataSourceResponseBody() = default;
};
class CloneDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneDataSourceResponseBody> body{};

  CloneDataSourceResponse() {}

  explicit CloneDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CloneDataSourceResponse() = default;
};
class CreateAlertRuleRequestNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateAlertRuleRequestNotificationReceivers() {}

  explicit CreateAlertRuleRequestNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAlertRuleRequestNotificationReceivers() = default;
};
class CreateAlertRuleRequestNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<CreateAlertRuleRequestNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  CreateAlertRuleRequestNotification() {}

  explicit CreateAlertRuleRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<CreateAlertRuleRequestNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlertRuleRequestNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<CreateAlertRuleRequestNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~CreateAlertRuleRequestNotification() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  CreateAlertRuleRequestTriggerConditionExtensionError() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionError() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  CreateAlertRuleRequestTriggerConditionExtensionTimeout() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionTimeout() = default;
};
class CreateAlertRuleRequestTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  CreateAlertRuleRequestTriggerConditionExtensionUnFinished() {}

  explicit CreateAlertRuleRequestTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtensionUnFinished() = default;
};
class CreateAlertRuleRequestTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionError> error{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtensionUnFinished> unFinished{};

  CreateAlertRuleRequestTriggerConditionExtension() {}

  explicit CreateAlertRuleRequestTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<CreateAlertRuleRequestTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<CreateAlertRuleRequestTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        CreateAlertRuleRequestTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<CreateAlertRuleRequestTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionExtension() = default;
};
class CreateAlertRuleRequestTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  CreateAlertRuleRequestTriggerConditionTarget() {}

  explicit CreateAlertRuleRequestTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerConditionTarget() = default;
};
class CreateAlertRuleRequestTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<CreateAlertRuleRequestTriggerConditionExtension> extension{};
  shared_ptr<CreateAlertRuleRequestTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  CreateAlertRuleRequestTriggerCondition() {}

  explicit CreateAlertRuleRequestTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        CreateAlertRuleRequestTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<CreateAlertRuleRequestTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateAlertRuleRequestTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateAlertRuleRequestTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateAlertRuleRequestTriggerCondition() = default;
};
class CreateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> name{};
  shared_ptr<CreateAlertRuleRequestNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<CreateAlertRuleRequestTriggerCondition> triggerCondition{};

  CreateAlertRuleRequest() {}

  explicit CreateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        CreateAlertRuleRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<CreateAlertRuleRequestNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        CreateAlertRuleRequestTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<CreateAlertRuleRequestTriggerCondition>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleRequest() = default;
};
class CreateAlertRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> triggerConditionShrink{};

  CreateAlertRuleShrinkRequest() {}

  explicit CreateAlertRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerConditionShrink) {
      res["TriggerCondition"] = boost::any(*triggerConditionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      triggerConditionShrink = make_shared<string>(boost::any_cast<string>(m["TriggerCondition"]));
    }
  }


  virtual ~CreateAlertRuleShrinkRequest() = default;
};
class CreateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateAlertRuleResponseBody() {}

  explicit CreateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertRuleResponseBody() = default;
};
class CreateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertRuleResponseBody> body{};

  CreateAlertRuleResponse() {}

  explicit CreateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertRuleResponse() = default;
};
class CreateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> useType{};

  CreateBusinessRequest() {}

  explicit CreateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~CreateBusinessRequest() = default;
};
class CreateBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBusinessResponseBody() {}

  explicit CreateBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBusinessResponseBody() = default;
};
class CreateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBusinessResponseBody> body{};

  CreateBusinessResponse() {}

  explicit CreateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBusinessResponse() = default;
};
class CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels() {}

  explicit CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels() = default;
};
class CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() {}

  explicit CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() = default;
};
class CreateDIAlarmRuleRequestNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>> notificationReceivers{};

  CreateDIAlarmRuleRequestNotificationSettings() {}

  explicit CreateDIAlarmRuleRequestNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleRequestNotificationSettings() = default;
};
class CreateDIAlarmRuleRequestTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  CreateDIAlarmRuleRequestTriggerConditions() {}

  explicit CreateDIAlarmRuleRequestTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~CreateDIAlarmRuleRequestTriggerConditions() = default;
};
class CreateDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<CreateDIAlarmRuleRequestNotificationSettings> notificationSettings{};
  shared_ptr<vector<CreateDIAlarmRuleRequestTriggerConditions>> triggerConditions{};

  CreateDIAlarmRuleRequest() {}

  explicit CreateDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        CreateDIAlarmRuleRequestNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<CreateDIAlarmRuleRequestNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<CreateDIAlarmRuleRequestTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIAlarmRuleRequestTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<CreateDIAlarmRuleRequestTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleRequest() = default;
};
class CreateDIAlarmRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationSettingsShrink{};
  shared_ptr<string> triggerConditionsShrink{};

  CreateDIAlarmRuleShrinkRequest() {}

  explicit CreateDIAlarmRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettingsShrink) {
      res["NotificationSettings"] = boost::any(*notificationSettingsShrink);
    }
    if (triggerConditionsShrink) {
      res["TriggerConditions"] = boost::any(*triggerConditionsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      notificationSettingsShrink = make_shared<string>(boost::any_cast<string>(m["NotificationSettings"]));
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      triggerConditionsShrink = make_shared<string>(boost::any_cast<string>(m["TriggerConditions"]));
    }
  }


  virtual ~CreateDIAlarmRuleShrinkRequest() = default;
};
class CreateDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DIAlarmRuleId{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDIAlarmRuleResponseBody() {}

  explicit CreateDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<string>(boost::any_cast<string>(m["DIAlarmRuleId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDIAlarmRuleResponseBody() = default;
};
class CreateDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDIAlarmRuleResponseBody> body{};

  CreateDIAlarmRuleResponse() {}

  explicit CreateDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDIAlarmRuleResponse() = default;
};
class CreateDIJobRequestDestinationDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};

  CreateDIJobRequestDestinationDataSourceSettings() {}

  explicit CreateDIJobRequestDestinationDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
  }


  virtual ~CreateDIJobRequestDestinationDataSourceSettings() = default;
};
class CreateDIJobRequestJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  CreateDIJobRequestJobSettingsColumnDataTypeSettings() {}

  explicit CreateDIJobRequestJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsColumnDataTypeSettings() = default;
};
class CreateDIJobRequestJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> cycleMigrationType{};
  shared_ptr<string> scheduleParameters{};

  CreateDIJobRequestJobSettingsCycleScheduleSettings() {}

  explicit CreateDIJobRequestJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleMigrationType) {
      res["CycleMigrationType"] = boost::any(*cycleMigrationType);
    }
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleMigrationType") != m.end() && !m["CycleMigrationType"].empty()) {
      cycleMigrationType = make_shared<string>(boost::any_cast<string>(m["CycleMigrationType"]));
    }
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsCycleScheduleSettings() = default;
};
class CreateDIJobRequestJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  CreateDIJobRequestJobSettingsDdlHandlingSettings() {}

  explicit CreateDIJobRequestJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsDdlHandlingSettings() = default;
};
class CreateDIJobRequestJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateDIJobRequestJobSettingsRuntimeSettings() {}

  explicit CreateDIJobRequestJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDIJobRequestJobSettingsRuntimeSettings() = default;
};
class CreateDIJobRequestJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<CreateDIJobRequestJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<CreateDIJobRequestJobSettingsRuntimeSettings>> runtimeSettings{};

  CreateDIJobRequestJobSettings() {}

  explicit CreateDIJobRequestJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<CreateDIJobRequestJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        CreateDIJobRequestJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<CreateDIJobRequestJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<CreateDIJobRequestJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<CreateDIJobRequestJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<CreateDIJobRequestJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequestJobSettings() = default;
};
class CreateDIJobRequestResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsOfflineResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsOfflineResourceSettings() = default;
};
class CreateDIJobRequestResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsRealtimeResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsRealtimeResourceSettings() = default;
};
class CreateDIJobRequestResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  CreateDIJobRequestResourceSettingsScheduleResourceSettings() {}

  explicit CreateDIJobRequestResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~CreateDIJobRequestResourceSettingsScheduleResourceSettings() = default;
};
class CreateDIJobRequestResourceSettings : public Darabonba::Model {
public:
  shared_ptr<CreateDIJobRequestResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<CreateDIJobRequestResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<CreateDIJobRequestResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  CreateDIJobRequestResourceSettings() {}

  explicit CreateDIJobRequestResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<CreateDIJobRequestResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<CreateDIJobRequestResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        CreateDIJobRequestResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<CreateDIJobRequestResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~CreateDIJobRequestResourceSettings() = default;
};
class CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties : public Darabonba::Model {
public:
  shared_ptr<string> encoding{};
  shared_ptr<string> timezone{};

  CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties() {}

  explicit CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
  }


  virtual ~CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties() = default;
};
class CreateDIJobRequestSourceDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};
  shared_ptr<CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties> dataSourceProperties{};

  CreateDIJobRequestSourceDataSourceSettings() {}

  explicit CreateDIJobRequestSourceDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (dataSourceProperties) {
      res["DataSourceProperties"] = dataSourceProperties ? boost::any(dataSourceProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("DataSourceProperties") != m.end() && !m["DataSourceProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceProperties"].type()) {
        CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceProperties"]));
        dataSourceProperties = make_shared<CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties>(model1);
      }
    }
  }


  virtual ~CreateDIJobRequestSourceDataSourceSettings() = default;
};
class CreateDIJobRequestTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  CreateDIJobRequestTableMappingsSourceObjectSelectionRules() {}

  explicit CreateDIJobRequestTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~CreateDIJobRequestTableMappingsSourceObjectSelectionRules() = default;
};
class CreateDIJobRequestTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  CreateDIJobRequestTableMappingsTransformationRules() {}

  explicit CreateDIJobRequestTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~CreateDIJobRequestTableMappingsTransformationRules() = default;
};
class CreateDIJobRequestTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<CreateDIJobRequestTableMappingsTransformationRules>> transformationRules{};

  CreateDIJobRequestTableMappings() {}

  explicit CreateDIJobRequestTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<CreateDIJobRequestTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<CreateDIJobRequestTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<CreateDIJobRequestTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequestTableMappings() = default;
};
class CreateDIJobRequestTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  CreateDIJobRequestTransformationRules() {}

  explicit CreateDIJobRequestTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~CreateDIJobRequestTransformationRules() = default;
};
class CreateDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<CreateDIJobRequestDestinationDataSourceSettings>> destinationDataSourceSettings{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> jobName{};
  shared_ptr<CreateDIJobRequestJobSettings> jobSettings{};
  shared_ptr<string> jobType{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDIJobRequestResourceSettings> resourceSettings{};
  shared_ptr<vector<CreateDIJobRequestSourceDataSourceSettings>> sourceDataSourceSettings{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<vector<CreateDIJobRequestTableMappings>> tableMappings{};
  shared_ptr<vector<CreateDIJobRequestTransformationRules>> transformationRules{};

  CreateDIJobRequest() {}

  explicit CreateDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*destinationDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationDataSourceSettings"] = boost::any(temp1);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDataSourceSettings"] = boost::any(temp1);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationDataSourceSettings"].type()) {
        vector<CreateDIJobRequestDestinationDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestDestinationDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationDataSourceSettings = make_shared<vector<CreateDIJobRequestDestinationDataSourceSettings>>(expect1);
      }
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        CreateDIJobRequestJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<CreateDIJobRequestJobSettings>(model1);
      }
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        CreateDIJobRequestResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<CreateDIJobRequestResourceSettings>(model1);
      }
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDataSourceSettings"].type()) {
        vector<CreateDIJobRequestSourceDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestSourceDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDataSourceSettings = make_shared<vector<CreateDIJobRequestSourceDataSourceSettings>>(expect1);
      }
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<CreateDIJobRequestTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<CreateDIJobRequestTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<CreateDIJobRequestTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDIJobRequestTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<CreateDIJobRequestTransformationRules>>(expect1);
      }
    }
  }


  virtual ~CreateDIJobRequest() = default;
};
class CreateDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationDataSourceSettingsShrink{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobSettingsShrink{};
  shared_ptr<string> jobType{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceSettingsShrink{};
  shared_ptr<string> sourceDataSourceSettingsShrink{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<string> tableMappingsShrink{};
  shared_ptr<string> transformationRulesShrink{};

  CreateDIJobShrinkRequest() {}

  explicit CreateDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettingsShrink) {
      res["DestinationDataSourceSettings"] = boost::any(*destinationDataSourceSettingsShrink);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettingsShrink) {
      res["JobSettings"] = boost::any(*jobSettingsShrink);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettingsShrink) {
      res["ResourceSettings"] = boost::any(*resourceSettingsShrink);
    }
    if (sourceDataSourceSettingsShrink) {
      res["SourceDataSourceSettings"] = boost::any(*sourceDataSourceSettingsShrink);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappingsShrink) {
      res["TableMappings"] = boost::any(*tableMappingsShrink);
    }
    if (transformationRulesShrink) {
      res["TransformationRules"] = boost::any(*transformationRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      destinationDataSourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceSettings"]));
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      jobSettingsShrink = make_shared<string>(boost::any_cast<string>(m["JobSettings"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      resourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["ResourceSettings"]));
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      sourceDataSourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceSettings"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      tableMappingsShrink = make_shared<string>(boost::any_cast<string>(m["TableMappings"]));
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      transformationRulesShrink = make_shared<string>(boost::any_cast<string>(m["TransformationRules"]));
    }
  }


  virtual ~CreateDIJobShrinkRequest() = default;
};
class CreateDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDIJobResponseBody() {}

  explicit CreateDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDIJobResponseBody() = default;
};
class CreateDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDIJobResponseBody> body{};

  CreateDIJobResponse() {}

  explicit CreateDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDIJobResponse() = default;
};
class CreateDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<string> valueType{};
  shared_ptr<vector<string>> values{};

  CreateDataAssetTagRequest() {}

  explicit CreateDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataAssetTagRequest() = default;
};
class CreateDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> valueType{};
  shared_ptr<string> valuesShrink{};

  CreateDataAssetTagShrinkRequest() {}

  explicit CreateDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~CreateDataAssetTagShrinkRequest() = default;
};
class CreateDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataAssetTagResponseBody() {}

  explicit CreateDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataAssetTagResponseBody() = default;
};
class CreateDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataAssetTagResponseBody> body{};

  CreateDataAssetTagResponse() {}

  explicit CreateDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataAssetTagResponse() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() = default;
};
class CreateDataQualityEvaluationTaskRequestDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  CreateDataQualityEvaluationTaskRequestDataQualityRules() {}

  explicit CreateDataQualityEvaluationTaskRequestDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestDataQualityRules() = default;
};
class CreateDataQualityEvaluationTaskRequestHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestHooks() {}

  explicit CreateDataQualityEvaluationTaskRequestHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestHooks() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() = default;
};
class CreateDataQualityEvaluationTaskRequestNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  CreateDataQualityEvaluationTaskRequestNotificationsNotifications() {}

  explicit CreateDataQualityEvaluationTaskRequestNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotificationsNotifications() = default;
};
class CreateDataQualityEvaluationTaskRequestNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications>> notifications{};

  CreateDataQualityEvaluationTaskRequestNotifications() {}

  explicit CreateDataQualityEvaluationTaskRequestNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<CreateDataQualityEvaluationTaskRequestNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestNotifications() = default;
};
class CreateDataQualityEvaluationTaskRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};

  CreateDataQualityEvaluationTaskRequestTarget() {}

  explicit CreateDataQualityEvaluationTaskRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestTarget() = default;
};
class CreateDataQualityEvaluationTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  CreateDataQualityEvaluationTaskRequestTrigger() {}

  explicit CreateDataQualityEvaluationTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequestTrigger() = default;
};
class CreateDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestDataQualityRules>> dataQualityRules{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateDataQualityEvaluationTaskRequestHooks>> hooks{};
  shared_ptr<string> name{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestTarget> target{};
  shared_ptr<CreateDataQualityEvaluationTaskRequestTrigger> trigger{};

  CreateDataQualityEvaluationTaskRequest() {}

  explicit CreateDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<CreateDataQualityEvaluationTaskRequestDataQualityRules>>(expect1);
      }
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<CreateDataQualityEvaluationTaskRequestHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityEvaluationTaskRequestHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<CreateDataQualityEvaluationTaskRequestHooks>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        CreateDataQualityEvaluationTaskRequestNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<CreateDataQualityEvaluationTaskRequestNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateDataQualityEvaluationTaskRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateDataQualityEvaluationTaskRequestTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        CreateDataQualityEvaluationTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<CreateDataQualityEvaluationTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskRequest() = default;
};
class CreateDataQualityEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataQualityRulesShrink{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> hooksShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> triggerShrink{};

  CreateDataQualityEvaluationTaskShrinkRequest() {}

  explicit CreateDataQualityEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRulesShrink) {
      res["DataQualityRules"] = boost::any(*dataQualityRulesShrink);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooksShrink) {
      res["Hooks"] = boost::any(*hooksShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationsShrink) {
      res["Notifications"] = boost::any(*notificationsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      dataQualityRulesShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRules"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooksShrink = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      notificationsShrink = make_shared<string>(boost::any_cast<string>(m["Notifications"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskShrinkRequest() = default;
};
class CreateDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityEvaluationTaskResponseBody() {}

  explicit CreateDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskResponseBody() = default;
};
class CreateDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityEvaluationTaskResponseBody> body{};

  CreateDataQualityEvaluationTaskResponse() {}

  explicit CreateDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskResponse() = default;
};
class CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<double> cu{};
  shared_ptr<string> resourceGroupId{};

  CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource() {}

  explicit CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<double>(boost::any_cast<double>(m["Cu"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource() = default;
};
class CreateDataQualityEvaluationTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource> runtimeResource{};

  CreateDataQualityEvaluationTaskInstanceRequest() {}

  explicit CreateDataQualityEvaluationTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceRequest() = default;
};
class CreateDataQualityEvaluationTaskInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResourceShrink{};

  CreateDataQualityEvaluationTaskInstanceShrinkRequest() {}

  explicit CreateDataQualityEvaluationTaskInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResourceShrink) {
      res["RuntimeResource"] = boost::any(*runtimeResourceShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResourceShrink = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceShrinkRequest() = default;
};
class CreateDataQualityEvaluationTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityEvaluationTaskInstanceResponseBody() {}

  explicit CreateDataQualityEvaluationTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceResponseBody() = default;
};
class CreateDataQualityEvaluationTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityEvaluationTaskInstanceResponseBody> body{};

  CreateDataQualityEvaluationTaskInstanceResponse() {}

  explicit CreateDataQualityEvaluationTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityEvaluationTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityEvaluationTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityEvaluationTaskInstanceResponse() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsCritical() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsCritical() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsExpected() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsExpected() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateDataQualityRuleRequestCheckingConfigThresholdsWarned() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholdsWarned() = default;
};
class CreateDataQualityRuleRequestCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsCritical> critical{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsExpected> expected{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholdsWarned> warned{};

  CreateDataQualityRuleRequestCheckingConfigThresholds() {}

  explicit CreateDataQualityRuleRequestCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfigThresholds() = default;
};
class CreateDataQualityRuleRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<CreateDataQualityRuleRequestCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestCheckingConfig() {}

  explicit CreateDataQualityRuleRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        CreateDataQualityRuleRequestCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<CreateDataQualityRuleRequestCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestCheckingConfig() = default;
};
class CreateDataQualityRuleRequestErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestErrorHandlers() {}

  explicit CreateDataQualityRuleRequestErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestErrorHandlers() = default;
};
class CreateDataQualityRuleRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityRuleRequestSamplingConfig() {}

  explicit CreateDataQualityRuleRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestSamplingConfig() = default;
};
class CreateDataQualityRuleRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  CreateDataQualityRuleRequestTarget() {}

  explicit CreateDataQualityRuleRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleRequestTarget() = default;
};
class CreateDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<CreateDataQualityRuleRequestErrorHandlers>> errorHandlers{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityRuleRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<CreateDataQualityRuleRequestTarget> target{};
  shared_ptr<string> templateCode{};

  CreateDataQualityRuleRequest() {}

  explicit CreateDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityRuleRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityRuleRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<CreateDataQualityRuleRequestErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataQualityRuleRequestErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<CreateDataQualityRuleRequestErrorHandlers>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityRuleRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityRuleRequestSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateDataQualityRuleRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateDataQualityRuleRequestTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityRuleRequest() = default;
};
class CreateDataQualityRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> errorHandlersShrink{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> severity{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> templateCode{};

  CreateDataQualityRuleShrinkRequest() {}

  explicit CreateDataQualityRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlersShrink) {
      res["ErrorHandlers"] = boost::any(*errorHandlersShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      errorHandlersShrink = make_shared<string>(boost::any_cast<string>(m["ErrorHandlers"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CreateDataQualityRuleShrinkRequest() = default;
};
class CreateDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataQualityRuleResponseBody() {}

  explicit CreateDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityRuleResponseBody() = default;
};
class CreateDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityRuleResponseBody> body{};

  CreateDataQualityRuleResponse() {}

  explicit CreateDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleResponse() = default;
};
class CreateDataQualityRuleTemplateRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  CreateDataQualityRuleTemplateRequestCheckingConfig() {}

  explicit CreateDataQualityRuleTemplateRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequestCheckingConfig() = default;
};
class CreateDataQualityRuleTemplateRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  CreateDataQualityRuleTemplateRequestSamplingConfig() {}

  explicit CreateDataQualityRuleTemplateRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequestSamplingConfig() = default;
};
class CreateDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataQualityRuleTemplateRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<CreateDataQualityRuleTemplateRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  CreateDataQualityRuleTemplateRequest() {}

  explicit CreateDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        CreateDataQualityRuleTemplateRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<CreateDataQualityRuleTemplateRequestCheckingConfig>(model1);
      }
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        CreateDataQualityRuleTemplateRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<CreateDataQualityRuleTemplateRequestSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateRequest() = default;
};
class CreateDataQualityRuleTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> visibleScope{};

  CreateDataQualityRuleTemplateShrinkRequest() {}

  explicit CreateDataQualityRuleTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateShrinkRequest() = default;
};
class CreateDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  CreateDataQualityRuleTemplateResponseBody() {}

  explicit CreateDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataQualityRuleTemplateResponseBody() = default;
};
class CreateDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataQualityRuleTemplateResponseBody> body{};

  CreateDataQualityRuleTemplateResponse() {}

  explicit CreateDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataQualityRuleTemplateResponse() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<string>(boost::any_cast<string>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataSourceResponseBody() {}

  explicit CreateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataSourceResponseBody() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceResponseBody> body{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class CreateDataSourceSharedRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> envType{};
  shared_ptr<string> sharedUser{};
  shared_ptr<long> targetProjectId{};

  CreateDataSourceSharedRuleRequest() {}

  explicit CreateDataSourceSharedRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (sharedUser) {
      res["SharedUser"] = boost::any(*sharedUser);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("SharedUser") != m.end() && !m["SharedUser"].empty()) {
      sharedUser = make_shared<string>(boost::any_cast<string>(m["SharedUser"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~CreateDataSourceSharedRuleRequest() = default;
};
class CreateDataSourceSharedRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDataSourceSharedRuleResponseBody() {}

  explicit CreateDataSourceSharedRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataSourceSharedRuleResponseBody() = default;
};
class CreateDataSourceSharedRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceSharedRuleResponseBody> body{};

  CreateDataSourceSharedRuleResponse() {}

  explicit CreateDataSourceSharedRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceSharedRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceSharedRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceSharedRuleResponse() = default;
};
class CreateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> advancedSettings{};
  shared_ptr<bool> applyScheduleImmediately{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> content{};
  shared_ptr<bool> createFolderIfNotExists{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> dependentType{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<bool> ignoreParentSkipRunningProperty{};
  shared_ptr<string> imageId{};
  shared_ptr<string> inputList{};
  shared_ptr<string> inputParameters{};
  shared_ptr<string> outputParameters{};
  shared_ptr<string> owner{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<string> schedulerType{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<bool> startImmediately{};
  shared_ptr<bool> stop{};
  shared_ptr<long> timeout{};

  CreateFileRequest() {}

  explicit CreateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedSettings) {
      res["AdvancedSettings"] = boost::any(*advancedSettings);
    }
    if (applyScheduleImmediately) {
      res["ApplyScheduleImmediately"] = boost::any(*applyScheduleImmediately);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createFolderIfNotExists) {
      res["CreateFolderIfNotExists"] = boost::any(*createFolderIfNotExists);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (ignoreParentSkipRunningProperty) {
      res["IgnoreParentSkipRunningProperty"] = boost::any(*ignoreParentSkipRunningProperty);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (outputParameters) {
      res["OutputParameters"] = boost::any(*outputParameters);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (startImmediately) {
      res["StartImmediately"] = boost::any(*startImmediately);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedSettings") != m.end() && !m["AdvancedSettings"].empty()) {
      advancedSettings = make_shared<string>(boost::any_cast<string>(m["AdvancedSettings"]));
    }
    if (m.find("ApplyScheduleImmediately") != m.end() && !m["ApplyScheduleImmediately"].empty()) {
      applyScheduleImmediately = make_shared<bool>(boost::any_cast<bool>(m["ApplyScheduleImmediately"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateFolderIfNotExists") != m.end() && !m["CreateFolderIfNotExists"].empty()) {
      createFolderIfNotExists = make_shared<bool>(boost::any_cast<bool>(m["CreateFolderIfNotExists"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("IgnoreParentSkipRunningProperty") != m.end() && !m["IgnoreParentSkipRunningProperty"].empty()) {
      ignoreParentSkipRunningProperty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreParentSkipRunningProperty"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParameters = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("OutputParameters") != m.end() && !m["OutputParameters"].empty()) {
      outputParameters = make_shared<string>(boost::any_cast<string>(m["OutputParameters"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("StartImmediately") != m.end() && !m["StartImmediately"].empty()) {
      startImmediately = make_shared<bool>(boost::any_cast<bool>(m["StartImmediately"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateFileRequest() = default;
};
class CreateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFileResponseBody() {}

  explicit CreateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFileResponseBody() = default;
};
class CreateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileResponseBody> body{};

  CreateFileResponse() {}

  explicit CreateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileResponse() = default;
};
class CreateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<string> folderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  CreateFolderRequest() {}

  explicit CreateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~CreateFolderRequest() = default;
};
class CreateFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFolderResponseBody() {}

  explicit CreateFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFolderResponseBody() = default;
};
class CreateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFolderResponseBody> body{};

  CreateFolderResponse() {}

  explicit CreateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFolderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFolderResponse() = default;
};
class CreateFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  CreateFunctionRequest() {}

  explicit CreateFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateFunctionRequest() = default;
};
class CreateFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateFunctionResponseBody() {}

  explicit CreateFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFunctionResponseBody() = default;
};
class CreateFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFunctionResponseBody> body{};

  CreateFunctionResponse() {}

  explicit CreateFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFunctionResponse() = default;
};
class CreateLineageRelationshipRequest : public Darabonba::Model {
public:
  shared_ptr<LineageEntity> dstEntity{};
  shared_ptr<LineageEntity> srcEntity{};
  shared_ptr<LineageTask> task{};

  CreateLineageRelationshipRequest() {}

  explicit CreateLineageRelationshipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstEntity) {
      res["DstEntity"] = dstEntity ? boost::any(dstEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (srcEntity) {
      res["SrcEntity"] = srcEntity ? boost::any(srcEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstEntity") != m.end() && !m["DstEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstEntity"]));
        dstEntity = make_shared<LineageEntity>(model1);
      }
    }
    if (m.find("SrcEntity") != m.end() && !m["SrcEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcEntity"]));
        srcEntity = make_shared<LineageEntity>(model1);
      }
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        LineageTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<LineageTask>(model1);
      }
    }
  }


  virtual ~CreateLineageRelationshipRequest() = default;
};
class CreateLineageRelationshipShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dstEntityShrink{};
  shared_ptr<string> srcEntityShrink{};
  shared_ptr<string> taskShrink{};

  CreateLineageRelationshipShrinkRequest() {}

  explicit CreateLineageRelationshipShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstEntityShrink) {
      res["DstEntity"] = boost::any(*dstEntityShrink);
    }
    if (srcEntityShrink) {
      res["SrcEntity"] = boost::any(*srcEntityShrink);
    }
    if (taskShrink) {
      res["Task"] = boost::any(*taskShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstEntity") != m.end() && !m["DstEntity"].empty()) {
      dstEntityShrink = make_shared<string>(boost::any_cast<string>(m["DstEntity"]));
    }
    if (m.find("SrcEntity") != m.end() && !m["SrcEntity"].empty()) {
      srcEntityShrink = make_shared<string>(boost::any_cast<string>(m["SrcEntity"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      taskShrink = make_shared<string>(boost::any_cast<string>(m["Task"]));
    }
  }


  virtual ~CreateLineageRelationshipShrinkRequest() = default;
};
class CreateLineageRelationshipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateLineageRelationshipResponseBody() {}

  explicit CreateLineageRelationshipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateLineageRelationshipResponseBody() = default;
};
class CreateLineageRelationshipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLineageRelationshipResponseBody> body{};

  CreateLineageRelationshipResponse() {}

  explicit CreateLineageRelationshipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLineageRelationshipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLineageRelationshipResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLineageRelationshipResponse() = default;
};
class CreateMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> type{};

  CreateMetaCollectionRequest() {}

  explicit CreateMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMetaCollectionRequest() = default;
};
class CreateMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateMetaCollectionResponseBody() {}

  explicit CreateMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMetaCollectionResponseBody() = default;
};
class CreateMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMetaCollectionResponseBody> body{};

  CreateMetaCollectionResponse() {}

  explicit CreateMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetaCollectionResponse() = default;
};
class CreateNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateNetworkRequest() {}

  explicit CreateNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateNetworkRequest() = default;
};
class CreateNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNetworkResponseBody() {}

  explicit CreateNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNetworkResponseBody() = default;
};
class CreateNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkResponseBody> body{};

  CreateNetworkResponse() {}

  explicit CreateNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkResponse() = default;
};
class CreateNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> containerId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> scene{};
  shared_ptr<string> spec{};

  CreateNodeRequest() {}

  explicit CreateNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<long>(boost::any_cast<long>(m["ContainerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateNodeRequest() = default;
};
class CreateNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateNodeResponseBody() {}

  explicit CreateNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNodeResponseBody() = default;
};
class CreateNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNodeResponseBody> body{};

  CreateNodeResponse() {}

  explicit CreateNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNodeResponse() = default;
};
class CreatePipelineRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<string>> objectIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreatePipelineRunRequest() {}

  explicit CreatePipelineRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectIds) {
      res["ObjectIds"] = boost::any(*objectIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ObjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ObjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePipelineRunRequest() = default;
};
class CreatePipelineRunShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> objectIdsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  CreatePipelineRunShrinkRequest() {}

  explicit CreatePipelineRunShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectIdsShrink) {
      res["ObjectIds"] = boost::any(*objectIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      objectIdsShrink = make_shared<string>(boost::any_cast<string>(m["ObjectIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePipelineRunShrinkRequest() = default;
};
class CreatePipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreatePipelineRunResponseBody() {}

  explicit CreatePipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePipelineRunResponseBody() = default;
};
class CreatePipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineRunResponseBody> body{};

  CreatePipelineRunResponse() {}

  explicit CreatePipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineRunResponse() = default;
};
class CreateProjectRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateProjectRequestAliyunResourceTags() {}

  explicit CreateProjectRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateProjectRequestAliyunResourceTags() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<CreateProjectRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> paiTaskEnabled{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<CreateProjectRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<CreateProjectRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> paiTaskEnabled{};

  CreateProjectShrinkRequest() {}

  explicit CreateProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
  }


  virtual ~CreateProjectShrinkRequest() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> requestId{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class CreateProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  CreateProjectMemberRequest() {}

  explicit CreateProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateProjectMemberRequest() = default;
};
class CreateProjectMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  CreateProjectMemberShrinkRequest() {}

  explicit CreateProjectMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateProjectMemberShrinkRequest() = default;
};
class CreateProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectMemberResponseBody() {}

  explicit CreateProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectMemberResponseBody() = default;
};
class CreateProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectMemberResponseBody> body{};

  CreateProjectMemberResponse() {}

  explicit CreateProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectMemberResponse() = default;
};
class CreateResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceFile{};
  shared_ptr<string> spec{};

  CreateResourceRequest() {}

  explicit CreateResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceFile) {
      res["ResourceFile"] = boost::any(*resourceFile);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFile = make_shared<string>(boost::any_cast<string>(m["ResourceFile"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateResourceRequest() = default;
};
class CreateResourceAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<Darabonba::Stream> resourceFileObject{};
  shared_ptr<string> spec{};

  CreateResourceAdvanceRequest() {}

  explicit CreateResourceAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceFileObject) {
      res["ResourceFile"] = boost::any(*resourceFileObject);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["ResourceFile"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateResourceAdvanceRequest() = default;
};
class CreateResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateResourceResponseBody() {}

  explicit CreateResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateResourceResponseBody() = default;
};
class CreateResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceResponseBody> body{};

  CreateResourceResponse() {}

  explicit CreateResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceResponse() = default;
};
class CreateResourceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<string> originResourceName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> registerToCalcEngine{};
  shared_ptr<string> resourceFile{};
  shared_ptr<string> storageURL{};
  shared_ptr<bool> uploadMode{};

  CreateResourceFileRequest() {}

  explicit CreateResourceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (originResourceName) {
      res["OriginResourceName"] = boost::any(*originResourceName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (registerToCalcEngine) {
      res["RegisterToCalcEngine"] = boost::any(*registerToCalcEngine);
    }
    if (resourceFile) {
      res["ResourceFile"] = boost::any(*resourceFile);
    }
    if (storageURL) {
      res["StorageURL"] = boost::any(*storageURL);
    }
    if (uploadMode) {
      res["UploadMode"] = boost::any(*uploadMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("OriginResourceName") != m.end() && !m["OriginResourceName"].empty()) {
      originResourceName = make_shared<string>(boost::any_cast<string>(m["OriginResourceName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RegisterToCalcEngine") != m.end() && !m["RegisterToCalcEngine"].empty()) {
      registerToCalcEngine = make_shared<bool>(boost::any_cast<bool>(m["RegisterToCalcEngine"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFile = make_shared<string>(boost::any_cast<string>(m["ResourceFile"]));
    }
    if (m.find("StorageURL") != m.end() && !m["StorageURL"].empty()) {
      storageURL = make_shared<string>(boost::any_cast<string>(m["StorageURL"]));
    }
    if (m.find("UploadMode") != m.end() && !m["UploadMode"].empty()) {
      uploadMode = make_shared<bool>(boost::any_cast<bool>(m["UploadMode"]));
    }
  }


  virtual ~CreateResourceFileRequest() = default;
};
class CreateResourceFileAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<string> originResourceName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> registerToCalcEngine{};
  shared_ptr<Darabonba::Stream> resourceFileObject{};
  shared_ptr<string> storageURL{};
  shared_ptr<bool> uploadMode{};

  CreateResourceFileAdvanceRequest() {}

  explicit CreateResourceFileAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (originResourceName) {
      res["OriginResourceName"] = boost::any(*originResourceName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (registerToCalcEngine) {
      res["RegisterToCalcEngine"] = boost::any(*registerToCalcEngine);
    }
    if (resourceFileObject) {
      res["ResourceFile"] = boost::any(*resourceFileObject);
    }
    if (storageURL) {
      res["StorageURL"] = boost::any(*storageURL);
    }
    if (uploadMode) {
      res["UploadMode"] = boost::any(*uploadMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("OriginResourceName") != m.end() && !m["OriginResourceName"].empty()) {
      originResourceName = make_shared<string>(boost::any_cast<string>(m["OriginResourceName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RegisterToCalcEngine") != m.end() && !m["RegisterToCalcEngine"].empty()) {
      registerToCalcEngine = make_shared<bool>(boost::any_cast<bool>(m["RegisterToCalcEngine"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["ResourceFile"]));
    }
    if (m.find("StorageURL") != m.end() && !m["StorageURL"].empty()) {
      storageURL = make_shared<string>(boost::any_cast<string>(m["StorageURL"]));
    }
    if (m.find("UploadMode") != m.end() && !m["UploadMode"].empty()) {
      uploadMode = make_shared<bool>(boost::any_cast<bool>(m["UploadMode"]));
    }
  }


  virtual ~CreateResourceFileAdvanceRequest() = default;
};
class CreateResourceFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  CreateResourceFileResponseBody() {}

  explicit CreateResourceFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateResourceFileResponseBody() = default;
};
class CreateResourceFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceFileResponseBody> body{};

  CreateResourceFileResponse() {}

  explicit CreateResourceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceFileResponse() = default;
};
class CreateResourceGroupRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateResourceGroupRequestAliyunResourceTags() {}

  explicit CreateResourceGroupRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateResourceGroupRequestAliyunResourceTags() = default;
};
class CreateResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<CreateResourceGroupRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<bool> autoRenewEnabled{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<long> spec{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateResourceGroupRequest() {}

  explicit CreateResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<CreateResourceGroupRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResourceGroupRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<CreateResourceGroupRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateResourceGroupRequest() = default;
};
class CreateResourceGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<bool> autoRenewEnabled{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<long> spec{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  CreateResourceGroupShrinkRequest() {}

  explicit CreateResourceGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateResourceGroupShrinkRequest() = default;
};
class CreateResourceGroupResponseBodyResourceGroupOrder : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> orderId{};
  shared_ptr<string> orderInstanceId{};

  CreateResourceGroupResponseBodyResourceGroupOrder() {}

  explicit CreateResourceGroupResponseBodyResourceGroupOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
  }


  virtual ~CreateResourceGroupResponseBodyResourceGroupOrder() = default;
};
class CreateResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateResourceGroupResponseBodyResourceGroupOrder> resourceGroupOrder{};
  shared_ptr<bool> success{};

  CreateResourceGroupResponseBody() {}

  explicit CreateResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupOrder) {
      res["ResourceGroupOrder"] = resourceGroupOrder ? boost::any(resourceGroupOrder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupOrder") != m.end() && !m["ResourceGroupOrder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroupOrder"].type()) {
        CreateResourceGroupResponseBodyResourceGroupOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroupOrder"]));
        resourceGroupOrder = make_shared<CreateResourceGroupResponseBodyResourceGroupOrder>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateResourceGroupResponseBody() = default;
};
class CreateResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceGroupResponseBody> body{};

  CreateResourceGroupResponse() {}

  explicit CreateResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceGroupResponse() = default;
};
class CreateRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> networkId{};
  shared_ptr<string> resourceGroupId{};

  CreateRouteRequest() {}

  explicit CreateRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateRouteRequest() = default;
};
class CreateRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateRouteResponseBody() {}

  explicit CreateRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRouteResponseBody() = default;
};
class CreateRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteResponseBody> body{};

  CreateRouteResponse() {}

  explicit CreateRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteResponse() = default;
};
class CreateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> className{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<bool> createFolderIfNotExists{};
  shared_ptr<string> example{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileName{};
  shared_ptr<string> functionType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> resources{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> udfDescription{};

  CreateUdfFileRequest() {}

  explicit CreateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (createFolderIfNotExists) {
      res["CreateFolderIfNotExists"] = boost::any(*createFolderIfNotExists);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("CreateFolderIfNotExists") != m.end() && !m["CreateFolderIfNotExists"].empty()) {
      createFolderIfNotExists = make_shared<bool>(boost::any_cast<bool>(m["CreateFolderIfNotExists"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
  }


  virtual ~CreateUdfFileRequest() = default;
};
class CreateUdfFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateUdfFileResponseBody() {}

  explicit CreateUdfFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateUdfFileResponseBody() = default;
};
class CreateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUdfFileResponseBody> body{};

  CreateUdfFileResponse() {}

  explicit CreateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUdfFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUdfFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUdfFileResponse() = default;
};
class CreateWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  CreateWorkflowDefinitionRequest() {}

  explicit CreateWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateWorkflowDefinitionRequest() = default;
};
class CreateWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateWorkflowDefinitionResponseBody() {}

  explicit CreateWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWorkflowDefinitionResponseBody() = default;
};
class CreateWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkflowDefinitionResponseBody> body{};

  CreateWorkflowDefinitionResponse() {}

  explicit CreateWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkflowDefinitionResponse() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesAlert : public Darabonba::Model {
public:
  shared_ptr<string> noticeType{};
  shared_ptr<string> type{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesAlert() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesAlert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesAlert() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis : public Darabonba::Model {
public:
  shared_ptr<bool> blocked{};
  shared_ptr<bool> enabled{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blocked) {
      res["Blocked"] = boost::any(*blocked);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blocked") != m.end() && !m["Blocked"].empty()) {
      blocked = make_shared<bool>(boost::any_cast<bool>(m["Blocked"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis() = default;
};
class CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<bool> immediately{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy() {}

  explicit CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (immediately) {
      res["Immediately"] = boost::any(*immediately);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Immediately") != m.end() && !m["Immediately"].empty()) {
      immediately = make_shared<bool>(boost::any_cast<bool>(m["Immediately"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy() = default;
};
class CreateWorkflowInstancesRequestDefaultRunProperties : public Darabonba::Model {
public:
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesAlert> alert{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis> analysis{};
  shared_ptr<vector<long>> excludeProjectIds{};
  shared_ptr<vector<long>> excludeTaskIds{};
  shared_ptr<vector<long>> includeProjectIds{};
  shared_ptr<vector<long>> includeTaskIds{};
  shared_ptr<string> mode{};
  shared_ptr<string> order{};
  shared_ptr<long> parallelism{};
  shared_ptr<long> priority{};
  shared_ptr<vector<long>> rootTaskIds{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy> runPolicy{};
  shared_ptr<string> runtimeResource{};

  CreateWorkflowInstancesRequestDefaultRunProperties() {}

  explicit CreateWorkflowInstancesRequestDefaultRunProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alert) {
      res["Alert"] = alert ? boost::any(alert->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (excludeProjectIds) {
      res["ExcludeProjectIds"] = boost::any(*excludeProjectIds);
    }
    if (excludeTaskIds) {
      res["ExcludeTaskIds"] = boost::any(*excludeTaskIds);
    }
    if (includeProjectIds) {
      res["IncludeProjectIds"] = boost::any(*includeProjectIds);
    }
    if (includeTaskIds) {
      res["IncludeTaskIds"] = boost::any(*includeTaskIds);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (rootTaskIds) {
      res["RootTaskIds"] = boost::any(*rootTaskIds);
    }
    if (runPolicy) {
      res["RunPolicy"] = runPolicy ? boost::any(runPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alert") != m.end() && !m["Alert"].empty()) {
      if (typeid(map<string, boost::any>) == m["Alert"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesAlert model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Alert"]));
        alert = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesAlert>(model1);
      }
    }
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis>(model1);
      }
    }
    if (m.find("ExcludeProjectIds") != m.end() && !m["ExcludeProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      excludeProjectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ExcludeTaskIds") != m.end() && !m["ExcludeTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      excludeTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IncludeProjectIds") != m.end() && !m["IncludeProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      includeProjectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IncludeTaskIds") != m.end() && !m["IncludeTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      includeTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<long>(boost::any_cast<long>(m["Parallelism"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RootTaskIds") != m.end() && !m["RootTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RootTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RootTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      rootTaskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RunPolicy") != m.end() && !m["RunPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunPolicy"].type()) {
        CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunPolicy"]));
        runPolicy = make_shared<CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestDefaultRunProperties() = default;
};
class CreateWorkflowInstancesRequestPeriodsBizDates : public Darabonba::Model {
public:
  shared_ptr<string> endBizDate{};
  shared_ptr<string> startBizDate{};

  CreateWorkflowInstancesRequestPeriodsBizDates() {}

  explicit CreateWorkflowInstancesRequestPeriodsBizDates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestPeriodsBizDates() = default;
};
class CreateWorkflowInstancesRequestPeriods : public Darabonba::Model {
public:
  shared_ptr<vector<CreateWorkflowInstancesRequestPeriodsBizDates>> bizDates{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  CreateWorkflowInstancesRequestPeriods() {}

  explicit CreateWorkflowInstancesRequestPeriods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDates) {
      vector<boost::any> temp1;
      for(auto item1:*bizDates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizDates"] = boost::any(temp1);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDates") != m.end() && !m["BizDates"].empty()) {
      if (typeid(vector<boost::any>) == m["BizDates"].type()) {
        vector<CreateWorkflowInstancesRequestPeriodsBizDates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizDates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWorkflowInstancesRequestPeriodsBizDates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizDates = make_shared<vector<CreateWorkflowInstancesRequestPeriodsBizDates>>(expect1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequestPeriods() = default;
};
class CreateWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStartEnabled{};
  shared_ptr<string> comment{};
  shared_ptr<CreateWorkflowInstancesRequestDefaultRunProperties> defaultRunProperties{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<CreateWorkflowInstancesRequestPeriods> periods{};
  shared_ptr<long> projectId{};
  shared_ptr<string> taskParameters{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};
  shared_ptr<string> workflowParameters{};

  CreateWorkflowInstancesRequest() {}

  explicit CreateWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStartEnabled) {
      res["AutoStartEnabled"] = boost::any(*autoStartEnabled);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (defaultRunProperties) {
      res["DefaultRunProperties"] = defaultRunProperties ? boost::any(defaultRunProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (periods) {
      res["Periods"] = periods ? boost::any(periods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskParameters) {
      res["TaskParameters"] = boost::any(*taskParameters);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowParameters) {
      res["WorkflowParameters"] = boost::any(*workflowParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStartEnabled") != m.end() && !m["AutoStartEnabled"].empty()) {
      autoStartEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoStartEnabled"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DefaultRunProperties") != m.end() && !m["DefaultRunProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultRunProperties"].type()) {
        CreateWorkflowInstancesRequestDefaultRunProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultRunProperties"]));
        defaultRunProperties = make_shared<CreateWorkflowInstancesRequestDefaultRunProperties>(model1);
      }
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      if (typeid(map<string, boost::any>) == m["Periods"].type()) {
        CreateWorkflowInstancesRequestPeriods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Periods"]));
        periods = make_shared<CreateWorkflowInstancesRequestPeriods>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskParameters") != m.end() && !m["TaskParameters"].empty()) {
      taskParameters = make_shared<string>(boost::any_cast<string>(m["TaskParameters"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowParameters") != m.end() && !m["WorkflowParameters"].empty()) {
      workflowParameters = make_shared<string>(boost::any_cast<string>(m["WorkflowParameters"]));
    }
  }


  virtual ~CreateWorkflowInstancesRequest() = default;
};
class CreateWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStartEnabled{};
  shared_ptr<string> comment{};
  shared_ptr<string> defaultRunPropertiesShrink{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> periodsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> taskParameters{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};
  shared_ptr<string> workflowParameters{};

  CreateWorkflowInstancesShrinkRequest() {}

  explicit CreateWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStartEnabled) {
      res["AutoStartEnabled"] = boost::any(*autoStartEnabled);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (defaultRunPropertiesShrink) {
      res["DefaultRunProperties"] = boost::any(*defaultRunPropertiesShrink);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (periodsShrink) {
      res["Periods"] = boost::any(*periodsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskParameters) {
      res["TaskParameters"] = boost::any(*taskParameters);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowParameters) {
      res["WorkflowParameters"] = boost::any(*workflowParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStartEnabled") != m.end() && !m["AutoStartEnabled"].empty()) {
      autoStartEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoStartEnabled"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DefaultRunProperties") != m.end() && !m["DefaultRunProperties"].empty()) {
      defaultRunPropertiesShrink = make_shared<string>(boost::any_cast<string>(m["DefaultRunProperties"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      periodsShrink = make_shared<string>(boost::any_cast<string>(m["Periods"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskParameters") != m.end() && !m["TaskParameters"].empty()) {
      taskParameters = make_shared<string>(boost::any_cast<string>(m["TaskParameters"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowParameters") != m.end() && !m["WorkflowParameters"].empty()) {
      workflowParameters = make_shared<string>(boost::any_cast<string>(m["WorkflowParameters"]));
    }
  }


  virtual ~CreateWorkflowInstancesShrinkRequest() = default;
};
class CreateWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  CreateWorkflowInstancesResponseBody() {}

  explicit CreateWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWorkflowInstancesResponseBody() = default;
};
class CreateWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkflowInstancesResponseBody> body{};

  CreateWorkflowInstancesResponse() {}

  explicit CreateWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkflowInstancesResponse() = default;
};
class DeleteAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteAlertRuleRequest() {}

  explicit DeleteAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteAlertRuleRequest() = default;
};
class DeleteAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAlertRuleResponseBody() {}

  explicit DeleteAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAlertRuleResponseBody() = default;
};
class DeleteAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRuleResponseBody> body{};

  DeleteAlertRuleResponse() {}

  explicit DeleteAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRuleResponse() = default;
};
class DeleteBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  DeleteBusinessRequest() {}

  explicit DeleteBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~DeleteBusinessRequest() = default;
};
class DeleteBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBusinessResponseBody() {}

  explicit DeleteBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBusinessResponseBody() = default;
};
class DeleteBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBusinessResponseBody> body{};

  DeleteBusinessResponse() {}

  explicit DeleteBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBusinessResponse() = default;
};
class DeleteCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteCertificateRequest() {}

  explicit DeleteCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteCertificateRequest() = default;
};
class DeleteCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCertificateResponseBody() {}

  explicit DeleteCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCertificateResponseBody() = default;
};
class DeleteCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCertificateResponseBody> body{};

  DeleteCertificateResponse() {}

  explicit DeleteCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCertificateResponse() = default;
};
class DeleteDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};

  DeleteDIAlarmRuleRequest() {}

  explicit DeleteDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDIAlarmRuleRequest() = default;
};
class DeleteDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDIAlarmRuleResponseBody() {}

  explicit DeleteDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDIAlarmRuleResponseBody() = default;
};
class DeleteDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDIAlarmRuleResponseBody> body{};

  DeleteDIAlarmRuleResponse() {}

  explicit DeleteDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDIAlarmRuleResponse() = default;
};
class DeleteDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDIJobRequest() {}

  explicit DeleteDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDIJobRequest() = default;
};
class DeleteDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDIJobResponseBody() {}

  explicit DeleteDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDIJobResponseBody() = default;
};
class DeleteDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDIJobResponseBody> body{};

  DeleteDIJobResponse() {}

  explicit DeleteDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDIJobResponse() = default;
};
class DeleteDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> values{};

  DeleteDataAssetTagRequest() {}

  explicit DeleteDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteDataAssetTagRequest() = default;
};
class DeleteDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> valuesShrink{};

  DeleteDataAssetTagShrinkRequest() {}

  explicit DeleteDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DeleteDataAssetTagShrinkRequest() = default;
};
class DeleteDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataAssetTagResponseBody() {}

  explicit DeleteDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataAssetTagResponseBody() = default;
};
class DeleteDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataAssetTagResponseBody> body{};

  DeleteDataAssetTagResponse() {}

  explicit DeleteDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataAssetTagResponse() = default;
};
class DeleteDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDataQualityEvaluationTaskRequest() {}

  explicit DeleteDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskRequest() = default;
};
class DeleteDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityEvaluationTaskResponseBody() {}

  explicit DeleteDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskResponseBody() = default;
};
class DeleteDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityEvaluationTaskResponseBody> body{};

  DeleteDataQualityEvaluationTaskResponse() {}

  explicit DeleteDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityEvaluationTaskResponse() = default;
};
class DeleteDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteDataQualityRuleRequest() {}

  explicit DeleteDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityRuleRequest() = default;
};
class DeleteDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityRuleResponseBody() {}

  explicit DeleteDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityRuleResponseBody() = default;
};
class DeleteDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityRuleResponseBody> body{};

  DeleteDataQualityRuleResponse() {}

  explicit DeleteDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityRuleResponse() = default;
};
class DeleteDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> projectId{};

  DeleteDataQualityRuleTemplateRequest() {}

  explicit DeleteDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDataQualityRuleTemplateRequest() = default;
};
class DeleteDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataQualityRuleTemplateResponseBody() {}

  explicit DeleteDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataQualityRuleTemplateResponseBody() = default;
};
class DeleteDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataQualityRuleTemplateResponseBody> body{};

  DeleteDataQualityRuleTemplateResponse() {}

  explicit DeleteDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataQualityRuleTemplateResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteDataSourceSharedRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteDataSourceSharedRuleRequest() {}

  explicit DeleteDataSourceSharedRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDataSourceSharedRuleRequest() = default;
};
class DeleteDataSourceSharedRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceSharedRuleResponseBody() {}

  explicit DeleteDataSourceSharedRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceSharedRuleResponseBody() = default;
};
class DeleteDataSourceSharedRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceSharedRuleResponseBody> body{};

  DeleteDataSourceSharedRuleResponse() {}

  explicit DeleteDataSourceSharedRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceSharedRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceSharedRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceSharedRuleResponse() = default;
};
class DeleteFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  DeleteFileRequest() {}

  explicit DeleteFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~DeleteFileRequest() = default;
};
class DeleteFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> deploymentId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFileResponseBody() {}

  explicit DeleteFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<long>(boost::any_cast<long>(m["DeploymentId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFileResponseBody() = default;
};
class DeleteFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFileResponseBody> body{};

  DeleteFileResponse() {}

  explicit DeleteFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileResponse() = default;
};
class DeleteFolderRequest : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  DeleteFolderRequest() {}

  explicit DeleteFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~DeleteFolderRequest() = default;
};
class DeleteFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFolderResponseBody() {}

  explicit DeleteFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFolderResponseBody() = default;
};
class DeleteFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFolderResponseBody> body{};

  DeleteFolderResponse() {}

  explicit DeleteFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFolderResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFolderResponse() = default;
};
class DeleteFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteFunctionRequest() {}

  explicit DeleteFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteFunctionRequest() = default;
};
class DeleteFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFunctionResponseBody() {}

  explicit DeleteFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFunctionResponseBody() = default;
};
class DeleteFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFunctionResponseBody> body{};

  DeleteFunctionResponse() {}

  explicit DeleteFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFunctionResponse() = default;
};
class DeleteLineageRelationshipRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteLineageRelationshipRequest() {}

  explicit DeleteLineageRelationshipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteLineageRelationshipRequest() = default;
};
class DeleteLineageRelationshipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLineageRelationshipResponseBody() {}

  explicit DeleteLineageRelationshipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLineageRelationshipResponseBody() = default;
};
class DeleteLineageRelationshipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLineageRelationshipResponseBody> body{};

  DeleteLineageRelationshipResponse() {}

  explicit DeleteLineageRelationshipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLineageRelationshipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLineageRelationshipResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLineageRelationshipResponse() = default;
};
class DeleteMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteMetaCollectionRequest() {}

  explicit DeleteMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteMetaCollectionRequest() = default;
};
class DeleteMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMetaCollectionResponseBody() {}

  explicit DeleteMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMetaCollectionResponseBody() = default;
};
class DeleteMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetaCollectionResponseBody> body{};

  DeleteMetaCollectionResponse() {}

  explicit DeleteMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetaCollectionResponse() = default;
};
class DeleteNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteNetworkRequest() {}

  explicit DeleteNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteNetworkRequest() = default;
};
class DeleteNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNetworkResponseBody() {}

  explicit DeleteNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNetworkResponseBody() = default;
};
class DeleteNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkResponseBody> body{};

  DeleteNetworkResponse() {}

  explicit DeleteNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkResponse() = default;
};
class DeleteNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteNodeRequest() {}

  explicit DeleteNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteNodeRequest() = default;
};
class DeleteNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNodeResponseBody() {}

  explicit DeleteNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNodeResponseBody() = default;
};
class DeleteNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNodeResponseBody> body{};

  DeleteNodeResponse() {}

  explicit DeleteNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNodeResponse() = default;
};
class DeleteProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteProjectRequest() {}

  explicit DeleteProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteProjectRequest() = default;
};
class DeleteProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectResponseBody() {}

  explicit DeleteProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectResponseBody() = default;
};
class DeleteProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectResponseBody> body{};

  DeleteProjectResponse() {}

  explicit DeleteProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectResponse() = default;
};
class DeleteProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  DeleteProjectMemberRequest() {}

  explicit DeleteProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteProjectMemberRequest() = default;
};
class DeleteProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectMemberResponseBody() {}

  explicit DeleteProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectMemberResponseBody() = default;
};
class DeleteProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectMemberResponseBody> body{};

  DeleteProjectMemberResponse() {}

  explicit DeleteProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectMemberResponse() = default;
};
class DeleteResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteResourceRequest() {}

  explicit DeleteResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteResourceRequest() = default;
};
class DeleteResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteResourceResponseBody() {}

  explicit DeleteResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteResourceResponseBody() = default;
};
class DeleteResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceResponseBody> body{};

  DeleteResourceResponse() {}

  explicit DeleteResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceResponse() = default;
};
class DeleteResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteResourceGroupRequest() {}

  explicit DeleteResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteResourceGroupRequest() = default;
};
class DeleteResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteResourceGroupResponseBody() {}

  explicit DeleteResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteResourceGroupResponseBody() = default;
};
class DeleteResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceGroupResponseBody> body{};

  DeleteResourceGroupResponse() {}

  explicit DeleteResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceGroupResponse() = default;
};
class DeleteRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteRouteRequest() {}

  explicit DeleteRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteRouteRequest() = default;
};
class DeleteRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRouteResponseBody() {}

  explicit DeleteRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRouteResponseBody() = default;
};
class DeleteRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteResponseBody> body{};

  DeleteRouteResponse() {}

  explicit DeleteRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteResponse() = default;
};
class DeleteTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectEnv{};

  DeleteTaskRequest() {}

  explicit DeleteTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~DeleteTaskRequest() = default;
};
class DeleteTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTaskResponseBody() {}

  explicit DeleteTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTaskResponseBody() = default;
};
class DeleteTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskResponseBody> body{};

  DeleteTaskResponse() {}

  explicit DeleteTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskResponse() = default;
};
class DeleteWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};

  DeleteWorkflowRequest() {}

  explicit DeleteWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteWorkflowRequest() = default;
};
class DeleteWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteWorkflowResponseBody() {}

  explicit DeleteWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteWorkflowResponseBody() = default;
};
class DeleteWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkflowResponseBody> body{};

  DeleteWorkflowResponse() {}

  explicit DeleteWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkflowResponse() = default;
};
class DeleteWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  DeleteWorkflowDefinitionRequest() {}

  explicit DeleteWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteWorkflowDefinitionRequest() = default;
};
class DeleteWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteWorkflowDefinitionResponseBody() {}

  explicit DeleteWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteWorkflowDefinitionResponseBody() = default;
};
class DeleteWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkflowDefinitionResponseBody> body{};

  DeleteWorkflowDefinitionResponse() {}

  explicit DeleteWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkflowDefinitionResponse() = default;
};
class DeployFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> fileId{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  DeployFileRequest() {}

  explicit DeployFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~DeployFileRequest() = default;
};
class DeployFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeployFileResponseBody() {}

  explicit DeployFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeployFileResponseBody() = default;
};
class DeployFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployFileResponseBody> body{};

  DeployFileResponse() {}

  explicit DeployFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeployFileResponse() = default;
};
class DetachDataQualityRulesFromEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<vector<long>> dataQualityRuleIds{};
  shared_ptr<long> projectId{};

  DetachDataQualityRulesFromEvaluationTaskRequest() {}

  explicit DetachDataQualityRulesFromEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIds) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DataQualityRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataQualityRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dataQualityRuleIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskRequest() = default;
};
class DetachDataQualityRulesFromEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> dataQualityRuleIdsShrink{};
  shared_ptr<long> projectId{};

  DetachDataQualityRulesFromEvaluationTaskShrinkRequest() {}

  explicit DetachDataQualityRulesFromEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityRuleIdsShrink) {
      res["DataQualityRuleIds"] = boost::any(*dataQualityRuleIdsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityRuleIds") != m.end() && !m["DataQualityRuleIds"].empty()) {
      dataQualityRuleIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRuleIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskShrinkRequest() = default;
};
class DetachDataQualityRulesFromEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetachDataQualityRulesFromEvaluationTaskResponseBody() {}

  explicit DetachDataQualityRulesFromEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskResponseBody() = default;
};
class DetachDataQualityRulesFromEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDataQualityRulesFromEvaluationTaskResponseBody> body{};

  DetachDataQualityRulesFromEvaluationTaskResponse() {}

  explicit DetachDataQualityRulesFromEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDataQualityRulesFromEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDataQualityRulesFromEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDataQualityRulesFromEvaluationTaskResponse() = default;
};
class DissociateProjectFromResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupId{};

  DissociateProjectFromResourceGroupRequest() {}

  explicit DissociateProjectFromResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DissociateProjectFromResourceGroupRequest() = default;
};
class DissociateProjectFromResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DissociateProjectFromResourceGroupResponseBody() {}

  explicit DissociateProjectFromResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DissociateProjectFromResourceGroupResponseBody() = default;
};
class DissociateProjectFromResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateProjectFromResourceGroupResponseBody> body{};

  DissociateProjectFromResourceGroupResponse() {}

  explicit DissociateProjectFromResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateProjectFromResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateProjectFromResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateProjectFromResourceGroupResponse() = default;
};
class EstablishRelationTableToBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessId{};
  shared_ptr<string> folderId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> tableGuid{};

  EstablishRelationTableToBusinessRequest() {}

  explicit EstablishRelationTableToBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<string>(boost::any_cast<string>(m["BusinessId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessRequest() = default;
};
class EstablishRelationTableToBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EstablishRelationTableToBusinessResponseBody() {}

  explicit EstablishRelationTableToBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessResponseBody() = default;
};
class EstablishRelationTableToBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EstablishRelationTableToBusinessResponseBody> body{};

  EstablishRelationTableToBusinessResponse() {}

  explicit EstablishRelationTableToBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstablishRelationTableToBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstablishRelationTableToBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~EstablishRelationTableToBusinessResponse() = default;
};
class ExecPipelineRunStageRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  ExecPipelineRunStageRequest() {}

  explicit ExecPipelineRunStageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ExecPipelineRunStageRequest() = default;
};
class ExecPipelineRunStageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecPipelineRunStageResponseBody() {}

  explicit ExecPipelineRunStageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecPipelineRunStageResponseBody() = default;
};
class ExecPipelineRunStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecPipelineRunStageResponseBody> body{};

  ExecPipelineRunStageResponse() {}

  explicit ExecPipelineRunStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecPipelineRunStageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecPipelineRunStageResponseBody>(model1);
      }
    }
  }


  virtual ~ExecPipelineRunStageResponse() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ExecuteAdhocWorkflowInstanceRequestTasksDataSource() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksDataSource() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksDependencies : public Darabonba::Model {
public:
  shared_ptr<string> upstreamOutput{};

  ExecuteAdhocWorkflowInstanceRequestTasksDependencies() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksDependencies() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables>> variables{};

  ExecuteAdhocWorkflowInstanceRequestTasksInputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksInputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables>> variables{};

  ExecuteAdhocWorkflowInstanceRequestTasksOutputs() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksOutputs() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasksScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  ExecuteAdhocWorkflowInstanceRequestTasksScript() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasksScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasksScript() = default;
};
class ExecuteAdhocWorkflowInstanceRequestTasks : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksDataSource> dataSource{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies>> dependencies{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksInputs> inputs{};
  shared_ptr<string> name{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<ExecuteAdhocWorkflowInstanceRequestTasksScript> script{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};

  ExecuteAdhocWorkflowInstanceRequestTasks() {}

  explicit ExecuteAdhocWorkflowInstanceRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasksDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasksDependencies>>(expect1);
      }
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksInputs>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ExecuteAdhocWorkflowInstanceRequestTasksScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ExecuteAdhocWorkflowInstanceRequestTasksScript>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequestTasks() = default;
};
class ExecuteAdhocWorkflowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ExecuteAdhocWorkflowInstanceRequestTasks>> tasks{};

  ExecuteAdhocWorkflowInstanceRequest() {}

  explicit ExecuteAdhocWorkflowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ExecuteAdhocWorkflowInstanceRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdhocWorkflowInstanceRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ExecuteAdhocWorkflowInstanceRequestTasks>>(expect1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceRequest() = default;
};
class ExecuteAdhocWorkflowInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tasksShrink{};

  ExecuteAdhocWorkflowInstanceShrinkRequest() {}

  explicit ExecuteAdhocWorkflowInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceShrinkRequest() = default;
};
class ExecuteAdhocWorkflowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> workflowInstanceId{};

  ExecuteAdhocWorkflowInstanceResponseBody() {}

  explicit ExecuteAdhocWorkflowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceResponseBody() = default;
};
class ExecuteAdhocWorkflowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteAdhocWorkflowInstanceResponseBody> body{};

  ExecuteAdhocWorkflowInstanceResponse() {}

  explicit ExecuteAdhocWorkflowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteAdhocWorkflowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteAdhocWorkflowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteAdhocWorkflowInstanceResponse() = default;
};
class GetAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetAlertRuleRequest() {}

  explicit GetAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetAlertRuleRequest() = default;
};
class GetAlertRuleResponseBodyAlertRuleNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetAlertRuleResponseBodyAlertRuleNotificationReceivers() {}

  explicit GetAlertRuleResponseBodyAlertRuleNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleNotificationReceivers() = default;
};
class GetAlertRuleResponseBodyAlertRuleNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  GetAlertRuleResponseBodyAlertRuleNotification() {}

  explicit GetAlertRuleResponseBodyAlertRuleNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRuleResponseBodyAlertRuleNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<GetAlertRuleResponseBodyAlertRuleNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleNotification() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError> error{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished> unFinished{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget() = default;
};
class GetAlertRuleResponseBodyAlertRuleTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension> extension{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  GetAlertRuleResponseBodyAlertRuleTriggerCondition() {}

  explicit GetAlertRuleResponseBodyAlertRuleTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRuleTriggerCondition() = default;
};
class GetAlertRuleResponseBodyAlertRule : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<GetAlertRuleResponseBodyAlertRuleTriggerCondition> triggerCondition{};

  GetAlertRuleResponseBodyAlertRule() {}

  explicit GetAlertRuleResponseBodyAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        GetAlertRuleResponseBodyAlertRuleNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<GetAlertRuleResponseBodyAlertRuleNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        GetAlertRuleResponseBodyAlertRuleTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<GetAlertRuleResponseBodyAlertRuleTriggerCondition>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponseBodyAlertRule() = default;
};
class GetAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlertRuleResponseBodyAlertRule> alertRule{};
  shared_ptr<string> requestId{};

  GetAlertRuleResponseBody() {}

  explicit GetAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        GetAlertRuleResponseBodyAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<GetAlertRuleResponseBodyAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlertRuleResponseBody() = default;
};
class GetAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlertRuleResponseBody> body{};

  GetAlertRuleResponse() {}

  explicit GetAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlertRuleResponse() = default;
};
class GetBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  GetBusinessRequest() {}

  explicit GetBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~GetBusinessRequest() = default;
};
class GetBusinessResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<string> projectId{};
  shared_ptr<string> useType{};

  GetBusinessResponseBodyData() {}

  explicit GetBusinessResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetBusinessResponseBodyData() = default;
};
class GetBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBusinessResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBusinessResponseBody() {}

  explicit GetBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBusinessResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBusinessResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBusinessResponseBody() = default;
};
class GetBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBusinessResponseBody> body{};

  GetBusinessResponse() {}

  explicit GetBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~GetBusinessResponse() = default;
};
class GetCatalogRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetCatalogRequest() {}

  explicit GetCatalogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetCatalogRequest() = default;
};
class GetCatalogResponseBody : public Darabonba::Model {
public:
  shared_ptr<Catalog> catalog{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCatalogResponseBody() {}

  explicit GetCatalogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalog) {
      res["Catalog"] = catalog ? boost::any(catalog->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Catalog") != m.end() && !m["Catalog"].empty()) {
      if (typeid(map<string, boost::any>) == m["Catalog"].type()) {
        Catalog model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Catalog"]));
        catalog = make_shared<Catalog>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCatalogResponseBody() = default;
};
class GetCatalogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCatalogResponseBody> body{};

  GetCatalogResponse() {}

  explicit GetCatalogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCatalogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCatalogResponseBody>(model1);
      }
    }
  }


  virtual ~GetCatalogResponse() = default;
};
class GetCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetCertificateRequest() {}

  explicit GetCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetCertificateRequest() = default;
};
class GetCertificateResponseBodyCertificate : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> fileSizeInBytes{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  GetCertificateResponseBodyCertificate() {}

  explicit GetCertificateResponseBodyCertificate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileSizeInBytes) {
      res["FileSizeInBytes"] = boost::any(*fileSizeInBytes);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileSizeInBytes") != m.end() && !m["FileSizeInBytes"].empty()) {
      fileSizeInBytes = make_shared<long>(boost::any_cast<long>(m["FileSizeInBytes"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetCertificateResponseBodyCertificate() = default;
};
class GetCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCertificateResponseBodyCertificate> certificate{};
  shared_ptr<string> requestId{};

  GetCertificateResponseBody() {}

  explicit GetCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificate) {
      res["Certificate"] = certificate ? boost::any(certificate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Certificate"].type()) {
        GetCertificateResponseBodyCertificate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Certificate"]));
        certificate = make_shared<GetCertificateResponseBodyCertificate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCertificateResponseBody() = default;
};
class GetCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCertificateResponseBody> body{};

  GetCertificateResponse() {}

  explicit GetCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~GetCertificateResponse() = default;
};
class GetColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetColumnRequest() {}

  explicit GetColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetColumnRequest() = default;
};
class GetColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<Column> column{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetColumnResponseBody() {}

  explicit GetColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = column ? boost::any(column->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      if (typeid(map<string, boost::any>) == m["Column"].type()) {
        Column model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Column"]));
        column = make_shared<Column>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetColumnResponseBody() = default;
};
class GetColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetColumnResponseBody> body{};

  GetColumnResponse() {}

  explicit GetColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetColumnResponseBody>(model1);
      }
    }
  }


  virtual ~GetColumnResponse() = default;
};
class GetCreateWorkflowInstancesResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};

  GetCreateWorkflowInstancesResultRequest() {}

  explicit GetCreateWorkflowInstancesResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
  }


  virtual ~GetCreateWorkflowInstancesResultRequest() = default;
};
class GetCreateWorkflowInstancesResultResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> failureMessage{};
  shared_ptr<string> status{};
  shared_ptr<vector<long>> workflowInstanceIds{};

  GetCreateWorkflowInstancesResultResponseBodyResult() {}

  explicit GetCreateWorkflowInstancesResultResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureMessage) {
      res["FailureMessage"] = boost::any(*failureMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (workflowInstanceIds) {
      res["WorkflowInstanceIds"] = boost::any(*workflowInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureMessage") != m.end() && !m["FailureMessage"].empty()) {
      failureMessage = make_shared<string>(boost::any_cast<string>(m["FailureMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("WorkflowInstanceIds") != m.end() && !m["WorkflowInstanceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["WorkflowInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkflowInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      workflowInstanceIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponseBodyResult() = default;
};
class GetCreateWorkflowInstancesResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetCreateWorkflowInstancesResultResponseBodyResult> result{};

  GetCreateWorkflowInstancesResultResponseBody() {}

  explicit GetCreateWorkflowInstancesResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetCreateWorkflowInstancesResultResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetCreateWorkflowInstancesResultResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponseBody() = default;
};
class GetCreateWorkflowInstancesResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCreateWorkflowInstancesResultResponseBody> body{};

  GetCreateWorkflowInstancesResultResponse() {}

  explicit GetCreateWorkflowInstancesResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCreateWorkflowInstancesResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCreateWorkflowInstancesResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetCreateWorkflowInstancesResultResponse() = default;
};
class GetDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> withDetails{};

  GetDIJobRequest() {}

  explicit GetDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (withDetails) {
      res["WithDetails"] = boost::any(*withDetails);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("WithDetails") != m.end() && !m["WithDetails"].empty()) {
      withDetails = make_shared<bool>(boost::any_cast<bool>(m["WithDetails"]));
    }
  }


  virtual ~GetDIJobRequest() = default;
};
class GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};

  GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> cycleMigrationType{};
  shared_ptr<string> scheduleParameters{};

  GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleMigrationType) {
      res["CycleMigrationType"] = boost::any(*cycleMigrationType);
    }
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleMigrationType") != m.end() && !m["CycleMigrationType"].empty()) {
      cycleMigrationType = make_shared<string>(boost::any_cast<string>(m["CycleMigrationType"]));
    }
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings() = default;
};
class GetDIJobResponseBodyPagingInfoJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings>> runtimeSettings{};

  GetDIJobResponseBodyPagingInfoJobSettings() {}

  explicit GetDIJobResponseBodyPagingInfoJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoJobSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoResourceSettings : public Darabonba::Model {
public:
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  GetDIJobResponseBodyPagingInfoResourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoResourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties : public Darabonba::Model {
public:
  shared_ptr<string> encoding{};
  shared_ptr<string> timezone{};

  GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties() {}

  explicit GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties() = default;
};
class GetDIJobResponseBodyPagingInfoSourceDataSourceSettings : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceName{};
  shared_ptr<GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties> dataSourceProperties{};

  GetDIJobResponseBodyPagingInfoSourceDataSourceSettings() {}

  explicit GetDIJobResponseBodyPagingInfoSourceDataSourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (dataSourceProperties) {
      res["DataSourceProperties"] = dataSourceProperties ? boost::any(dataSourceProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("DataSourceProperties") != m.end() && !m["DataSourceProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceProperties"].type()) {
        GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceProperties"]));
        dataSourceProperties = make_shared<GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties>(model1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoSourceDataSourceSettings() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules() = default;
};
class GetDIJobResponseBodyPagingInfoTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules>> transformationRules{};

  GetDIJobResponseBodyPagingInfoTableMappings() {}

  explicit GetDIJobResponseBodyPagingInfoTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTableMappings() = default;
};
class GetDIJobResponseBodyPagingInfoTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  GetDIJobResponseBodyPagingInfoTransformationRules() {}

  explicit GetDIJobResponseBodyPagingInfoTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfoTransformationRules() = default;
};
class GetDIJobResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<string> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings>> destinationDataSourceSettings{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<long> id{};
  shared_ptr<string> jobName{};
  shared_ptr<GetDIJobResponseBodyPagingInfoJobSettings> jobSettings{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> migrationType{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDIJobResponseBodyPagingInfoResourceSettings> resourceSettings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings>> sourceDataSourceSettings{};
  shared_ptr<string> sourceDataSourceType{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTableMappings>> tableMappings{};
  shared_ptr<vector<GetDIJobResponseBodyPagingInfoTransformationRules>> transformationRules{};

  GetDIJobResponseBodyPagingInfo() {}

  explicit GetDIJobResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*destinationDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationDataSourceSettings"] = boost::any(temp1);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceDataSourceSettings) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDataSourceSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDataSourceSettings"] = boost::any(temp1);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<string>(boost::any_cast<string>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDataSourceSettings") != m.end() && !m["DestinationDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationDataSourceSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationDataSourceSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings>>(expect1);
      }
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        GetDIJobResponseBodyPagingInfoJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<GetDIJobResponseBodyPagingInfoJobSettings>(model1);
      }
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        GetDIJobResponseBodyPagingInfoResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<GetDIJobResponseBodyPagingInfoResourceSettings>(model1);
      }
    }
    if (m.find("SourceDataSourceSettings") != m.end() && !m["SourceDataSourceSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDataSourceSettings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDataSourceSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoSourceDataSourceSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDataSourceSettings = make_shared<vector<GetDIJobResponseBodyPagingInfoSourceDataSourceSettings>>(expect1);
      }
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<GetDIJobResponseBodyPagingInfoTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<GetDIJobResponseBodyPagingInfoTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDIJobResponseBodyPagingInfoTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<GetDIJobResponseBodyPagingInfoTransformationRules>>(expect1);
      }
    }
  }


  virtual ~GetDIJobResponseBodyPagingInfo() = default;
};
class GetDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDIJobResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  GetDIJobResponseBody() {}

  explicit GetDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        GetDIJobResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<GetDIJobResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDIJobResponseBody() = default;
};
class GetDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDIJobResponseBody> body{};

  GetDIJobResponse() {}

  explicit GetDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDIJobResponse() = default;
};
class GetDIJobLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> failoverId{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> pageNumber{};

  GetDIJobLogRequest() {}

  explicit GetDIJobLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (failoverId) {
      res["FailoverId"] = boost::any(*failoverId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("FailoverId") != m.end() && !m["FailoverId"].empty()) {
      failoverId = make_shared<long>(boost::any_cast<long>(m["FailoverId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~GetDIJobLogRequest() = default;
};
class GetDIJobLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> log{};
  shared_ptr<string> requestId{};

  GetDIJobLogResponseBody() {}

  explicit GetDIJobLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDIJobLogResponseBody() = default;
};
class GetDIJobLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDIJobLogResponseBody> body{};

  GetDIJobLogResponse() {}

  explicit GetDIJobLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDIJobLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDIJobLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetDIJobLogResponse() = default;
};
class GetDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityEvaluationTaskRequest() {}

  explicit GetDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskRequest() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications>> notifications{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger() = default;
};
class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget> target{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger> trigger{};

  GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask() {}

  explicit GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask() = default;
};
class GetDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask> dataQualityEvaluationTask{};
  shared_ptr<string> requestId{};

  GetDataQualityEvaluationTaskResponseBody() {}

  explicit GetDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTask) {
      res["DataQualityEvaluationTask"] = dataQualityEvaluationTask ? boost::any(dataQualityEvaluationTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTask") != m.end() && !m["DataQualityEvaluationTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityEvaluationTask"].type()) {
        GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityEvaluationTask"]));
        dataQualityEvaluationTask = make_shared<GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponseBody() = default;
};
class GetDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityEvaluationTaskResponseBody> body{};

  GetDataQualityEvaluationTaskResponse() {}

  explicit GetDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskResponse() = default;
};
class GetDataQualityEvaluationTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityEvaluationTaskInstanceRequest() {}

  explicit GetDataQualityEvaluationTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceRequest() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkedValue{};
  shared_ptr<string> referencedValue{};
  shared_ptr<string> status{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkedValue) {
      res["CheckedValue"] = boost::any(*checkedValue);
    }
    if (referencedValue) {
      res["ReferencedValue"] = boost::any(*referencedValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckedValue") != m.end() && !m["CheckedValue"].empty()) {
      checkedValue = make_shared<string>(boost::any_cast<string>(m["CheckedValue"]));
    }
    if (m.find("ReferencedValue") != m.end() && !m["ReferencedValue"].empty()) {
      referencedValue = make_shared<string>(boost::any_cast<string>(m["ReferencedValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned> warned{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget> target{};
  shared_ptr<string> templateCode{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails>> details{};
  shared_ptr<long> id{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule> rule{};
  shared_ptr<string> sample{};
  shared_ptr<string> status{};
  shared_ptr<long> taskInstanceId{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule>(model1);
      }
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications>> notifications{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget> target{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger> trigger{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults>> results{};
  shared_ptr<string> status{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask> task{};
  shared_ptr<string> triggerContext{};

  GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerContext) {
      res["TriggerContext"] = boost::any(*triggerContext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask>(model1);
      }
    }
    if (m.find("TriggerContext") != m.end() && !m["TriggerContext"].empty()) {
      triggerContext = make_shared<string>(boost::any_cast<string>(m["TriggerContext"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance() = default;
};
class GetDataQualityEvaluationTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance> dataQualityEvaluationTaskInstance{};
  shared_ptr<string> requestId{};

  GetDataQualityEvaluationTaskInstanceResponseBody() {}

  explicit GetDataQualityEvaluationTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskInstance) {
      res["DataQualityEvaluationTaskInstance"] = dataQualityEvaluationTaskInstance ? boost::any(dataQualityEvaluationTaskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskInstance") != m.end() && !m["DataQualityEvaluationTaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityEvaluationTaskInstance"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityEvaluationTaskInstance"]));
        dataQualityEvaluationTaskInstance = make_shared<GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponseBody() = default;
};
class GetDataQualityEvaluationTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityEvaluationTaskInstanceResponseBody> body{};

  GetDataQualityEvaluationTaskInstanceResponse() {}

  explicit GetDataQualityEvaluationTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityEvaluationTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityEvaluationTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityEvaluationTaskInstanceResponse() = default;
};
class GetDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataQualityRuleRequest() {}

  explicit GetDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataQualityRuleRequest() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned> warned{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  GetDataQualityRuleResponseBodyDataQualityRuleTarget() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRuleTarget() = default;
};
class GetDataQualityRuleResponseBodyDataQualityRule : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRuleTarget> target{};
  shared_ptr<string> templateCode{};

  GetDataQualityRuleResponseBodyDataQualityRule() {}

  explicit GetDataQualityRuleResponseBodyDataQualityRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<GetDataQualityRuleResponseBodyDataQualityRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBodyDataQualityRule() = default;
};
class GetDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleResponseBodyDataQualityRule> dataQualityRule{};
  shared_ptr<string> requestId{};

  GetDataQualityRuleResponseBody() {}

  explicit GetDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRule) {
      res["DataQualityRule"] = dataQualityRule ? boost::any(dataQualityRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRule") != m.end() && !m["DataQualityRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityRule"].type()) {
        GetDataQualityRuleResponseBodyDataQualityRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityRule"]));
        dataQualityRule = make_shared<GetDataQualityRuleResponseBodyDataQualityRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityRuleResponseBody() = default;
};
class GetDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityRuleResponseBody> body{};

  GetDataQualityRuleResponse() {}

  explicit GetDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleResponse() = default;
};
class GetDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  GetDataQualityRuleTemplateRequest() {}

  explicit GetDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateRequest() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig() = default;
};
class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate() {}

  explicit GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate() = default;
};
class GetDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate> dataQualityRuleTemplate{};
  shared_ptr<string> requestId{};

  GetDataQualityRuleTemplateResponseBody() {}

  explicit GetDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRuleTemplate) {
      res["DataQualityRuleTemplate"] = dataQualityRuleTemplate ? boost::any(dataQualityRuleTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRuleTemplate") != m.end() && !m["DataQualityRuleTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataQualityRuleTemplate"].type()) {
        GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataQualityRuleTemplate"]));
        dataQualityRuleTemplate = make_shared<GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataQualityRuleTemplateResponseBody() = default;
};
class GetDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataQualityRuleTemplateResponseBody> body{};

  GetDataQualityRuleTemplateResponse() {}

  explicit GetDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataQualityRuleTemplateResponse() = default;
};
class GetDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetDataSourceRequest() {}

  explicit GetDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetDataSourceRequest() = default;
};
class GetDataSourceResponseBodyDataSource : public Darabonba::Model {
public:
  shared_ptr<boost::any> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> qualifiedName{};
  shared_ptr<string> type{};

  GetDataSourceResponseBodyDataSource() {}

  explicit GetDataSourceResponseBodyDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataSourceResponseBodyDataSource() = default;
};
class GetDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataSourceResponseBodyDataSource> dataSource{};
  shared_ptr<string> requestId{};

  GetDataSourceResponseBody() {}

  explicit GetDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetDataSourceResponseBodyDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetDataSourceResponseBodyDataSource>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataSourceResponseBody() = default;
};
class GetDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataSourceResponseBody> body{};

  GetDataSourceResponse() {}

  explicit GetDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataSourceResponse() = default;
};
class GetDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetDatabaseRequest() {}

  explicit GetDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetDatabaseRequest() = default;
};
class GetDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<Database> database{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDatabaseResponseBody() {}

  explicit GetDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = database ? boost::any(database->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(map<string, boost::any>) == m["Database"].type()) {
        Database model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Database"]));
        database = make_shared<Database>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDatabaseResponseBody() = default;
};
class GetDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatabaseResponseBody> body{};

  GetDatabaseResponse() {}

  explicit GetDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatabaseResponse() = default;
};
class GetDeploymentPackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> deploymentId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  GetDeploymentPackageRequest() {}

  explicit GetDeploymentPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<long>(boost::any_cast<long>(m["DeploymentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~GetDeploymentPackageRequest() = default;
};
class GetDeploymentPackageResponseBodyDataDeployedItems : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> fileVersion{};
  shared_ptr<long> status{};

  GetDeploymentPackageResponseBodyDataDeployedItems() {}

  explicit GetDeploymentPackageResponseBodyDataDeployedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetDeploymentPackageResponseBodyDataDeployedItems() = default;
};
class GetDeploymentPackageResponseBodyDataDeployment : public Darabonba::Model {
public:
  shared_ptr<long> checkingStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> executeTime{};
  shared_ptr<long> fromEnvironment{};
  shared_ptr<string> handlerId{};
  shared_ptr<string> name{};
  shared_ptr<long> status{};
  shared_ptr<long> toEnvironment{};

  GetDeploymentPackageResponseBodyDataDeployment() {}

  explicit GetDeploymentPackageResponseBodyDataDeployment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingStatus) {
      res["CheckingStatus"] = boost::any(*checkingStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (fromEnvironment) {
      res["FromEnvironment"] = boost::any(*fromEnvironment);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (toEnvironment) {
      res["ToEnvironment"] = boost::any(*toEnvironment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingStatus") != m.end() && !m["CheckingStatus"].empty()) {
      checkingStatus = make_shared<long>(boost::any_cast<long>(m["CheckingStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("FromEnvironment") != m.end() && !m["FromEnvironment"].empty()) {
      fromEnvironment = make_shared<long>(boost::any_cast<long>(m["FromEnvironment"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<string>(boost::any_cast<string>(m["HandlerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ToEnvironment") != m.end() && !m["ToEnvironment"].empty()) {
      toEnvironment = make_shared<long>(boost::any_cast<long>(m["ToEnvironment"]));
    }
  }


  virtual ~GetDeploymentPackageResponseBodyDataDeployment() = default;
};
class GetDeploymentPackageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetDeploymentPackageResponseBodyDataDeployedItems>> deployedItems{};
  shared_ptr<GetDeploymentPackageResponseBodyDataDeployment> deployment{};

  GetDeploymentPackageResponseBodyData() {}

  explicit GetDeploymentPackageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedItems) {
      vector<boost::any> temp1;
      for(auto item1:*deployedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedItems"] = boost::any(temp1);
    }
    if (deployment) {
      res["Deployment"] = deployment ? boost::any(deployment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedItems") != m.end() && !m["DeployedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedItems"].type()) {
        vector<GetDeploymentPackageResponseBodyDataDeployedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeploymentPackageResponseBodyDataDeployedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedItems = make_shared<vector<GetDeploymentPackageResponseBodyDataDeployedItems>>(expect1);
      }
    }
    if (m.find("Deployment") != m.end() && !m["Deployment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deployment"].type()) {
        GetDeploymentPackageResponseBodyDataDeployment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deployment"]));
        deployment = make_shared<GetDeploymentPackageResponseBodyDataDeployment>(model1);
      }
    }
  }


  virtual ~GetDeploymentPackageResponseBodyData() = default;
};
class GetDeploymentPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDeploymentPackageResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDeploymentPackageResponseBody() {}

  explicit GetDeploymentPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeploymentPackageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeploymentPackageResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDeploymentPackageResponseBody() = default;
};
class GetDeploymentPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeploymentPackageResponseBody> body{};

  GetDeploymentPackageResponse() {}

  explicit GetDeploymentPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeploymentPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeploymentPackageResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeploymentPackageResponse() = default;
};
class GetFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  GetFileRequest() {}

  explicit GetFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~GetFileRequest() = default;
};
class GetFileResponseBodyDataFile : public Darabonba::Model {
public:
  shared_ptr<string> advancedSettings{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<long> bizId{};
  shared_ptr<long> businessId{};
  shared_ptr<long> commitStatus{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> currentVersion{};
  shared_ptr<string> deletedStatus{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> owner{};
  shared_ptr<long> parentId{};
  shared_ptr<string> useType{};

  GetFileResponseBodyDataFile() {}

  explicit GetFileResponseBodyDataFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedSettings) {
      res["AdvancedSettings"] = boost::any(*advancedSettings);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (deletedStatus) {
      res["DeletedStatus"] = boost::any(*deletedStatus);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedSettings") != m.end() && !m["AdvancedSettings"].empty()) {
      advancedSettings = make_shared<string>(boost::any_cast<string>(m["AdvancedSettings"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<long>(boost::any_cast<long>(m["CommitStatus"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("DeletedStatus") != m.end() && !m["DeletedStatus"].empty()) {
      deletedStatus = make_shared<string>(boost::any_cast<string>(m["DeletedStatus"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetFileResponseBodyDataFile() = default;
};
class GetFileResponseBodyDataNodeConfigurationInputList : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> parseType{};

  GetFileResponseBodyDataNodeConfigurationInputList() {}

  explicit GetFileResponseBodyDataNodeConfigurationInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (parseType) {
      res["ParseType"] = boost::any(*parseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ParseType") != m.end() && !m["ParseType"].empty()) {
      parseType = make_shared<string>(boost::any_cast<string>(m["ParseType"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationInputList() = default;
};
class GetFileResponseBodyDataNodeConfigurationInputParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> valueSource{};

  GetFileResponseBodyDataNodeConfigurationInputParameters() {}

  explicit GetFileResponseBodyDataNodeConfigurationInputParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (valueSource) {
      res["ValueSource"] = boost::any(*valueSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ValueSource") != m.end() && !m["ValueSource"].empty()) {
      valueSource = make_shared<string>(boost::any_cast<string>(m["ValueSource"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationInputParameters() = default;
};
class GetFileResponseBodyDataNodeConfigurationOutputList : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> refTableName{};

  GetFileResponseBodyDataNodeConfigurationOutputList() {}

  explicit GetFileResponseBodyDataNodeConfigurationOutputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (refTableName) {
      res["RefTableName"] = boost::any(*refTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RefTableName") != m.end() && !m["RefTableName"].empty()) {
      refTableName = make_shared<string>(boost::any_cast<string>(m["RefTableName"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationOutputList() = default;
};
class GetFileResponseBodyDataNodeConfigurationOutputParameters : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetFileResponseBodyDataNodeConfigurationOutputParameters() {}

  explicit GetFileResponseBodyDataNodeConfigurationOutputParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationOutputParameters() = default;
};
class GetFileResponseBodyDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> applyScheduleImmediately{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> dependentType{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> ignoreParentSkipRunningProperty{};
  shared_ptr<string> imageId{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationInputList>> inputList{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationInputParameters>> inputParameters{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationOutputList>> outputList{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationOutputParameters>> outputParameters{};
  shared_ptr<string> paraValue{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> schedulerType{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<bool> startImmediately{};
  shared_ptr<bool> stop{};
  shared_ptr<long> timeout{};

  GetFileResponseBodyDataNodeConfiguration() {}

  explicit GetFileResponseBodyDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyScheduleImmediately) {
      res["ApplyScheduleImmediately"] = boost::any(*applyScheduleImmediately);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (ignoreParentSkipRunningProperty) {
      res["IgnoreParentSkipRunningProperty"] = boost::any(*ignoreParentSkipRunningProperty);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (inputParameters) {
      vector<boost::any> temp1;
      for(auto item1:*inputParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputParameters"] = boost::any(temp1);
    }
    if (outputList) {
      vector<boost::any> temp1;
      for(auto item1:*outputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputList"] = boost::any(temp1);
    }
    if (outputParameters) {
      vector<boost::any> temp1;
      for(auto item1:*outputParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputParameters"] = boost::any(temp1);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (startImmediately) {
      res["StartImmediately"] = boost::any(*startImmediately);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyScheduleImmediately") != m.end() && !m["ApplyScheduleImmediately"].empty()) {
      applyScheduleImmediately = make_shared<string>(boost::any_cast<string>(m["ApplyScheduleImmediately"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("IgnoreParentSkipRunningProperty") != m.end() && !m["IgnoreParentSkipRunningProperty"].empty()) {
      ignoreParentSkipRunningProperty = make_shared<string>(boost::any_cast<string>(m["IgnoreParentSkipRunningProperty"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<GetFileResponseBodyDataNodeConfigurationInputList>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["InputParameters"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationInputParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationInputParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputParameters = make_shared<vector<GetFileResponseBodyDataNodeConfigurationInputParameters>>(expect1);
      }
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputList"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationOutputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationOutputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputList = make_shared<vector<GetFileResponseBodyDataNodeConfigurationOutputList>>(expect1);
      }
    }
    if (m.find("OutputParameters") != m.end() && !m["OutputParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputParameters"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationOutputParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationOutputParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputParameters = make_shared<vector<GetFileResponseBodyDataNodeConfigurationOutputParameters>>(expect1);
      }
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("StartImmediately") != m.end() && !m["StartImmediately"].empty()) {
      startImmediately = make_shared<bool>(boost::any_cast<bool>(m["StartImmediately"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfiguration() = default;
};
class GetFileResponseBodyDataResourceDownloadLink : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};

  GetFileResponseBodyDataResourceDownloadLink() {}

  explicit GetFileResponseBodyDataResourceDownloadLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["downloadLink"] = boost::any(*downloadLink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadLink") != m.end() && !m["downloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["downloadLink"]));
    }
  }


  virtual ~GetFileResponseBodyDataResourceDownloadLink() = default;
};
class GetFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetFileResponseBodyDataFile> file{};
  shared_ptr<GetFileResponseBodyDataNodeConfiguration> nodeConfiguration{};
  shared_ptr<GetFileResponseBodyDataResourceDownloadLink> resourceDownloadLink{};

  GetFileResponseBodyData() {}

  explicit GetFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeConfiguration) {
      res["NodeConfiguration"] = nodeConfiguration ? boost::any(nodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceDownloadLink) {
      res["ResourceDownloadLink"] = resourceDownloadLink ? boost::any(resourceDownloadLink->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetFileResponseBodyDataFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetFileResponseBodyDataFile>(model1);
      }
    }
    if (m.find("NodeConfiguration") != m.end() && !m["NodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeConfiguration"].type()) {
        GetFileResponseBodyDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeConfiguration"]));
        nodeConfiguration = make_shared<GetFileResponseBodyDataNodeConfiguration>(model1);
      }
    }
    if (m.find("ResourceDownloadLink") != m.end() && !m["ResourceDownloadLink"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDownloadLink"].type()) {
        GetFileResponseBodyDataResourceDownloadLink model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDownloadLink"]));
        resourceDownloadLink = make_shared<GetFileResponseBodyDataResourceDownloadLink>(model1);
      }
    }
  }


  virtual ~GetFileResponseBodyData() = default;
};
class GetFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFileResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFileResponseBody() {}

  explicit GetFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFileResponseBody() = default;
};
class GetFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileResponseBody> body{};

  GetFileResponse() {}

  explicit GetFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileResponse() = default;
};
class GetFileVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> fileVersion{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  GetFileVersionRequest() {}

  explicit GetFileVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~GetFileVersionRequest() = default;
};
class GetFileVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeType{};
  shared_ptr<string> comment{};
  shared_ptr<long> commitTime{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> fileContent{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<long> fileVersion{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<string> nodeContent{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> status{};
  shared_ptr<string> useType{};

  GetFileVersionResponseBodyData() {}

  explicit GetFileVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetFileVersionResponseBodyData() = default;
};
class GetFileVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFileVersionResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFileVersionResponseBody() {}

  explicit GetFileVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileVersionResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFileVersionResponseBody() = default;
};
class GetFileVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileVersionResponseBody> body{};

  GetFileVersionResponse() {}

  explicit GetFileVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileVersionResponse() = default;
};
class GetFolderRequest : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  GetFolderRequest() {}

  explicit GetFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~GetFolderRequest() = default;
};
class GetFolderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  GetFolderResponseBodyData() {}

  explicit GetFolderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~GetFolderResponseBodyData() = default;
};
class GetFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFolderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFolderResponseBody() {}

  explicit GetFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFolderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFolderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFolderResponseBody() = default;
};
class GetFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFolderResponseBody> body{};

  GetFolderResponse() {}

  explicit GetFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFolderResponseBody>(model1);
      }
    }
  }


  virtual ~GetFolderResponse() = default;
};
class GetFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetFunctionRequest() {}

  explicit GetFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetFunctionRequest() = default;
};
class GetFunctionResponseBodyFunction : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  GetFunctionResponseBodyFunction() {}

  explicit GetFunctionResponseBodyFunction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~GetFunctionResponseBodyFunction() = default;
};
class GetFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFunctionResponseBodyFunction> function{};
  shared_ptr<string> requestId{};

  GetFunctionResponseBody() {}

  explicit GetFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = function ? boost::any(function->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      if (typeid(map<string, boost::any>) == m["Function"].type()) {
        GetFunctionResponseBodyFunction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Function"]));
        function = make_shared<GetFunctionResponseBodyFunction>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFunctionResponseBody() = default;
};
class GetFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFunctionResponseBody> body{};

  GetFunctionResponse() {}

  explicit GetFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~GetFunctionResponse() = default;
};
class GetIDEEventDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<long> projectId{};

  GetIDEEventDetailRequest() {}

  explicit GetIDEEventDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetIDEEventDetailRequest() = default;
};
class GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<long> currentVersion{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<string> folderId{};
  shared_ptr<string> owner{};
  shared_ptr<long> parentFileId{};

  GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent() {}

  explicit GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentFileId) {
      res["ParentFileId"] = boost::any(*parentFileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentFileId") != m.end() && !m["ParentFileId"].empty()) {
      parentFileId = make_shared<long>(boost::any_cast<long>(m["ParentFileId"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent() = default;
};
class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> parseType{};

  GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList() {}

  explicit GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (parseType) {
      res["ParseType"] = boost::any(*parseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ParseType") != m.end() && !m["ParseType"].empty()) {
      parseType = make_shared<string>(boost::any_cast<string>(m["ParseType"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList() = default;
};
class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> refTableName{};

  GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList() {}

  explicit GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (refTableName) {
      res["RefTableName"] = boost::any(*refTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RefTableName") != m.end() && !m["RefTableName"].empty()) {
      refTableName = make_shared<string>(boost::any_cast<string>(m["RefTableName"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList() = default;
};
class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> dependentType{};
  shared_ptr<vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList>> inputList{};
  shared_ptr<vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList>> outputList{};
  shared_ptr<string> paraValue{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> schedulerType{};

  GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration() {}

  explicit GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (outputList) {
      vector<boost::any> temp1;
      for(auto item1:*outputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputList"] = boost::any(temp1);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList>>(expect1);
      }
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputList"].type()) {
        vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputList = make_shared<vector<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList>>(expect1);
      }
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration() = default;
};
class GetIDEEventDetailResponseBodyEventDetailCommittedFile : public Darabonba::Model {
public:
  shared_ptr<string> changeType{};
  shared_ptr<string> comment{};
  shared_ptr<string> committor{};
  shared_ptr<string> content{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent> filePropertyContent{};
  shared_ptr<long> fileType{};
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration> nodeConfiguration{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> useType{};

  GetIDEEventDetailResponseBodyEventDetailCommittedFile() {}

  explicit GetIDEEventDetailResponseBodyEventDetailCommittedFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (committor) {
      res["Committor"] = boost::any(*committor);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = filePropertyContent ? boost::any(filePropertyContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (nodeConfiguration) {
      res["NodeConfiguration"] = nodeConfiguration ? boost::any(nodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Committor") != m.end() && !m["Committor"].empty()) {
      committor = make_shared<string>(boost::any_cast<string>(m["Committor"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilePropertyContent"].type()) {
        GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilePropertyContent"]));
        filePropertyContent = make_shared<GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent>(model1);
      }
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("NodeConfiguration") != m.end() && !m["NodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeConfiguration"].type()) {
        GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeConfiguration"]));
        nodeConfiguration = make_shared<GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration>(model1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailCommittedFile() = default;
};
class GetIDEEventDetailResponseBodyEventDetailDeletedFile : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> content{};
  shared_ptr<long> currentVersion{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<string> folderId{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> owner{};
  shared_ptr<long> parentFileId{};
  shared_ptr<string> useType{};

  GetIDEEventDetailResponseBodyEventDetailDeletedFile() {}

  explicit GetIDEEventDetailResponseBodyEventDetailDeletedFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentFileId) {
      res["ParentFileId"] = boost::any(*parentFileId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentFileId") != m.end() && !m["ParentFileId"].empty()) {
      parentFileId = make_shared<long>(boost::any_cast<long>(m["ParentFileId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailDeletedFile() = default;
};
class GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<long> fileId{};
  shared_ptr<long> fileType{};

  GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand() {}

  explicit GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand() = default;
};
class GetIDEEventDetailResponseBodyEventDetailTableModelColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<string> comment{};
  shared_ptr<bool> isPartitionColumn{};

  GetIDEEventDetailResponseBodyEventDetailTableModelColumns() {}

  explicit GetIDEEventDetailResponseBodyEventDetailTableModelColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (isPartitionColumn) {
      res["IsPartitionColumn"] = boost::any(*isPartitionColumn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("IsPartitionColumn") != m.end() && !m["IsPartitionColumn"].empty()) {
      isPartitionColumn = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionColumn"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailTableModelColumns() = default;
};
class GetIDEEventDetailResponseBodyEventDetailTableModel : public Darabonba::Model {
public:
  shared_ptr<vector<GetIDEEventDetailResponseBodyEventDetailTableModelColumns>> columns{};
  shared_ptr<string> comment{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<string> env{};
  shared_ptr<long> lifeCycle{};
  shared_ptr<string> location{};
  shared_ptr<string> tableName{};

  GetIDEEventDetailResponseBodyEventDetailTableModel() {}

  explicit GetIDEEventDetailResponseBodyEventDetailTableModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (dataSourceName) {
      res["DataSourceName"] = boost::any(*dataSourceName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<GetIDEEventDetailResponseBodyEventDetailTableModelColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIDEEventDetailResponseBodyEventDetailTableModelColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<GetIDEEventDetailResponseBodyEventDetailTableModelColumns>>(expect1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DataSourceName") != m.end() && !m["DataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["DataSourceName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<long>(boost::any_cast<long>(m["LifeCycle"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetailTableModel() = default;
};
class GetIDEEventDetailResponseBodyEventDetail : public Darabonba::Model {
public:
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailCommittedFile> committedFile{};
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailDeletedFile> deletedFile{};
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand> fileExecutionCommand{};
  shared_ptr<GetIDEEventDetailResponseBodyEventDetailTableModel> tableModel{};

  GetIDEEventDetailResponseBodyEventDetail() {}

  explicit GetIDEEventDetailResponseBodyEventDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (committedFile) {
      res["CommittedFile"] = committedFile ? boost::any(committedFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deletedFile) {
      res["DeletedFile"] = deletedFile ? boost::any(deletedFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileExecutionCommand) {
      res["FileExecutionCommand"] = fileExecutionCommand ? boost::any(fileExecutionCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableModel) {
      res["TableModel"] = tableModel ? boost::any(tableModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommittedFile") != m.end() && !m["CommittedFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommittedFile"].type()) {
        GetIDEEventDetailResponseBodyEventDetailCommittedFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommittedFile"]));
        committedFile = make_shared<GetIDEEventDetailResponseBodyEventDetailCommittedFile>(model1);
      }
    }
    if (m.find("DeletedFile") != m.end() && !m["DeletedFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeletedFile"].type()) {
        GetIDEEventDetailResponseBodyEventDetailDeletedFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeletedFile"]));
        deletedFile = make_shared<GetIDEEventDetailResponseBodyEventDetailDeletedFile>(model1);
      }
    }
    if (m.find("FileExecutionCommand") != m.end() && !m["FileExecutionCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileExecutionCommand"].type()) {
        GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileExecutionCommand"]));
        fileExecutionCommand = make_shared<GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand>(model1);
      }
    }
    if (m.find("TableModel") != m.end() && !m["TableModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableModel"].type()) {
        GetIDEEventDetailResponseBodyEventDetailTableModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableModel"]));
        tableModel = make_shared<GetIDEEventDetailResponseBodyEventDetailTableModel>(model1);
      }
    }
  }


  virtual ~GetIDEEventDetailResponseBodyEventDetail() = default;
};
class GetIDEEventDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIDEEventDetailResponseBodyEventDetail> eventDetail{};
  shared_ptr<string> requestId{};

  GetIDEEventDetailResponseBody() {}

  explicit GetIDEEventDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventDetail) {
      res["EventDetail"] = eventDetail ? boost::any(eventDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventDetail") != m.end() && !m["EventDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventDetail"].type()) {
        GetIDEEventDetailResponseBodyEventDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventDetail"]));
        eventDetail = make_shared<GetIDEEventDetailResponseBodyEventDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIDEEventDetailResponseBody() = default;
};
class GetIDEEventDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIDEEventDetailResponseBody> body{};

  GetIDEEventDetailResponse() {}

  explicit GetIDEEventDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIDEEventDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIDEEventDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetIDEEventDetailResponse() = default;
};
class GetJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetJobStatusRequest() {}

  explicit GetJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobStatusRequest() = default;
};
class GetJobStatusResponseBodyJobStatus : public Darabonba::Model {
public:
  shared_ptr<string> completed{};
  shared_ptr<string> createTime{};
  shared_ptr<string> error{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> status{};

  GetJobStatusResponseBodyJobStatus() {}

  explicit GetJobStatusResponseBodyJobStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<string>(boost::any_cast<string>(m["Completed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetJobStatusResponseBodyJobStatus() = default;
};
class GetJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetJobStatusResponseBodyJobStatus> jobStatus{};
  shared_ptr<string> requestId{};

  GetJobStatusResponseBody() {}

  explicit GetJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = jobStatus ? boost::any(jobStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobStatus"].type()) {
        GetJobStatusResponseBodyJobStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobStatus"]));
        jobStatus = make_shared<GetJobStatusResponseBodyJobStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetJobStatusResponseBody() = default;
};
class GetJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetJobStatusResponseBody> body{};

  GetJobStatusResponse() {}

  explicit GetJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobStatusResponse() = default;
};
class GetLineageRelationshipRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetLineageRelationshipRequest() {}

  explicit GetLineageRelationshipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetLineageRelationshipRequest() = default;
};
class GetLineageRelationshipResponseBody : public Darabonba::Model {
public:
  shared_ptr<LineageRelationship> lineageRelationship{};
  shared_ptr<string> requestId{};

  GetLineageRelationshipResponseBody() {}

  explicit GetLineageRelationshipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineageRelationship) {
      res["LineageRelationship"] = lineageRelationship ? boost::any(lineageRelationship->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineageRelationship") != m.end() && !m["LineageRelationship"].empty()) {
      if (typeid(map<string, boost::any>) == m["LineageRelationship"].type()) {
        LineageRelationship model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LineageRelationship"]));
        lineageRelationship = make_shared<LineageRelationship>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLineageRelationshipResponseBody() = default;
};
class GetLineageRelationshipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLineageRelationshipResponseBody> body{};

  GetLineageRelationshipResponse() {}

  explicit GetLineageRelationshipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLineageRelationshipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLineageRelationshipResponseBody>(model1);
      }
    }
  }


  virtual ~GetLineageRelationshipResponse() = default;
};
class GetMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetMetaCollectionRequest() {}

  explicit GetMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetMetaCollectionRequest() = default;
};
class GetMetaCollectionResponseBodyMetaCollection : public Darabonba::Model {
public:
  shared_ptr<vector<long>> administrators{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> type{};

  GetMetaCollectionResponseBodyMetaCollection() {}

  explicit GetMetaCollectionResponseBodyMetaCollection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administrators) {
      res["Administrators"] = boost::any(*administrators);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Administrators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Administrators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      administrators = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMetaCollectionResponseBodyMetaCollection() = default;
};
class GetMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMetaCollectionResponseBodyMetaCollection> metaCollection{};
  shared_ptr<string> requestId{};

  GetMetaCollectionResponseBody() {}

  explicit GetMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaCollection) {
      res["MetaCollection"] = metaCollection ? boost::any(metaCollection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaCollection") != m.end() && !m["MetaCollection"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetaCollection"].type()) {
        GetMetaCollectionResponseBodyMetaCollection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetaCollection"]));
        metaCollection = make_shared<GetMetaCollectionResponseBodyMetaCollection>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMetaCollectionResponseBody() = default;
};
class GetMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMetaCollectionResponseBody> body{};

  GetMetaCollectionResponse() {}

  explicit GetMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaCollectionResponse() = default;
};
class GetNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetNetworkRequest() {}

  explicit GetNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetNetworkRequest() = default;
};
class GetNetworkResponseBodyNetwork : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  GetNetworkResponseBodyNetwork() {}

  explicit GetNetworkResponseBodyNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~GetNetworkResponseBodyNetwork() = default;
};
class GetNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNetworkResponseBodyNetwork> network{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNetworkResponseBody() {}

  explicit GetNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (network) {
      res["Network"] = network ? boost::any(network->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(map<string, boost::any>) == m["Network"].type()) {
        GetNetworkResponseBodyNetwork model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Network"]));
        network = make_shared<GetNetworkResponseBodyNetwork>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNetworkResponseBody() = default;
};
class GetNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNetworkResponseBody> body{};

  GetNetworkResponse() {}

  explicit GetNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~GetNetworkResponse() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};
  shared_ptr<long> taskId{};

  GetNodeResponseBodyNode() {}

  explicit GetNodeResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~GetNodeResponseBodyNode() = default;
};
class GetNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeResponseBody() {}

  explicit GetNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        GetNodeResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<GetNodeResponseBodyNode>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNodeResponseBody() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeResponseBody> body{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class GetPartitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> tableId{};

  GetPartitionRequest() {}

  explicit GetPartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
  }


  virtual ~GetPartitionRequest() = default;
};
class GetPartitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<Partition> partition{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPartitionResponseBody() {}

  explicit GetPartitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (partition) {
      res["Partition"] = partition ? boost::any(partition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Partition") != m.end() && !m["Partition"].empty()) {
      if (typeid(map<string, boost::any>) == m["Partition"].type()) {
        Partition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Partition"]));
        partition = make_shared<Partition>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPartitionResponseBody() = default;
};
class GetPartitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPartitionResponseBody> body{};

  GetPartitionResponse() {}

  explicit GetPartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPartitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPartitionResponseBody>(model1);
      }
    }
  }


  virtual ~GetPartitionResponse() = default;
};
class GetPipelineRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> projectId{};

  GetPipelineRunRequest() {}

  explicit GetPipelineRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetPipelineRunRequest() = default;
};
class GetPipelineRunResponseBodyPipelineStages : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<long> step{};
  shared_ptr<string> type{};

  GetPipelineRunResponseBodyPipelineStages() {}

  explicit GetPipelineRunResponseBodyPipelineStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineStages() = default;
};
class GetPipelineRunResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetPipelineRunResponseBodyPipelineStages>> stages{};
  shared_ptr<string> status{};

  GetPipelineRunResponseBodyPipeline() {}

  explicit GetPipelineRunResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stages"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      if (typeid(vector<boost::any>) == m["Stages"].type()) {
        vector<GetPipelineRunResponseBodyPipelineStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineRunResponseBodyPipelineStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<GetPipelineRunResponseBodyPipelineStages>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipeline() = default;
};
class GetPipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPipelineRunResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  GetPipelineRunResponseBody() {}

  explicit GetPipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        GetPipelineRunResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<GetPipelineRunResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPipelineRunResponseBody() = default;
};
class GetPipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineRunResponseBody> body{};

  GetPipelineRunResponse() {}

  explicit GetPipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineRunResponse() = default;
};
class GetProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetProjectRequest() {}

  explicit GetProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetProjectRequest() = default;
};
class GetProjectResponseBodyProjectAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetProjectResponseBodyProjectAliyunResourceTags() {}

  explicit GetProjectResponseBodyProjectAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetProjectResponseBodyProjectAliyunResourceTags() = default;
};
class GetProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<GetProjectResponseBodyProjectAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  GetProjectResponseBodyProject() {}

  explicit GetProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<GetProjectResponseBodyProjectAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProjectResponseBodyProjectAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<GetProjectResponseBodyProjectAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetProjectResponseBodyProject() = default;
};
class GetProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  GetProjectResponseBody() {}

  explicit GetProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        GetProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<GetProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectResponseBody() = default;
};
class GetProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectResponseBody> body{};

  GetProjectResponse() {}

  explicit GetProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectResponse() = default;
};
class GetProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  GetProjectMemberRequest() {}

  explicit GetProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetProjectMemberRequest() = default;
};
class GetProjectMemberResponseBodyProjectMemberRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetProjectMemberResponseBodyProjectMemberRoles() {}

  explicit GetProjectMemberResponseBodyProjectMemberRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetProjectMemberResponseBodyProjectMemberRoles() = default;
};
class GetProjectMemberResponseBodyProjectMember : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetProjectMemberResponseBodyProjectMemberRoles>> roles{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  GetProjectMemberResponseBodyProjectMember() {}

  explicit GetProjectMemberResponseBodyProjectMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<GetProjectMemberResponseBodyProjectMemberRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProjectMemberResponseBodyProjectMemberRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<GetProjectMemberResponseBodyProjectMemberRoles>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetProjectMemberResponseBodyProjectMember() = default;
};
class GetProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectMemberResponseBodyProjectMember> projectMember{};
  shared_ptr<string> requestId{};

  GetProjectMemberResponseBody() {}

  explicit GetProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectMember) {
      res["ProjectMember"] = projectMember ? boost::any(projectMember->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectMember") != m.end() && !m["ProjectMember"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMember"].type()) {
        GetProjectMemberResponseBodyProjectMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMember"]));
        projectMember = make_shared<GetProjectMemberResponseBodyProjectMember>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectMemberResponseBody() = default;
};
class GetProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectMemberResponseBody> body{};

  GetProjectMemberResponse() {}

  explicit GetProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectMemberResponse() = default;
};
class GetProjectRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> projectId{};

  GetProjectRoleRequest() {}

  explicit GetProjectRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectRoleRequest() = default;
};
class GetProjectRoleResponseBodyProjectRole : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  GetProjectRoleResponseBodyProjectRole() {}

  explicit GetProjectRoleResponseBodyProjectRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetProjectRoleResponseBodyProjectRole() = default;
};
class GetProjectRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectRoleResponseBodyProjectRole> projectRole{};
  shared_ptr<string> requestId{};

  GetProjectRoleResponseBody() {}

  explicit GetProjectRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRole) {
      res["ProjectRole"] = projectRole ? boost::any(projectRole->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRole") != m.end() && !m["ProjectRole"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectRole"].type()) {
        GetProjectRoleResponseBodyProjectRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectRole"]));
        projectRole = make_shared<GetProjectRoleResponseBodyProjectRole>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectRoleResponseBody() = default;
};
class GetProjectRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectRoleResponseBody> body{};

  GetProjectRoleResponse() {}

  explicit GetProjectRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectRoleResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectRoleResponse() = default;
};
class GetResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  GetResourceRequest() {}

  explicit GetResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetResourceRequest() = default;
};
class GetResourceResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  GetResourceResponseBodyResource() {}

  explicit GetResourceResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~GetResourceResponseBodyResource() = default;
};
class GetResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceResponseBodyResource> resource{};

  GetResourceResponseBody() {}

  explicit GetResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        GetResourceResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<GetResourceResponseBodyResource>(model1);
      }
    }
  }


  virtual ~GetResourceResponseBody() = default;
};
class GetResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceResponseBody> body{};

  GetResourceResponse() {}

  explicit GetResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceResponse() = default;
};
class GetResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetResourceGroupRequest() {}

  explicit GetResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetResourceGroupRequest() = default;
};
class GetResourceGroupResponseBodyResourceGroupAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetResourceGroupResponseBodyResourceGroupAliyunResourceTags() {}

  explicit GetResourceGroupResponseBodyResourceGroupAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroupAliyunResourceTags() = default;
};
class GetResourceGroupResponseBodyResourceGroupSpec : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> standard{};

  GetResourceGroupResponseBodyResourceGroupSpec() {}

  explicit GetResourceGroupResponseBodyResourceGroupSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (standard) {
      res["Standard"] = boost::any(*standard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Standard") != m.end() && !m["Standard"].empty()) {
      standard = make_shared<string>(boost::any_cast<string>(m["Standard"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroupSpec() = default;
};
class GetResourceGroupResponseBodyResourceGroup : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> defaultVpcId{};
  shared_ptr<string> defaultVswitchId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<GetResourceGroupResponseBodyResourceGroupSpec> spec{};
  shared_ptr<string> status{};

  GetResourceGroupResponseBodyResourceGroup() {}

  explicit GetResourceGroupResponseBodyResourceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (defaultVpcId) {
      res["DefaultVpcId"] = boost::any(*defaultVpcId);
    }
    if (defaultVswitchId) {
      res["DefaultVswitchId"] = boost::any(*defaultVswitchId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceGroupResponseBodyResourceGroupAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<GetResourceGroupResponseBodyResourceGroupAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DefaultVpcId") != m.end() && !m["DefaultVpcId"].empty()) {
      defaultVpcId = make_shared<string>(boost::any_cast<string>(m["DefaultVpcId"]));
    }
    if (m.find("DefaultVswitchId") != m.end() && !m["DefaultVswitchId"].empty()) {
      defaultVswitchId = make_shared<string>(boost::any_cast<string>(m["DefaultVswitchId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        GetResourceGroupResponseBodyResourceGroupSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<GetResourceGroupResponseBodyResourceGroupSpec>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetResourceGroupResponseBodyResourceGroup() = default;
};
class GetResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceGroupResponseBodyResourceGroup> resourceGroup{};
  shared_ptr<bool> success{};

  GetResourceGroupResponseBody() {}

  explicit GetResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = resourceGroup ? boost::any(resourceGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceGroup"].type()) {
        GetResourceGroupResponseBodyResourceGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceGroup"]));
        resourceGroup = make_shared<GetResourceGroupResponseBodyResourceGroup>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetResourceGroupResponseBody() = default;
};
class GetResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceGroupResponseBody> body{};

  GetResourceGroupResponse() {}

  explicit GetResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceGroupResponse() = default;
};
class GetRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetRouteRequest() {}

  explicit GetRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetRouteRequest() = default;
};
class GetRouteResponseBodyRoute : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  GetRouteResponseBodyRoute() {}

  explicit GetRouteResponseBodyRoute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~GetRouteResponseBodyRoute() = default;
};
class GetRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRouteResponseBodyRoute> route{};
  shared_ptr<bool> success{};

  GetRouteResponseBody() {}

  explicit GetRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (route) {
      res["Route"] = route ? boost::any(route->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      if (typeid(map<string, boost::any>) == m["Route"].type()) {
        GetRouteResponseBodyRoute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Route"]));
        route = make_shared<GetRouteResponseBodyRoute>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRouteResponseBody() = default;
};
class GetRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRouteResponseBody> body{};

  GetRouteResponse() {}

  explicit GetRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRouteResponseBody>(model1);
      }
    }
  }


  virtual ~GetRouteResponse() = default;
};
class GetSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetSchemaRequest() {}

  explicit GetSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetSchemaRequest() = default;
};
class GetSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<Schema> schema{};
  shared_ptr<bool> success{};

  GetSchemaResponseBody() {}

  explicit GetSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        Schema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<Schema>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSchemaResponseBody() = default;
};
class GetSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSchemaResponseBody> body{};

  GetSchemaResponse() {}

  explicit GetSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~GetSchemaResponse() = default;
};
class GetTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> includeBusinessMetadata{};

  GetTableRequest() {}

  explicit GetTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeBusinessMetadata) {
      res["IncludeBusinessMetadata"] = boost::any(*includeBusinessMetadata);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncludeBusinessMetadata") != m.end() && !m["IncludeBusinessMetadata"].empty()) {
      includeBusinessMetadata = make_shared<bool>(boost::any_cast<bool>(m["IncludeBusinessMetadata"]));
    }
  }


  virtual ~GetTableRequest() = default;
};
class GetTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<Table> table{};

  GetTableResponseBody() {}

  explicit GetTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (table) {
      res["Table"] = table ? boost::any(table->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      if (typeid(map<string, boost::any>) == m["Table"].type()) {
        Table model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Table"]));
        table = make_shared<Table>(model1);
      }
    }
  }


  virtual ~GetTableResponseBody() = default;
};
class GetTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTableResponseBody> body{};

  GetTableResponse() {}

  explicit GetTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTableResponseBody>(model1);
      }
    }
  }


  virtual ~GetTableResponse() = default;
};
class GetTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectEnv{};

  GetTaskRequest() {}

  explicit GetTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetTaskRequest() = default;
};
class GetTaskResponseBodyTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskResponseBodyTaskDataSource() {}

  explicit GetTaskResponseBodyTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskDataSource() = default;
};
class GetTaskResponseBodyTaskDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<string> upstreamTaskId{};

  GetTaskResponseBodyTaskDependencies() {}

  explicit GetTaskResponseBodyTaskDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<string>(boost::any_cast<string>(m["UpstreamTaskId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskDependencies() = default;
};
class GetTaskResponseBodyTaskInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskInputsVariables() {}

  explicit GetTaskResponseBodyTaskInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskInputsVariables() = default;
};
class GetTaskResponseBodyTaskInputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskInputsVariables>> variables{};

  GetTaskResponseBodyTaskInputs() {}

  explicit GetTaskResponseBodyTaskInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskResponseBodyTaskInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskResponseBodyTaskInputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskResponseBodyTaskInputs() = default;
};
class GetTaskResponseBodyTaskOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetTaskResponseBodyTaskOutputsTaskOutputs() {}

  explicit GetTaskResponseBodyTaskOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputsTaskOutputs() = default;
};
class GetTaskResponseBodyTaskOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskOutputsVariables() {}

  explicit GetTaskResponseBodyTaskOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputsVariables() = default;
};
class GetTaskResponseBodyTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<GetTaskResponseBodyTaskOutputsVariables>> variables{};

  GetTaskResponseBodyTaskOutputs() {}

  explicit GetTaskResponseBodyTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetTaskResponseBodyTaskOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetTaskResponseBodyTaskOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskResponseBodyTaskOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskResponseBodyTaskOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskResponseBodyTaskOutputs() = default;
};
class GetTaskResponseBodyTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskResponseBodyTaskRuntimeResource() {}

  explicit GetTaskResponseBodyTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskRuntimeResource() = default;
};
class GetTaskResponseBodyTaskScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  GetTaskResponseBodyTaskScript() {}

  explicit GetTaskResponseBodyTaskScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskScript() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskResponseBodyTaskSubTasksSubTasksDataSource() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksDataSource() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskSubTasksSubTasksTrigger() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasksTrigger() = default;
};
class GetTaskResponseBodyTaskSubTasksSubTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<GetTaskResponseBodyTaskSubTasksSubTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetTaskResponseBodyTaskSubTasksSubTasks() {}

  explicit GetTaskResponseBodyTaskSubTasksSubTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetTaskResponseBodyTaskSubTasksSubTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetTaskResponseBodyTaskSubTasksSubTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasksSubTasks() = default;
};
class GetTaskResponseBodyTaskSubTasks : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskResponseBodyTaskSubTasksSubTasks>> subTasks{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskSubTasks() {}

  explicit GetTaskResponseBodyTaskSubTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subTasks) {
      vector<boost::any> temp1;
      for(auto item1:*subTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubTasks"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubTasks") != m.end() && !m["SubTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["SubTasks"].type()) {
        vector<GetTaskResponseBodyTaskSubTasksSubTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskSubTasksSubTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subTasks = make_shared<vector<GetTaskResponseBodyTaskSubTasksSubTasks>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskSubTasks() = default;
};
class GetTaskResponseBodyTaskTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTaskResponseBodyTaskTags() {}

  explicit GetTaskResponseBodyTaskTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskTags() = default;
};
class GetTaskResponseBodyTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetTaskResponseBodyTaskTrigger() {}

  explicit GetTaskResponseBodyTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTaskResponseBodyTaskTrigger() = default;
};
class GetTaskResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskResponseBodyTaskDataSource> dataSource{};
  shared_ptr<vector<GetTaskResponseBodyTaskDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<GetTaskResponseBodyTaskInputs> inputs{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<GetTaskResponseBodyTaskOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetTaskResponseBodyTaskRuntimeResource> runtimeResource{};
  shared_ptr<GetTaskResponseBodyTaskScript> script{};
  shared_ptr<GetTaskResponseBodyTaskSubTasks> subTasks{};
  shared_ptr<vector<GetTaskResponseBodyTaskTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<GetTaskResponseBodyTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetTaskResponseBodyTask() {}

  explicit GetTaskResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subTasks) {
      res["SubTasks"] = subTasks ? boost::any(subTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskResponseBodyTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskResponseBodyTaskDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<GetTaskResponseBodyTaskDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<GetTaskResponseBodyTaskDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        GetTaskResponseBodyTaskInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<GetTaskResponseBodyTaskInputs>(model1);
      }
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetTaskResponseBodyTaskOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetTaskResponseBodyTaskOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskResponseBodyTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskResponseBodyTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        GetTaskResponseBodyTaskScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<GetTaskResponseBodyTaskScript>(model1);
      }
    }
    if (m.find("SubTasks") != m.end() && !m["SubTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubTasks"].type()) {
        GetTaskResponseBodyTaskSubTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubTasks"]));
        subTasks = make_shared<GetTaskResponseBodyTaskSubTasks>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTaskResponseBodyTaskTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskResponseBodyTaskTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTaskResponseBodyTaskTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetTaskResponseBodyTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetTaskResponseBodyTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetTaskResponseBodyTask() = default;
};
class GetTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTaskResponseBodyTask> task{};

  GetTaskResponseBody() {}

  explicit GetTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetTaskResponseBodyTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetTaskResponseBodyTask>(model1);
      }
    }
  }


  virtual ~GetTaskResponseBody() = default;
};
class GetTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskResponseBody> body{};

  GetTaskResponse() {}

  explicit GetTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskResponse() = default;
};
class GetTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetTaskInstanceRequest() {}

  explicit GetTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetTaskInstanceRequest() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetTaskInstanceResponseBodyTaskInstanceDataSource() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceDataSource() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceInputsVariables() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceInputsVariables() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceInputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables>> variables{};

  GetTaskInstanceResponseBodyTaskInstanceInputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceInputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceInputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceOutputsVariables() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputsVariables() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables>> variables{};

  GetTaskInstanceResponseBodyTaskInstanceOutputs() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceOutputs() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  GetTaskInstanceResponseBodyTaskInstanceRuntime() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceRuntime() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetTaskInstanceResponseBodyTaskInstanceRuntimeResource() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceRuntimeResource() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  GetTaskInstanceResponseBodyTaskInstanceScript() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceScript() = default;
};
class GetTaskInstanceResponseBodyTaskInstanceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTaskInstanceResponseBodyTaskInstanceTags() {}

  explicit GetTaskInstanceResponseBodyTaskInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstanceTags() = default;
};
class GetTaskInstanceResponseBodyTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceRuntime> runtime{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstanceScript> script{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetTaskInstanceResponseBodyTaskInstanceTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  GetTaskInstanceResponseBodyTaskInstance() {}

  explicit GetTaskInstanceResponseBodyTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetTaskInstanceResponseBodyTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<GetTaskInstanceResponseBodyTaskInstanceInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetTaskInstanceResponseBodyTaskInstanceOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<GetTaskInstanceResponseBodyTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetTaskInstanceResponseBodyTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        GetTaskInstanceResponseBodyTaskInstanceScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<GetTaskInstanceResponseBodyTaskInstanceScript>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTaskInstanceResponseBodyTaskInstanceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceResponseBodyTaskInstanceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTaskInstanceResponseBodyTaskInstanceTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~GetTaskInstanceResponseBodyTaskInstance() = default;
};
class GetTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTaskInstanceResponseBodyTaskInstance> taskInstance{};

  GetTaskInstanceResponseBody() {}

  explicit GetTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        GetTaskInstanceResponseBodyTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<GetTaskInstanceResponseBodyTaskInstance>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceResponseBody() = default;
};
class GetTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskInstanceResponseBody> body{};

  GetTaskInstanceResponse() {}

  explicit GetTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceResponse() = default;
};
class GetTaskInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> runNumber{};

  GetTaskInstanceLogRequest() {}

  explicit GetTaskInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
  }


  virtual ~GetTaskInstanceLogRequest() = default;
};
class GetTaskInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskInstanceLog{};

  GetTaskInstanceLogResponseBody() {}

  explicit GetTaskInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInstanceLog) {
      res["TaskInstanceLog"] = boost::any(*taskInstanceLog);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInstanceLog") != m.end() && !m["TaskInstanceLog"].empty()) {
      taskInstanceLog = make_shared<string>(boost::any_cast<string>(m["TaskInstanceLog"]));
    }
  }


  virtual ~GetTaskInstanceLogResponseBody() = default;
};
class GetTaskInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskInstanceLogResponseBody> body{};

  GetTaskInstanceLogResponse() {}

  explicit GetTaskInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceLogResponse() = default;
};
class GetWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<long> id{};

  GetWorkflowRequest() {}

  explicit GetWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetWorkflowRequest() = default;
};
class GetWorkflowResponseBodyWorkflowDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  GetWorkflowResponseBodyWorkflowDependencies() {}

  explicit GetWorkflowResponseBodyWorkflowDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowDependencies() = default;
};
class GetWorkflowResponseBodyWorkflowOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  GetWorkflowResponseBodyWorkflowOutputsTaskOutputs() {}

  explicit GetWorkflowResponseBodyWorkflowOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowOutputsTaskOutputs() = default;
};
class GetWorkflowResponseBodyWorkflowOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs>> taskOutputs{};

  GetWorkflowResponseBodyWorkflowOutputs() {}

  explicit GetWorkflowResponseBodyWorkflowOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<GetWorkflowResponseBodyWorkflowOutputsTaskOutputs>>(expect1);
      }
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowOutputs() = default;
};
class GetWorkflowResponseBodyWorkflowTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetWorkflowResponseBodyWorkflowTags() {}

  explicit GetWorkflowResponseBodyWorkflowTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTags() = default;
};
class GetWorkflowResponseBodyWorkflowTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetWorkflowResponseBodyWorkflowTasksDataSource() {}

  explicit GetWorkflowResponseBodyWorkflowTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasksDataSource() = default;
};
class GetWorkflowResponseBodyWorkflowTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  GetWorkflowResponseBodyWorkflowTasksRuntimeResource() {}

  explicit GetWorkflowResponseBodyWorkflowTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasksRuntimeResource() = default;
};
class GetWorkflowResponseBodyWorkflowTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTasksRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetWorkflowResponseBodyWorkflowTasks() {}

  explicit GetWorkflowResponseBodyWorkflowTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetWorkflowResponseBodyWorkflowTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetWorkflowResponseBodyWorkflowTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        GetWorkflowResponseBodyWorkflowTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<GetWorkflowResponseBodyWorkflowTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTasks() = default;
};
class GetWorkflowResponseBodyWorkflowTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  GetWorkflowResponseBodyWorkflowTrigger() {}

  explicit GetWorkflowResponseBodyWorkflowTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflowTrigger() = default;
};
class GetWorkflowResponseBodyWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<GetWorkflowResponseBodyWorkflowOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowTags>> tags{};
  shared_ptr<vector<GetWorkflowResponseBodyWorkflowTasks>> tasks{};
  shared_ptr<GetWorkflowResponseBodyWorkflowTrigger> trigger{};

  GetWorkflowResponseBodyWorkflow() {}

  explicit GetWorkflowResponseBodyWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<GetWorkflowResponseBodyWorkflowDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<GetWorkflowResponseBodyWorkflowDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        GetWorkflowResponseBodyWorkflowOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<GetWorkflowResponseBodyWorkflowOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetWorkflowResponseBodyWorkflowTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetWorkflowResponseBodyWorkflowTags>>(expect1);
      }
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<GetWorkflowResponseBodyWorkflowTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkflowResponseBodyWorkflowTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetWorkflowResponseBodyWorkflowTasks>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        GetWorkflowResponseBodyWorkflowTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<GetWorkflowResponseBodyWorkflowTrigger>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponseBodyWorkflow() = default;
};
class GetWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowResponseBodyWorkflow> workflow{};

  GetWorkflowResponseBody() {}

  explicit GetWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflow) {
      res["Workflow"] = workflow ? boost::any(workflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Workflow") != m.end() && !m["Workflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Workflow"].type()) {
        GetWorkflowResponseBodyWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Workflow"]));
        workflow = make_shared<GetWorkflowResponseBodyWorkflow>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponseBody() = default;
};
class GetWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowResponseBody> body{};

  GetWorkflowResponse() {}

  explicit GetWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowResponse() = default;
};
class GetWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> includeScriptContent{};
  shared_ptr<long> projectId{};

  GetWorkflowDefinitionRequest() {}

  explicit GetWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeScriptContent) {
      res["IncludeScriptContent"] = boost::any(*includeScriptContent);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IncludeScriptContent") != m.end() && !m["IncludeScriptContent"].empty()) {
      includeScriptContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeScriptContent"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetWorkflowDefinitionRequest() = default;
};
class GetWorkflowDefinitionResponseBodyWorkflowDefinition : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};
  shared_ptr<long> workflowId{};

  GetWorkflowDefinitionResponseBodyWorkflowDefinition() {}

  explicit GetWorkflowDefinitionResponseBodyWorkflowDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowDefinitionResponseBodyWorkflowDefinition() = default;
};
class GetWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowDefinitionResponseBodyWorkflowDefinition> workflowDefinition{};

  GetWorkflowDefinitionResponseBody() {}

  explicit GetWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowDefinition) {
      res["WorkflowDefinition"] = workflowDefinition ? boost::any(workflowDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowDefinition") != m.end() && !m["WorkflowDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowDefinition"].type()) {
        GetWorkflowDefinitionResponseBodyWorkflowDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowDefinition"]));
        workflowDefinition = make_shared<GetWorkflowDefinitionResponseBodyWorkflowDefinition>(model1);
      }
    }
  }


  virtual ~GetWorkflowDefinitionResponseBody() = default;
};
class GetWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowDefinitionResponseBody> body{};

  GetWorkflowDefinitionResponse() {}

  explicit GetWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowDefinitionResponse() = default;
};
class GetWorkflowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetWorkflowInstanceRequest() {}

  explicit GetWorkflowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetWorkflowInstanceRequest() = default;
};
class GetWorkflowInstanceResponseBodyWorkflowInstance : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  GetWorkflowInstanceResponseBodyWorkflowInstance() {}

  explicit GetWorkflowInstanceResponseBodyWorkflowInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowInstanceResponseBodyWorkflowInstance() = default;
};
class GetWorkflowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowInstanceResponseBodyWorkflowInstance> workflowInstance{};

  GetWorkflowInstanceResponseBody() {}

  explicit GetWorkflowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowInstance) {
      res["WorkflowInstance"] = workflowInstance ? boost::any(workflowInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowInstance") != m.end() && !m["WorkflowInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowInstance"].type()) {
        GetWorkflowInstanceResponseBodyWorkflowInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowInstance"]));
        workflowInstance = make_shared<GetWorkflowInstanceResponseBodyWorkflowInstance>(model1);
      }
    }
  }


  virtual ~GetWorkflowInstanceResponseBody() = default;
};
class GetWorkflowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowInstanceResponseBody> body{};

  GetWorkflowInstanceResponse() {}

  explicit GetWorkflowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowInstanceResponse() = default;
};
class GrantMemberProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  GrantMemberProjectRolesRequest() {}

  explicit GrantMemberProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GrantMemberProjectRolesRequest() = default;
};
class GrantMemberProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  GrantMemberProjectRolesShrinkRequest() {}

  explicit GrantMemberProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GrantMemberProjectRolesShrinkRequest() = default;
};
class GrantMemberProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantMemberProjectRolesResponseBody() {}

  explicit GrantMemberProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantMemberProjectRolesResponseBody() = default;
};
class GrantMemberProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantMemberProjectRolesResponseBody> body{};

  GrantMemberProjectRolesResponse() {}

  explicit GrantMemberProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantMemberProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantMemberProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~GrantMemberProjectRolesResponse() = default;
};
class ImportCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateFile{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  ImportCertificateRequest() {}

  explicit ImportCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateFile) {
      res["CertificateFile"] = boost::any(*certificateFile);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateFile") != m.end() && !m["CertificateFile"].empty()) {
      certificateFile = make_shared<string>(boost::any_cast<string>(m["CertificateFile"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ImportCertificateRequest() = default;
};
class ImportCertificateAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<Darabonba::Stream> certificateFileObject{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  ImportCertificateAdvanceRequest() {}

  explicit ImportCertificateAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateFileObject) {
      res["CertificateFile"] = boost::any(*certificateFileObject);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateFile") != m.end() && !m["CertificateFile"].empty()) {
      certificateFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["CertificateFile"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ImportCertificateAdvanceRequest() = default;
};
class ImportCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  ImportCertificateResponseBody() {}

  explicit ImportCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportCertificateResponseBody() = default;
};
class ImportCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportCertificateResponseBody> body{};

  ImportCertificateResponse() {}

  explicit ImportCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ImportCertificateResponse() = default;
};
class ImportWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  ImportWorkflowDefinitionRequest() {}

  explicit ImportWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ImportWorkflowDefinitionRequest() = default;
};
class ImportWorkflowDefinitionResponseBodyAsyncJob : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<long> createTime{};
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<long> progress{};
  shared_ptr<string> response{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ImportWorkflowDefinitionResponseBodyAsyncJob() {}

  explicit ImportWorkflowDefinitionResponseBodyAsyncJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (response) {
      res["Response"] = boost::any(*response);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Response") != m.end() && !m["Response"].empty()) {
      response = make_shared<string>(boost::any_cast<string>(m["Response"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ImportWorkflowDefinitionResponseBodyAsyncJob() = default;
};
class ImportWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ImportWorkflowDefinitionResponseBodyAsyncJob> asyncJob{};
  shared_ptr<string> requestId{};

  ImportWorkflowDefinitionResponseBody() {}

  explicit ImportWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncJob) {
      res["AsyncJob"] = asyncJob ? boost::any(asyncJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncJob") != m.end() && !m["AsyncJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsyncJob"].type()) {
        ImportWorkflowDefinitionResponseBodyAsyncJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsyncJob"]));
        asyncJob = make_shared<ImportWorkflowDefinitionResponseBodyAsyncJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportWorkflowDefinitionResponseBody() = default;
};
class ImportWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportWorkflowDefinitionResponseBody> body{};

  ImportWorkflowDefinitionResponse() {}

  explicit ImportWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~ImportWorkflowDefinitionResponse() = default;
};
class ListAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> receiver{};
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<vector<string>> types{};

  ListAlertRulesRequest() {}

  explicit ListAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAlertRulesRequest() = default;
};
class ListAlertRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> receiver{};
  shared_ptr<string> taskIdsShrink{};
  shared_ptr<string> typesShrink{};

  ListAlertRulesShrinkRequest() {}

  explicit ListAlertRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListAlertRulesShrinkRequest() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError> error{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished> unFinished{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension> extension{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition() = default;
};
class ListAlertRulesResponseBodyPagingInfoAlertRules : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition> triggerCondition{};

  ListAlertRulesResponseBodyPagingInfoAlertRules() {}

  explicit ListAlertRulesResponseBodyPagingInfoAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfoAlertRules() = default;
};
class ListAlertRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertRulesResponseBodyPagingInfoAlertRules>> alertRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAlertRulesResponseBodyPagingInfo() {}

  explicit ListAlertRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<ListAlertRulesResponseBodyPagingInfoAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertRulesResponseBodyPagingInfoAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<ListAlertRulesResponseBodyPagingInfoAlertRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlertRulesResponseBodyPagingInfo() = default;
};
class ListAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAlertRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListAlertRulesResponseBody() {}

  explicit ListAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListAlertRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListAlertRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertRulesResponseBody() = default;
};
class ListAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertRulesResponseBody> body{};

  ListAlertRulesResponse() {}

  explicit ListAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertRulesResponse() = default;
};
class ListBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  ListBusinessRequest() {}

  explicit ListBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~ListBusinessRequest() = default;
};
class ListBusinessResponseBodyDataBusiness : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> useType{};

  ListBusinessResponseBodyDataBusiness() {}

  explicit ListBusinessResponseBodyDataBusiness(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListBusinessResponseBodyDataBusiness() = default;
};
class ListBusinessResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListBusinessResponseBodyDataBusiness>> business{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListBusinessResponseBodyData() {}

  explicit ListBusinessResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (business) {
      vector<boost::any> temp1;
      for(auto item1:*business){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Business"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      if (typeid(vector<boost::any>) == m["Business"].type()) {
        vector<ListBusinessResponseBodyDataBusiness> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Business"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBusinessResponseBodyDataBusiness model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        business = make_shared<vector<ListBusinessResponseBodyDataBusiness>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBusinessResponseBodyData() = default;
};
class ListBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListBusinessResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListBusinessResponseBody() {}

  explicit ListBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBusinessResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBusinessResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListBusinessResponseBody() = default;
};
class ListBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBusinessResponseBody> body{};

  ListBusinessResponse() {}

  explicit ListBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~ListBusinessResponse() = default;
};
class ListCatalogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> types{};

  ListCatalogsRequest() {}

  explicit ListCatalogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCatalogsRequest() = default;
};
class ListCatalogsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> typesShrink{};

  ListCatalogsShrinkRequest() {}

  explicit ListCatalogsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListCatalogsShrinkRequest() = default;
};
class ListCatalogsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<Catalog>> catalogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCatalogsResponseBodyPagingInfo() {}

  explicit ListCatalogsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalogs) {
      vector<boost::any> temp1;
      for(auto item1:*catalogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Catalogs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Catalogs") != m.end() && !m["Catalogs"].empty()) {
      if (typeid(vector<boost::any>) == m["Catalogs"].type()) {
        vector<Catalog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Catalogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Catalog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        catalogs = make_shared<vector<Catalog>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCatalogsResponseBodyPagingInfo() = default;
};
class ListCatalogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCatalogsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCatalogsResponseBody() {}

  explicit ListCatalogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListCatalogsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListCatalogsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCatalogsResponseBody() = default;
};
class ListCatalogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCatalogsResponseBody> body{};

  ListCatalogsResponse() {}

  explicit ListCatalogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCatalogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCatalogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCatalogsResponse() = default;
};
class ListCertificatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> createUser{};
  shared_ptr<long> endCreateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> startCreateTime{};

  ListCertificatesRequest() {}

  explicit ListCertificatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (endCreateTime) {
      res["EndCreateTime"] = boost::any(*endCreateTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startCreateTime) {
      res["StartCreateTime"] = boost::any(*startCreateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("EndCreateTime") != m.end() && !m["EndCreateTime"].empty()) {
      endCreateTime = make_shared<long>(boost::any_cast<long>(m["EndCreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartCreateTime") != m.end() && !m["StartCreateTime"].empty()) {
      startCreateTime = make_shared<long>(boost::any_cast<long>(m["StartCreateTime"]));
    }
  }


  virtual ~ListCertificatesRequest() = default;
};
class ListCertificatesResponseBodyPagingInfoCertificates : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> fileSizeInBytes{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListCertificatesResponseBodyPagingInfoCertificates() {}

  explicit ListCertificatesResponseBodyPagingInfoCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileSizeInBytes) {
      res["FileSizeInBytes"] = boost::any(*fileSizeInBytes);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileSizeInBytes") != m.end() && !m["FileSizeInBytes"].empty()) {
      fileSizeInBytes = make_shared<long>(boost::any_cast<long>(m["FileSizeInBytes"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListCertificatesResponseBodyPagingInfoCertificates() = default;
};
class ListCertificatesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListCertificatesResponseBodyPagingInfoCertificates>> certificates{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCertificatesResponseBodyPagingInfo() {}

  explicit ListCertificatesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<ListCertificatesResponseBodyPagingInfoCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCertificatesResponseBodyPagingInfoCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<ListCertificatesResponseBodyPagingInfoCertificates>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCertificatesResponseBodyPagingInfo() = default;
};
class ListCertificatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCertificatesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListCertificatesResponseBody() {}

  explicit ListCertificatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListCertificatesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListCertificatesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCertificatesResponseBody() = default;
};
class ListCertificatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCertificatesResponseBody> body{};

  ListCertificatesResponse() {}

  explicit ListCertificatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCertificatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCertificatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCertificatesResponse() = default;
};
class ListColumnsRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tableId{};

  ListColumnsRequest() {}

  explicit ListColumnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
  }


  virtual ~ListColumnsRequest() = default;
};
class ListColumnsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<Column>> columns{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListColumnsResponseBodyPagingInfo() {}

  explicit ListColumnsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<Column> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Column model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<Column>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListColumnsResponseBodyPagingInfo() = default;
};
class ListColumnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListColumnsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListColumnsResponseBody() {}

  explicit ListColumnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListColumnsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListColumnsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListColumnsResponseBody() = default;
};
class ListColumnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListColumnsResponseBody> body{};

  ListColumnsResponse() {}

  explicit ListColumnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListColumnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListColumnsResponseBody>(model1);
      }
    }
  }


  virtual ~ListColumnsResponse() = default;
};
class ListCrawlerTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CrawlerType>> crawlerTypes{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCrawlerTypesResponseBody() {}

  explicit ListCrawlerTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crawlerTypes) {
      vector<boost::any> temp1;
      for(auto item1:*crawlerTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrawlerTypes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CrawlerTypes") != m.end() && !m["CrawlerTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["CrawlerTypes"].type()) {
        vector<CrawlerType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrawlerTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CrawlerType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crawlerTypes = make_shared<vector<CrawlerType>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCrawlerTypesResponseBody() = default;
};
class ListCrawlerTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCrawlerTypesResponseBody> body{};

  ListCrawlerTypesResponse() {}

  explicit ListCrawlerTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCrawlerTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCrawlerTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCrawlerTypesResponse() = default;
};
class ListDIAlarmRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> jobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDIAlarmRulesRequest() {}

  explicit ListDIAlarmRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDIAlarmRulesRequest() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers>> notificationReceivers{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings> notificationSettings{};
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions>> triggerConditions{};

  ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules() = default;
};
class ListDIAlarmRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules>> DIJobAlarmRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIAlarmRulesResponseBodyPagingInfo() {}

  explicit ListDIAlarmRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobAlarmRules) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobAlarmRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobAlarmRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobAlarmRules") != m.end() && !m["DIJobAlarmRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobAlarmRules"].type()) {
        vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobAlarmRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobAlarmRules = make_shared<vector<ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBodyPagingInfo() = default;
};
class ListDIAlarmRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIAlarmRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIAlarmRulesResponseBody() {}

  explicit ListDIAlarmRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIAlarmRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIAlarmRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIAlarmRulesResponseBody() = default;
};
class ListDIAlarmRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIAlarmRulesResponseBody> body{};

  ListDIAlarmRulesResponse() {}

  explicit ListDIAlarmRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIAlarmRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIAlarmRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIAlarmRulesResponse() = default;
};
class ListDIJobEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListDIJobEventsRequest() {}

  explicit ListDIJobEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobEventsRequest() = default;
};
class ListDIJobEventsResponseBodyPagingInfoDIJobEvent : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> channels{};
  shared_ptr<string> createTime{};
  shared_ptr<string> detail{};
  shared_ptr<string> dstSql{};
  shared_ptr<string> dstTable{};
  shared_ptr<string> failoverMessage{};
  shared_ptr<string> id{};
  shared_ptr<string> severity{};
  shared_ptr<string> srcSql{};
  shared_ptr<string> srcTable{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListDIJobEventsResponseBodyPagingInfoDIJobEvent() {}

  explicit ListDIJobEventsResponseBodyPagingInfoDIJobEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (dstSql) {
      res["DstSql"] = boost::any(*dstSql);
    }
    if (dstTable) {
      res["DstTable"] = boost::any(*dstTable);
    }
    if (failoverMessage) {
      res["FailoverMessage"] = boost::any(*failoverMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (srcSql) {
      res["SrcSql"] = boost::any(*srcSql);
    }
    if (srcTable) {
      res["SrcTable"] = boost::any(*srcTable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("DstSql") != m.end() && !m["DstSql"].empty()) {
      dstSql = make_shared<string>(boost::any_cast<string>(m["DstSql"]));
    }
    if (m.find("DstTable") != m.end() && !m["DstTable"].empty()) {
      dstTable = make_shared<string>(boost::any_cast<string>(m["DstTable"]));
    }
    if (m.find("FailoverMessage") != m.end() && !m["FailoverMessage"].empty()) {
      failoverMessage = make_shared<string>(boost::any_cast<string>(m["FailoverMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("SrcSql") != m.end() && !m["SrcSql"].empty()) {
      srcSql = make_shared<string>(boost::any_cast<string>(m["SrcSql"]));
    }
    if (m.find("SrcTable") != m.end() && !m["SrcTable"].empty()) {
      srcTable = make_shared<string>(boost::any_cast<string>(m["SrcTable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDIJobEventsResponseBodyPagingInfoDIJobEvent() = default;
};
class ListDIJobEventsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent>> DIJobEvent{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIJobEventsResponseBodyPagingInfo() {}

  explicit ListDIJobEventsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobEvent) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobEvent"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobEvent") != m.end() && !m["DIJobEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobEvent"].type()) {
        vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobEventsResponseBodyPagingInfoDIJobEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobEvent = make_shared<vector<ListDIJobEventsResponseBodyPagingInfoDIJobEvent>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobEventsResponseBodyPagingInfo() = default;
};
class ListDIJobEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobEventsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobEventsResponseBody() {}

  explicit ListDIJobEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobEventsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobEventsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobEventsResponseBody() = default;
};
class ListDIJobEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobEventsResponseBody> body{};

  ListDIJobEventsResponse() {}

  explicit ListDIJobEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobEventsResponse() = default;
};
class ListDIJobMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> metricName{};
  shared_ptr<long> startTime{};

  ListDIJobMetricsRequest() {}

  explicit ListDIJobMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MetricName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MetricName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      metricName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobMetricsRequest() = default;
};
class ListDIJobMetricsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> metricNameShrink{};
  shared_ptr<long> startTime{};

  ListDIJobMetricsShrinkRequest() {}

  explicit ListDIJobMetricsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (metricNameShrink) {
      res["MetricName"] = boost::any(*metricNameShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricNameShrink = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDIJobMetricsShrinkRequest() = default;
};
class ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<double> value{};

  ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList() {}

  explicit ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList() = default;
};
class ListDIJobMetricsResponseBodyPagingInfoJobMetrics : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList>> seriesList{};

  ListDIJobMetricsResponseBodyPagingInfoJobMetrics() {}

  explicit ListDIJobMetricsResponseBodyPagingInfoJobMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (seriesList) {
      vector<boost::any> temp1;
      for(auto item1:*seriesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeriesList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SeriesList") != m.end() && !m["SeriesList"].empty()) {
      if (typeid(vector<boost::any>) == m["SeriesList"].type()) {
        vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeriesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seriesList = make_shared<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList>>(expect1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfoJobMetrics() = default;
};
class ListDIJobMetricsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics>> jobMetrics{};

  ListDIJobMetricsResponseBodyPagingInfo() {}

  explicit ListDIJobMetricsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*jobMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobMetrics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobMetrics") != m.end() && !m["JobMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["JobMetrics"].type()) {
        vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobMetricsResponseBodyPagingInfoJobMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobMetrics = make_shared<vector<ListDIJobMetricsResponseBodyPagingInfoJobMetrics>>(expect1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponseBodyPagingInfo() = default;
};
class ListDIJobMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobMetricsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobMetricsResponseBody() {}

  explicit ListDIJobMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobMetricsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobMetricsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobMetricsResponseBody() = default;
};
class ListDIJobMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobMetricsResponseBody> body{};

  ListDIJobMetricsResponse() {}

  explicit ListDIJobMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobMetricsResponse() = default;
};
class ListDIJobRunDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceDataSourceName{};
  shared_ptr<string> sourceDatabaseName{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<string> sourceTableName{};

  ListDIJobRunDetailsRequest() {}

  explicit ListDIJobRunDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceDataSourceName) {
      res["SourceDataSourceName"] = boost::any(*sourceDataSourceName);
    }
    if (sourceDatabaseName) {
      res["SourceDatabaseName"] = boost::any(*sourceDatabaseName);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceDataSourceName") != m.end() && !m["SourceDataSourceName"].empty()) {
      sourceDataSourceName = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceName"]));
    }
    if (m.find("SourceDatabaseName") != m.end() && !m["SourceDatabaseName"].empty()) {
      sourceDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceDatabaseName"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~ListDIJobRunDetailsRequest() = default;
};
class ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos : public Darabonba::Model {
public:
  shared_ptr<string> destinationDatabaseName{};
  shared_ptr<string> destinationDatasourceName{};
  shared_ptr<string> destinationSchemaName{};
  shared_ptr<string> destinationTableName{};
  shared_ptr<string> fullMigrationErrorMessage{};
  shared_ptr<string> fullMigrationStatus{};
  shared_ptr<long> offlineErrorRecords{};
  shared_ptr<long> offlineTotalBytes{};
  shared_ptr<long> offlineTotalRecords{};
  shared_ptr<string> realtimeMigrationErrorMessage{};
  shared_ptr<string> realtimeMigrationStatus{};
  shared_ptr<string> sourceDatabaseName{};
  shared_ptr<string> sourceDatasourceName{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> structureMigrationErrorMessage{};
  shared_ptr<string> structureMigrationStatus{};

  ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos() {}

  explicit ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDatabaseName) {
      res["DestinationDatabaseName"] = boost::any(*destinationDatabaseName);
    }
    if (destinationDatasourceName) {
      res["DestinationDatasourceName"] = boost::any(*destinationDatasourceName);
    }
    if (destinationSchemaName) {
      res["DestinationSchemaName"] = boost::any(*destinationSchemaName);
    }
    if (destinationTableName) {
      res["DestinationTableName"] = boost::any(*destinationTableName);
    }
    if (fullMigrationErrorMessage) {
      res["FullMigrationErrorMessage"] = boost::any(*fullMigrationErrorMessage);
    }
    if (fullMigrationStatus) {
      res["FullMigrationStatus"] = boost::any(*fullMigrationStatus);
    }
    if (offlineErrorRecords) {
      res["OfflineErrorRecords"] = boost::any(*offlineErrorRecords);
    }
    if (offlineTotalBytes) {
      res["OfflineTotalBytes"] = boost::any(*offlineTotalBytes);
    }
    if (offlineTotalRecords) {
      res["OfflineTotalRecords"] = boost::any(*offlineTotalRecords);
    }
    if (realtimeMigrationErrorMessage) {
      res["RealtimeMigrationErrorMessage"] = boost::any(*realtimeMigrationErrorMessage);
    }
    if (realtimeMigrationStatus) {
      res["RealtimeMigrationStatus"] = boost::any(*realtimeMigrationStatus);
    }
    if (sourceDatabaseName) {
      res["SourceDatabaseName"] = boost::any(*sourceDatabaseName);
    }
    if (sourceDatasourceName) {
      res["SourceDatasourceName"] = boost::any(*sourceDatasourceName);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (structureMigrationErrorMessage) {
      res["StructureMigrationErrorMessage"] = boost::any(*structureMigrationErrorMessage);
    }
    if (structureMigrationStatus) {
      res["StructureMigrationStatus"] = boost::any(*structureMigrationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDatabaseName") != m.end() && !m["DestinationDatabaseName"].empty()) {
      destinationDatabaseName = make_shared<string>(boost::any_cast<string>(m["DestinationDatabaseName"]));
    }
    if (m.find("DestinationDatasourceName") != m.end() && !m["DestinationDatasourceName"].empty()) {
      destinationDatasourceName = make_shared<string>(boost::any_cast<string>(m["DestinationDatasourceName"]));
    }
    if (m.find("DestinationSchemaName") != m.end() && !m["DestinationSchemaName"].empty()) {
      destinationSchemaName = make_shared<string>(boost::any_cast<string>(m["DestinationSchemaName"]));
    }
    if (m.find("DestinationTableName") != m.end() && !m["DestinationTableName"].empty()) {
      destinationTableName = make_shared<string>(boost::any_cast<string>(m["DestinationTableName"]));
    }
    if (m.find("FullMigrationErrorMessage") != m.end() && !m["FullMigrationErrorMessage"].empty()) {
      fullMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["FullMigrationErrorMessage"]));
    }
    if (m.find("FullMigrationStatus") != m.end() && !m["FullMigrationStatus"].empty()) {
      fullMigrationStatus = make_shared<string>(boost::any_cast<string>(m["FullMigrationStatus"]));
    }
    if (m.find("OfflineErrorRecords") != m.end() && !m["OfflineErrorRecords"].empty()) {
      offlineErrorRecords = make_shared<long>(boost::any_cast<long>(m["OfflineErrorRecords"]));
    }
    if (m.find("OfflineTotalBytes") != m.end() && !m["OfflineTotalBytes"].empty()) {
      offlineTotalBytes = make_shared<long>(boost::any_cast<long>(m["OfflineTotalBytes"]));
    }
    if (m.find("OfflineTotalRecords") != m.end() && !m["OfflineTotalRecords"].empty()) {
      offlineTotalRecords = make_shared<long>(boost::any_cast<long>(m["OfflineTotalRecords"]));
    }
    if (m.find("RealtimeMigrationErrorMessage") != m.end() && !m["RealtimeMigrationErrorMessage"].empty()) {
      realtimeMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["RealtimeMigrationErrorMessage"]));
    }
    if (m.find("RealtimeMigrationStatus") != m.end() && !m["RealtimeMigrationStatus"].empty()) {
      realtimeMigrationStatus = make_shared<string>(boost::any_cast<string>(m["RealtimeMigrationStatus"]));
    }
    if (m.find("SourceDatabaseName") != m.end() && !m["SourceDatabaseName"].empty()) {
      sourceDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceDatabaseName"]));
    }
    if (m.find("SourceDatasourceName") != m.end() && !m["SourceDatasourceName"].empty()) {
      sourceDatasourceName = make_shared<string>(boost::any_cast<string>(m["SourceDatasourceName"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("StructureMigrationErrorMessage") != m.end() && !m["StructureMigrationErrorMessage"].empty()) {
      structureMigrationErrorMessage = make_shared<string>(boost::any_cast<string>(m["StructureMigrationErrorMessage"]));
    }
    if (m.find("StructureMigrationStatus") != m.end() && !m["StructureMigrationStatus"].empty()) {
      structureMigrationStatus = make_shared<string>(boost::any_cast<string>(m["StructureMigrationStatus"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos() = default;
};
class ListDIJobRunDetailsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos>> jobRunInfos{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListDIJobRunDetailsResponseBodyPagingInfo() {}

  explicit ListDIJobRunDetailsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobRunInfos) {
      vector<boost::any> temp1;
      for(auto item1:*jobRunInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobRunInfos"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobRunInfos") != m.end() && !m["JobRunInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["JobRunInfos"].type()) {
        vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobRunInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobRunInfos = make_shared<vector<ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBodyPagingInfo() = default;
};
class ListDIJobRunDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobRunDetailsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobRunDetailsResponseBody() {}

  explicit ListDIJobRunDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobRunDetailsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobRunDetailsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobRunDetailsResponseBody() = default;
};
class ListDIJobRunDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobRunDetailsResponseBody> body{};

  ListDIJobRunDetailsResponse() {}

  explicit ListDIJobRunDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobRunDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobRunDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobRunDetailsResponse() = default;
};
class ListDIJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sourceDataSourceType{};

  ListDIJobsRequest() {}

  explicit ListDIJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
  }


  virtual ~ListDIJobsRequest() = default;
};
class ListDIJobsResponseBodyPagingInfoDIJobs : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> destinationDataSourceType{};
  shared_ptr<long> id{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> migrationType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sourceDataSourceType{};

  ListDIJobsResponseBodyPagingInfoDIJobs() {}

  explicit ListDIJobsResponseBodyPagingInfoDIJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (destinationDataSourceType) {
      res["DestinationDataSourceType"] = boost::any(*destinationDataSourceType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceDataSourceType) {
      res["SourceDataSourceType"] = boost::any(*sourceDataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("DestinationDataSourceType") != m.end() && !m["DestinationDataSourceType"].empty()) {
      destinationDataSourceType = make_shared<string>(boost::any_cast<string>(m["DestinationDataSourceType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SourceDataSourceType") != m.end() && !m["SourceDataSourceType"].empty()) {
      sourceDataSourceType = make_shared<string>(boost::any_cast<string>(m["SourceDataSourceType"]));
    }
  }


  virtual ~ListDIJobsResponseBodyPagingInfoDIJobs() = default;
};
class ListDIJobsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDIJobsResponseBodyPagingInfoDIJobs>> DIJobs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDIJobsResponseBodyPagingInfo() {}

  explicit ListDIJobsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobs) {
      vector<boost::any> temp1;
      for(auto item1:*DIJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DIJobs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobs") != m.end() && !m["DIJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["DIJobs"].type()) {
        vector<ListDIJobsResponseBodyPagingInfoDIJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DIJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDIJobsResponseBodyPagingInfoDIJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DIJobs = make_shared<vector<ListDIJobsResponseBodyPagingInfoDIJobs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDIJobsResponseBodyPagingInfo() = default;
};
class ListDIJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDIJobsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDIJobsResponseBody() {}

  explicit ListDIJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDIJobsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDIJobsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDIJobsResponseBody() = default;
};
class ListDIJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDIJobsResponseBody> body{};

  ListDIJobsResponse() {}

  explicit ListDIJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDIJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDIJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDIJobsResponse() = default;
};
class ListDataAssetTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> key{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDataAssetTagsRequest() {}

  explicit ListDataAssetTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDataAssetTagsRequest() = default;
};
class ListDataAssetTagsResponseBodyPagingInfoDataAssetTags : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> valueType{};
  shared_ptr<vector<string>> values{};

  ListDataAssetTagsResponseBodyPagingInfoDataAssetTags() {}

  explicit ListDataAssetTagsResponseBodyPagingInfoDataAssetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataAssetTagsResponseBodyPagingInfoDataAssetTags() = default;
};
class ListDataAssetTagsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags>> dataAssetTags{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataAssetTagsResponseBodyPagingInfo() {}

  explicit ListDataAssetTagsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetTags) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssetTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssetTags"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetTags") != m.end() && !m["DataAssetTags"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssetTags"].type()) {
        vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssetTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetTagsResponseBodyPagingInfoDataAssetTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssetTags = make_shared<vector<ListDataAssetTagsResponseBodyPagingInfoDataAssetTags>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataAssetTagsResponseBodyPagingInfo() = default;
};
class ListDataAssetTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataAssetTagsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataAssetTagsResponseBody() {}

  explicit ListDataAssetTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataAssetTagsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataAssetTagsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataAssetTagsResponseBody() = default;
};
class ListDataAssetTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataAssetTagsResponseBody> body{};

  ListDataAssetTagsResponse() {}

  explicit ListDataAssetTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataAssetTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataAssetTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataAssetTagsResponse() = default;
};
class ListDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDataAssetsRequestTags() {}

  explicit ListDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataAssetsRequestTags() = default;
};
class ListDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListDataAssetsRequestTags>> tags{};

  ListDataAssetsRequest() {}

  explicit ListDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListDataAssetsRequest() = default;
};
class ListDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  ListDataAssetsShrinkRequest() {}

  explicit ListDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListDataAssetsShrinkRequest() = default;
};
class ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataAssetId{};
  shared_ptr<string> key{};
  shared_ptr<string> tagSource{};
  shared_ptr<string> value{};

  ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings() {}

  explicit ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataAssetId) {
      res["DataAssetId"] = boost::any(*dataAssetId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagSource) {
      res["TagSource"] = boost::any(*tagSource);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataAssetId") != m.end() && !m["DataAssetId"].empty()) {
      dataAssetId = make_shared<string>(boost::any_cast<string>(m["DataAssetId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagSource") != m.end() && !m["TagSource"].empty()) {
      tagSource = make_shared<string>(boost::any_cast<string>(m["TagSource"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings() = default;
};
class ListDataAssetsResponseBodyPagingInfoDataAssets : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings>> dataAssetTagMappings{};
  shared_ptr<string> envType{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListDataAssetsResponseBodyPagingInfoDataAssets() {}

  explicit ListDataAssetsResponseBodyPagingInfoDataAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetTagMappings) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssetTagMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssetTagMappings"] = boost::any(temp1);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetTagMappings") != m.end() && !m["DataAssetTagMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssetTagMappings"].type()) {
        vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssetTagMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssetTagMappings = make_shared<vector<ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings>>(expect1);
      }
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfoDataAssets() = default;
};
class ListDataAssetsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataAssetsResponseBodyPagingInfoDataAssets>> dataAssets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataAssetsResponseBodyPagingInfo() {}

  explicit ListDataAssetsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssets) {
      vector<boost::any> temp1;
      for(auto item1:*dataAssets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataAssets"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssets") != m.end() && !m["DataAssets"].empty()) {
      if (typeid(vector<boost::any>) == m["DataAssets"].type()) {
        vector<ListDataAssetsResponseBodyPagingInfoDataAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataAssets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataAssetsResponseBodyPagingInfoDataAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataAssets = make_shared<vector<ListDataAssetsResponseBodyPagingInfoDataAssets>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataAssetsResponseBodyPagingInfo() = default;
};
class ListDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataAssetsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataAssetsResponseBody() {}

  explicit ListDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataAssetsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataAssetsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataAssetsResponseBody() = default;
};
class ListDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataAssetsResponseBody> body{};

  ListDataAssetsResponse() {}

  explicit ListDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataAssetsResponse() = default;
};
class ListDataQualityEvaluationTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizdateFrom{};
  shared_ptr<string> bizdateTo{};
  shared_ptr<long> createTimeFrom{};
  shared_ptr<long> createTimeTo{};
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> triggerClient{};
  shared_ptr<string> triggerClientId{};

  ListDataQualityEvaluationTaskInstancesRequest() {}

  explicit ListDataQualityEvaluationTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdateFrom) {
      res["BizdateFrom"] = boost::any(*bizdateFrom);
    }
    if (bizdateTo) {
      res["BizdateTo"] = boost::any(*bizdateTo);
    }
    if (createTimeFrom) {
      res["CreateTimeFrom"] = boost::any(*createTimeFrom);
    }
    if (createTimeTo) {
      res["CreateTimeTo"] = boost::any(*createTimeTo);
    }
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (triggerClient) {
      res["TriggerClient"] = boost::any(*triggerClient);
    }
    if (triggerClientId) {
      res["TriggerClientId"] = boost::any(*triggerClientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizdateFrom") != m.end() && !m["BizdateFrom"].empty()) {
      bizdateFrom = make_shared<string>(boost::any_cast<string>(m["BizdateFrom"]));
    }
    if (m.find("BizdateTo") != m.end() && !m["BizdateTo"].empty()) {
      bizdateTo = make_shared<string>(boost::any_cast<string>(m["BizdateTo"]));
    }
    if (m.find("CreateTimeFrom") != m.end() && !m["CreateTimeFrom"].empty()) {
      createTimeFrom = make_shared<long>(boost::any_cast<long>(m["CreateTimeFrom"]));
    }
    if (m.find("CreateTimeTo") != m.end() && !m["CreateTimeTo"].empty()) {
      createTimeTo = make_shared<long>(boost::any_cast<long>(m["CreateTimeTo"]));
    }
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TriggerClient") != m.end() && !m["TriggerClient"].empty()) {
      triggerClient = make_shared<string>(boost::any_cast<string>(m["TriggerClient"]));
    }
    if (m.find("TriggerClientId") != m.end() && !m["TriggerClientId"].empty()) {
      triggerClientId = make_shared<string>(boost::any_cast<string>(m["TriggerClientId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesRequest() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers>> nofiticationReceivers{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels>> notificationChannels{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nofiticationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*nofiticationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NofiticationReceivers"] = boost::any(temp1);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NofiticationReceivers") != m.end() && !m["NofiticationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NofiticationReceivers"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NofiticationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nofiticationReceivers = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers>>(expect1);
      }
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications>> notifications{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget> target{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger> trigger{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask> task{};
  shared_ptr<string> triggerContext{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerContext) {
      res["TriggerContext"] = boost::any(*triggerContext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask>(model1);
      }
    }
    if (m.find("TriggerContext") != m.end() && !m["TriggerContext"].empty()) {
      triggerContext = make_shared<string>(boost::any_cast<string>(m["TriggerContext"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances>> dataQualityEvaluationTaskInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityEvaluationTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityEvaluationTaskInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskInstances") != m.end() && !m["DataQualityEvaluationTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityEvaluationTaskInstances"].type()) {
        vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityEvaluationTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityEvaluationTaskInstances = make_shared<vector<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo() = default;
};
class ListDataQualityEvaluationTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityEvaluationTaskInstancesResponseBody() {}

  explicit ListDataQualityEvaluationTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponseBody() = default;
};
class ListDataQualityEvaluationTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityEvaluationTaskInstancesResponseBody> body{};

  ListDataQualityEvaluationTaskInstancesResponse() {}

  explicit ListDataQualityEvaluationTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityEvaluationTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityEvaluationTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTaskInstancesResponse() = default;
};
class ListDataQualityEvaluationTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};

  ListDataQualityEvaluationTasksRequest() {}

  explicit ListDataQualityEvaluationTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksRequest() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications>> notifications{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget> target{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger> trigger{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks() = default;
};
class ListDataQualityEvaluationTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks>> dataQualityEvaluationTasks{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListDataQualityEvaluationTasksResponseBodyPagingInfo() {}

  explicit ListDataQualityEvaluationTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTasks) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityEvaluationTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityEvaluationTasks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTasks") != m.end() && !m["DataQualityEvaluationTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityEvaluationTasks"].type()) {
        vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityEvaluationTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityEvaluationTasks = make_shared<vector<ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBodyPagingInfo() = default;
};
class ListDataQualityEvaluationTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityEvaluationTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityEvaluationTasksResponseBody() {}

  explicit ListDataQualityEvaluationTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityEvaluationTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityEvaluationTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponseBody() = default;
};
class ListDataQualityEvaluationTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityEvaluationTasksResponseBody> body{};

  ListDataQualityEvaluationTasksResponse() {}

  explicit ListDataQualityEvaluationTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityEvaluationTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityEvaluationTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityEvaluationTasksResponse() = default;
};
class ListDataQualityResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizdateFrom{};
  shared_ptr<string> bizdateTo{};
  shared_ptr<long> createTimeFrom{};
  shared_ptr<long> createTimeTo{};
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<long> dataQualityEvaluationTaskInstanceId{};
  shared_ptr<long> dataQualityRuleId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListDataQualityResultsRequest() {}

  explicit ListDataQualityResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdateFrom) {
      res["BizdateFrom"] = boost::any(*bizdateFrom);
    }
    if (bizdateTo) {
      res["BizdateTo"] = boost::any(*bizdateTo);
    }
    if (createTimeFrom) {
      res["CreateTimeFrom"] = boost::any(*createTimeFrom);
    }
    if (createTimeTo) {
      res["CreateTimeTo"] = boost::any(*createTimeTo);
    }
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (dataQualityEvaluationTaskInstanceId) {
      res["DataQualityEvaluationTaskInstanceId"] = boost::any(*dataQualityEvaluationTaskInstanceId);
    }
    if (dataQualityRuleId) {
      res["DataQualityRuleId"] = boost::any(*dataQualityRuleId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizdateFrom") != m.end() && !m["BizdateFrom"].empty()) {
      bizdateFrom = make_shared<string>(boost::any_cast<string>(m["BizdateFrom"]));
    }
    if (m.find("BizdateTo") != m.end() && !m["BizdateTo"].empty()) {
      bizdateTo = make_shared<string>(boost::any_cast<string>(m["BizdateTo"]));
    }
    if (m.find("CreateTimeFrom") != m.end() && !m["CreateTimeFrom"].empty()) {
      createTimeFrom = make_shared<long>(boost::any_cast<long>(m["CreateTimeFrom"]));
    }
    if (m.find("CreateTimeTo") != m.end() && !m["CreateTimeTo"].empty()) {
      createTimeTo = make_shared<long>(boost::any_cast<long>(m["CreateTimeTo"]));
    }
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("DataQualityEvaluationTaskInstanceId") != m.end() && !m["DataQualityEvaluationTaskInstanceId"].empty()) {
      dataQualityEvaluationTaskInstanceId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskInstanceId"]));
    }
    if (m.find("DataQualityRuleId") != m.end() && !m["DataQualityRuleId"].empty()) {
      dataQualityRuleId = make_shared<long>(boost::any_cast<long>(m["DataQualityRuleId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataQualityResultsRequest() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkedValue{};
  shared_ptr<string> referencedValue{};
  shared_ptr<string> status{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkedValue) {
      res["CheckedValue"] = boost::any(*checkedValue);
    }
    if (referencedValue) {
      res["ReferencedValue"] = boost::any(*referencedValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckedValue") != m.end() && !m["CheckedValue"].empty()) {
      checkedValue = make_shared<string>(boost::any_cast<string>(m["CheckedValue"]));
    }
    if (m.find("ReferencedValue") != m.end() && !m["ReferencedValue"].empty()) {
      referencedValue = make_shared<string>(boost::any_cast<string>(m["ReferencedValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical> critical{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected> expected{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned> warned{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget> target{};
  shared_ptr<string> templateCode{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule() = default;
};
class ListDataQualityResultsResponseBodyPagingInfoDataQualityResults : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails>> details{};
  shared_ptr<long> id{};
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule> rule{};
  shared_ptr<string> sample{};
  shared_ptr<string> status{};
  shared_ptr<long> taskInstanceId{};

  ListDataQualityResultsResponseBodyPagingInfoDataQualityResults() {}

  explicit ListDataQualityResultsResponseBodyPagingInfoDataQualityResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule>(model1);
      }
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfoDataQualityResults() = default;
};
class ListDataQualityResultsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults>> dataQualityResults{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityResultsResponseBodyPagingInfo() {}

  explicit ListDataQualityResultsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityResults) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityResults"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityResults") != m.end() && !m["DataQualityResults"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityResults"].type()) {
        vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityResultsResponseBodyPagingInfoDataQualityResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityResults = make_shared<vector<ListDataQualityResultsResponseBodyPagingInfoDataQualityResults>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBodyPagingInfo() = default;
};
class ListDataQualityResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityResultsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityResultsResponseBody() {}

  explicit ListDataQualityResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityResultsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityResultsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityResultsResponseBody() = default;
};
class ListDataQualityResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityResultsResponseBody> body{};

  ListDataQualityResultsResponse() {}

  explicit ListDataQualityResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityResultsResponse() = default;
};
class ListDataQualityRuleTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> creationSource{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListDataQualityRuleTemplatesRequest() {}

  explicit ListDataQualityRuleTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationSource) {
      res["CreationSource"] = boost::any(*creationSource);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationSource") != m.end() && !m["CreationSource"].empty()) {
      creationSource = make_shared<string>(boost::any_cast<string>(m["CreationSource"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesRequest() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig> samplingConfig{};
  shared_ptr<string> visibleScope{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibleScope) {
      res["VisibleScope"] = boost::any(*visibleScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig>(model1);
      }
    }
    if (m.find("VisibleScope") != m.end() && !m["VisibleScope"].empty()) {
      visibleScope = make_shared<string>(boost::any_cast<string>(m["VisibleScope"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates() = default;
};
class ListDataQualityRuleTemplatesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates>> dataQualityRuleTemplates{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityRuleTemplatesResponseBodyPagingInfo() {}

  explicit ListDataQualityRuleTemplatesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRuleTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRuleTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRuleTemplates"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRuleTemplates") != m.end() && !m["DataQualityRuleTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRuleTemplates"].type()) {
        vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRuleTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRuleTemplates = make_shared<vector<ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBodyPagingInfo() = default;
};
class ListDataQualityRuleTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRuleTemplatesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityRuleTemplatesResponseBody() {}

  explicit ListDataQualityRuleTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityRuleTemplatesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityRuleTemplatesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponseBody() = default;
};
class ListDataQualityRuleTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityRuleTemplatesResponseBody> body{};

  ListDataQualityRuleTemplatesResponse() {}

  explicit ListDataQualityRuleTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityRuleTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityRuleTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityRuleTemplatesResponse() = default;
};
class ListDataQualityRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataQualityEvaluationTaskId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};

  ListDataQualityRulesRequest() {}

  explicit ListDataQualityRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityEvaluationTaskId) {
      res["DataQualityEvaluationTaskId"] = boost::any(*dataQualityEvaluationTaskId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityEvaluationTaskId") != m.end() && !m["DataQualityEvaluationTaskId"].empty()) {
      dataQualityEvaluationTaskId = make_shared<long>(boost::any_cast<long>(m["DataQualityEvaluationTaskId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~ListDataQualityRulesRequest() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> type{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget() = default;
};
class ListDataQualityRulesResponseBodyPagingInfoDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget> target{};
  shared_ptr<string> templateCode{};

  ListDataQualityRulesResponseBodyPagingInfoDataQualityRules() {}

  explicit ListDataQualityRulesResponseBodyPagingInfoDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfoDataQualityRules() = default;
};
class ListDataQualityRulesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules>> dataQualityRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataQualityRulesResponseBodyPagingInfo() {}

  explicit ListDataQualityRulesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataQualityRulesResponseBodyPagingInfoDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<ListDataQualityRulesResponseBodyPagingInfoDataQualityRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBodyPagingInfo() = default;
};
class ListDataQualityRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataQualityRulesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataQualityRulesResponseBody() {}

  explicit ListDataQualityRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataQualityRulesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataQualityRulesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataQualityRulesResponseBody() = default;
};
class ListDataQualityRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataQualityRulesResponseBody> body{};

  ListDataQualityRulesResponse() {}

  explicit ListDataQualityRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataQualityRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataQualityRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataQualityRulesResponse() = default;
};
class ListDataSourceSharedRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<long> targetProjectId{};

  ListDataSourceSharedRulesRequest() {}

  explicit ListDataSourceSharedRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesRequest() = default;
};
class ListDataSourceSharedRulesResponseBodyDataSourceSharedRules : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> sharedDataSourceName{};
  shared_ptr<string> sharedUser{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<long> targetProjectId{};

  ListDataSourceSharedRulesResponseBodyDataSourceSharedRules() {}

  explicit ListDataSourceSharedRulesResponseBodyDataSourceSharedRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sharedDataSourceName) {
      res["SharedDataSourceName"] = boost::any(*sharedDataSourceName);
    }
    if (sharedUser) {
      res["SharedUser"] = boost::any(*sharedUser);
    }
    if (sourceProjectId) {
      res["SourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (targetProjectId) {
      res["TargetProjectId"] = boost::any(*targetProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SharedDataSourceName") != m.end() && !m["SharedDataSourceName"].empty()) {
      sharedDataSourceName = make_shared<string>(boost::any_cast<string>(m["SharedDataSourceName"]));
    }
    if (m.find("SharedUser") != m.end() && !m["SharedUser"].empty()) {
      sharedUser = make_shared<string>(boost::any_cast<string>(m["SharedUser"]));
    }
    if (m.find("SourceProjectId") != m.end() && !m["SourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["SourceProjectId"]));
    }
    if (m.find("TargetProjectId") != m.end() && !m["TargetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["TargetProjectId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesResponseBodyDataSourceSharedRules() = default;
};
class ListDataSourceSharedRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules>> dataSourceSharedRules{};
  shared_ptr<string> requestId{};

  ListDataSourceSharedRulesResponseBody() {}

  explicit ListDataSourceSharedRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceSharedRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataSourceSharedRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSourceSharedRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceSharedRules") != m.end() && !m["DataSourceSharedRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSourceSharedRules"].type()) {
        vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSourceSharedRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceSharedRulesResponseBodyDataSourceSharedRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSourceSharedRules = make_shared<vector<ListDataSourceSharedRulesResponseBodyDataSourceSharedRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataSourceSharedRulesResponseBody() = default;
};
class ListDataSourceSharedRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourceSharedRulesResponseBody> body{};

  ListDataSourceSharedRulesResponse() {}

  explicit ListDataSourceSharedRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourceSharedRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourceSharedRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourceSharedRulesResponse() = default;
};
class ListDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tags{};
  shared_ptr<vector<string>> types{};

  ListDataSourcesRequest() {}

  explicit ListDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataSourcesRequest() = default;
};
class ListDataSourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tags{};
  shared_ptr<string> typesShrink{};

  ListDataSourcesShrinkRequest() {}

  explicit ListDataSourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListDataSourcesShrinkRequest() = default;
};
class ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource : public Darabonba::Model {
public:
  shared_ptr<boost::any> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> qualifiedName{};

  ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource() {}

  explicit ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource() = default;
};
class ListDataSourcesResponseBodyPagingInfoDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource>> dataSource{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListDataSourcesResponseBodyPagingInfoDataSources() {}

  explicit ListDataSourcesResponseBodyPagingInfoDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfoDataSources() = default;
};
class ListDataSourcesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourcesResponseBodyPagingInfoDataSources>> dataSources{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDataSourcesResponseBodyPagingInfo() {}

  explicit ListDataSourcesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ListDataSourcesResponseBodyPagingInfoDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseBodyPagingInfoDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ListDataSourcesResponseBodyPagingInfoDataSources>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyPagingInfo() = default;
};
class ListDataSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataSourcesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDataSourcesResponseBody() {}

  explicit ListDataSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDataSourcesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDataSourcesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDataSourcesResponseBody() = default;
};
class ListDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourcesResponseBody> body{};

  ListDataSourcesResponse() {}

  explicit ListDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourcesResponse() = default;
};
class ListDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};

  ListDatabasesRequest() {}

  explicit ListDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListDatabasesRequest() = default;
};
class ListDatabasesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<Database>> databases{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDatabasesResponseBodyPagingInfo() {}

  explicit ListDatabasesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<Database> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Database model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<Database>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabasesResponseBodyPagingInfo() = default;
};
class ListDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDatabasesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDatabasesResponseBody() {}

  explicit ListDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDatabasesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDatabasesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDatabasesResponseBody() = default;
};
class ListDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabasesResponseBody> body{};

  ListDatabasesResponse() {}

  explicit ListDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabasesResponse() = default;
};
class ListDeploymentPackageFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<long> changeType{};
  shared_ptr<string> commitFrom{};
  shared_ptr<string> commitTo{};
  shared_ptr<string> commitUserId{};
  shared_ptr<vector<string>> fileIds{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> solutionId{};

  ListDeploymentPackageFilesRequest() {}

  explicit ListDeploymentPackageFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (commitFrom) {
      res["CommitFrom"] = boost::any(*commitFrom);
    }
    if (commitTo) {
      res["CommitTo"] = boost::any(*commitTo);
    }
    if (commitUserId) {
      res["CommitUserId"] = boost::any(*commitUserId);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (solutionId) {
      res["SolutionId"] = boost::any(*solutionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["ChangeType"]));
    }
    if (m.find("CommitFrom") != m.end() && !m["CommitFrom"].empty()) {
      commitFrom = make_shared<string>(boost::any_cast<string>(m["CommitFrom"]));
    }
    if (m.find("CommitTo") != m.end() && !m["CommitTo"].empty()) {
      commitTo = make_shared<string>(boost::any_cast<string>(m["CommitTo"]));
    }
    if (m.find("CommitUserId") != m.end() && !m["CommitUserId"].empty()) {
      commitUserId = make_shared<string>(boost::any_cast<string>(m["CommitUserId"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SolutionId") != m.end() && !m["SolutionId"].empty()) {
      solutionId = make_shared<long>(boost::any_cast<long>(m["SolutionId"]));
    }
  }


  virtual ~ListDeploymentPackageFilesRequest() = default;
};
class ListDeploymentPackageFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<long> changeType{};
  shared_ptr<string> commitFrom{};
  shared_ptr<string> commitTo{};
  shared_ptr<string> commitUserId{};
  shared_ptr<string> fileIdsShrink{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> solutionId{};

  ListDeploymentPackageFilesShrinkRequest() {}

  explicit ListDeploymentPackageFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (commitFrom) {
      res["CommitFrom"] = boost::any(*commitFrom);
    }
    if (commitTo) {
      res["CommitTo"] = boost::any(*commitTo);
    }
    if (commitUserId) {
      res["CommitUserId"] = boost::any(*commitUserId);
    }
    if (fileIdsShrink) {
      res["FileIds"] = boost::any(*fileIdsShrink);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (solutionId) {
      res["SolutionId"] = boost::any(*solutionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["ChangeType"]));
    }
    if (m.find("CommitFrom") != m.end() && !m["CommitFrom"].empty()) {
      commitFrom = make_shared<string>(boost::any_cast<string>(m["CommitFrom"]));
    }
    if (m.find("CommitTo") != m.end() && !m["CommitTo"].empty()) {
      commitTo = make_shared<string>(boost::any_cast<string>(m["CommitTo"]));
    }
    if (m.find("CommitUserId") != m.end() && !m["CommitUserId"].empty()) {
      commitUserId = make_shared<string>(boost::any_cast<string>(m["CommitUserId"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIdsShrink = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SolutionId") != m.end() && !m["SolutionId"].empty()) {
      solutionId = make_shared<long>(boost::any_cast<long>(m["SolutionId"]));
    }
  }


  virtual ~ListDeploymentPackageFilesShrinkRequest() = default;
};
class ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles : public Darabonba::Model {
public:
  shared_ptr<long> changeType{};
  shared_ptr<string> comment{};
  shared_ptr<string> commitTime{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> commitUserName{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<long> fileVersion{};
  shared_ptr<long> id{};
  shared_ptr<bool> isSameAsProductionVersion{};
  shared_ptr<string> nodeConfiguration{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> smokeTestStatus{};
  shared_ptr<long> status{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> useType{};

  ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles() {}

  explicit ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (commitUserName) {
      res["CommitUserName"] = boost::any(*commitUserName);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isSameAsProductionVersion) {
      res["IsSameAsProductionVersion"] = boost::any(*isSameAsProductionVersion);
    }
    if (nodeConfiguration) {
      res["NodeConfiguration"] = boost::any(*nodeConfiguration);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (smokeTestStatus) {
      res["SmokeTestStatus"] = boost::any(*smokeTestStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["ChangeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<string>(boost::any_cast<string>(m["CommitTime"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("CommitUserName") != m.end() && !m["CommitUserName"].empty()) {
      commitUserName = make_shared<string>(boost::any_cast<string>(m["CommitUserName"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsSameAsProductionVersion") != m.end() && !m["IsSameAsProductionVersion"].empty()) {
      isSameAsProductionVersion = make_shared<bool>(boost::any_cast<bool>(m["IsSameAsProductionVersion"]));
    }
    if (m.find("NodeConfiguration") != m.end() && !m["NodeConfiguration"].empty()) {
      nodeConfiguration = make_shared<string>(boost::any_cast<string>(m["NodeConfiguration"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SmokeTestStatus") != m.end() && !m["SmokeTestStatus"].empty()) {
      smokeTestStatus = make_shared<string>(boost::any_cast<string>(m["SmokeTestStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles() = default;
};
class ListDeploymentPackageFilesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles>> deploymentPackageFiles{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDeploymentPackageFilesResponseBodyPagingInfo() {}

  explicit ListDeploymentPackageFilesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentPackageFiles) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentPackageFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentPackageFiles"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentPackageFiles") != m.end() && !m["DeploymentPackageFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentPackageFiles"].type()) {
        vector<ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentPackageFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentPackageFiles = make_shared<vector<ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDeploymentPackageFilesResponseBodyPagingInfo() = default;
};
class ListDeploymentPackageFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDeploymentPackageFilesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDeploymentPackageFilesResponseBody() {}

  explicit ListDeploymentPackageFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDeploymentPackageFilesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDeploymentPackageFilesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeploymentPackageFilesResponseBody() = default;
};
class ListDeploymentPackageFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeploymentPackageFilesResponseBody> body{};

  ListDeploymentPackageFilesResponse() {}

  explicit ListDeploymentPackageFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeploymentPackageFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeploymentPackageFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeploymentPackageFilesResponse() = default;
};
class ListDeploymentPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<long> endCreateTime{};
  shared_ptr<long> endExecuteTime{};
  shared_ptr<string> executor{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> status{};

  ListDeploymentPackagesRequest() {}

  explicit ListDeploymentPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (endCreateTime) {
      res["EndCreateTime"] = boost::any(*endCreateTime);
    }
    if (endExecuteTime) {
      res["EndExecuteTime"] = boost::any(*endExecuteTime);
    }
    if (executor) {
      res["Executor"] = boost::any(*executor);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("EndCreateTime") != m.end() && !m["EndCreateTime"].empty()) {
      endCreateTime = make_shared<long>(boost::any_cast<long>(m["EndCreateTime"]));
    }
    if (m.find("EndExecuteTime") != m.end() && !m["EndExecuteTime"].empty()) {
      endExecuteTime = make_shared<long>(boost::any_cast<long>(m["EndExecuteTime"]));
    }
    if (m.find("Executor") != m.end() && !m["Executor"].empty()) {
      executor = make_shared<string>(boost::any_cast<string>(m["Executor"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListDeploymentPackagesRequest() = default;
};
class ListDeploymentPackagesResponseBodyDataDeployments : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> executeTime{};
  shared_ptr<string> executor{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> status{};

  ListDeploymentPackagesResponseBodyDataDeployments() {}

  explicit ListDeploymentPackagesResponseBodyDataDeployments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executor) {
      res["Executor"] = boost::any(*executor);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("Executor") != m.end() && !m["Executor"].empty()) {
      executor = make_shared<string>(boost::any_cast<string>(m["Executor"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListDeploymentPackagesResponseBodyDataDeployments() = default;
};
class ListDeploymentPackagesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeploymentPackagesResponseBodyDataDeployments>> deployments{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDeploymentPackagesResponseBodyData() {}

  explicit ListDeploymentPackagesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployments) {
      vector<boost::any> temp1;
      for(auto item1:*deployments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Deployments"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deployments") != m.end() && !m["Deployments"].empty()) {
      if (typeid(vector<boost::any>) == m["Deployments"].type()) {
        vector<ListDeploymentPackagesResponseBodyDataDeployments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Deployments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeploymentPackagesResponseBodyDataDeployments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployments = make_shared<vector<ListDeploymentPackagesResponseBodyDataDeployments>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDeploymentPackagesResponseBodyData() = default;
};
class ListDeploymentPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDeploymentPackagesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListDeploymentPackagesResponseBody() {}

  explicit ListDeploymentPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDeploymentPackagesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDeploymentPackagesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeploymentPackagesResponseBody() = default;
};
class ListDeploymentPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeploymentPackagesResponseBody> body{};

  ListDeploymentPackagesResponse() {}

  explicit ListDeploymentPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeploymentPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeploymentPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeploymentPackagesResponse() = default;
};
class ListDownstreamTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDownstreamTaskInstancesRequest() {}

  explicit ListDownstreamTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesRequest() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime> runtime{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance> taskInstance{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance>(model1);
      }
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stepType{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListDownstreamTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances>> downstreamTaskInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};

  ListDownstreamTaskInstancesResponseBodyPagingInfo() {}

  explicit ListDownstreamTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downstreamTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*downstreamTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownstreamTaskInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownstreamTaskInstances") != m.end() && !m["DownstreamTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["DownstreamTaskInstances"].type()) {
        vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownstreamTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downstreamTaskInstances = make_shared<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBodyPagingInfo() = default;
};
class ListDownstreamTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDownstreamTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDownstreamTaskInstancesResponseBody() {}

  explicit ListDownstreamTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDownstreamTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDownstreamTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDownstreamTaskInstancesResponseBody() = default;
};
class ListDownstreamTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDownstreamTaskInstancesResponseBody> body{};

  ListDownstreamTaskInstancesResponse() {}

  explicit ListDownstreamTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDownstreamTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDownstreamTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDownstreamTaskInstancesResponse() = default;
};
class ListDownstreamTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListDownstreamTasksRequest() {}

  explicit ListDownstreamTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListDownstreamTasksRequest() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask> task{};

  ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask>(model1);
      }
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListDownstreamTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListDownstreamTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListDownstreamTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> stepType{};
  shared_ptr<long> timeout{};
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListDownstreamTasksResponseBodyPagingInfoTasks() {}

  explicit ListDownstreamTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListDownstreamTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListDownstreamTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfoTasks() = default;
};
class ListDownstreamTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks>> downstreamTasks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListDownstreamTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListDownstreamTasksResponseBodyPagingInfo() {}

  explicit ListDownstreamTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downstreamTasks) {
      vector<boost::any> temp1;
      for(auto item1:*downstreamTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownstreamTasks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownstreamTasks") != m.end() && !m["DownstreamTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["DownstreamTasks"].type()) {
        vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownstreamTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downstreamTasks = make_shared<vector<ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListDownstreamTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownstreamTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListDownstreamTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBodyPagingInfo() = default;
};
class ListDownstreamTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDownstreamTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListDownstreamTasksResponseBody() {}

  explicit ListDownstreamTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListDownstreamTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListDownstreamTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDownstreamTasksResponseBody() = default;
};
class ListDownstreamTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDownstreamTasksResponseBody> body{};

  ListDownstreamTasksResponse() {}

  explicit ListDownstreamTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDownstreamTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDownstreamTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDownstreamTasksResponse() = default;
};
class ListEntitiesInMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityDescription{};
  shared_ptr<string> entityName{};
  shared_ptr<string> entityType{};
  shared_ptr<string> id{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListEntitiesInMetaCollectionRequest() {}

  explicit ListEntitiesInMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDescription) {
      res["EntityDescription"] = boost::any(*entityDescription);
    }
    if (entityName) {
      res["EntityName"] = boost::any(*entityName);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityDescription") != m.end() && !m["EntityDescription"].empty()) {
      entityDescription = make_shared<string>(boost::any_cast<string>(m["EntityDescription"]));
    }
    if (m.find("EntityName") != m.end() && !m["EntityName"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["EntityName"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListEntitiesInMetaCollectionRequest() = default;
};
class ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities() {}

  explicit ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities() = default;
};
class ListEntitiesInMetaCollectionResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities>> entities{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListEntitiesInMetaCollectionResponseBodyPagingInfo() {}

  explicit ListEntitiesInMetaCollectionResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Entities"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entities") != m.end() && !m["Entities"].empty()) {
      if (typeid(vector<boost::any>) == m["Entities"].type()) {
        vector<ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEntitiesInMetaCollectionResponseBodyPagingInfo() = default;
};
class ListEntitiesInMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEntitiesInMetaCollectionResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListEntitiesInMetaCollectionResponseBody() {}

  explicit ListEntitiesInMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListEntitiesInMetaCollectionResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListEntitiesInMetaCollectionResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEntitiesInMetaCollectionResponseBody() = default;
};
class ListEntitiesInMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEntitiesInMetaCollectionResponseBody> body{};

  ListEntitiesInMetaCollectionResponse() {}

  explicit ListEntitiesInMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEntitiesInMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEntitiesInMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~ListEntitiesInMetaCollectionResponse() = default;
};
class ListFileVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  ListFileVersionsRequest() {}

  explicit ListFileVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~ListFileVersionsRequest() = default;
};
class ListFileVersionsResponseBodyDataFileVersions : public Darabonba::Model {
public:
  shared_ptr<string> changeType{};
  shared_ptr<string> comment{};
  shared_ptr<long> commitTime{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> fileContent{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<long> fileVersion{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<string> nodeContent{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> status{};
  shared_ptr<string> useType{};

  ListFileVersionsResponseBodyDataFileVersions() {}

  explicit ListFileVersionsResponseBodyDataFileVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListFileVersionsResponseBodyDataFileVersions() = default;
};
class ListFileVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListFileVersionsResponseBodyDataFileVersions>> fileVersions{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFileVersionsResponseBodyData() {}

  explicit ListFileVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileVersions) {
      vector<boost::any> temp1;
      for(auto item1:*fileVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileVersions"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileVersions") != m.end() && !m["FileVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["FileVersions"].type()) {
        vector<ListFileVersionsResponseBodyDataFileVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFileVersionsResponseBodyDataFileVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileVersions = make_shared<vector<ListFileVersionsResponseBodyDataFileVersions>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFileVersionsResponseBodyData() = default;
};
class ListFileVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFileVersionsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFileVersionsResponseBody() {}

  explicit ListFileVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFileVersionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFileVersionsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFileVersionsResponseBody() = default;
};
class ListFileVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFileVersionsResponseBody> body{};

  ListFileVersionsResponse() {}

  explicit ListFileVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFileVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFileVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFileVersionsResponse() = default;
};
class ListFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> commitStatus{};
  shared_ptr<string> exactFileName{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileIdIn{};
  shared_ptr<string> fileTypes{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<bool> needAbsoluteFolderPath{};
  shared_ptr<bool> needContent{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> useType{};

  ListFilesRequest() {}

  explicit ListFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (exactFileName) {
      res["ExactFileName"] = boost::any(*exactFileName);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileIdIn) {
      res["FileIdIn"] = boost::any(*fileIdIn);
    }
    if (fileTypes) {
      res["FileTypes"] = boost::any(*fileTypes);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (needAbsoluteFolderPath) {
      res["NeedAbsoluteFolderPath"] = boost::any(*needAbsoluteFolderPath);
    }
    if (needContent) {
      res["NeedContent"] = boost::any(*needContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<long>(boost::any_cast<long>(m["CommitStatus"]));
    }
    if (m.find("ExactFileName") != m.end() && !m["ExactFileName"].empty()) {
      exactFileName = make_shared<string>(boost::any_cast<string>(m["ExactFileName"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileIdIn") != m.end() && !m["FileIdIn"].empty()) {
      fileIdIn = make_shared<string>(boost::any_cast<string>(m["FileIdIn"]));
    }
    if (m.find("FileTypes") != m.end() && !m["FileTypes"].empty()) {
      fileTypes = make_shared<string>(boost::any_cast<string>(m["FileTypes"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("NeedAbsoluteFolderPath") != m.end() && !m["NeedAbsoluteFolderPath"].empty()) {
      needAbsoluteFolderPath = make_shared<bool>(boost::any_cast<bool>(m["NeedAbsoluteFolderPath"]));
    }
    if (m.find("NeedContent") != m.end() && !m["NeedContent"].empty()) {
      needContent = make_shared<bool>(boost::any_cast<bool>(m["NeedContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListFilesRequest() = default;
};
class ListFilesResponseBodyDataFiles : public Darabonba::Model {
public:
  shared_ptr<string> absoluteFolderPath{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<long> bizId{};
  shared_ptr<long> businessId{};
  shared_ptr<long> commitStatus{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> currentVersion{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> owner{};
  shared_ptr<long> parentId{};
  shared_ptr<string> useType{};

  ListFilesResponseBodyDataFiles() {}

  explicit ListFilesResponseBodyDataFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (absoluteFolderPath) {
      res["AbsoluteFolderPath"] = boost::any(*absoluteFolderPath);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbsoluteFolderPath") != m.end() && !m["AbsoluteFolderPath"].empty()) {
      absoluteFolderPath = make_shared<string>(boost::any_cast<string>(m["AbsoluteFolderPath"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<long>(boost::any_cast<long>(m["CommitStatus"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListFilesResponseBodyDataFiles() = default;
};
class ListFilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListFilesResponseBodyDataFiles>> files{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFilesResponseBodyData() {}

  explicit ListFilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFilesResponseBodyDataFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilesResponseBodyDataFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFilesResponseBodyDataFiles>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFilesResponseBodyData() = default;
};
class ListFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFilesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFilesResponseBody() {}

  explicit ListFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFilesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFilesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFilesResponseBody() = default;
};
class ListFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFilesResponseBody> body{};

  ListFilesResponse() {}

  explicit ListFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilesResponse() = default;
};
class ListFoldersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  ListFoldersRequest() {}

  explicit ListFoldersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentFolderPath) {
      res["ParentFolderPath"] = boost::any(*parentFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentFolderPath") != m.end() && !m["ParentFolderPath"].empty()) {
      parentFolderPath = make_shared<string>(boost::any_cast<string>(m["ParentFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~ListFoldersRequest() = default;
};
class ListFoldersResponseBodyDataFolders : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  ListFoldersResponseBodyDataFolders() {}

  explicit ListFoldersResponseBodyDataFolders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~ListFoldersResponseBodyDataFolders() = default;
};
class ListFoldersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListFoldersResponseBodyDataFolders>> folders{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFoldersResponseBodyData() {}

  explicit ListFoldersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folders) {
      vector<boost::any> temp1;
      for(auto item1:*folders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Folders"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Folders") != m.end() && !m["Folders"].empty()) {
      if (typeid(vector<boost::any>) == m["Folders"].type()) {
        vector<ListFoldersResponseBodyDataFolders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Folders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFoldersResponseBodyDataFolders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        folders = make_shared<vector<ListFoldersResponseBodyDataFolders>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFoldersResponseBodyData() = default;
};
class ListFoldersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFoldersResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFoldersResponseBody() {}

  explicit ListFoldersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFoldersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFoldersResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFoldersResponseBody() = default;
};
class ListFoldersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFoldersResponseBody> body{};

  ListFoldersResponse() {}

  explicit ListFoldersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFoldersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFoldersResponseBody>(model1);
      }
    }
  }


  virtual ~ListFoldersResponse() = default;
};
class ListFunctionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListFunctionsRequest() {}

  explicit ListFunctionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsRequest() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListFunctionsResponseBodyPagingInfoFunctionsDataSource() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsDataSource() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctionsScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime> runtime{};

  ListFunctionsResponseBodyPagingInfoFunctionsScript() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctionsScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctionsScript() = default;
};
class ListFunctionsResponseBodyPagingInfoFunctions : public Darabonba::Model {
public:
  shared_ptr<string> armResource{};
  shared_ptr<string> className{};
  shared_ptr<string> commandDescription{};
  shared_ptr<long> createTime{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsDataSource> dataSource{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> description{};
  shared_ptr<string> embeddedCode{};
  shared_ptr<string> embeddedCodeType{};
  shared_ptr<string> embeddedResourceType{};
  shared_ptr<string> exampleDescription{};
  shared_ptr<string> fileResource{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<long> projectId{};
  shared_ptr<string> returnValueDescription{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource> runtimeResource{};
  shared_ptr<ListFunctionsResponseBodyPagingInfoFunctionsScript> script{};
  shared_ptr<string> type{};

  ListFunctionsResponseBodyPagingInfoFunctions() {}

  explicit ListFunctionsResponseBodyPagingInfoFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armResource) {
      res["ArmResource"] = boost::any(*armResource);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (commandDescription) {
      res["CommandDescription"] = boost::any(*commandDescription);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (embeddedCode) {
      res["EmbeddedCode"] = boost::any(*embeddedCode);
    }
    if (embeddedCodeType) {
      res["EmbeddedCodeType"] = boost::any(*embeddedCodeType);
    }
    if (embeddedResourceType) {
      res["EmbeddedResourceType"] = boost::any(*embeddedResourceType);
    }
    if (exampleDescription) {
      res["ExampleDescription"] = boost::any(*exampleDescription);
    }
    if (fileResource) {
      res["FileResource"] = boost::any(*fileResource);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (returnValueDescription) {
      res["ReturnValueDescription"] = boost::any(*returnValueDescription);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmResource") != m.end() && !m["ArmResource"].empty()) {
      armResource = make_shared<string>(boost::any_cast<string>(m["ArmResource"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("CommandDescription") != m.end() && !m["CommandDescription"].empty()) {
      commandDescription = make_shared<string>(boost::any_cast<string>(m["CommandDescription"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsDataSource>(model1);
      }
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EmbeddedCode") != m.end() && !m["EmbeddedCode"].empty()) {
      embeddedCode = make_shared<string>(boost::any_cast<string>(m["EmbeddedCode"]));
    }
    if (m.find("EmbeddedCodeType") != m.end() && !m["EmbeddedCodeType"].empty()) {
      embeddedCodeType = make_shared<string>(boost::any_cast<string>(m["EmbeddedCodeType"]));
    }
    if (m.find("EmbeddedResourceType") != m.end() && !m["EmbeddedResourceType"].empty()) {
      embeddedResourceType = make_shared<string>(boost::any_cast<string>(m["EmbeddedResourceType"]));
    }
    if (m.find("ExampleDescription") != m.end() && !m["ExampleDescription"].empty()) {
      exampleDescription = make_shared<string>(boost::any_cast<string>(m["ExampleDescription"]));
    }
    if (m.find("FileResource") != m.end() && !m["FileResource"].empty()) {
      fileResource = make_shared<string>(boost::any_cast<string>(m["FileResource"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ReturnValueDescription") != m.end() && !m["ReturnValueDescription"].empty()) {
      returnValueDescription = make_shared<string>(boost::any_cast<string>(m["ReturnValueDescription"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListFunctionsResponseBodyPagingInfoFunctionsScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListFunctionsResponseBodyPagingInfoFunctionsScript>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfoFunctions() = default;
};
class ListFunctionsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListFunctionsResponseBodyPagingInfoFunctions>> functions{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFunctionsResponseBodyPagingInfo() {}

  explicit ListFunctionsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functions) {
      vector<boost::any> temp1;
      for(auto item1:*functions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Functions"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      if (typeid(vector<boost::any>) == m["Functions"].type()) {
        vector<ListFunctionsResponseBodyPagingInfoFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Functions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFunctionsResponseBodyPagingInfoFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functions = make_shared<vector<ListFunctionsResponseBodyPagingInfoFunctions>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFunctionsResponseBodyPagingInfo() = default;
};
class ListFunctionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFunctionsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListFunctionsResponseBody() {}

  explicit ListFunctionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListFunctionsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListFunctionsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFunctionsResponseBody() = default;
};
class ListFunctionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFunctionsResponseBody> body{};

  ListFunctionsResponse() {}

  explicit ListFunctionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFunctionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFunctionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFunctionsResponse() = default;
};
class ListLineageRelationshipsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dstEntityId{};
  shared_ptr<string> dstEntityName{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> srcEntityId{};
  shared_ptr<string> srcEntityName{};

  ListLineageRelationshipsRequest() {}

  explicit ListLineageRelationshipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstEntityId) {
      res["DstEntityId"] = boost::any(*dstEntityId);
    }
    if (dstEntityName) {
      res["DstEntityName"] = boost::any(*dstEntityName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (srcEntityId) {
      res["SrcEntityId"] = boost::any(*srcEntityId);
    }
    if (srcEntityName) {
      res["SrcEntityName"] = boost::any(*srcEntityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstEntityId") != m.end() && !m["DstEntityId"].empty()) {
      dstEntityId = make_shared<string>(boost::any_cast<string>(m["DstEntityId"]));
    }
    if (m.find("DstEntityName") != m.end() && !m["DstEntityName"].empty()) {
      dstEntityName = make_shared<string>(boost::any_cast<string>(m["DstEntityName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SrcEntityId") != m.end() && !m["SrcEntityId"].empty()) {
      srcEntityId = make_shared<string>(boost::any_cast<string>(m["SrcEntityId"]));
    }
    if (m.find("SrcEntityName") != m.end() && !m["SrcEntityName"].empty()) {
      srcEntityName = make_shared<string>(boost::any_cast<string>(m["SrcEntityName"]));
    }
  }


  virtual ~ListLineageRelationshipsRequest() = default;
};
class ListLineageRelationshipsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<LineageRelationship>> lineageRelationships{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLineageRelationshipsResponseBodyPagingInfo() {}

  explicit ListLineageRelationshipsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineageRelationships) {
      vector<boost::any> temp1;
      for(auto item1:*lineageRelationships){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LineageRelationships"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineageRelationships") != m.end() && !m["LineageRelationships"].empty()) {
      if (typeid(vector<boost::any>) == m["LineageRelationships"].type()) {
        vector<LineageRelationship> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LineageRelationships"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LineageRelationship model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineageRelationships = make_shared<vector<LineageRelationship>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLineageRelationshipsResponseBodyPagingInfo() = default;
};
class ListLineageRelationshipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLineageRelationshipsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLineageRelationshipsResponseBody() {}

  explicit ListLineageRelationshipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListLineageRelationshipsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListLineageRelationshipsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLineageRelationshipsResponseBody() = default;
};
class ListLineageRelationshipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLineageRelationshipsResponseBody> body{};

  ListLineageRelationshipsResponse() {}

  explicit ListLineageRelationshipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLineageRelationshipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLineageRelationshipsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLineageRelationshipsResponse() = default;
};
class ListLineagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dstEntityId{};
  shared_ptr<string> dstEntityName{};
  shared_ptr<bool> needAttachRelationship{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> srcEntityId{};
  shared_ptr<string> srcEntityName{};

  ListLineagesRequest() {}

  explicit ListLineagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstEntityId) {
      res["DstEntityId"] = boost::any(*dstEntityId);
    }
    if (dstEntityName) {
      res["DstEntityName"] = boost::any(*dstEntityName);
    }
    if (needAttachRelationship) {
      res["NeedAttachRelationship"] = boost::any(*needAttachRelationship);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (srcEntityId) {
      res["SrcEntityId"] = boost::any(*srcEntityId);
    }
    if (srcEntityName) {
      res["SrcEntityName"] = boost::any(*srcEntityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstEntityId") != m.end() && !m["DstEntityId"].empty()) {
      dstEntityId = make_shared<string>(boost::any_cast<string>(m["DstEntityId"]));
    }
    if (m.find("DstEntityName") != m.end() && !m["DstEntityName"].empty()) {
      dstEntityName = make_shared<string>(boost::any_cast<string>(m["DstEntityName"]));
    }
    if (m.find("NeedAttachRelationship") != m.end() && !m["NeedAttachRelationship"].empty()) {
      needAttachRelationship = make_shared<bool>(boost::any_cast<bool>(m["NeedAttachRelationship"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SrcEntityId") != m.end() && !m["SrcEntityId"].empty()) {
      srcEntityId = make_shared<string>(boost::any_cast<string>(m["SrcEntityId"]));
    }
    if (m.find("SrcEntityName") != m.end() && !m["SrcEntityName"].empty()) {
      srcEntityName = make_shared<string>(boost::any_cast<string>(m["SrcEntityName"]));
    }
  }


  virtual ~ListLineagesRequest() = default;
};
class ListLineagesResponseBodyPagingInfoLineages : public Darabonba::Model {
public:
  shared_ptr<LineageEntity> dstEntity{};
  shared_ptr<vector<LineageRelationship>> relationships{};
  shared_ptr<LineageEntity> srcEntity{};

  ListLineagesResponseBodyPagingInfoLineages() {}

  explicit ListLineagesResponseBodyPagingInfoLineages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstEntity) {
      res["DstEntity"] = dstEntity ? boost::any(dstEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relationships) {
      vector<boost::any> temp1;
      for(auto item1:*relationships){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Relationships"] = boost::any(temp1);
    }
    if (srcEntity) {
      res["SrcEntity"] = srcEntity ? boost::any(srcEntity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstEntity") != m.end() && !m["DstEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstEntity"]));
        dstEntity = make_shared<LineageEntity>(model1);
      }
    }
    if (m.find("Relationships") != m.end() && !m["Relationships"].empty()) {
      if (typeid(vector<boost::any>) == m["Relationships"].type()) {
        vector<LineageRelationship> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Relationships"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LineageRelationship model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationships = make_shared<vector<LineageRelationship>>(expect1);
      }
    }
    if (m.find("SrcEntity") != m.end() && !m["SrcEntity"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcEntity"].type()) {
        LineageEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcEntity"]));
        srcEntity = make_shared<LineageEntity>(model1);
      }
    }
  }


  virtual ~ListLineagesResponseBodyPagingInfoLineages() = default;
};
class ListLineagesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListLineagesResponseBodyPagingInfoLineages>> lineages{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLineagesResponseBodyPagingInfo() {}

  explicit ListLineagesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineages) {
      vector<boost::any> temp1;
      for(auto item1:*lineages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lineages"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lineages") != m.end() && !m["Lineages"].empty()) {
      if (typeid(vector<boost::any>) == m["Lineages"].type()) {
        vector<ListLineagesResponseBodyPagingInfoLineages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lineages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLineagesResponseBodyPagingInfoLineages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineages = make_shared<vector<ListLineagesResponseBodyPagingInfoLineages>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLineagesResponseBodyPagingInfo() = default;
};
class ListLineagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLineagesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLineagesResponseBody() {}

  explicit ListLineagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListLineagesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListLineagesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLineagesResponseBody() = default;
};
class ListLineagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLineagesResponseBody> body{};

  ListLineagesResponse() {}

  explicit ListLineagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLineagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLineagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLineagesResponse() = default;
};
class ListMetaCollectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> administrator{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};

  ListMetaCollectionsRequest() {}

  explicit ListMetaCollectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administrator) {
      res["Administrator"] = boost::any(*administrator);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrator") != m.end() && !m["Administrator"].empty()) {
      administrator = make_shared<string>(boost::any_cast<string>(m["Administrator"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMetaCollectionsRequest() = default;
};
class ListMetaCollectionsResponseBodyDataMetaCollections : public Darabonba::Model {
public:
  shared_ptr<vector<string>> administrators{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> type{};

  ListMetaCollectionsResponseBodyDataMetaCollections() {}

  explicit ListMetaCollectionsResponseBodyDataMetaCollections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administrators) {
      res["Administrators"] = boost::any(*administrators);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Administrators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Administrators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      administrators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMetaCollectionsResponseBodyDataMetaCollections() = default;
};
class ListMetaCollectionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListMetaCollectionsResponseBodyDataMetaCollections>> metaCollections{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMetaCollectionsResponseBodyData() {}

  explicit ListMetaCollectionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaCollections) {
      vector<boost::any> temp1;
      for(auto item1:*metaCollections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetaCollections"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaCollections") != m.end() && !m["MetaCollections"].empty()) {
      if (typeid(vector<boost::any>) == m["MetaCollections"].type()) {
        vector<ListMetaCollectionsResponseBodyDataMetaCollections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetaCollections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMetaCollectionsResponseBodyDataMetaCollections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metaCollections = make_shared<vector<ListMetaCollectionsResponseBodyDataMetaCollections>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMetaCollectionsResponseBodyData() = default;
};
class ListMetaCollectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMetaCollectionsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListMetaCollectionsResponseBody() {}

  explicit ListMetaCollectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListMetaCollectionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListMetaCollectionsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMetaCollectionsResponseBody() = default;
};
class ListMetaCollectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMetaCollectionsResponseBody> body{};

  ListMetaCollectionsResponse() {}

  explicit ListMetaCollectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMetaCollectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMetaCollectionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMetaCollectionsResponse() = default;
};
class ListNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sortBy{};

  ListNetworksRequest() {}

  explicit ListNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListNetworksRequest() = default;
};
class ListNetworksResponseBodyPagingInfoNetworkList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  ListNetworksResponseBodyPagingInfoNetworkList() {}

  explicit ListNetworksResponseBodyPagingInfoNetworkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ListNetworksResponseBodyPagingInfoNetworkList() = default;
};
class ListNetworksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworksResponseBodyPagingInfoNetworkList>> networkList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListNetworksResponseBodyPagingInfo() {}

  explicit ListNetworksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkList) {
      vector<boost::any> temp1;
      for(auto item1:*networkList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkList") != m.end() && !m["NetworkList"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkList"].type()) {
        vector<ListNetworksResponseBodyPagingInfoNetworkList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworksResponseBodyPagingInfoNetworkList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkList = make_shared<vector<ListNetworksResponseBodyPagingInfoNetworkList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNetworksResponseBodyPagingInfo() = default;
};
class ListNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNetworksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListNetworksResponseBody() {}

  explicit ListNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNetworksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNetworksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListNetworksResponseBody() = default;
};
class ListNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworksResponseBody> body{};

  ListNetworksResponse() {}

  explicit ListNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworksResponse() = default;
};
class ListNodeDependenciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};

  ListNodeDependenciesRequest() {}

  explicit ListNodeDependenciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListNodeDependenciesRequest() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListNodeDependenciesResponseBodyPagingInfoNodesDataSource() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesDataSource() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables>> tables{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables>> variables{};

  ListNodeDependenciesResponseBodyPagingInfoNodesInputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesInputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables>> tables{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables>> variables{};

  ListNodeDependenciesResponseBodyPagingInfoNodesOutputs() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesOutputs() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime> runtime{};

  ListNodeDependenciesResponseBodyPagingInfoNodesScript() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesScript() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> instanceMode{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<long> timeout{};

  ListNodeDependenciesResponseBodyPagingInfoNodesStrategy() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesStrategy() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListNodeDependenciesResponseBodyPagingInfoNodesTags() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesTags() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodesTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListNodeDependenciesResponseBodyPagingInfoNodesTrigger() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodesTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodesTrigger() = default;
};
class ListNodeDependenciesResponseBodyPagingInfoNodes : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource> runtimeResource{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesScript> script{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesStrategy> strategy{};
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfoNodesTrigger> trigger{};

  ListNodeDependenciesResponseBodyPagingInfoNodes() {}

  explicit ListNodeDependenciesResponseBodyPagingInfoNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesScript>(model1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesStrategy>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodesTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListNodeDependenciesResponseBodyPagingInfoNodesTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListNodeDependenciesResponseBodyPagingInfoNodesTrigger>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfoNodes() = default;
};
class ListNodeDependenciesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodeDependenciesResponseBodyPagingInfoNodes>> nodes{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListNodeDependenciesResponseBodyPagingInfo() {}

  explicit ListNodeDependenciesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodeDependenciesResponseBodyPagingInfoNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDependenciesResponseBodyPagingInfoNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodeDependenciesResponseBodyPagingInfoNodes>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBodyPagingInfo() = default;
};
class ListNodeDependenciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNodeDependenciesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListNodeDependenciesResponseBody() {}

  explicit ListNodeDependenciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNodeDependenciesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNodeDependenciesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNodeDependenciesResponseBody() = default;
};
class ListNodeDependenciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodeDependenciesResponseBody> body{};

  ListNodeDependenciesResponse() {}

  explicit ListNodeDependenciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeDependenciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeDependenciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeDependenciesResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> containerId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> rerunMode{};
  shared_ptr<string> scene{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<long>(boost::any_cast<long>(m["ContainerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseBodyPagingInfoNodesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListNodesResponseBodyPagingInfoNodesDataSource() {}

  explicit ListNodesResponseBodyPagingInfoNodesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesDataSource() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodesResponseBodyPagingInfoNodesInputsTables() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsTables() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodesResponseBodyPagingInfoNodesInputsVariablesNode() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsVariablesNode() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesInputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesInputsVariables() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodesResponseBodyPagingInfoNodesInputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodesResponseBodyPagingInfoNodesInputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputsVariables() = default;
};
class ListNodesResponseBodyPagingInfoNodesInputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsTables>> tables{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesInputsVariables>> variables{};

  ListNodesResponseBodyPagingInfoNodesInputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesInputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesInputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsTables : public Darabonba::Model {
public:
  shared_ptr<string> guid{};

  ListNodesResponseBodyPagingInfoNodesOutputsTables() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsTables() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> artifactType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode> node{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesOutputsVariables() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (artifactType) {
      res["ArtifactType"] = boost::any(*artifactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArtifactType") != m.end() && !m["ArtifactType"].empty()) {
      artifactType = make_shared<string>(boost::any_cast<string>(m["ArtifactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode>(model1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputsVariables() = default;
};
class ListNodesResponseBodyPagingInfoNodesOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs>> nodeOutputs{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsTables>> tables{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables>> variables{};

  ListNodesResponseBodyPagingInfoNodesOutputs() {}

  explicit ListNodesResponseBodyPagingInfoNodesOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOutputs"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeOutputs") != m.end() && !m["NodeOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOutputs"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOutputs = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsTables>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListNodesResponseBodyPagingInfoNodesOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesOutputs() = default;
};
class ListNodesResponseBodyPagingInfoNodesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceGroupId{};

  ListNodesResponseBodyPagingInfoNodesRuntimeResource() {}

  explicit ListNodesResponseBodyPagingInfoNodesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesRuntimeResource() = default;
};
class ListNodesResponseBodyPagingInfoNodesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListNodesResponseBodyPagingInfoNodesScriptRuntime() {}

  explicit ListNodesResponseBodyPagingInfoNodesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesScriptRuntime() = default;
};
class ListNodesResponseBodyPagingInfoNodesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesScriptRuntime> runtime{};

  ListNodesResponseBodyPagingInfoNodesScript() {}

  explicit ListNodesResponseBodyPagingInfoNodesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListNodesResponseBodyPagingInfoNodesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListNodesResponseBodyPagingInfoNodesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesScript() = default;
};
class ListNodesResponseBodyPagingInfoNodesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> instanceMode{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<long> timeout{};

  ListNodesResponseBodyPagingInfoNodesStrategy() {}

  explicit ListNodesResponseBodyPagingInfoNodesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesStrategy() = default;
};
class ListNodesResponseBodyPagingInfoNodesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListNodesResponseBodyPagingInfoNodesTags() {}

  explicit ListNodesResponseBodyPagingInfoNodesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesTags() = default;
};
class ListNodesResponseBodyPagingInfoNodesTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListNodesResponseBodyPagingInfoNodesTrigger() {}

  explicit ListNodesResponseBodyPagingInfoNodesTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodesTrigger() = default;
};
class ListNodesResponseBodyPagingInfoNodes : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesInputs> inputs{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> recurrence{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesRuntimeResource> runtimeResource{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesScript> script{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesStrategy> strategy{};
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodesTags>> tags{};
  shared_ptr<long> taskId{};
  shared_ptr<ListNodesResponseBodyPagingInfoNodesTrigger> trigger{};

  ListNodesResponseBodyPagingInfoNodes() {}

  explicit ListNodesResponseBodyPagingInfoNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListNodesResponseBodyPagingInfoNodesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListNodesResponseBodyPagingInfoNodesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        ListNodesResponseBodyPagingInfoNodesInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<ListNodesResponseBodyPagingInfoNodesInputs>(model1);
      }
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        ListNodesResponseBodyPagingInfoNodesOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<ListNodesResponseBodyPagingInfoNodesOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListNodesResponseBodyPagingInfoNodesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListNodesResponseBodyPagingInfoNodesRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListNodesResponseBodyPagingInfoNodesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListNodesResponseBodyPagingInfoNodesScript>(model1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListNodesResponseBodyPagingInfoNodesStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListNodesResponseBodyPagingInfoNodesStrategy>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListNodesResponseBodyPagingInfoNodesTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListNodesResponseBodyPagingInfoNodesTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListNodesResponseBodyPagingInfoNodesTrigger>(model1);
      }
    }
  }


  virtual ~ListNodesResponseBodyPagingInfoNodes() = default;
};
class ListNodesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPagingInfoNodes>> nodes{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};

  ListNodesResponseBodyPagingInfo() {}

  explicit ListNodesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodesResponseBodyPagingInfoNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPagingInfoNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseBodyPagingInfoNodes>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNodesResponseBodyPagingInfo() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNodesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListNodesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListNodesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListPartitionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tableId{};

  ListPartitionsRequest() {}

  explicit ListPartitionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
  }


  virtual ~ListPartitionsRequest() = default;
};
class ListPartitionsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<Partition>> partitionList{};
  shared_ptr<long> totalCount{};

  ListPartitionsResponseBodyPagingInfo() {}

  explicit ListPartitionsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (partitionList) {
      vector<boost::any> temp1;
      for(auto item1:*partitionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PartitionList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PartitionList") != m.end() && !m["PartitionList"].empty()) {
      if (typeid(vector<boost::any>) == m["PartitionList"].type()) {
        vector<Partition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PartitionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Partition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        partitionList = make_shared<vector<Partition>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPartitionsResponseBodyPagingInfo() = default;
};
class ListPartitionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPartitionsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPartitionsResponseBody() {}

  explicit ListPartitionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListPartitionsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListPartitionsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPartitionsResponseBody() = default;
};
class ListPartitionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPartitionsResponseBody> body{};

  ListPartitionsResponse() {}

  explicit ListPartitionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPartitionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPartitionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPartitionsResponse() = default;
};
class ListPipelineRunItemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pipelineRunId{};
  shared_ptr<long> projectId{};

  ListPipelineRunItemsRequest() {}

  explicit ListPipelineRunItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineRunId) {
      res["PipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineRunId") != m.end() && !m["PipelineRunId"].empty()) {
      pipelineRunId = make_shared<string>(boost::any_cast<string>(m["PipelineRunId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListPipelineRunItemsRequest() = default;
};
class ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> version{};

  ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems() {}

  explicit ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems() = default;
};
class ListPipelineRunItemsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems>> pipelineRunItems{};
  shared_ptr<long> totalCount{};

  ListPipelineRunItemsResponseBodyPagingInfo() {}

  explicit ListPipelineRunItemsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineRunItems) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineRunItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineRunItems"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineRunItems") != m.end() && !m["PipelineRunItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineRunItems"].type()) {
        vector<ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineRunItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineRunItems = make_shared<vector<ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPipelineRunItemsResponseBodyPagingInfo() = default;
};
class ListPipelineRunItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPipelineRunItemsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListPipelineRunItemsResponseBody() {}

  explicit ListPipelineRunItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListPipelineRunItemsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListPipelineRunItemsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPipelineRunItemsResponseBody() = default;
};
class ListPipelineRunItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineRunItemsResponseBody> body{};

  ListPipelineRunItemsResponse() {}

  explicit ListPipelineRunItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineRunItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineRunItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineRunItemsResponse() = default;
};
class ListPipelineRunsRequest : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};

  ListPipelineRunsRequest() {}

  explicit ListPipelineRunsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPipelineRunsRequest() = default;
};
class ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<long> step{};
  shared_ptr<string> type{};

  ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages() {}

  explicit ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages() = default;
};
class ListPipelineRunsResponseBodyPagingInfoPipelineRuns : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages>> stages{};
  shared_ptr<string> status{};

  ListPipelineRunsResponseBodyPagingInfoPipelineRuns() {}

  explicit ListPipelineRunsResponseBodyPagingInfoPipelineRuns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stages"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      if (typeid(vector<boost::any>) == m["Stages"].type()) {
        vector<ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPipelineRunsResponseBodyPagingInfoPipelineRuns() = default;
};
class ListPipelineRunsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListPipelineRunsResponseBodyPagingInfoPipelineRuns>> pipelineRuns{};
  shared_ptr<long> totalCount{};

  ListPipelineRunsResponseBodyPagingInfo() {}

  explicit ListPipelineRunsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineRuns) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineRuns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineRuns"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineRuns") != m.end() && !m["PipelineRuns"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineRuns"].type()) {
        vector<ListPipelineRunsResponseBodyPagingInfoPipelineRuns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineRuns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineRunsResponseBodyPagingInfoPipelineRuns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineRuns = make_shared<vector<ListPipelineRunsResponseBodyPagingInfoPipelineRuns>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPipelineRunsResponseBodyPagingInfo() = default;
};
class ListPipelineRunsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPipelineRunsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListPipelineRunsResponseBody() {}

  explicit ListPipelineRunsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListPipelineRunsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListPipelineRunsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPipelineRunsResponseBody() = default;
};
class ListPipelineRunsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineRunsResponseBody> body{};

  ListPipelineRunsResponse() {}

  explicit ListPipelineRunsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineRunsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineRunsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineRunsResponse() = default;
};
class ListProjectMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<vector<string>> userIds{};

  ListProjectMembersRequest() {}

  explicit ListProjectMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectMembersRequest() = default;
};
class ListProjectMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userIdsShrink{};

  ListProjectMembersShrinkRequest() {}

  explicit ListProjectMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~ListProjectMembersShrinkRequest() = default;
};
class ListProjectMembersResponseBodyPagingInfoProjectMembersRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListProjectMembersResponseBodyPagingInfoProjectMembersRoles() {}

  explicit ListProjectMembersResponseBodyPagingInfoProjectMembersRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfoProjectMembersRoles() = default;
};
class ListProjectMembersResponseBodyPagingInfoProjectMembers : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles>> roles{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  ListProjectMembersResponseBodyPagingInfoProjectMembers() {}

  explicit ListProjectMembersResponseBodyPagingInfoProjectMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyPagingInfoProjectMembersRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<ListProjectMembersResponseBodyPagingInfoProjectMembersRoles>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfoProjectMembers() = default;
};
class ListProjectMembersResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProjectMembersResponseBodyPagingInfoProjectMembers>> projectMembers{};
  shared_ptr<long> totalCount{};

  ListProjectMembersResponseBodyPagingInfo() {}

  explicit ListProjectMembersResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectMembers) {
      vector<boost::any> temp1;
      for(auto item1:*projectMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectMembers"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectMembers") != m.end() && !m["ProjectMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectMembers"].type()) {
        vector<ListProjectMembersResponseBodyPagingInfoProjectMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyPagingInfoProjectMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectMembers = make_shared<vector<ListProjectMembersResponseBodyPagingInfoProjectMembers>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyPagingInfo() = default;
};
class ListProjectMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectMembersResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectMembersResponseBody() {}

  explicit ListProjectMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectMembersResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectMembersResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectMembersResponseBody() = default;
};
class ListProjectMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectMembersResponseBody> body{};

  ListProjectMembersResponse() {}

  explicit ListProjectMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponse() = default;
};
class ListProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> codes{};
  shared_ptr<vector<string>> names{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesRequest() {}

  explicit ListProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codes) {
      res["Codes"] = boost::any(*codes);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Codes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Codes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      codes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      names = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesRequest() = default;
};
class ListProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> codesShrink{};
  shared_ptr<string> namesShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesShrinkRequest() {}

  explicit ListProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codesShrink) {
      res["Codes"] = boost::any(*codesShrink);
    }
    if (namesShrink) {
      res["Names"] = boost::any(*namesShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      codesShrink = make_shared<string>(boost::any_cast<string>(m["Codes"]));
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      namesShrink = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesShrinkRequest() = default;
};
class ListProjectRolesResponseBodyPagingInfoProjectRoles : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListProjectRolesResponseBodyPagingInfoProjectRoles() {}

  explicit ListProjectRolesResponseBodyPagingInfoProjectRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectRolesResponseBodyPagingInfoProjectRoles() = default;
};
class ListProjectRolesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<vector<ListProjectRolesResponseBodyPagingInfoProjectRoles>> projectRoles{};
  shared_ptr<string> totalCount{};

  ListProjectRolesResponseBodyPagingInfo() {}

  explicit ListProjectRolesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectRoles) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoles"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ProjectRoles") != m.end() && !m["ProjectRoles"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoles"].type()) {
        vector<ListProjectRolesResponseBodyPagingInfoProjectRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectRolesResponseBodyPagingInfoProjectRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoles = make_shared<vector<ListProjectRolesResponseBodyPagingInfoProjectRoles>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectRolesResponseBodyPagingInfo() = default;
};
class ListProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectRolesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectRolesResponseBody() {}

  explicit ListProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectRolesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectRolesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectRolesResponseBody() = default;
};
class ListProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectRolesResponseBody> body{};

  ListProjectRolesResponse() {}

  explicit ListProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectRolesResponse() = default;
};
class ListProjectsRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListProjectsRequestAliyunResourceTags() {}

  explicit ListProjectsRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListProjectsRequestAliyunResourceTags() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListProjectsRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<vector<string>> names{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListProjectsRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListProjectsRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      names = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> namesShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsShrinkRequest() {}

  explicit ListProjectsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (namesShrink) {
      res["Names"] = boost::any(*namesShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      namesShrink = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsShrinkRequest() = default;
};
class ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags() {}

  explicit ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags() = default;
};
class ListProjectsResponseBodyPagingInfoProjects : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  ListProjectsResponseBodyPagingInfoProjects() {}

  explicit ListProjectsResponseBodyPagingInfoProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfoProjects() = default;
};
class ListProjectsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProjectsResponseBodyPagingInfoProjects>> projects{};
  shared_ptr<long> totalCount{};

  ListProjectsResponseBodyPagingInfo() {}

  explicit ListProjectsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<ListProjectsResponseBodyPagingInfoProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyPagingInfoProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<ListProjectsResponseBodyPagingInfoProjects>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectsResponseBodyPagingInfo() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListProjectsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListProjectsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListProjectsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListResourceGroupsRequestAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListResourceGroupsRequestAliyunResourceTags() {}

  explicit ListResourceGroupsRequestAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListResourceGroupsRequestAliyunResourceTags() = default;
};
class ListResourceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListResourceGroupsRequestAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> resourceGroupTypes{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> statuses{};

  ListResourceGroupsRequest() {}

  explicit ListResourceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupTypes) {
      res["ResourceGroupTypes"] = boost::any(*resourceGroupTypes);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListResourceGroupsRequestAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsRequestAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListResourceGroupsRequestAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupTypes") != m.end() && !m["ResourceGroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceGroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceGroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceGroupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListResourceGroupsRequest() = default;
};
class ListResourceGroupsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> aliyunResourceTagsShrink{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupTypesShrink{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> statusesShrink{};

  ListResourceGroupsShrinkRequest() {}

  explicit ListResourceGroupsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTagsShrink) {
      res["AliyunResourceTags"] = boost::any(*aliyunResourceTagsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupTypesShrink) {
      res["ResourceGroupTypes"] = boost::any(*resourceGroupTypesShrink);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (statusesShrink) {
      res["Statuses"] = boost::any(*statusesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      aliyunResourceTagsShrink = make_shared<string>(boost::any_cast<string>(m["AliyunResourceTags"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupTypes") != m.end() && !m["ResourceGroupTypes"].empty()) {
      resourceGroupTypesShrink = make_shared<string>(boost::any_cast<string>(m["ResourceGroupTypes"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statusesShrink = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
  }


  virtual ~ListResourceGroupsShrinkRequest() = default;
};
class ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags() {}

  explicit ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags() = default;
};
class ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> standard{};

  ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec() {}

  explicit ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (standard) {
      res["Standard"] = boost::any(*standard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Standard") != m.end() && !m["Standard"].empty()) {
      standard = make_shared<string>(boost::any_cast<string>(m["Standard"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec() = default;
};
class ListResourceGroupsResponseBodyPagingInfoResourceGroupList : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags>> aliyunResourceTags{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> defaultVpcId{};
  shared_ptr<string> defaultVswicthId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec> spec{};
  shared_ptr<string> status{};

  ListResourceGroupsResponseBodyPagingInfoResourceGroupList() {}

  explicit ListResourceGroupsResponseBodyPagingInfoResourceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (aliyunResourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunResourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunResourceTags"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (defaultVpcId) {
      res["DefaultVpcId"] = boost::any(*defaultVpcId);
    }
    if (defaultVswicthId) {
      res["DefaultVswicthId"] = boost::any(*defaultVswicthId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("AliyunResourceTags") != m.end() && !m["AliyunResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunResourceTags"].type()) {
        vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunResourceTags = make_shared<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DefaultVpcId") != m.end() && !m["DefaultVpcId"].empty()) {
      defaultVpcId = make_shared<string>(boost::any_cast<string>(m["DefaultVpcId"]));
    }
    if (m.find("DefaultVswicthId") != m.end() && !m["DefaultVswicthId"].empty()) {
      defaultVswicthId = make_shared<string>(boost::any_cast<string>(m["DefaultVswicthId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfoResourceGroupList() = default;
};
class ListResourceGroupsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList>> resourceGroupList{};
  shared_ptr<long> totalCount{};

  ListResourceGroupsResponseBodyPagingInfo() {}

  explicit ListResourceGroupsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceGroupList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceGroupList"].type()) {
        vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsResponseBodyPagingInfoResourceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceGroupList = make_shared<vector<ListResourceGroupsResponseBodyPagingInfoResourceGroupList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyPagingInfo() = default;
};
class ListResourceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourceGroupsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListResourceGroupsResponseBody() {}

  explicit ListResourceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListResourceGroupsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListResourceGroupsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListResourceGroupsResponseBody() = default;
};
class ListResourceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceGroupsResponseBody> body{};

  ListResourceGroupsResponse() {}

  explicit ListResourceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceGroupsResponse() = default;
};
class ListResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListResourcesRequest() {}

  explicit ListResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesRequest() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListResourcesResponseBodyPagingInfoResourcesDataSource() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesDataSource() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListResourcesResponseBodyPagingInfoResourcesScriptRuntime() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesScriptRuntime() = default;
};
class ListResourcesResponseBodyPagingInfoResourcesScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesScriptRuntime> runtime{};

  ListResourcesResponseBodyPagingInfoResourcesScript() {}

  explicit ListResourcesResponseBodyPagingInfoResourcesScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListResourcesResponseBodyPagingInfoResourcesScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResourcesScript() = default;
};
class ListResourcesResponseBodyPagingInfoResources : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesDataSource> dataSource{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<ListResourcesResponseBodyPagingInfoResourcesScript> script{};
  shared_ptr<string> sourcePath{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetPath{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  ListResourcesResponseBodyPagingInfoResources() {}

  explicit ListResourcesResponseBodyPagingInfoResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourcePath) {
      res["SourcePath"] = boost::any(*sourcePath);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetPath) {
      res["TargetPath"] = boost::any(*targetPath);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListResourcesResponseBodyPagingInfoResourcesDataSource>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListResourcesResponseBodyPagingInfoResourcesScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListResourcesResponseBodyPagingInfoResourcesScript>(model1);
      }
    }
    if (m.find("SourcePath") != m.end() && !m["SourcePath"].empty()) {
      sourcePath = make_shared<string>(boost::any_cast<string>(m["SourcePath"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetPath") != m.end() && !m["TargetPath"].empty()) {
      targetPath = make_shared<string>(boost::any_cast<string>(m["TargetPath"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfoResources() = default;
};
class ListResourcesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListResourcesResponseBodyPagingInfoResources>> resources{};
  shared_ptr<long> totalCount{};

  ListResourcesResponseBodyPagingInfo() {}

  explicit ListResourcesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<ListResourcesResponseBodyPagingInfoResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcesResponseBodyPagingInfoResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<ListResourcesResponseBodyPagingInfoResources>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourcesResponseBodyPagingInfo() = default;
};
class ListResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourcesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListResourcesResponseBody() {}

  explicit ListResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListResourcesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListResourcesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListResourcesResponseBody() = default;
};
class ListResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcesResponseBody> body{};

  ListResourcesResponse() {}

  explicit ListResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcesResponse() = default;
};
class ListRoutesRequest : public Darabonba::Model {
public:
  shared_ptr<long> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sortBy{};

  ListRoutesRequest() {}

  explicit ListRoutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListRoutesRequest() = default;
};
class ListRoutesResponseBodyPagingInfoRouteList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  ListRoutesResponseBodyPagingInfoRouteList() {}

  explicit ListRoutesResponseBodyPagingInfoRouteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListRoutesResponseBodyPagingInfoRouteList() = default;
};
class ListRoutesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListRoutesResponseBodyPagingInfoRouteList>> routeList{};
  shared_ptr<long> totalCount{};

  ListRoutesResponseBodyPagingInfo() {}

  explicit ListRoutesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (routeList) {
      vector<boost::any> temp1;
      for(auto item1:*routeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RouteList") != m.end() && !m["RouteList"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteList"].type()) {
        vector<ListRoutesResponseBodyPagingInfoRouteList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoutesResponseBodyPagingInfoRouteList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeList = make_shared<vector<ListRoutesResponseBodyPagingInfoRouteList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRoutesResponseBodyPagingInfo() = default;
};
class ListRoutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRoutesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListRoutesResponseBody() {}

  explicit ListRoutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListRoutesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListRoutesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRoutesResponseBody() = default;
};
class ListRoutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRoutesResponseBody> body{};

  ListRoutesResponse() {}

  explicit ListRoutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoutesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoutesResponse() = default;
};
class ListSchemasRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> types{};

  ListSchemasRequest() {}

  explicit ListSchemasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListSchemasRequest() = default;
};
class ListSchemasShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> typesShrink{};

  ListSchemasShrinkRequest() {}

  explicit ListSchemasShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListSchemasShrinkRequest() = default;
};
class ListSchemasResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<Schema>> schemas{};
  shared_ptr<long> totalCount{};

  ListSchemasResponseBodyPagingInfo() {}

  explicit ListSchemasResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (schemas) {
      vector<boost::any> temp1;
      for(auto item1:*schemas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schemas"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Schemas") != m.end() && !m["Schemas"].empty()) {
      if (typeid(vector<boost::any>) == m["Schemas"].type()) {
        vector<Schema> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schemas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Schema model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schemas = make_shared<vector<Schema>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSchemasResponseBodyPagingInfo() = default;
};
class ListSchemasResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSchemasResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSchemasResponseBody() {}

  explicit ListSchemasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListSchemasResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListSchemasResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSchemasResponseBody() = default;
};
class ListSchemasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSchemasResponseBody> body{};

  ListSchemasResponse() {}

  explicit ListSchemasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSchemasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSchemasResponseBody>(model1);
      }
    }
  }


  virtual ~ListSchemasResponse() = default;
};
class ListTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> tableTypes{};

  ListTablesRequest() {}

  explicit ListTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tableTypes) {
      res["TableTypes"] = boost::any(*tableTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TableTypes") != m.end() && !m["TableTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTablesRequest() = default;
};
class ListTablesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentMetaEntityId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> tableTypesShrink{};

  ListTablesShrinkRequest() {}

  explicit ListTablesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentMetaEntityId) {
      res["ParentMetaEntityId"] = boost::any(*parentMetaEntityId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (tableTypesShrink) {
      res["TableTypes"] = boost::any(*tableTypesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentMetaEntityId") != m.end() && !m["ParentMetaEntityId"].empty()) {
      parentMetaEntityId = make_shared<string>(boost::any_cast<string>(m["ParentMetaEntityId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TableTypes") != m.end() && !m["TableTypes"].empty()) {
      tableTypesShrink = make_shared<string>(boost::any_cast<string>(m["TableTypes"]));
    }
  }


  virtual ~ListTablesShrinkRequest() = default;
};
class ListTablesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<Table>> tables{};
  shared_ptr<long> totalCount{};

  ListTablesResponseBodyPagingInfo() {}

  explicit ListTablesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<Table> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Table model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<Table>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTablesResponseBodyPagingInfo() = default;
};
class ListTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTablesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTablesResponseBody() {}

  explicit ListTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTablesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTablesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTablesResponseBody() = default;
};
class ListTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTablesResponseBody> body{};

  ListTablesResponse() {}

  explicit ListTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTablesResponse() = default;
};
class ListTaskInstanceOperationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListTaskInstanceOperationLogsRequest() {}

  explicit ListTaskInstanceOperationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsRequest() = default;
};
class ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> operationContent{};
  shared_ptr<long> operationSeq{};
  shared_ptr<long> taskInstanceId{};
  shared_ptr<string> user{};

  ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs() {}

  explicit ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (operationContent) {
      res["OperationContent"] = boost::any(*operationContent);
    }
    if (operationSeq) {
      res["OperationSeq"] = boost::any(*operationSeq);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("OperationContent") != m.end() && !m["OperationContent"].empty()) {
      operationContent = make_shared<string>(boost::any_cast<string>(m["OperationContent"]));
    }
    if (m.find("OperationSeq") != m.end() && !m["OperationSeq"].empty()) {
      operationSeq = make_shared<long>(boost::any_cast<long>(m["OperationSeq"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs() = default;
};
class ListTaskInstanceOperationLogsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs>> operationLogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTaskInstanceOperationLogsResponseBodyPagingInfo() {}

  explicit ListTaskInstanceOperationLogsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLogs) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLogs") != m.end() && !m["OperationLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogs"].type()) {
        vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogs = make_shared<vector<ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBodyPagingInfo() = default;
};
class ListTaskInstanceOperationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskInstanceOperationLogsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskInstanceOperationLogsResponseBody() {}

  explicit ListTaskInstanceOperationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskInstanceOperationLogsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskInstanceOperationLogsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponseBody() = default;
};
class ListTaskInstanceOperationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskInstanceOperationLogsResponseBody> body{};

  ListTaskInstanceOperationLogsResponse() {}

  explicit ListTaskInstanceOperationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskInstanceOperationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskInstanceOperationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskInstanceOperationLogsResponse() = default;
};
class ListTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizdate{};
  shared_ptr<long> id{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};

  ListTaskInstancesRequest() {}

  explicit ListTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
  }


  virtual ~ListTaskInstancesRequest() = default;
};
class ListTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizdate{};
  shared_ptr<long> id{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskIdsShrink{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};

  ListTaskInstancesShrinkRequest() {}

  explicit ListTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
  }


  virtual ~ListTaskInstancesShrinkRequest() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};

  ListTaskInstancesResponseBodyPagingInfo() {}

  explicit ListTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskInstancesResponseBodyPagingInfo() = default;
};
class ListTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskInstancesResponseBody() {}

  explicit ListTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskInstancesResponseBody() = default;
};
class ListTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskInstancesResponseBody> body{};

  ListTaskInstancesResponse() {}

  explicit ListTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskInstancesResponse() = default;
};
class ListTaskOperationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListTaskOperationLogsRequest() {}

  explicit ListTaskOperationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListTaskOperationLogsRequest() = default;
};
class ListTaskOperationLogsResponseBodyPagingInfoOperationLogs : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> operationContent{};
  shared_ptr<long> operationSeq{};
  shared_ptr<long> taskId{};
  shared_ptr<string> user{};

  ListTaskOperationLogsResponseBodyPagingInfoOperationLogs() {}

  explicit ListTaskOperationLogsResponseBodyPagingInfoOperationLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (operationContent) {
      res["OperationContent"] = boost::any(*operationContent);
    }
    if (operationSeq) {
      res["OperationSeq"] = boost::any(*operationSeq);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("OperationContent") != m.end() && !m["OperationContent"].empty()) {
      operationContent = make_shared<string>(boost::any_cast<string>(m["OperationContent"]));
    }
    if (m.find("OperationSeq") != m.end() && !m["OperationSeq"].empty()) {
      operationSeq = make_shared<long>(boost::any_cast<long>(m["OperationSeq"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBodyPagingInfoOperationLogs() = default;
};
class ListTaskOperationLogsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs>> operationLogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTaskOperationLogsResponseBodyPagingInfo() {}

  explicit ListTaskOperationLogsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLogs) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLogs") != m.end() && !m["OperationLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogs"].type()) {
        vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskOperationLogsResponseBodyPagingInfoOperationLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogs = make_shared<vector<ListTaskOperationLogsResponseBodyPagingInfoOperationLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBodyPagingInfo() = default;
};
class ListTaskOperationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskOperationLogsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTaskOperationLogsResponseBody() {}

  explicit ListTaskOperationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTaskOperationLogsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTaskOperationLogsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTaskOperationLogsResponseBody() = default;
};
class ListTaskOperationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskOperationLogsResponseBody> body{};

  ListTaskOperationLogsResponse() {}

  explicit ListTaskOperationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskOperationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskOperationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskOperationLogsResponse() = default;
};
class ListTasksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};

  ListTasksRequest() {}

  explicit ListTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksRequest() = default;
};
class ListTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeResource{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> taskType{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};

  ListTasksShrinkRequest() {}

  explicit ListTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksShrinkRequest() = default;
};
class ListTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  ListTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> scriptParameters{};
  shared_ptr<long> timeout{};
  shared_ptr<ListTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListTasksResponseBodyPagingInfoTasks() {}

  explicit ListTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptParameters) {
      res["ScriptParameters"] = boost::any(*scriptParameters);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("ScriptParameters") != m.end() && !m["ScriptParameters"].empty()) {
      scriptParameters = make_shared<string>(boost::any_cast<string>(m["ScriptParameters"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfoTasks() = default;
};
class ListTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListTasksResponseBodyPagingInfo() {}

  explicit ListTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTasksResponseBodyPagingInfo() = default;
};
class ListTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListTasksResponseBody() {}

  explicit ListTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTasksResponseBody() = default;
};
class ListTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTasksResponseBody> body{};

  ListTasksResponse() {}

  explicit ListTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListTasksResponse() = default;
};
class ListUpstreamTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUpstreamTaskInstancesRequest() {}

  explicit ListUpstreamTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesRequest() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime> runtime{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stepType{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime : public Darabonba::Model {
public:
  shared_ptr<string> gateway{};
  shared_ptr<string> processId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> owner{};
  shared_ptr<long> periodNumber{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> runNumber{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime> runtime{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource> runtimeResource{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerRecurrence{};
  shared_ptr<long> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<long> workflowId{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowInstanceType{};
  shared_ptr<string> workflowName{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (periodNumber) {
      res["PeriodNumber"] = boost::any(*periodNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (runNumber) {
      res["RunNumber"] = boost::any(*runNumber);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerRecurrence) {
      res["TriggerRecurrence"] = boost::any(*triggerRecurrence);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowInstanceType) {
      res["WorkflowInstanceType"] = boost::any(*workflowInstanceType);
    }
    if (workflowName) {
      res["WorkflowName"] = boost::any(*workflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PeriodNumber") != m.end() && !m["PeriodNumber"].empty()) {
      periodNumber = make_shared<long>(boost::any_cast<long>(m["PeriodNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RunNumber") != m.end() && !m["RunNumber"].empty()) {
      runNumber = make_shared<long>(boost::any_cast<long>(m["RunNumber"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime>(model1);
      }
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource>(model1);
      }
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TriggerRecurrence") != m.end() && !m["TriggerRecurrence"].empty()) {
      triggerRecurrence = make_shared<string>(boost::any_cast<string>(m["TriggerRecurrence"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowInstanceType") != m.end() && !m["WorkflowInstanceType"].empty()) {
      workflowInstanceType = make_shared<string>(boost::any_cast<string>(m["WorkflowInstanceType"]));
    }
    if (m.find("WorkflowName") != m.end() && !m["WorkflowName"].empty()) {
      workflowName = make_shared<string>(boost::any_cast<string>(m["WorkflowName"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance> taskInstance{};

  ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (taskInstance) {
      res["TaskInstance"] = taskInstance ? boost::any(taskInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("TaskInstance") != m.end() && !m["TaskInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInstance"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInstance"]));
        taskInstance = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance>(model1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances() = default;
};
class ListUpstreamTaskInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances>> taskInstances{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances>> upstreamTaskInstances{};

  ListUpstreamTaskInstancesResponseBodyPagingInfo() {}

  explicit ListUpstreamTaskInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (upstreamTaskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamTaskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamTaskInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UpstreamTaskInstances") != m.end() && !m["UpstreamTaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamTaskInstances"].type()) {
        vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamTaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamTaskInstances = make_shared<vector<ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBodyPagingInfo() = default;
};
class ListUpstreamTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamTaskInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListUpstreamTaskInstancesResponseBody() {}

  explicit ListUpstreamTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListUpstreamTaskInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListUpstreamTaskInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUpstreamTaskInstancesResponseBody() = default;
};
class ListUpstreamTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUpstreamTaskInstancesResponseBody> body{};

  ListUpstreamTaskInstancesResponse() {}

  explicit ListUpstreamTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamTaskInstancesResponse() = default;
};
class ListUpstreamTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectEnv{};

  ListUpstreamTasksRequest() {}

  explicit ListUpstreamTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListUpstreamTasksRequest() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTasksResponseBodyPagingInfoTasksDataSource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksDataSource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListUpstreamTasksResponseBodyPagingInfoTasksTrigger() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasksTrigger() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoTasks : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<string> projectEnv{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource> runtimeResource{};
  shared_ptr<string> stepType{};
  shared_ptr<long> timeout{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoTasksTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListUpstreamTasksResponseBodyPagingInfoTasks() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["StepType"] = boost::any(*stepType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource>(model1);
      }
    }
    if (m.find("StepType") != m.end() && !m["StepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["StepType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListUpstreamTasksResponseBodyPagingInfoTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoTasks() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource> runtimeResource{};
  shared_ptr<long> timeout{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger> trigger{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask() = default;
};
class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks : public Darabonba::Model {
public:
  shared_ptr<string> dependencyType{};
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask> task{};

  ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks() {}

  explicit ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencyType) {
      res["DependencyType"] = boost::any(*dependencyType);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependencyType") != m.end() && !m["DependencyType"].empty()) {
      dependencyType = make_shared<string>(boost::any_cast<string>(m["DependencyType"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask>(model1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks() = default;
};
class ListUpstreamTasksResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListUpstreamTasksResponseBodyPagingInfoTasks>> tasks{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks>> upstreamTasks{};

  ListUpstreamTasksResponseBodyPagingInfo() {}

  explicit ListUpstreamTasksResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (upstreamTasks) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListUpstreamTasksResponseBodyPagingInfoTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTasksResponseBodyPagingInfoTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListUpstreamTasksResponseBodyPagingInfoTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UpstreamTasks") != m.end() && !m["UpstreamTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamTasks"].type()) {
        vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamTasks = make_shared<vector<ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponseBodyPagingInfo() = default;
};
class ListUpstreamTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamTasksResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListUpstreamTasksResponseBody() {}

  explicit ListUpstreamTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListUpstreamTasksResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListUpstreamTasksResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUpstreamTasksResponseBody() = default;
};
class ListUpstreamTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUpstreamTasksResponseBody> body{};

  ListUpstreamTasksResponse() {}

  explicit ListUpstreamTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamTasksResponse() = default;
};
class ListWorkflowDefinitionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> type{};

  ListWorkflowDefinitionsRequest() {}

  explicit ListWorkflowDefinitionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowDefinitionsRequest() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime : public Darabonba::Model {
public:
  shared_ptr<string> command{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime> runtime{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime>(model1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript> script{};
  shared_ptr<string> type{};

  ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions() = default;
};
class ListWorkflowDefinitionsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions>> workflowDefinitions{};

  ListWorkflowDefinitionsResponseBodyPagingInfo() {}

  explicit ListWorkflowDefinitionsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflowDefinitions) {
      vector<boost::any> temp1;
      for(auto item1:*workflowDefinitions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowDefinitions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WorkflowDefinitions") != m.end() && !m["WorkflowDefinitions"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowDefinitions"].type()) {
        vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowDefinitions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowDefinitions = make_shared<vector<ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBodyPagingInfo() = default;
};
class ListWorkflowDefinitionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowDefinitionsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowDefinitionsResponseBody() {}

  explicit ListWorkflowDefinitionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowDefinitionsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowDefinitionsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowDefinitionsResponseBody() = default;
};
class ListWorkflowDefinitionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowDefinitionsResponseBody> body{};

  ListWorkflowDefinitionsResponse() {}

  explicit ListWorkflowDefinitionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowDefinitionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowDefinitionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowDefinitionsResponse() = default;
};
class ListWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesRequest() {}

  explicit ListWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesRequest() = default;
};
class ListWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesShrinkRequest() {}

  explicit ListWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesShrinkRequest() = default;
};
class ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> envType{};
  shared_ptr<long> finishedTime{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<long> startedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> workflowId{};

  ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances() {}

  explicit ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startedTime) {
      res["StartedTime"] = boost::any(*startedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartedTime") != m.end() && !m["StartedTime"].empty()) {
      startedTime = make_shared<long>(boost::any_cast<long>(m["StartedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<long>(boost::any_cast<long>(m["WorkflowId"]));
    }
  }


  virtual ~ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances() = default;
};
class ListWorkflowInstancesResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances>> workflowInstances{};

  ListWorkflowInstancesResponseBodyPagingInfo() {}

  explicit ListWorkflowInstancesResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflowInstances) {
      vector<boost::any> temp1;
      for(auto item1:*workflowInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WorkflowInstances") != m.end() && !m["WorkflowInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowInstances"].type()) {
        vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowInstances = make_shared<vector<ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowInstancesResponseBodyPagingInfo() = default;
};
class ListWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowInstancesResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowInstancesResponseBody() {}

  explicit ListWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowInstancesResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowInstancesResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowInstancesResponseBody() = default;
};
class ListWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowInstancesResponseBody> body{};

  ListWorkflowInstancesResponse() {}

  explicit ListWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowInstancesResponse() = default;
};
class ListWorkflowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> triggerType{};

  ListWorkflowsRequest() {}

  explicit ListWorkflowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ListWorkflowsRequest() = default;
};
class ListWorkflowsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> triggerType{};

  ListWorkflowsShrinkRequest() {}

  explicit ListWorkflowsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ListWorkflowsShrinkRequest() = default;
};
class ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger() {}

  explicit ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger() = default;
};
class ListWorkflowsResponseBodyPagingInfoWorkflows : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> modifyUser{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<long> projectId{};
  shared_ptr<ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger> trigger{};

  ListWorkflowsResponseBodyPagingInfoWorkflows() {}

  explicit ListWorkflowsResponseBodyPagingInfoWorkflows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger>(model1);
      }
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfoWorkflows() = default;
};
class ListWorkflowsResponseBodyPagingInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkflowsResponseBodyPagingInfoWorkflows>> workflows{};

  ListWorkflowsResponseBodyPagingInfo() {}

  explicit ListWorkflowsResponseBodyPagingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (workflows) {
      vector<boost::any> temp1;
      for(auto item1:*workflows){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Workflows"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Workflows") != m.end() && !m["Workflows"].empty()) {
      if (typeid(vector<boost::any>) == m["Workflows"].type()) {
        vector<ListWorkflowsResponseBodyPagingInfoWorkflows> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Workflows"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkflowsResponseBodyPagingInfoWorkflows model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflows = make_shared<vector<ListWorkflowsResponseBodyPagingInfoWorkflows>>(expect1);
      }
    }
  }


  virtual ~ListWorkflowsResponseBodyPagingInfo() = default;
};
class ListWorkflowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListWorkflowsResponseBodyPagingInfo> pagingInfo{};
  shared_ptr<string> requestId{};

  ListWorkflowsResponseBody() {}

  explicit ListWorkflowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagingInfo) {
      res["PagingInfo"] = pagingInfo ? boost::any(pagingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagingInfo") != m.end() && !m["PagingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagingInfo"].type()) {
        ListWorkflowsResponseBodyPagingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagingInfo"]));
        pagingInfo = make_shared<ListWorkflowsResponseBodyPagingInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWorkflowsResponseBody() = default;
};
class ListWorkflowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkflowsResponseBody> body{};

  ListWorkflowsResponse() {}

  explicit ListWorkflowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkflowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkflowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkflowsResponse() = default;
};
class MoveFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveFunctionRequest() {}

  explicit MoveFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveFunctionRequest() = default;
};
class MoveFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveFunctionResponseBody() {}

  explicit MoveFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveFunctionResponseBody() = default;
};
class MoveFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveFunctionResponseBody> body{};

  MoveFunctionResponse() {}

  explicit MoveFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~MoveFunctionResponse() = default;
};
class MoveNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveNodeRequest() {}

  explicit MoveNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveNodeRequest() = default;
};
class MoveNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveNodeResponseBody() {}

  explicit MoveNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveNodeResponseBody() = default;
};
class MoveNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveNodeResponseBody> body{};

  MoveNodeResponse() {}

  explicit MoveNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveNodeResponseBody>(model1);
      }
    }
  }


  virtual ~MoveNodeResponse() = default;
};
class MoveResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveResourceRequest() {}

  explicit MoveResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveResourceRequest() = default;
};
class MoveResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveResourceResponseBody() {}

  explicit MoveResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveResourceResponseBody() = default;
};
class MoveResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveResourceResponseBody> body{};

  MoveResourceResponse() {}

  explicit MoveResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceResponse() = default;
};
class MoveWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> path{};
  shared_ptr<long> projectId{};

  MoveWorkflowDefinitionRequest() {}

  explicit MoveWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~MoveWorkflowDefinitionRequest() = default;
};
class MoveWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveWorkflowDefinitionResponseBody() {}

  explicit MoveWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveWorkflowDefinitionResponseBody() = default;
};
class MoveWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveWorkflowDefinitionResponseBody> body{};

  MoveWorkflowDefinitionResponse() {}

  explicit MoveWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~MoveWorkflowDefinitionResponse() = default;
};
class RemoveEntityFromMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> metaCollectionId{};

  RemoveEntityFromMetaCollectionRequest() {}

  explicit RemoveEntityFromMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metaCollectionId) {
      res["MetaCollectionId"] = boost::any(*metaCollectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MetaCollectionId") != m.end() && !m["MetaCollectionId"].empty()) {
      metaCollectionId = make_shared<string>(boost::any_cast<string>(m["MetaCollectionId"]));
    }
  }


  virtual ~RemoveEntityFromMetaCollectionRequest() = default;
};
class RemoveEntityFromMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveEntityFromMetaCollectionResponseBody() {}

  explicit RemoveEntityFromMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveEntityFromMetaCollectionResponseBody() = default;
};
class RemoveEntityFromMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveEntityFromMetaCollectionResponseBody> body{};

  RemoveEntityFromMetaCollectionResponse() {}

  explicit RemoveEntityFromMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveEntityFromMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveEntityFromMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveEntityFromMetaCollectionResponse() = default;
};
class RemoveTaskInstanceDependenciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<vector<long>> upstreamTaskInstanceIds{};

  RemoveTaskInstanceDependenciesRequest() {}

  explicit RemoveTaskInstanceDependenciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (upstreamTaskInstanceIds) {
      res["UpstreamTaskInstanceIds"] = boost::any(*upstreamTaskInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UpstreamTaskInstanceIds") != m.end() && !m["UpstreamTaskInstanceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["UpstreamTaskInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UpstreamTaskInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      upstreamTaskInstanceIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RemoveTaskInstanceDependenciesRequest() = default;
};
class RemoveTaskInstanceDependenciesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<string> upstreamTaskInstanceIdsShrink{};

  RemoveTaskInstanceDependenciesShrinkRequest() {}

  explicit RemoveTaskInstanceDependenciesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (upstreamTaskInstanceIdsShrink) {
      res["UpstreamTaskInstanceIds"] = boost::any(*upstreamTaskInstanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UpstreamTaskInstanceIds") != m.end() && !m["UpstreamTaskInstanceIds"].empty()) {
      upstreamTaskInstanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["UpstreamTaskInstanceIds"]));
    }
  }


  virtual ~RemoveTaskInstanceDependenciesShrinkRequest() = default;
};
class RemoveTaskInstanceDependenciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveTaskInstanceDependenciesResponseBody() {}

  explicit RemoveTaskInstanceDependenciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveTaskInstanceDependenciesResponseBody() = default;
};
class RemoveTaskInstanceDependenciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTaskInstanceDependenciesResponseBody> body{};

  RemoveTaskInstanceDependenciesResponse() {}

  explicit RemoveTaskInstanceDependenciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTaskInstanceDependenciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTaskInstanceDependenciesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTaskInstanceDependenciesResponse() = default;
};
class RenameFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameFunctionRequest() {}

  explicit RenameFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameFunctionRequest() = default;
};
class RenameFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  RenameFunctionResponseBody() {}

  explicit RenameFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~RenameFunctionResponseBody() = default;
};
class RenameFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameFunctionResponseBody> body{};

  RenameFunctionResponse() {}

  explicit RenameFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~RenameFunctionResponse() = default;
};
class RenameNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameNodeRequest() {}

  explicit RenameNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameNodeRequest() = default;
};
class RenameNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameNodeResponseBody() {}

  explicit RenameNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameNodeResponseBody() = default;
};
class RenameNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameNodeResponseBody> body{};

  RenameNodeResponse() {}

  explicit RenameNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameNodeResponseBody>(model1);
      }
    }
  }


  virtual ~RenameNodeResponse() = default;
};
class RenameResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameResourceRequest() {}

  explicit RenameResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameResourceRequest() = default;
};
class RenameResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameResourceResponseBody() {}

  explicit RenameResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameResourceResponseBody() = default;
};
class RenameResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameResourceResponseBody> body{};

  RenameResourceResponse() {}

  explicit RenameResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameResourceResponseBody>(model1);
      }
    }
  }


  virtual ~RenameResourceResponse() = default;
};
class RenameWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  RenameWorkflowDefinitionRequest() {}

  explicit RenameWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RenameWorkflowDefinitionRequest() = default;
};
class RenameWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenameWorkflowDefinitionResponseBody() {}

  explicit RenameWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenameWorkflowDefinitionResponseBody() = default;
};
class RenameWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameWorkflowDefinitionResponseBody> body{};

  RenameWorkflowDefinitionResponse() {}

  explicit RenameWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~RenameWorkflowDefinitionResponse() = default;
};
class RerunTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  RerunTaskInstancesRequest() {}

  explicit RerunTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RerunTaskInstancesRequest() = default;
};
class RerunTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  RerunTaskInstancesShrinkRequest() {}

  explicit RerunTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~RerunTaskInstancesShrinkRequest() = default;
};
class RerunTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  RerunTaskInstancesResponseBody() {}

  explicit RerunTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~RerunTaskInstancesResponseBody() = default;
};
class RerunTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RerunTaskInstancesResponseBody> body{};

  RerunTaskInstancesResponse() {}

  explicit RerunTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RerunTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RerunTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RerunTaskInstancesResponse() = default;
};
class ResumeTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  ResumeTaskInstancesRequest() {}

  explicit ResumeTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ResumeTaskInstancesRequest() = default;
};
class ResumeTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  ResumeTaskInstancesShrinkRequest() {}

  explicit ResumeTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~ResumeTaskInstancesShrinkRequest() = default;
};
class ResumeTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  ResumeTaskInstancesResponseBody() {}

  explicit ResumeTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~ResumeTaskInstancesResponseBody() = default;
};
class ResumeTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeTaskInstancesResponseBody> body{};

  ResumeTaskInstancesResponse() {}

  explicit ResumeTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeTaskInstancesResponse() = default;
};
class RevokeMemberProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> roleCodes{};
  shared_ptr<string> userId{};

  RevokeMemberProjectRolesRequest() {}

  explicit RevokeMemberProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodes) {
      res["RoleCodes"] = boost::any(*roleCodes);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesRequest() = default;
};
class RevokeMemberProjectRolesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> roleCodesShrink{};
  shared_ptr<string> userId{};

  RevokeMemberProjectRolesShrinkRequest() {}

  explicit RevokeMemberProjectRolesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (roleCodesShrink) {
      res["RoleCodes"] = boost::any(*roleCodesShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RoleCodes") != m.end() && !m["RoleCodes"].empty()) {
      roleCodesShrink = make_shared<string>(boost::any_cast<string>(m["RoleCodes"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesShrinkRequest() = default;
};
class RevokeMemberProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeMemberProjectRolesResponseBody() {}

  explicit RevokeMemberProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeMemberProjectRolesResponseBody() = default;
};
class RevokeMemberProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeMemberProjectRolesResponseBody> body{};

  RevokeMemberProjectRolesResponse() {}

  explicit RevokeMemberProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeMemberProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeMemberProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeMemberProjectRolesResponse() = default;
};
class SetSuccessTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  SetSuccessTaskInstancesRequest() {}

  explicit SetSuccessTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SetSuccessTaskInstancesRequest() = default;
};
class SetSuccessTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  SetSuccessTaskInstancesShrinkRequest() {}

  explicit SetSuccessTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~SetSuccessTaskInstancesShrinkRequest() = default;
};
class SetSuccessTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  SetSuccessTaskInstancesResponseBody() {}

  explicit SetSuccessTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~SetSuccessTaskInstancesResponseBody() = default;
};
class SetSuccessTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetSuccessTaskInstancesResponseBody> body{};

  SetSuccessTaskInstancesResponse() {}

  explicit SetSuccessTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSuccessTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSuccessTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~SetSuccessTaskInstancesResponse() = default;
};
class StartDIJobRequestRealtimeStartSettingsFailoverSettings : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<long> upperLimit{};

  StartDIJobRequestRealtimeStartSettingsFailoverSettings() {}

  explicit StartDIJobRequestRealtimeStartSettingsFailoverSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (upperLimit) {
      res["UpperLimit"] = boost::any(*upperLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("UpperLimit") != m.end() && !m["UpperLimit"].empty()) {
      upperLimit = make_shared<long>(boost::any_cast<long>(m["UpperLimit"]));
    }
  }


  virtual ~StartDIJobRequestRealtimeStartSettingsFailoverSettings() = default;
};
class StartDIJobRequestRealtimeStartSettings : public Darabonba::Model {
public:
  shared_ptr<StartDIJobRequestRealtimeStartSettingsFailoverSettings> failoverSettings{};
  shared_ptr<long> startTime{};

  StartDIJobRequestRealtimeStartSettings() {}

  explicit StartDIJobRequestRealtimeStartSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failoverSettings) {
      res["FailoverSettings"] = failoverSettings ? boost::any(failoverSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailoverSettings") != m.end() && !m["FailoverSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailoverSettings"].type()) {
        StartDIJobRequestRealtimeStartSettingsFailoverSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailoverSettings"]));
        failoverSettings = make_shared<StartDIJobRequestRealtimeStartSettingsFailoverSettings>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~StartDIJobRequestRealtimeStartSettings() = default;
};
class StartDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<bool> forceToRerun{};
  shared_ptr<long> id{};
  shared_ptr<StartDIJobRequestRealtimeStartSettings> realtimeStartSettings{};

  StartDIJobRequest() {}

  explicit StartDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (forceToRerun) {
      res["ForceToRerun"] = boost::any(*forceToRerun);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (realtimeStartSettings) {
      res["RealtimeStartSettings"] = realtimeStartSettings ? boost::any(realtimeStartSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("ForceToRerun") != m.end() && !m["ForceToRerun"].empty()) {
      forceToRerun = make_shared<bool>(boost::any_cast<bool>(m["ForceToRerun"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RealtimeStartSettings") != m.end() && !m["RealtimeStartSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeStartSettings"].type()) {
        StartDIJobRequestRealtimeStartSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeStartSettings"]));
        realtimeStartSettings = make_shared<StartDIJobRequestRealtimeStartSettings>(model1);
      }
    }
  }


  virtual ~StartDIJobRequest() = default;
};
class StartDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<bool> forceToRerun{};
  shared_ptr<long> id{};
  shared_ptr<string> realtimeStartSettingsShrink{};

  StartDIJobShrinkRequest() {}

  explicit StartDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (forceToRerun) {
      res["ForceToRerun"] = boost::any(*forceToRerun);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (realtimeStartSettingsShrink) {
      res["RealtimeStartSettings"] = boost::any(*realtimeStartSettingsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("ForceToRerun") != m.end() && !m["ForceToRerun"].empty()) {
      forceToRerun = make_shared<bool>(boost::any_cast<bool>(m["ForceToRerun"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RealtimeStartSettings") != m.end() && !m["RealtimeStartSettings"].empty()) {
      realtimeStartSettingsShrink = make_shared<string>(boost::any_cast<string>(m["RealtimeStartSettings"]));
    }
  }


  virtual ~StartDIJobShrinkRequest() = default;
};
class StartDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartDIJobResponseBody() {}

  explicit StartDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartDIJobResponseBody() = default;
};
class StartDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDIJobResponseBody> body{};

  StartDIJobResponse() {}

  explicit StartDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartDIJobResponse() = default;
};
class StartWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StartWorkflowInstancesRequest() {}

  explicit StartWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StartWorkflowInstancesRequest() = default;
};
class StartWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StartWorkflowInstancesShrinkRequest() {}

  explicit StartWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StartWorkflowInstancesShrinkRequest() = default;
};
class StartWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StartWorkflowInstancesResponseBody() {}

  explicit StartWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StartWorkflowInstancesResponseBody() = default;
};
class StartWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartWorkflowInstancesResponseBody> body{};

  StartWorkflowInstancesResponse() {}

  explicit StartWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StartWorkflowInstancesResponse() = default;
};
class StopDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceId{};

  StopDIJobRequest() {}

  explicit StopDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
  }


  virtual ~StopDIJobRequest() = default;
};
class StopDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopDIJobResponseBody() {}

  explicit StopDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopDIJobResponseBody() = default;
};
class StopDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDIJobResponseBody> body{};

  StopDIJobResponse() {}

  explicit StopDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopDIJobResponse() = default;
};
class StopTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StopTaskInstancesRequest() {}

  explicit StopTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StopTaskInstancesRequest() = default;
};
class StopTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StopTaskInstancesShrinkRequest() {}

  explicit StopTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StopTaskInstancesShrinkRequest() = default;
};
class StopTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StopTaskInstancesResponseBody() {}

  explicit StopTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StopTaskInstancesResponseBody() = default;
};
class StopTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopTaskInstancesResponseBody> body{};

  StopTaskInstancesResponse() {}

  explicit StopTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopTaskInstancesResponse() = default;
};
class StopWorkflowInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  StopWorkflowInstancesRequest() {}

  explicit StopWorkflowInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~StopWorkflowInstancesRequest() = default;
};
class StopWorkflowInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  StopWorkflowInstancesShrinkRequest() {}

  explicit StopWorkflowInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~StopWorkflowInstancesShrinkRequest() = default;
};
class StopWorkflowInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  StopWorkflowInstancesResponseBody() {}

  explicit StopWorkflowInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~StopWorkflowInstancesResponseBody() = default;
};
class StopWorkflowInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopWorkflowInstancesResponseBody> body{};

  StopWorkflowInstancesResponse() {}

  explicit StopWorkflowInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopWorkflowInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopWorkflowInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopWorkflowInstancesResponse() = default;
};
class SubmitFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<bool> skipAllDeployFileExtensions{};

  SubmitFileRequest() {}

  explicit SubmitFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (skipAllDeployFileExtensions) {
      res["SkipAllDeployFileExtensions"] = boost::any(*skipAllDeployFileExtensions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("SkipAllDeployFileExtensions") != m.end() && !m["SkipAllDeployFileExtensions"].empty()) {
      skipAllDeployFileExtensions = make_shared<bool>(boost::any_cast<bool>(m["SkipAllDeployFileExtensions"]));
    }
  }


  virtual ~SubmitFileRequest() = default;
};
class SubmitFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitFileResponseBody() {}

  explicit SubmitFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitFileResponseBody() = default;
};
class SubmitFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFileResponseBody> body{};

  SubmitFileResponse() {}

  explicit SubmitFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFileResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFileResponse() = default;
};
class SuspendTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<long>> ids{};

  SuspendTaskInstancesRequest() {}

  explicit SuspendTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SuspendTaskInstancesRequest() = default;
};
class SuspendTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> idsShrink{};

  SuspendTaskInstancesShrinkRequest() {}

  explicit SuspendTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~SuspendTaskInstancesShrinkRequest() = default;
};
class SuspendTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  SuspendTaskInstancesResponseBody() {}

  explicit SuspendTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~SuspendTaskInstancesResponseBody() = default;
};
class SuspendTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendTaskInstancesResponseBody> body{};

  SuspendTaskInstancesResponse() {}

  explicit SuspendTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendTaskInstancesResponse() = default;
};
class TagDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagDataAssetsRequestTags() {}

  explicit TagDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagDataAssetsRequestTags() = default;
};
class TagDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<TagDataAssetsRequestTags>> tags{};

  TagDataAssetsRequest() {}

  explicit TagDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~TagDataAssetsRequest() = default;
};
class TagDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoTraceEnabled{};
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  TagDataAssetsShrinkRequest() {}

  explicit TagDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoTraceEnabled) {
      res["AutoTraceEnabled"] = boost::any(*autoTraceEnabled);
    }
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoTraceEnabled") != m.end() && !m["AutoTraceEnabled"].empty()) {
      autoTraceEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTraceEnabled"]));
    }
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~TagDataAssetsShrinkRequest() = default;
};
class TagDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  TagDataAssetsResponseBody() {}

  explicit TagDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~TagDataAssetsResponseBody() = default;
};
class TagDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagDataAssetsResponseBody> body{};

  TagDataAssetsResponse() {}

  explicit TagDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~TagDataAssetsResponse() = default;
};
class TestDataSourceConnectivityRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceGroupId{};

  TestDataSourceConnectivityRequest() {}

  explicit TestDataSourceConnectivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~TestDataSourceConnectivityRequest() = default;
};
class TestDataSourceConnectivityResponseBodyConnectivityDetailLogs : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> endTime{};
  shared_ptr<string> message{};
  shared_ptr<long> startTime{};

  TestDataSourceConnectivityResponseBodyConnectivityDetailLogs() {}

  explicit TestDataSourceConnectivityResponseBodyConnectivityDetailLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~TestDataSourceConnectivityResponseBodyConnectivityDetailLogs() = default;
};
class TestDataSourceConnectivityResponseBodyConnectivity : public Darabonba::Model {
public:
  shared_ptr<string> connectMessage{};
  shared_ptr<string> connectState{};
  shared_ptr<vector<TestDataSourceConnectivityResponseBodyConnectivityDetailLogs>> detailLogs{};

  TestDataSourceConnectivityResponseBodyConnectivity() {}

  explicit TestDataSourceConnectivityResponseBodyConnectivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectMessage) {
      res["ConnectMessage"] = boost::any(*connectMessage);
    }
    if (connectState) {
      res["ConnectState"] = boost::any(*connectState);
    }
    if (detailLogs) {
      vector<boost::any> temp1;
      for(auto item1:*detailLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DetailLogs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectMessage") != m.end() && !m["ConnectMessage"].empty()) {
      connectMessage = make_shared<string>(boost::any_cast<string>(m["ConnectMessage"]));
    }
    if (m.find("ConnectState") != m.end() && !m["ConnectState"].empty()) {
      connectState = make_shared<string>(boost::any_cast<string>(m["ConnectState"]));
    }
    if (m.find("DetailLogs") != m.end() && !m["DetailLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["DetailLogs"].type()) {
        vector<TestDataSourceConnectivityResponseBodyConnectivityDetailLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DetailLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TestDataSourceConnectivityResponseBodyConnectivityDetailLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detailLogs = make_shared<vector<TestDataSourceConnectivityResponseBodyConnectivityDetailLogs>>(expect1);
      }
    }
  }


  virtual ~TestDataSourceConnectivityResponseBodyConnectivity() = default;
};
class TestDataSourceConnectivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<TestDataSourceConnectivityResponseBodyConnectivity> connectivity{};
  shared_ptr<string> requestId{};

  TestDataSourceConnectivityResponseBody() {}

  explicit TestDataSourceConnectivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectivity) {
      res["Connectivity"] = connectivity ? boost::any(connectivity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connectivity") != m.end() && !m["Connectivity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Connectivity"].type()) {
        TestDataSourceConnectivityResponseBodyConnectivity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Connectivity"]));
        connectivity = make_shared<TestDataSourceConnectivityResponseBodyConnectivity>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TestDataSourceConnectivityResponseBody() = default;
};
class TestDataSourceConnectivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TestDataSourceConnectivityResponseBody> body{};

  TestDataSourceConnectivityResponse() {}

  explicit TestDataSourceConnectivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TestDataSourceConnectivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TestDataSourceConnectivityResponseBody>(model1);
      }
    }
  }


  virtual ~TestDataSourceConnectivityResponse() = default;
};
class TriggerSchedulerTaskInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<long> taskId{};
  shared_ptr<long> triggerTime{};

  TriggerSchedulerTaskInstanceRequest() {}

  explicit TriggerSchedulerTaskInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (triggerTime) {
      res["TriggerTime"] = boost::any(*triggerTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TriggerTime") != m.end() && !m["TriggerTime"].empty()) {
      triggerTime = make_shared<long>(boost::any_cast<long>(m["TriggerTime"]));
    }
  }


  virtual ~TriggerSchedulerTaskInstanceRequest() = default;
};
class TriggerSchedulerTaskInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TriggerSchedulerTaskInstanceResponseBody() {}

  explicit TriggerSchedulerTaskInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TriggerSchedulerTaskInstanceResponseBody() = default;
};
class TriggerSchedulerTaskInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TriggerSchedulerTaskInstanceResponseBody> body{};

  TriggerSchedulerTaskInstanceResponse() {}

  explicit TriggerSchedulerTaskInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerSchedulerTaskInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerSchedulerTaskInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerSchedulerTaskInstanceResponse() = default;
};
class UnTagDataAssetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UnTagDataAssetsRequestTags() {}

  explicit UnTagDataAssetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UnTagDataAssetsRequestTags() = default;
};
class UnTagDataAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataAssetIds{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<UnTagDataAssetsRequestTags>> tags{};

  UnTagDataAssetsRequest() {}

  explicit UnTagDataAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIds) {
      res["DataAssetIds"] = boost::any(*dataAssetIds);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAssetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAssetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAssetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UnTagDataAssetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnTagDataAssetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UnTagDataAssetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~UnTagDataAssetsRequest() = default;
};
class UnTagDataAssetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataAssetIdsShrink{};
  shared_ptr<string> dataAssetType{};
  shared_ptr<string> envType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tagsShrink{};

  UnTagDataAssetsShrinkRequest() {}

  explicit UnTagDataAssetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAssetIdsShrink) {
      res["DataAssetIds"] = boost::any(*dataAssetIdsShrink);
    }
    if (dataAssetType) {
      res["DataAssetType"] = boost::any(*dataAssetType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAssetIds") != m.end() && !m["DataAssetIds"].empty()) {
      dataAssetIdsShrink = make_shared<string>(boost::any_cast<string>(m["DataAssetIds"]));
    }
    if (m.find("DataAssetType") != m.end() && !m["DataAssetType"].empty()) {
      dataAssetType = make_shared<string>(boost::any_cast<string>(m["DataAssetType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UnTagDataAssetsShrinkRequest() = default;
};
class UnTagDataAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UnTagDataAssetsResponseBody() {}

  explicit UnTagDataAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UnTagDataAssetsResponseBody() = default;
};
class UnTagDataAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnTagDataAssetsResponseBody> body{};

  UnTagDataAssetsResponse() {}

  explicit UnTagDataAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnTagDataAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnTagDataAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~UnTagDataAssetsResponse() = default;
};
class UpdateAlertRuleRequestNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateAlertRuleRequestNotificationReceivers() {}

  explicit UpdateAlertRuleRequestNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateAlertRuleRequestNotificationReceivers() = default;
};
class UpdateAlertRuleRequestNotification : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<long> intervalInMinutes{};
  shared_ptr<long> maximum{};
  shared_ptr<vector<UpdateAlertRuleRequestNotificationReceivers>> receivers{};
  shared_ptr<string> silenceEndTime{};
  shared_ptr<string> silenceStartTime{};

  UpdateAlertRuleRequestNotification() {}

  explicit UpdateAlertRuleRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (intervalInMinutes) {
      res["IntervalInMinutes"] = boost::any(*intervalInMinutes);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (receivers) {
      vector<boost::any> temp1;
      for(auto item1:*receivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Receivers"] = boost::any(temp1);
    }
    if (silenceEndTime) {
      res["SilenceEndTime"] = boost::any(*silenceEndTime);
    }
    if (silenceStartTime) {
      res["SilenceStartTime"] = boost::any(*silenceStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IntervalInMinutes") != m.end() && !m["IntervalInMinutes"].empty()) {
      intervalInMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalInMinutes"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<long>(boost::any_cast<long>(m["Maximum"]));
    }
    if (m.find("Receivers") != m.end() && !m["Receivers"].empty()) {
      if (typeid(vector<boost::any>) == m["Receivers"].type()) {
        vector<UpdateAlertRuleRequestNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Receivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAlertRuleRequestNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        receivers = make_shared<vector<UpdateAlertRuleRequestNotificationReceivers>>(expect1);
      }
    }
    if (m.find("SilenceEndTime") != m.end() && !m["SilenceEndTime"].empty()) {
      silenceEndTime = make_shared<string>(boost::any_cast<string>(m["SilenceEndTime"]));
    }
    if (m.find("SilenceStartTime") != m.end() && !m["SilenceStartTime"].empty()) {
      silenceStartTime = make_shared<string>(boost::any_cast<string>(m["SilenceStartTime"]));
    }
  }


  virtual ~UpdateAlertRuleRequestNotification() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime : public Darabonba::Model {
public:
  shared_ptr<long> cycleId{};
  shared_ptr<string> time{};

  UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleId) {
      res["CycleId"] = boost::any(*cycleId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleId") != m.end() && !m["CycleId"].empty()) {
      cycleId = make_shared<long>(boost::any_cast<long>(m["CycleId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>> cycleAndTime{};

  UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleAndTime) {
      vector<boost::any> temp1;
      for(auto item1:*cycleAndTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleAndTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleAndTime") != m.end() && !m["CycleAndTime"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleAndTime"].type()) {
        vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleAndTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleAndTime = make_shared<vector<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime>>(expect1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionError : public Darabonba::Model {
public:
  shared_ptr<bool> autoRerunAlertEnabled{};
  shared_ptr<vector<long>> streamTaskIds{};

  UpdateAlertRuleRequestTriggerConditionExtensionError() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunAlertEnabled) {
      res["AutoRerunAlertEnabled"] = boost::any(*autoRerunAlertEnabled);
    }
    if (streamTaskIds) {
      res["StreamTaskIds"] = boost::any(*streamTaskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunAlertEnabled") != m.end() && !m["AutoRerunAlertEnabled"].empty()) {
      autoRerunAlertEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRerunAlertEnabled"]));
    }
    if (m.find("StreamTaskIds") != m.end() && !m["StreamTaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StreamTaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamTaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      streamTaskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionError() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<string> trend{};

  UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionTimeout : public Darabonba::Model {
public:
  shared_ptr<long> timeoutInMinutes{};

  UpdateAlertRuleRequestTriggerConditionExtensionTimeout() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionTimeout() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtensionUnFinished : public Darabonba::Model {
public:
  shared_ptr<string> unFinishedTime{};

  UpdateAlertRuleRequestTriggerConditionExtensionUnFinished() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtensionUnFinished(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unFinishedTime) {
      res["UnFinishedTime"] = boost::any(*unFinishedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnFinishedTime") != m.end() && !m["UnFinishedTime"].empty()) {
      unFinishedTime = make_shared<string>(boost::any_cast<string>(m["UnFinishedTime"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtensionUnFinished() = default;
};
class UpdateAlertRuleRequestTriggerConditionExtension : public Darabonba::Model {
public:
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished> cycleUnfinished{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionError> error{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount> instanceErrorCount{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage> instanceErrorPercentage{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate> instanceTransferFluctuate{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionTimeout> timeout{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtensionUnFinished> unFinished{};

  UpdateAlertRuleRequestTriggerConditionExtension() {}

  explicit UpdateAlertRuleRequestTriggerConditionExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleUnfinished) {
      res["CycleUnfinished"] = cycleUnfinished ? boost::any(cycleUnfinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (error) {
      res["Error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorCount) {
      res["InstanceErrorCount"] = instanceErrorCount ? boost::any(instanceErrorCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceErrorPercentage) {
      res["InstanceErrorPercentage"] = instanceErrorPercentage ? boost::any(instanceErrorPercentage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTransferFluctuate) {
      res["InstanceTransferFluctuate"] = instanceTransferFluctuate ? boost::any(instanceTransferFluctuate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unFinished) {
      res["UnFinished"] = unFinished ? boost::any(unFinished->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleUnfinished") != m.end() && !m["CycleUnfinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleUnfinished"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleUnfinished"]));
        cycleUnfinished = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished>(model1);
      }
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      if (typeid(map<string, boost::any>) == m["Error"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Error"]));
        error = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionError>(model1);
      }
    }
    if (m.find("InstanceErrorCount") != m.end() && !m["InstanceErrorCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorCount"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorCount"]));
        instanceErrorCount = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount>(model1);
      }
    }
    if (m.find("InstanceErrorPercentage") != m.end() && !m["InstanceErrorPercentage"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorPercentage"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorPercentage"]));
        instanceErrorPercentage = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage>(model1);
      }
    }
    if (m.find("InstanceTransferFluctuate") != m.end() && !m["InstanceTransferFluctuate"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTransferFluctuate"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTransferFluctuate"]));
        instanceTransferFluctuate = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionTimeout>(model1);
      }
    }
    if (m.find("UnFinished") != m.end() && !m["UnFinished"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnFinished"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtensionUnFinished model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnFinished"]));
        unFinished = make_shared<UpdateAlertRuleRequestTriggerConditionExtensionUnFinished>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionExtension() = default;
};
class UpdateAlertRuleRequestTriggerConditionTarget : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowTasks{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> type{};

  UpdateAlertRuleRequestTriggerConditionTarget() {}

  explicit UpdateAlertRuleRequestTriggerConditionTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowTasks) {
      res["AllowTasks"] = boost::any(*allowTasks);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowTasks") != m.end() && !m["AllowTasks"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AllowTasks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllowTasks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowTasks = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerConditionTarget() = default;
};
class UpdateAlertRuleRequestTriggerCondition : public Darabonba::Model {
public:
  shared_ptr<UpdateAlertRuleRequestTriggerConditionExtension> extension{};
  shared_ptr<UpdateAlertRuleRequestTriggerConditionTarget> target{};
  shared_ptr<string> type{};

  UpdateAlertRuleRequestTriggerCondition() {}

  explicit UpdateAlertRuleRequestTriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = extension ? boost::any(extension->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extension"].type()) {
        UpdateAlertRuleRequestTriggerConditionExtension model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extension"]));
        extension = make_shared<UpdateAlertRuleRequestTriggerConditionExtension>(model1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        UpdateAlertRuleRequestTriggerConditionTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<UpdateAlertRuleRequestTriggerConditionTarget>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateAlertRuleRequestTriggerCondition() = default;
};
class UpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateAlertRuleRequestNotification> notification{};
  shared_ptr<string> owner{};
  shared_ptr<UpdateAlertRuleRequestTriggerCondition> triggerCondition{};

  UpdateAlertRuleRequest() {}

  explicit UpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerCondition) {
      res["TriggerCondition"] = triggerCondition ? boost::any(triggerCondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        UpdateAlertRuleRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<UpdateAlertRuleRequestNotification>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerCondition"].type()) {
        UpdateAlertRuleRequestTriggerCondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerCondition"]));
        triggerCondition = make_shared<UpdateAlertRuleRequestTriggerCondition>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleRequest() = default;
};
class UpdateAlertRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> triggerConditionShrink{};

  UpdateAlertRuleShrinkRequest() {}

  explicit UpdateAlertRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (triggerConditionShrink) {
      res["TriggerCondition"] = boost::any(*triggerConditionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TriggerCondition") != m.end() && !m["TriggerCondition"].empty()) {
      triggerConditionShrink = make_shared<string>(boost::any_cast<string>(m["TriggerCondition"]));
    }
  }


  virtual ~UpdateAlertRuleShrinkRequest() = default;
};
class UpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAlertRuleResponseBody() {}

  explicit UpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAlertRuleResponseBody() = default;
};
class UpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertRuleResponseBody> body{};

  UpdateAlertRuleResponse() {}

  explicit UpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleResponse() = default;
};
class UpdateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  UpdateBusinessRequest() {}

  explicit UpdateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~UpdateBusinessRequest() = default;
};
class UpdateBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateBusinessResponseBody() {}

  explicit UpdateBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBusinessResponseBody() = default;
};
class UpdateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBusinessResponseBody> body{};

  UpdateBusinessResponse() {}

  explicit UpdateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBusinessResponse() = default;
};
class UpdateColumnBusinessMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> id{};

  UpdateColumnBusinessMetadataRequest() {}

  explicit UpdateColumnBusinessMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateColumnBusinessMetadataRequest() = default;
};
class UpdateColumnBusinessMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateColumnBusinessMetadataResponseBody() {}

  explicit UpdateColumnBusinessMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateColumnBusinessMetadataResponseBody() = default;
};
class UpdateColumnBusinessMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateColumnBusinessMetadataResponseBody> body{};

  UpdateColumnBusinessMetadataResponse() {}

  explicit UpdateColumnBusinessMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateColumnBusinessMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateColumnBusinessMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateColumnBusinessMetadataResponse() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> severity{};

  UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers() = default;
};
class UpdateDIAlarmRuleRequestNotificationSettings : public Darabonba::Model {
public:
  shared_ptr<long> inhibitionInterval{};
  shared_ptr<long> muteInterval{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>> notificationReceivers{};

  UpdateDIAlarmRuleRequestNotificationSettings() {}

  explicit UpdateDIAlarmRuleRequestNotificationSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inhibitionInterval) {
      res["InhibitionInterval"] = boost::any(*inhibitionInterval);
    }
    if (muteInterval) {
      res["MuteInterval"] = boost::any(*muteInterval);
    }
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InhibitionInterval") != m.end() && !m["InhibitionInterval"].empty()) {
      inhibitionInterval = make_shared<long>(boost::any_cast<long>(m["InhibitionInterval"]));
    }
    if (m.find("MuteInterval") != m.end() && !m["MuteInterval"].empty()) {
      muteInterval = make_shared<long>(boost::any_cast<long>(m["MuteInterval"]));
    }
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleRequestNotificationSettings() = default;
};
class UpdateDIAlarmRuleRequestTriggerConditions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ddlReportTags{};
  shared_ptr<vector<string>> ddlTypes{};
  shared_ptr<long> duration{};
  shared_ptr<string> severity{};
  shared_ptr<long> threshold{};

  UpdateDIAlarmRuleRequestTriggerConditions() {}

  explicit UpdateDIAlarmRuleRequestTriggerConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddlReportTags) {
      res["DdlReportTags"] = boost::any(*ddlReportTags);
    }
    if (ddlTypes) {
      res["DdlTypes"] = boost::any(*ddlTypes);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdlReportTags") != m.end() && !m["DdlReportTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlReportTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlReportTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlReportTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DdlTypes") != m.end() && !m["DdlTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DdlTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DdlTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ddlTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~UpdateDIAlarmRuleRequestTriggerConditions() = default;
};
class UpdateDIAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDIAlarmRuleRequestNotificationSettings> notificationSettings{};
  shared_ptr<vector<UpdateDIAlarmRuleRequestTriggerConditions>> triggerConditions{};

  UpdateDIAlarmRuleRequest() {}

  explicit UpdateDIAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettings) {
      res["NotificationSettings"] = notificationSettings ? boost::any(notificationSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConditions) {
      vector<boost::any> temp1;
      for(auto item1:*triggerConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TriggerConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationSettings"].type()) {
        UpdateDIAlarmRuleRequestNotificationSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationSettings"]));
        notificationSettings = make_shared<UpdateDIAlarmRuleRequestNotificationSettings>(model1);
      }
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["TriggerConditions"].type()) {
        vector<UpdateDIAlarmRuleRequestTriggerConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TriggerConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIAlarmRuleRequestTriggerConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggerConditions = make_shared<vector<UpdateDIAlarmRuleRequestTriggerConditions>>(expect1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleRequest() = default;
};
class UpdateDIAlarmRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIAlarmRuleId{};
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> id{};
  shared_ptr<string> metricType{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationSettingsShrink{};
  shared_ptr<string> triggerConditionsShrink{};

  UpdateDIAlarmRuleShrinkRequest() {}

  explicit UpdateDIAlarmRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIAlarmRuleId) {
      res["DIAlarmRuleId"] = boost::any(*DIAlarmRuleId);
    }
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationSettingsShrink) {
      res["NotificationSettings"] = boost::any(*notificationSettingsShrink);
    }
    if (triggerConditionsShrink) {
      res["TriggerConditions"] = boost::any(*triggerConditionsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIAlarmRuleId") != m.end() && !m["DIAlarmRuleId"].empty()) {
      DIAlarmRuleId = make_shared<long>(boost::any_cast<long>(m["DIAlarmRuleId"]));
    }
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotificationSettings") != m.end() && !m["NotificationSettings"].empty()) {
      notificationSettingsShrink = make_shared<string>(boost::any_cast<string>(m["NotificationSettings"]));
    }
    if (m.find("TriggerConditions") != m.end() && !m["TriggerConditions"].empty()) {
      triggerConditionsShrink = make_shared<string>(boost::any_cast<string>(m["TriggerConditions"]));
    }
  }


  virtual ~UpdateDIAlarmRuleShrinkRequest() = default;
};
class UpdateDIAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDIAlarmRuleResponseBody() {}

  explicit UpdateDIAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDIAlarmRuleResponseBody() = default;
};
class UpdateDIAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDIAlarmRuleResponseBody> body{};

  UpdateDIAlarmRuleResponse() {}

  explicit UpdateDIAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDIAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDIAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDIAlarmRuleResponse() = default;
};
class UpdateDIJobRequestJobSettingsColumnDataTypeSettings : public Darabonba::Model {
public:
  shared_ptr<string> destinationDataType{};
  shared_ptr<string> sourceDataType{};

  UpdateDIJobRequestJobSettingsColumnDataTypeSettings() {}

  explicit UpdateDIJobRequestJobSettingsColumnDataTypeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDataType) {
      res["DestinationDataType"] = boost::any(*destinationDataType);
    }
    if (sourceDataType) {
      res["SourceDataType"] = boost::any(*sourceDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDataType") != m.end() && !m["DestinationDataType"].empty()) {
      destinationDataType = make_shared<string>(boost::any_cast<string>(m["DestinationDataType"]));
    }
    if (m.find("SourceDataType") != m.end() && !m["SourceDataType"].empty()) {
      sourceDataType = make_shared<string>(boost::any_cast<string>(m["SourceDataType"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsColumnDataTypeSettings() = default;
};
class UpdateDIJobRequestJobSettingsCycleScheduleSettings : public Darabonba::Model {
public:
  shared_ptr<string> scheduleParameters{};

  UpdateDIJobRequestJobSettingsCycleScheduleSettings() {}

  explicit UpdateDIJobRequestJobSettingsCycleScheduleSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleParameters) {
      res["ScheduleParameters"] = boost::any(*scheduleParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleParameters") != m.end() && !m["ScheduleParameters"].empty()) {
      scheduleParameters = make_shared<string>(boost::any_cast<string>(m["ScheduleParameters"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsCycleScheduleSettings() = default;
};
class UpdateDIJobRequestJobSettingsDdlHandlingSettings : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> type{};

  UpdateDIJobRequestJobSettingsDdlHandlingSettings() {}

  explicit UpdateDIJobRequestJobSettingsDdlHandlingSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsDdlHandlingSettings() = default;
};
class UpdateDIJobRequestJobSettingsRuntimeSettings : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdateDIJobRequestJobSettingsRuntimeSettings() {}

  explicit UpdateDIJobRequestJobSettingsRuntimeSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDIJobRequestJobSettingsRuntimeSettings() = default;
};
class UpdateDIJobRequestJobSettings : public Darabonba::Model {
public:
  shared_ptr<string> channelSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings>> columnDataTypeSettings{};
  shared_ptr<UpdateDIJobRequestJobSettingsCycleScheduleSettings> cycleScheduleSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings>> ddlHandlingSettings{};
  shared_ptr<vector<UpdateDIJobRequestJobSettingsRuntimeSettings>> runtimeSettings{};

  UpdateDIJobRequestJobSettings() {}

  explicit UpdateDIJobRequestJobSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelSettings) {
      res["ChannelSettings"] = boost::any(*channelSettings);
    }
    if (columnDataTypeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*columnDataTypeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnDataTypeSettings"] = boost::any(temp1);
    }
    if (cycleScheduleSettings) {
      res["CycleScheduleSettings"] = cycleScheduleSettings ? boost::any(cycleScheduleSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddlHandlingSettings) {
      vector<boost::any> temp1;
      for(auto item1:*ddlHandlingSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdlHandlingSettings"] = boost::any(temp1);
    }
    if (runtimeSettings) {
      vector<boost::any> temp1;
      for(auto item1:*runtimeSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimeSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelSettings") != m.end() && !m["ChannelSettings"].empty()) {
      channelSettings = make_shared<string>(boost::any_cast<string>(m["ChannelSettings"]));
    }
    if (m.find("ColumnDataTypeSettings") != m.end() && !m["ColumnDataTypeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnDataTypeSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnDataTypeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsColumnDataTypeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnDataTypeSettings = make_shared<vector<UpdateDIJobRequestJobSettingsColumnDataTypeSettings>>(expect1);
      }
    }
    if (m.find("CycleScheduleSettings") != m.end() && !m["CycleScheduleSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CycleScheduleSettings"].type()) {
        UpdateDIJobRequestJobSettingsCycleScheduleSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CycleScheduleSettings"]));
        cycleScheduleSettings = make_shared<UpdateDIJobRequestJobSettingsCycleScheduleSettings>(model1);
      }
    }
    if (m.find("DdlHandlingSettings") != m.end() && !m["DdlHandlingSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["DdlHandlingSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdlHandlingSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsDdlHandlingSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddlHandlingSettings = make_shared<vector<UpdateDIJobRequestJobSettingsDdlHandlingSettings>>(expect1);
      }
    }
    if (m.find("RuntimeSettings") != m.end() && !m["RuntimeSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimeSettings"].type()) {
        vector<UpdateDIJobRequestJobSettingsRuntimeSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimeSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestJobSettingsRuntimeSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimeSettings = make_shared<vector<UpdateDIJobRequestJobSettingsRuntimeSettings>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequestJobSettings() = default;
};
class UpdateDIJobRequestResourceSettingsOfflineResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsOfflineResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsOfflineResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsOfflineResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettingsRealtimeResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsRealtimeResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsRealtimeResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsRealtimeResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettingsScheduleResourceSettings : public Darabonba::Model {
public:
  shared_ptr<double> requestedCu{};
  shared_ptr<string> resourceGroupIdentifier{};

  UpdateDIJobRequestResourceSettingsScheduleResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettingsScheduleResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestedCu) {
      res["RequestedCu"] = boost::any(*requestedCu);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestedCu") != m.end() && !m["RequestedCu"].empty()) {
      requestedCu = make_shared<double>(boost::any_cast<double>(m["RequestedCu"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
  }


  virtual ~UpdateDIJobRequestResourceSettingsScheduleResourceSettings() = default;
};
class UpdateDIJobRequestResourceSettings : public Darabonba::Model {
public:
  shared_ptr<UpdateDIJobRequestResourceSettingsOfflineResourceSettings> offlineResourceSettings{};
  shared_ptr<UpdateDIJobRequestResourceSettingsRealtimeResourceSettings> realtimeResourceSettings{};
  shared_ptr<UpdateDIJobRequestResourceSettingsScheduleResourceSettings> scheduleResourceSettings{};

  UpdateDIJobRequestResourceSettings() {}

  explicit UpdateDIJobRequestResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineResourceSettings) {
      res["OfflineResourceSettings"] = offlineResourceSettings ? boost::any(offlineResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realtimeResourceSettings) {
      res["RealtimeResourceSettings"] = realtimeResourceSettings ? boost::any(realtimeResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleResourceSettings) {
      res["ScheduleResourceSettings"] = scheduleResourceSettings ? boost::any(scheduleResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineResourceSettings") != m.end() && !m["OfflineResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsOfflineResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResourceSettings"]));
        offlineResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsOfflineResourceSettings>(model1);
      }
    }
    if (m.find("RealtimeResourceSettings") != m.end() && !m["RealtimeResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealtimeResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsRealtimeResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealtimeResourceSettings"]));
        realtimeResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsRealtimeResourceSettings>(model1);
      }
    }
    if (m.find("ScheduleResourceSettings") != m.end() && !m["ScheduleResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettingsScheduleResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleResourceSettings"]));
        scheduleResourceSettings = make_shared<UpdateDIJobRequestResourceSettingsScheduleResourceSettings>(model1);
      }
    }
  }


  virtual ~UpdateDIJobRequestResourceSettings() = default;
};
class UpdateDIJobRequestTableMappingsSourceObjectSelectionRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionType{};
  shared_ptr<string> objectType{};

  UpdateDIJobRequestTableMappingsSourceObjectSelectionRules() {}

  explicit UpdateDIJobRequestTableMappingsSourceObjectSelectionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionType) {
      res["ExpressionType"] = boost::any(*expressionType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionType") != m.end() && !m["ExpressionType"].empty()) {
      expressionType = make_shared<string>(boost::any_cast<string>(m["ExpressionType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~UpdateDIJobRequestTableMappingsSourceObjectSelectionRules() = default;
};
class UpdateDIJobRequestTableMappingsTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  UpdateDIJobRequestTableMappingsTransformationRules() {}

  explicit UpdateDIJobRequestTableMappingsTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~UpdateDIJobRequestTableMappingsTransformationRules() = default;
};
class UpdateDIJobRequestTableMappings : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules>> sourceObjectSelectionRules{};
  shared_ptr<vector<UpdateDIJobRequestTableMappingsTransformationRules>> transformationRules{};

  UpdateDIJobRequestTableMappings() {}

  explicit UpdateDIJobRequestTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceObjectSelectionRules) {
      vector<boost::any> temp1;
      for(auto item1:*sourceObjectSelectionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceObjectSelectionRules"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceObjectSelectionRules") != m.end() && !m["SourceObjectSelectionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceObjectSelectionRules"].type()) {
        vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceObjectSelectionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappingsSourceObjectSelectionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceObjectSelectionRules = make_shared<vector<UpdateDIJobRequestTableMappingsSourceObjectSelectionRules>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<UpdateDIJobRequestTableMappingsTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappingsTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<UpdateDIJobRequestTableMappingsTransformationRules>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequestTableMappings() = default;
};
class UpdateDIJobRequestTransformationRules : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleExpression{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleTargetType{};

  UpdateDIJobRequestTransformationRules() {}

  explicit UpdateDIJobRequestTransformationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleExpression) {
      res["RuleExpression"] = boost::any(*ruleExpression);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTargetType) {
      res["RuleTargetType"] = boost::any(*ruleTargetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleExpression") != m.end() && !m["RuleExpression"].empty()) {
      ruleExpression = make_shared<string>(boost::any_cast<string>(m["RuleExpression"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTargetType") != m.end() && !m["RuleTargetType"].empty()) {
      ruleTargetType = make_shared<string>(boost::any_cast<string>(m["RuleTargetType"]));
    }
  }


  virtual ~UpdateDIJobRequestTransformationRules() = default;
};
class UpdateDIJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<UpdateDIJobRequestJobSettings> jobSettings{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDIJobRequestResourceSettings> resourceSettings{};
  shared_ptr<vector<UpdateDIJobRequestTableMappings>> tableMappings{};
  shared_ptr<vector<UpdateDIJobRequestTransformationRules>> transformationRules{};

  UpdateDIJobRequest() {}

  explicit UpdateDIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobSettings) {
      res["JobSettings"] = jobSettings ? boost::any(jobSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettings) {
      res["ResourceSettings"] = resourceSettings ? boost::any(resourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (transformationRules) {
      vector<boost::any> temp1;
      for(auto item1:*transformationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransformationRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobSettings"].type()) {
        UpdateDIJobRequestJobSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobSettings"]));
        jobSettings = make_shared<UpdateDIJobRequestJobSettings>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSettings"].type()) {
        UpdateDIJobRequestResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSettings"]));
        resourceSettings = make_shared<UpdateDIJobRequestResourceSettings>(model1);
      }
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<UpdateDIJobRequestTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<UpdateDIJobRequestTableMappings>>(expect1);
      }
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["TransformationRules"].type()) {
        vector<UpdateDIJobRequestTransformationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransformationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDIJobRequestTransformationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transformationRules = make_shared<vector<UpdateDIJobRequestTransformationRules>>(expect1);
      }
    }
  }


  virtual ~UpdateDIJobRequest() = default;
};
class UpdateDIJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> DIJobId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> jobSettingsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceSettingsShrink{};
  shared_ptr<string> tableMappingsShrink{};
  shared_ptr<string> transformationRulesShrink{};

  UpdateDIJobShrinkRequest() {}

  explicit UpdateDIJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DIJobId) {
      res["DIJobId"] = boost::any(*DIJobId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobSettingsShrink) {
      res["JobSettings"] = boost::any(*jobSettingsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceSettingsShrink) {
      res["ResourceSettings"] = boost::any(*resourceSettingsShrink);
    }
    if (tableMappingsShrink) {
      res["TableMappings"] = boost::any(*tableMappingsShrink);
    }
    if (transformationRulesShrink) {
      res["TransformationRules"] = boost::any(*transformationRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DIJobId") != m.end() && !m["DIJobId"].empty()) {
      DIJobId = make_shared<long>(boost::any_cast<long>(m["DIJobId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JobSettings") != m.end() && !m["JobSettings"].empty()) {
      jobSettingsShrink = make_shared<string>(boost::any_cast<string>(m["JobSettings"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceSettings") != m.end() && !m["ResourceSettings"].empty()) {
      resourceSettingsShrink = make_shared<string>(boost::any_cast<string>(m["ResourceSettings"]));
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      tableMappingsShrink = make_shared<string>(boost::any_cast<string>(m["TableMappings"]));
    }
    if (m.find("TransformationRules") != m.end() && !m["TransformationRules"].empty()) {
      transformationRulesShrink = make_shared<string>(boost::any_cast<string>(m["TransformationRules"]));
    }
  }


  virtual ~UpdateDIJobShrinkRequest() = default;
};
class UpdateDIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDIJobResponseBody() {}

  explicit UpdateDIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDIJobResponseBody() = default;
};
class UpdateDIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDIJobResponseBody> body{};

  UpdateDIJobResponse() {}

  explicit UpdateDIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDIJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDIJobResponse() = default;
};
class UpdateDataAssetTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<vector<string>> values{};

  UpdateDataAssetTagRequest() {}

  explicit UpdateDataAssetTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataAssetTagRequest() = default;
};
class UpdateDataAssetTagShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> valuesShrink{};

  UpdateDataAssetTagShrinkRequest() {}

  explicit UpdateDataAssetTagShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~UpdateDataAssetTagShrinkRequest() = default;
};
class UpdateDataAssetTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataAssetTagResponseBody() {}

  explicit UpdateDataAssetTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataAssetTagResponseBody() = default;
};
class UpdateDataAssetTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataAssetTagResponseBody> body{};

  UpdateDataAssetTagResponse() {}

  explicit UpdateDataAssetTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataAssetTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataAssetTagResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataAssetTagResponse() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical> critical{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected> expected{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned> warned{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig() = default;
};
class UpdateDataQualityEvaluationTaskRequestDataQualityRules : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityEvaluationTaskRequestDataQualityRules() {}

  explicit UpdateDataQualityEvaluationTaskRequestDataQualityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestDataQualityRules() = default;
};
class UpdateDataQualityEvaluationTaskRequestHooks : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestHooks() {}

  explicit UpdateDataQualityEvaluationTaskRequestHooks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestHooks() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channels{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> receiverType{};
  shared_ptr<vector<string>> receiverValues{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotificationsNotifications : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>> notificationChannels{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>> notificationReceivers{};

  UpdateDataQualityEvaluationTaskRequestNotificationsNotifications() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotificationsNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationChannels) {
      vector<boost::any> temp1;
      for(auto item1:*notificationChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationChannels"] = boost::any(temp1);
    }
    if (notificationReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*notificationReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationReceivers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationChannels") != m.end() && !m["NotificationChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationChannels"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationChannels = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels>>(expect1);
      }
    }
    if (m.find("NotificationReceivers") != m.end() && !m["NotificationReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationReceivers"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationReceivers = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers>>(expect1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotificationsNotifications() = default;
};
class UpdateDataQualityEvaluationTaskRequestNotifications : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications>> notifications{};

  UpdateDataQualityEvaluationTaskRequestNotifications() {}

  explicit UpdateDataQualityEvaluationTaskRequestNotifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (notifications) {
      vector<boost::any> temp1;
      for(auto item1:*notifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Notifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(vector<boost::any>) == m["Notifications"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Notifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestNotificationsNotifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifications = make_shared<vector<UpdateDataQualityEvaluationTaskRequestNotificationsNotifications>>(expect1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestNotifications() = default;
};
class UpdateDataQualityEvaluationTaskRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> partitionSpec{};
  shared_ptr<string> tableGuid{};

  UpdateDataQualityEvaluationTaskRequestTarget() {}

  explicit UpdateDataQualityEvaluationTaskRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (partitionSpec) {
      res["PartitionSpec"] = boost::any(*partitionSpec);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("PartitionSpec") != m.end() && !m["PartitionSpec"].empty()) {
      partitionSpec = make_shared<string>(boost::any_cast<string>(m["PartitionSpec"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestTarget() = default;
};
class UpdateDataQualityEvaluationTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<vector<long>> taskIds{};
  shared_ptr<string> type{};

  UpdateDataQualityEvaluationTaskRequestTrigger() {}

  explicit UpdateDataQualityEvaluationTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequestTrigger() = default;
};
class UpdateDataQualityEvaluationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules>> dataQualityRules{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<vector<UpdateDataQualityEvaluationTaskRequestHooks>> hooks{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestNotifications> notifications{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestTarget> target{};
  shared_ptr<UpdateDataQualityEvaluationTaskRequestTrigger> trigger{};

  UpdateDataQualityEvaluationTaskRequest() {}

  explicit UpdateDataQualityEvaluationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRules) {
      vector<boost::any> temp1;
      for(auto item1:*dataQualityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataQualityRules"] = boost::any(temp1);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooks) {
      vector<boost::any> temp1;
      for(auto item1:*hooks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hooks"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifications) {
      res["Notifications"] = notifications ? boost::any(notifications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DataQualityRules"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataQualityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestDataQualityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataQualityRules = make_shared<vector<UpdateDataQualityEvaluationTaskRequestDataQualityRules>>(expect1);
      }
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hooks"].type()) {
        vector<UpdateDataQualityEvaluationTaskRequestHooks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hooks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityEvaluationTaskRequestHooks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hooks = make_shared<vector<UpdateDataQualityEvaluationTaskRequestHooks>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notifications"].type()) {
        UpdateDataQualityEvaluationTaskRequestNotifications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notifications"]));
        notifications = make_shared<UpdateDataQualityEvaluationTaskRequestNotifications>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        UpdateDataQualityEvaluationTaskRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<UpdateDataQualityEvaluationTaskRequestTarget>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateDataQualityEvaluationTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateDataQualityEvaluationTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskRequest() = default;
};
class UpdateDataQualityEvaluationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataQualityRulesShrink{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> hooksShrink{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> notificationsShrink{};
  shared_ptr<long> projectId{};
  shared_ptr<string> runtimeConf{};
  shared_ptr<string> targetShrink{};
  shared_ptr<string> triggerShrink{};

  UpdateDataQualityEvaluationTaskShrinkRequest() {}

  explicit UpdateDataQualityEvaluationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataQualityRulesShrink) {
      res["DataQualityRules"] = boost::any(*dataQualityRulesShrink);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hooksShrink) {
      res["Hooks"] = boost::any(*hooksShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notificationsShrink) {
      res["Notifications"] = boost::any(*notificationsShrink);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runtimeConf) {
      res["RuntimeConf"] = boost::any(*runtimeConf);
    }
    if (targetShrink) {
      res["Target"] = boost::any(*targetShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataQualityRules") != m.end() && !m["DataQualityRules"].empty()) {
      dataQualityRulesShrink = make_shared<string>(boost::any_cast<string>(m["DataQualityRules"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hooks") != m.end() && !m["Hooks"].empty()) {
      hooksShrink = make_shared<string>(boost::any_cast<string>(m["Hooks"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notifications") != m.end() && !m["Notifications"].empty()) {
      notificationsShrink = make_shared<string>(boost::any_cast<string>(m["Notifications"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RuntimeConf") != m.end() && !m["RuntimeConf"].empty()) {
      runtimeConf = make_shared<string>(boost::any_cast<string>(m["RuntimeConf"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      targetShrink = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskShrinkRequest() = default;
};
class UpdateDataQualityEvaluationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityEvaluationTaskResponseBody() {}

  explicit UpdateDataQualityEvaluationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskResponseBody() = default;
};
class UpdateDataQualityEvaluationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityEvaluationTaskResponseBody> body{};

  UpdateDataQualityEvaluationTaskResponse() {}

  explicit UpdateDataQualityEvaluationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityEvaluationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityEvaluationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityEvaluationTaskResponse() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned() = default;
};
class UpdateDataQualityRuleRequestCheckingConfigThresholds : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical> critical{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected> expected{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned> warned{};

  UpdateDataQualityRuleRequestCheckingConfigThresholds() {}

  explicit UpdateDataQualityRuleRequestCheckingConfigThresholds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expected) {
      res["Expected"] = expected ? boost::any(expected->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warned) {
      res["Warned"] = warned ? boost::any(warned->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical>(model1);
      }
    }
    if (m.find("Expected") != m.end() && !m["Expected"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expected"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expected"]));
        expected = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected>(model1);
      }
    }
    if (m.find("Warned") != m.end() && !m["Warned"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warned"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warned"]));
        warned = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfigThresholds() = default;
};
class UpdateDataQualityRuleRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfigThresholds> thresholds{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleRequestCheckingConfig() {}

  explicit UpdateDataQualityRuleRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (thresholds) {
      res["Thresholds"] = thresholds ? boost::any(thresholds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Thresholds") != m.end() && !m["Thresholds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thresholds"].type()) {
        UpdateDataQualityRuleRequestCheckingConfigThresholds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thresholds"]));
        thresholds = make_shared<UpdateDataQualityRuleRequestCheckingConfigThresholds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestCheckingConfig() = default;
};
class UpdateDataQualityRuleRequestErrorHandlers : public Darabonba::Model {
public:
  shared_ptr<string> errorDataFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleRequestErrorHandlers() {}

  explicit UpdateDataQualityRuleRequestErrorHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDataFilter) {
      res["ErrorDataFilter"] = boost::any(*errorDataFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDataFilter") != m.end() && !m["ErrorDataFilter"].empty()) {
      errorDataFilter = make_shared<string>(boost::any_cast<string>(m["ErrorDataFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestErrorHandlers() = default;
};
class UpdateDataQualityRuleRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> samplingFilter{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityRuleRequestSamplingConfig() {}

  explicit UpdateDataQualityRuleRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (samplingFilter) {
      res["SamplingFilter"] = boost::any(*samplingFilter);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SamplingFilter") != m.end() && !m["SamplingFilter"].empty()) {
      samplingFilter = make_shared<string>(boost::any_cast<string>(m["SamplingFilter"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequestSamplingConfig() = default;
};
class UpdateDataQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<vector<UpdateDataQualityRuleRequestErrorHandlers>> errorHandlers{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDataQualityRuleRequestSamplingConfig> samplingConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityRuleRequest() {}

  explicit UpdateDataQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlers) {
      vector<boost::any> temp1;
      for(auto item1:*errorHandlers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorHandlers"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityRuleRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityRuleRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorHandlers"].type()) {
        vector<UpdateDataQualityRuleRequestErrorHandlers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorHandlers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataQualityRuleRequestErrorHandlers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorHandlers = make_shared<vector<UpdateDataQualityRuleRequestErrorHandlers>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityRuleRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityRuleRequestSamplingConfig>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityRuleRequest() = default;
};
class UpdateDataQualityRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> errorHandlersShrink{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};
  shared_ptr<string> severity{};
  shared_ptr<string> templateCode{};

  UpdateDataQualityRuleShrinkRequest() {}

  explicit UpdateDataQualityRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (errorHandlersShrink) {
      res["ErrorHandlers"] = boost::any(*errorHandlersShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ErrorHandlers") != m.end() && !m["ErrorHandlers"].empty()) {
      errorHandlersShrink = make_shared<string>(boost::any_cast<string>(m["ErrorHandlers"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UpdateDataQualityRuleShrinkRequest() = default;
};
class UpdateDataQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityRuleResponseBody() {}

  explicit UpdateDataQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityRuleResponseBody() = default;
};
class UpdateDataQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityRuleResponseBody> body{};

  UpdateDataQualityRuleResponse() {}

  explicit UpdateDataQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleResponse() = default;
};
class UpdateDataQualityRuleTemplateRequestCheckingConfig : public Darabonba::Model {
public:
  shared_ptr<string> referencedSamplesFilter{};
  shared_ptr<string> type{};

  UpdateDataQualityRuleTemplateRequestCheckingConfig() {}

  explicit UpdateDataQualityRuleTemplateRequestCheckingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referencedSamplesFilter) {
      res["ReferencedSamplesFilter"] = boost::any(*referencedSamplesFilter);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferencedSamplesFilter") != m.end() && !m["ReferencedSamplesFilter"].empty()) {
      referencedSamplesFilter = make_shared<string>(boost::any_cast<string>(m["ReferencedSamplesFilter"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequestCheckingConfig() = default;
};
class UpdateDataQualityRuleTemplateRequestSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<string> metricParameters{};
  shared_ptr<string> settingConfig{};

  UpdateDataQualityRuleTemplateRequestSamplingConfig() {}

  explicit UpdateDataQualityRuleTemplateRequestSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (metricParameters) {
      res["MetricParameters"] = boost::any(*metricParameters);
    }
    if (settingConfig) {
      res["SettingConfig"] = boost::any(*settingConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("MetricParameters") != m.end() && !m["MetricParameters"].empty()) {
      metricParameters = make_shared<string>(boost::any_cast<string>(m["MetricParameters"]));
    }
    if (m.find("SettingConfig") != m.end() && !m["SettingConfig"].empty()) {
      settingConfig = make_shared<string>(boost::any_cast<string>(m["SettingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequestSamplingConfig() = default;
};
class UpdateDataQualityRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateDataQualityRuleTemplateRequestCheckingConfig> checkingConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<UpdateDataQualityRuleTemplateRequestSamplingConfig> samplingConfig{};

  UpdateDataQualityRuleTemplateRequest() {}

  explicit UpdateDataQualityRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfig) {
      res["CheckingConfig"] = checkingConfig ? boost::any(checkingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfig) {
      res["SamplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckingConfig"].type()) {
        UpdateDataQualityRuleTemplateRequestCheckingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckingConfig"]));
        checkingConfig = make_shared<UpdateDataQualityRuleTemplateRequestCheckingConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamplingConfig"].type()) {
        UpdateDataQualityRuleTemplateRequestSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamplingConfig"]));
        samplingConfig = make_shared<UpdateDataQualityRuleTemplateRequestSamplingConfig>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleTemplateRequest() = default;
};
class UpdateDataQualityRuleTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkingConfigShrink{};
  shared_ptr<string> code{};
  shared_ptr<string> directoryPath{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> samplingConfigShrink{};

  UpdateDataQualityRuleTemplateShrinkRequest() {}

  explicit UpdateDataQualityRuleTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingConfigShrink) {
      res["CheckingConfig"] = boost::any(*checkingConfigShrink);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (directoryPath) {
      res["DirectoryPath"] = boost::any(*directoryPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (samplingConfigShrink) {
      res["SamplingConfig"] = boost::any(*samplingConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingConfig") != m.end() && !m["CheckingConfig"].empty()) {
      checkingConfigShrink = make_shared<string>(boost::any_cast<string>(m["CheckingConfig"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DirectoryPath") != m.end() && !m["DirectoryPath"].empty()) {
      directoryPath = make_shared<string>(boost::any_cast<string>(m["DirectoryPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SamplingConfig") != m.end() && !m["SamplingConfig"].empty()) {
      samplingConfigShrink = make_shared<string>(boost::any_cast<string>(m["SamplingConfig"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateShrinkRequest() = default;
};
class UpdateDataQualityRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataQualityRuleTemplateResponseBody() {}

  explicit UpdateDataQualityRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataQualityRuleTemplateResponseBody() = default;
};
class UpdateDataQualityRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataQualityRuleTemplateResponseBody> body{};

  UpdateDataQualityRuleTemplateResponse() {}

  explicit UpdateDataQualityRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataQualityRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataQualityRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataQualityRuleTemplateResponse() = default;
};
class UpdateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> connectionProperties{};
  shared_ptr<string> connectionPropertiesMode{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};

  UpdateDataSourceRequest() {}

  explicit UpdateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionProperties) {
      res["ConnectionProperties"] = boost::any(*connectionProperties);
    }
    if (connectionPropertiesMode) {
      res["ConnectionPropertiesMode"] = boost::any(*connectionPropertiesMode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionProperties") != m.end() && !m["ConnectionProperties"].empty()) {
      connectionProperties = make_shared<string>(boost::any_cast<string>(m["ConnectionProperties"]));
    }
    if (m.find("ConnectionPropertiesMode") != m.end() && !m["ConnectionPropertiesMode"].empty()) {
      connectionPropertiesMode = make_shared<string>(boost::any_cast<string>(m["ConnectionPropertiesMode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateDataSourceRequest() = default;
};
class UpdateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataSourceResponseBody() {}

  explicit UpdateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataSourceResponseBody() = default;
};
class UpdateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataSourceResponseBody> body{};

  UpdateDataSourceResponse() {}

  explicit UpdateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceResponse() = default;
};
class UpdateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> advancedSettings{};
  shared_ptr<bool> applyScheduleImmediately{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> content{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> dependentType{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<bool> ignoreParentSkipRunningProperty{};
  shared_ptr<string> imageId{};
  shared_ptr<string> inputList{};
  shared_ptr<string> inputParameters{};
  shared_ptr<string> outputList{};
  shared_ptr<string> outputParameters{};
  shared_ptr<string> owner{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> rerunMode{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<string> schedulerType{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<bool> startImmediately{};
  shared_ptr<bool> stop{};
  shared_ptr<long> timeout{};

  UpdateFileRequest() {}

  explicit UpdateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedSettings) {
      res["AdvancedSettings"] = boost::any(*advancedSettings);
    }
    if (applyScheduleImmediately) {
      res["ApplyScheduleImmediately"] = boost::any(*applyScheduleImmediately);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (ignoreParentSkipRunningProperty) {
      res["IgnoreParentSkipRunningProperty"] = boost::any(*ignoreParentSkipRunningProperty);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (outputList) {
      res["OutputList"] = boost::any(*outputList);
    }
    if (outputParameters) {
      res["OutputParameters"] = boost::any(*outputParameters);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (startImmediately) {
      res["StartImmediately"] = boost::any(*startImmediately);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedSettings") != m.end() && !m["AdvancedSettings"].empty()) {
      advancedSettings = make_shared<string>(boost::any_cast<string>(m["AdvancedSettings"]));
    }
    if (m.find("ApplyScheduleImmediately") != m.end() && !m["ApplyScheduleImmediately"].empty()) {
      applyScheduleImmediately = make_shared<bool>(boost::any_cast<bool>(m["ApplyScheduleImmediately"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("IgnoreParentSkipRunningProperty") != m.end() && !m["IgnoreParentSkipRunningProperty"].empty()) {
      ignoreParentSkipRunningProperty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreParentSkipRunningProperty"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParameters = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      outputList = make_shared<string>(boost::any_cast<string>(m["OutputList"]));
    }
    if (m.find("OutputParameters") != m.end() && !m["OutputParameters"].empty()) {
      outputParameters = make_shared<string>(boost::any_cast<string>(m["OutputParameters"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("StartImmediately") != m.end() && !m["StartImmediately"].empty()) {
      startImmediately = make_shared<bool>(boost::any_cast<bool>(m["StartImmediately"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateFileRequest() = default;
};
class UpdateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFileResponseBody() {}

  explicit UpdateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFileResponseBody() = default;
};
class UpdateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileResponseBody> body{};

  UpdateFileResponse() {}

  explicit UpdateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileResponse() = default;
};
class UpdateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};

  UpdateFolderRequest() {}

  explicit UpdateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~UpdateFolderRequest() = default;
};
class UpdateFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFolderResponseBody() {}

  explicit UpdateFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFolderResponseBody() = default;
};
class UpdateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFolderResponseBody> body{};

  UpdateFolderResponse() {}

  explicit UpdateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFolderResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFolderResponse() = default;
};
class UpdateFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateFunctionRequest() {}

  explicit UpdateFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateFunctionRequest() = default;
};
class UpdateFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFunctionResponseBody() {}

  explicit UpdateFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFunctionResponseBody() = default;
};
class UpdateFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFunctionResponseBody> body{};

  UpdateFunctionResponse() {}

  explicit UpdateFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFunctionResponse() = default;
};
class UpdateIDEEventResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkResult{};
  shared_ptr<string> checkResultTip{};
  shared_ptr<string> extensionCode{};
  shared_ptr<string> messageId{};

  UpdateIDEEventResultRequest() {}

  explicit UpdateIDEEventResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (checkResultTip) {
      res["CheckResultTip"] = boost::any(*checkResultTip);
    }
    if (extensionCode) {
      res["ExtensionCode"] = boost::any(*extensionCode);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("CheckResultTip") != m.end() && !m["CheckResultTip"].empty()) {
      checkResultTip = make_shared<string>(boost::any_cast<string>(m["CheckResultTip"]));
    }
    if (m.find("ExtensionCode") != m.end() && !m["ExtensionCode"].empty()) {
      extensionCode = make_shared<string>(boost::any_cast<string>(m["ExtensionCode"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~UpdateIDEEventResultRequest() = default;
};
class UpdateIDEEventResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIDEEventResultResponseBody() {}

  explicit UpdateIDEEventResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIDEEventResultResponseBody() = default;
};
class UpdateIDEEventResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIDEEventResultResponseBody> body{};

  UpdateIDEEventResultResponse() {}

  explicit UpdateIDEEventResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIDEEventResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIDEEventResultResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIDEEventResultResponse() = default;
};
class UpdateMetaCollectionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> administrators{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  UpdateMetaCollectionRequest() {}

  explicit UpdateMetaCollectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administrators) {
      res["Administrators"] = boost::any(*administrators);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Administrators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Administrators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      administrators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateMetaCollectionRequest() = default;
};
class UpdateMetaCollectionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> administratorsShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  UpdateMetaCollectionShrinkRequest() {}

  explicit UpdateMetaCollectionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administratorsShrink) {
      res["Administrators"] = boost::any(*administratorsShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      administratorsShrink = make_shared<string>(boost::any_cast<string>(m["Administrators"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateMetaCollectionShrinkRequest() = default;
};
class UpdateMetaCollectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMetaCollectionResponseBody() {}

  explicit UpdateMetaCollectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMetaCollectionResponseBody() = default;
};
class UpdateMetaCollectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMetaCollectionResponseBody> body{};

  UpdateMetaCollectionResponse() {}

  explicit UpdateMetaCollectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMetaCollectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMetaCollectionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMetaCollectionResponse() = default;
};
class UpdateNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateNodeRequest() {}

  explicit UpdateNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateNodeRequest() = default;
};
class UpdateNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNodeResponseBody() {}

  explicit UpdateNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNodeResponseBody() = default;
};
class UpdateNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNodeResponseBody> body{};

  UpdateNodeResponse() {}

  explicit UpdateNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNodeResponse() = default;
};
class UpdateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> devEnvironmentEnabled{};
  shared_ptr<bool> devRoleDisabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> id{};
  shared_ptr<bool> paiTaskEnabled{};
  shared_ptr<string> status{};

  UpdateProjectRequest() {}

  explicit UpdateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devEnvironmentEnabled) {
      res["DevEnvironmentEnabled"] = boost::any(*devEnvironmentEnabled);
    }
    if (devRoleDisabled) {
      res["DevRoleDisabled"] = boost::any(*devRoleDisabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (paiTaskEnabled) {
      res["PaiTaskEnabled"] = boost::any(*paiTaskEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevEnvironmentEnabled") != m.end() && !m["DevEnvironmentEnabled"].empty()) {
      devEnvironmentEnabled = make_shared<bool>(boost::any_cast<bool>(m["DevEnvironmentEnabled"]));
    }
    if (m.find("DevRoleDisabled") != m.end() && !m["DevRoleDisabled"].empty()) {
      devRoleDisabled = make_shared<bool>(boost::any_cast<bool>(m["DevRoleDisabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PaiTaskEnabled") != m.end() && !m["PaiTaskEnabled"].empty()) {
      paiTaskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PaiTaskEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateProjectRequest() = default;
};
class UpdateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProjectResponseBody() {}

  explicit UpdateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProjectResponseBody() = default;
};
class UpdateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectResponseBody> body{};

  UpdateProjectResponse() {}

  explicit UpdateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectResponse() = default;
};
class UpdateResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> resourceFile{};
  shared_ptr<string> spec{};

  UpdateResourceRequest() {}

  explicit UpdateResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceFile) {
      res["ResourceFile"] = boost::any(*resourceFile);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFile = make_shared<string>(boost::any_cast<string>(m["ResourceFile"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateResourceRequest() = default;
};
class UpdateResourceAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<Darabonba::Stream> resourceFileObject{};
  shared_ptr<string> spec{};

  UpdateResourceAdvanceRequest() {}

  explicit UpdateResourceAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceFileObject) {
      res["ResourceFile"] = boost::any(*resourceFileObject);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResourceFile") != m.end() && !m["ResourceFile"].empty()) {
      resourceFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["ResourceFile"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateResourceAdvanceRequest() = default;
};
class UpdateResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateResourceResponseBody() {}

  explicit UpdateResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateResourceResponseBody() = default;
};
class UpdateResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceResponseBody> body{};

  UpdateResourceResponse() {}

  explicit UpdateResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceResponse() = default;
};
class UpdateResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunResourceGroupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};

  UpdateResourceGroupRequest() {}

  explicit UpdateResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunResourceGroupId) {
      res["AliyunResourceGroupId"] = boost::any(*aliyunResourceGroupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunResourceGroupId") != m.end() && !m["AliyunResourceGroupId"].empty()) {
      aliyunResourceGroupId = make_shared<string>(boost::any_cast<string>(m["AliyunResourceGroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateResourceGroupRequest() = default;
};
class UpdateResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateResourceGroupResponseBody() {}

  explicit UpdateResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateResourceGroupResponseBody() = default;
};
class UpdateResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceGroupResponseBody> body{};

  UpdateResourceGroupResponse() {}

  explicit UpdateResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceGroupResponse() = default;
};
class UpdateRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidr{};
  shared_ptr<long> id{};

  UpdateRouteRequest() {}

  explicit UpdateRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateRouteRequest() = default;
};
class UpdateRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateRouteResponseBody() {}

  explicit UpdateRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateRouteResponseBody() = default;
};
class UpdateRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRouteResponseBody> body{};

  UpdateRouteResponse() {}

  explicit UpdateRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRouteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRouteResponse() = default;
};
class UpdateTableBusinessMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> readme{};

  UpdateTableBusinessMetadataRequest() {}

  explicit UpdateTableBusinessMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (readme) {
      res["Readme"] = boost::any(*readme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Readme") != m.end() && !m["Readme"].empty()) {
      readme = make_shared<string>(boost::any_cast<string>(m["Readme"]));
    }
  }


  virtual ~UpdateTableBusinessMetadataRequest() = default;
};
class UpdateTableBusinessMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTableBusinessMetadataResponseBody() {}

  explicit UpdateTableBusinessMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTableBusinessMetadataResponseBody() = default;
};
class UpdateTableBusinessMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTableBusinessMetadataResponseBody> body{};

  UpdateTableBusinessMetadataResponse() {}

  explicit UpdateTableBusinessMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableBusinessMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableBusinessMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableBusinessMetadataResponse() = default;
};
class UpdateTaskRequestDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateTaskRequestDataSource() {}

  explicit UpdateTaskRequestDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateTaskRequestDataSource() = default;
};
class UpdateTaskRequestDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateTaskRequestDependencies() {}

  explicit UpdateTaskRequestDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateTaskRequestDependencies() = default;
};
class UpdateTaskRequestInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateTaskRequestInputsVariables() {}

  explicit UpdateTaskRequestInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestInputsVariables() = default;
};
class UpdateTaskRequestInputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTaskRequestInputsVariables>> variables{};

  UpdateTaskRequestInputs() {}

  explicit UpdateTaskRequestInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateTaskRequestInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateTaskRequestInputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskRequestInputs() = default;
};
class UpdateTaskRequestOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateTaskRequestOutputsTaskOutputs() {}

  explicit UpdateTaskRequestOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateTaskRequestOutputsTaskOutputs() = default;
};
class UpdateTaskRequestOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateTaskRequestOutputsVariables() {}

  explicit UpdateTaskRequestOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestOutputsVariables() = default;
};
class UpdateTaskRequestOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTaskRequestOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<UpdateTaskRequestOutputsVariables>> variables{};

  UpdateTaskRequestOutputs() {}

  explicit UpdateTaskRequestOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateTaskRequestOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateTaskRequestOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateTaskRequestOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateTaskRequestOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskRequestOutputs() = default;
};
class UpdateTaskRequestRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  UpdateTaskRequestRuntimeResource() {}

  explicit UpdateTaskRequestRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~UpdateTaskRequestRuntimeResource() = default;
};
class UpdateTaskRequestScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  UpdateTaskRequestScript() {}

  explicit UpdateTaskRequestScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~UpdateTaskRequestScript() = default;
};
class UpdateTaskRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateTaskRequestTags() {}

  explicit UpdateTaskRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskRequestTags() = default;
};
class UpdateTaskRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  UpdateTaskRequestTrigger() {}

  explicit UpdateTaskRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateTaskRequestTrigger() = default;
};
class UpdateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<UpdateTaskRequestDataSource> dataSource{};
  shared_ptr<vector<UpdateTaskRequestDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<UpdateTaskRequestInputs> inputs{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<UpdateTaskRequestOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<UpdateTaskRequestRuntimeResource> runtimeResource{};
  shared_ptr<UpdateTaskRequestScript> script{};
  shared_ptr<vector<UpdateTaskRequestTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<UpdateTaskRequestTrigger> trigger{};

  UpdateTaskRequest() {}

  explicit UpdateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateTaskRequestDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateTaskRequestDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateTaskRequestDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateTaskRequestDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        UpdateTaskRequestInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<UpdateTaskRequestInputs>(model1);
      }
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateTaskRequestOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateTaskRequestOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        UpdateTaskRequestRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<UpdateTaskRequestRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        UpdateTaskRequestScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<UpdateTaskRequestScript>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateTaskRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateTaskRequestTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateTaskRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateTaskRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateTaskRequest() = default;
};
class UpdateTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> dataSourceShrink{};
  shared_ptr<string> dependenciesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputsShrink{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<string> outputsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<string> runtimeResourceShrink{};
  shared_ptr<string> scriptShrink{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<long> timeout{};
  shared_ptr<string> triggerShrink{};

  UpdateTaskShrinkRequest() {}

  explicit UpdateTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSourceShrink) {
      res["DataSource"] = boost::any(*dataSourceShrink);
    }
    if (dependenciesShrink) {
      res["Dependencies"] = boost::any(*dependenciesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputsShrink) {
      res["Inputs"] = boost::any(*inputsShrink);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputsShrink) {
      res["Outputs"] = boost::any(*outputsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResourceShrink) {
      res["RuntimeResource"] = boost::any(*runtimeResourceShrink);
    }
    if (scriptShrink) {
      res["Script"] = boost::any(*scriptShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSourceShrink = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      dependenciesShrink = make_shared<string>(boost::any_cast<string>(m["Dependencies"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      inputsShrink = make_shared<string>(boost::any_cast<string>(m["Inputs"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputsShrink = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResourceShrink = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      scriptShrink = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateTaskShrinkRequest() = default;
};
class UpdateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskResponseBody() {}

  explicit UpdateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskResponseBody() = default;
};
class UpdateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskResponseBody> body{};

  UpdateTaskResponse() {}

  explicit UpdateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskResponse() = default;
};
class UpdateTaskInstancesRequestTaskInstancesDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateTaskInstancesRequestTaskInstancesDataSource() {}

  explicit UpdateTaskInstancesRequestTaskInstancesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateTaskInstancesRequestTaskInstancesDataSource() = default;
};
class UpdateTaskInstancesRequestTaskInstances : public Darabonba::Model {
public:
  shared_ptr<UpdateTaskInstancesRequestTaskInstancesDataSource> dataSource{};
  shared_ptr<long> id{};
  shared_ptr<long> priority{};
  shared_ptr<string> runtimeResource{};

  UpdateTaskInstancesRequestTaskInstances() {}

  explicit UpdateTaskInstancesRequestTaskInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = boost::any(*runtimeResource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateTaskInstancesRequestTaskInstancesDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateTaskInstancesRequestTaskInstancesDataSource>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      runtimeResource = make_shared<string>(boost::any_cast<string>(m["RuntimeResource"]));
    }
  }


  virtual ~UpdateTaskInstancesRequestTaskInstances() = default;
};
class UpdateTaskInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<UpdateTaskInstancesRequestTaskInstances>> taskInstances{};

  UpdateTaskInstancesRequest() {}

  explicit UpdateTaskInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (taskInstances) {
      vector<boost::any> temp1;
      for(auto item1:*taskInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInstances"].type()) {
        vector<UpdateTaskInstancesRequestTaskInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskInstancesRequestTaskInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInstances = make_shared<vector<UpdateTaskInstancesRequestTaskInstances>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskInstancesRequest() = default;
};
class UpdateTaskInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> taskInstancesShrink{};

  UpdateTaskInstancesShrinkRequest() {}

  explicit UpdateTaskInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (taskInstancesShrink) {
      res["TaskInstances"] = boost::any(*taskInstancesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("TaskInstances") != m.end() && !m["TaskInstances"].empty()) {
      taskInstancesShrink = make_shared<string>(boost::any_cast<string>(m["TaskInstances"]));
    }
  }


  virtual ~UpdateTaskInstancesShrinkRequest() = default;
};
class UpdateTaskInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, SuccessInfoValue>> successInfo{};

  UpdateTaskInstancesResponseBody() {}

  explicit UpdateTaskInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successInfo) {
      map<string, boost::any> temp1;
      for(auto item1:*successInfo){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["SuccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessInfo") != m.end() && !m["SuccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessInfo"].type()) {
        map<string, SuccessInfoValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SuccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            SuccessInfoValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        successInfo = make_shared<map<string, SuccessInfoValue>>(expect1);
      }
    }
  }


  virtual ~UpdateTaskInstancesResponseBody() = default;
};
class UpdateTaskInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskInstancesResponseBody> body{};

  UpdateTaskInstancesResponse() {}

  explicit UpdateTaskInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskInstancesResponse() = default;
};
class UpdateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> className{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<string> example{};
  shared_ptr<string> fileFolderPath{};
  shared_ptr<string> fileId{};
  shared_ptr<string> functionType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> resources{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> udfDescription{};

  UpdateUdfFileRequest() {}

  explicit UpdateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
  }


  virtual ~UpdateUdfFileRequest() = default;
};
class UpdateUdfFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateUdfFileResponseBody() {}

  explicit UpdateUdfFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateUdfFileResponseBody() = default;
};
class UpdateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUdfFileResponseBody> body{};

  UpdateUdfFileResponse() {}

  explicit UpdateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUdfFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUdfFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUdfFileResponse() = default;
};
class UpdateWorkflowRequestDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateWorkflowRequestDependencies() {}

  explicit UpdateWorkflowRequestDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateWorkflowRequestDependencies() = default;
};
class UpdateWorkflowRequestOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateWorkflowRequestOutputsTaskOutputs() {}

  explicit UpdateWorkflowRequestOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateWorkflowRequestOutputsTaskOutputs() = default;
};
class UpdateWorkflowRequestOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestOutputsTaskOutputs>> taskOutputs{};

  UpdateWorkflowRequestOutputs() {}

  explicit UpdateWorkflowRequestOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateWorkflowRequestOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateWorkflowRequestOutputsTaskOutputs>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestOutputs() = default;
};
class UpdateWorkflowRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTags() {}

  explicit UpdateWorkflowRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTags() = default;
};
class UpdateWorkflowRequestTasksDataSource : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateWorkflowRequestTasksDataSource() {}

  explicit UpdateWorkflowRequestTasksDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksDataSource() = default;
};
class UpdateWorkflowRequestTasksDependencies : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> upstreamOutput{};
  shared_ptr<long> upstreamTaskId{};

  UpdateWorkflowRequestTasksDependencies() {}

  explicit UpdateWorkflowRequestTasksDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (upstreamOutput) {
      res["UpstreamOutput"] = boost::any(*upstreamOutput);
    }
    if (upstreamTaskId) {
      res["UpstreamTaskId"] = boost::any(*upstreamTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpstreamOutput") != m.end() && !m["UpstreamOutput"].empty()) {
      upstreamOutput = make_shared<string>(boost::any_cast<string>(m["UpstreamOutput"]));
    }
    if (m.find("UpstreamTaskId") != m.end() && !m["UpstreamTaskId"].empty()) {
      upstreamTaskId = make_shared<long>(boost::any_cast<long>(m["UpstreamTaskId"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksDependencies() = default;
};
class UpdateWorkflowRequestTasksInputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksInputsVariables() {}

  explicit UpdateWorkflowRequestTasksInputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksInputsVariables() = default;
};
class UpdateWorkflowRequestTasksInputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestTasksInputsVariables>> variables{};

  UpdateWorkflowRequestTasksInputs() {}

  explicit UpdateWorkflowRequestTasksInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateWorkflowRequestTasksInputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksInputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateWorkflowRequestTasksInputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestTasksInputs() = default;
};
class UpdateWorkflowRequestTasksOutputsTaskOutputs : public Darabonba::Model {
public:
  shared_ptr<string> output{};

  UpdateWorkflowRequestTasksOutputsTaskOutputs() {}

  explicit UpdateWorkflowRequestTasksOutputsTaskOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputsTaskOutputs() = default;
};
class UpdateWorkflowRequestTasksOutputsVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksOutputsVariables() {}

  explicit UpdateWorkflowRequestTasksOutputsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputsVariables() = default;
};
class UpdateWorkflowRequestTasksOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkflowRequestTasksOutputsTaskOutputs>> taskOutputs{};
  shared_ptr<vector<UpdateWorkflowRequestTasksOutputsVariables>> variables{};

  UpdateWorkflowRequestTasksOutputs() {}

  explicit UpdateWorkflowRequestTasksOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskOutputs) {
      vector<boost::any> temp1;
      for(auto item1:*taskOutputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskOutputs"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskOutputs") != m.end() && !m["TaskOutputs"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskOutputs"].type()) {
        vector<UpdateWorkflowRequestTasksOutputsTaskOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskOutputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksOutputsTaskOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskOutputs = make_shared<vector<UpdateWorkflowRequestTasksOutputsTaskOutputs>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<UpdateWorkflowRequestTasksOutputsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksOutputsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<UpdateWorkflowRequestTasksOutputsVariables>>(expect1);
      }
    }
  }


  virtual ~UpdateWorkflowRequestTasksOutputs() = default;
};
class UpdateWorkflowRequestTasksRuntimeResource : public Darabonba::Model {
public:
  shared_ptr<string> cu{};
  shared_ptr<string> image{};
  shared_ptr<string> resourceGroupId{};

  UpdateWorkflowRequestTasksRuntimeResource() {}

  explicit UpdateWorkflowRequestTasksRuntimeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<string>(boost::any_cast<string>(m["Cu"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksRuntimeResource() = default;
};
class UpdateWorkflowRequestTasksScript : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> parameters{};

  UpdateWorkflowRequestTasksScript() {}

  explicit UpdateWorkflowRequestTasksScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksScript() = default;
};
class UpdateWorkflowRequestTasksTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateWorkflowRequestTasksTags() {}

  explicit UpdateWorkflowRequestTasksTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksTags() = default;
};
class UpdateWorkflowRequestTasksTrigger : public Darabonba::Model {
public:
  shared_ptr<string> recurrence{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTasksTrigger() {}

  explicit UpdateWorkflowRequestTasksTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recurrence) {
      res["Recurrence"] = boost::any(*recurrence);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasksTrigger() = default;
};
class UpdateWorkflowRequestTasks : public Darabonba::Model {
public:
  shared_ptr<long> baseLineId{};
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<UpdateWorkflowRequestTasksDataSource> dataSource{};
  shared_ptr<vector<UpdateWorkflowRequestTasksDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<UpdateWorkflowRequestTasksInputs> inputs{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWorkflowRequestTasksOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<long> rerunInterval{};
  shared_ptr<string> rerunMode{};
  shared_ptr<long> rerunTimes{};
  shared_ptr<UpdateWorkflowRequestTasksRuntimeResource> runtimeResource{};
  shared_ptr<UpdateWorkflowRequestTasksScript> script{};
  shared_ptr<vector<UpdateWorkflowRequestTasksTags>> tags{};
  shared_ptr<long> timeout{};
  shared_ptr<UpdateWorkflowRequestTasksTrigger> trigger{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTasks() {}

  explicit UpdateWorkflowRequestTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseLineId) {
      res["BaseLineId"] = boost::any(*baseLineId);
    }
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (rerunInterval) {
      res["RerunInterval"] = boost::any(*rerunInterval);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (rerunTimes) {
      res["RerunTimes"] = boost::any(*rerunTimes);
    }
    if (runtimeResource) {
      res["RuntimeResource"] = runtimeResource ? boost::any(runtimeResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseLineId") != m.end() && !m["BaseLineId"].empty()) {
      baseLineId = make_shared<long>(boost::any_cast<long>(m["BaseLineId"]));
    }
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        UpdateWorkflowRequestTasksDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<UpdateWorkflowRequestTasksDataSource>(model1);
      }
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateWorkflowRequestTasksDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateWorkflowRequestTasksDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        UpdateWorkflowRequestTasksInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<UpdateWorkflowRequestTasksInputs>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateWorkflowRequestTasksOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateWorkflowRequestTasksOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RerunInterval") != m.end() && !m["RerunInterval"].empty()) {
      rerunInterval = make_shared<long>(boost::any_cast<long>(m["RerunInterval"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("RerunTimes") != m.end() && !m["RerunTimes"].empty()) {
      rerunTimes = make_shared<long>(boost::any_cast<long>(m["RerunTimes"]));
    }
    if (m.find("RuntimeResource") != m.end() && !m["RuntimeResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeResource"].type()) {
        UpdateWorkflowRequestTasksRuntimeResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeResource"]));
        runtimeResource = make_shared<UpdateWorkflowRequestTasksRuntimeResource>(model1);
      }
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        UpdateWorkflowRequestTasksScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<UpdateWorkflowRequestTasksScript>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateWorkflowRequestTasksTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasksTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateWorkflowRequestTasksTags>>(expect1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateWorkflowRequestTasksTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateWorkflowRequestTasksTrigger>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTasks() = default;
};
class UpdateWorkflowRequestTrigger : public Darabonba::Model {
public:
  shared_ptr<string> cron{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  UpdateWorkflowRequestTrigger() {}

  explicit UpdateWorkflowRequestTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateWorkflowRequestTrigger() = default;
};
class UpdateWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<vector<UpdateWorkflowRequestDependencies>> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWorkflowRequestOutputs> outputs{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<vector<UpdateWorkflowRequestTags>> tags{};
  shared_ptr<vector<UpdateWorkflowRequestTasks>> tasks{};
  shared_ptr<UpdateWorkflowRequestTrigger> trigger{};

  UpdateWorkflowRequest() {}

  explicit UpdateWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dependencies"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      res["Outputs"] = outputs ? boost::any(outputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["Dependencies"].type()) {
        vector<UpdateWorkflowRequestDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<UpdateWorkflowRequestDependencies>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outputs"].type()) {
        UpdateWorkflowRequestOutputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outputs"]));
        outputs = make_shared<UpdateWorkflowRequestOutputs>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateWorkflowRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateWorkflowRequestTags>>(expect1);
      }
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<UpdateWorkflowRequestTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkflowRequestTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<UpdateWorkflowRequestTasks>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        UpdateWorkflowRequestTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<UpdateWorkflowRequestTrigger>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowRequest() = default;
};
class UpdateWorkflowShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientUniqueCode{};
  shared_ptr<string> dependenciesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> envType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceMode{};
  shared_ptr<string> name{};
  shared_ptr<string> outputsShrink{};
  shared_ptr<string> owner{};
  shared_ptr<string> parameters{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> tasksShrink{};
  shared_ptr<string> triggerShrink{};

  UpdateWorkflowShrinkRequest() {}

  explicit UpdateWorkflowShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientUniqueCode) {
      res["ClientUniqueCode"] = boost::any(*clientUniqueCode);
    }
    if (dependenciesShrink) {
      res["Dependencies"] = boost::any(*dependenciesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceMode) {
      res["InstanceMode"] = boost::any(*instanceMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputsShrink) {
      res["Outputs"] = boost::any(*outputsShrink);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (tasksShrink) {
      res["Tasks"] = boost::any(*tasksShrink);
    }
    if (triggerShrink) {
      res["Trigger"] = boost::any(*triggerShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientUniqueCode") != m.end() && !m["ClientUniqueCode"].empty()) {
      clientUniqueCode = make_shared<string>(boost::any_cast<string>(m["ClientUniqueCode"]));
    }
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      dependenciesShrink = make_shared<string>(boost::any_cast<string>(m["Dependencies"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceMode") != m.end() && !m["InstanceMode"].empty()) {
      instanceMode = make_shared<string>(boost::any_cast<string>(m["InstanceMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputsShrink = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasksShrink = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      triggerShrink = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~UpdateWorkflowShrinkRequest() = default;
};
class UpdateWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateWorkflowResponseBody() {}

  explicit UpdateWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateWorkflowResponseBody() = default;
};
class UpdateWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkflowResponseBody> body{};

  UpdateWorkflowResponse() {}

  explicit UpdateWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowResponse() = default;
};
class UpdateWorkflowDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> projectId{};
  shared_ptr<string> spec{};

  UpdateWorkflowDefinitionRequest() {}

  explicit UpdateWorkflowDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateWorkflowDefinitionRequest() = default;
};
class UpdateWorkflowDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateWorkflowDefinitionResponseBody() {}

  explicit UpdateWorkflowDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateWorkflowDefinitionResponseBody() = default;
};
class UpdateWorkflowDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkflowDefinitionResponseBody> body{};

  UpdateWorkflowDefinitionResponse() {}

  explicit UpdateWorkflowDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkflowDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkflowDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkflowDefinitionResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishPipelineRunResponse abolishPipelineRunWithOptions(shared_ptr<AbolishPipelineRunRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishPipelineRunResponse abolishPipelineRun(shared_ptr<AbolishPipelineRunRequest> request);
  AddEntityIntoMetaCollectionResponse addEntityIntoMetaCollectionWithOptions(shared_ptr<AddEntityIntoMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEntityIntoMetaCollectionResponse addEntityIntoMetaCollection(shared_ptr<AddEntityIntoMetaCollectionRequest> request);
  AssociateProjectToResourceGroupResponse associateProjectToResourceGroupWithOptions(shared_ptr<AssociateProjectToResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateProjectToResourceGroupResponse associateProjectToResourceGroup(shared_ptr<AssociateProjectToResourceGroupRequest> request);
  AttachDataQualityRulesToEvaluationTaskResponse attachDataQualityRulesToEvaluationTaskWithOptions(shared_ptr<AttachDataQualityRulesToEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDataQualityRulesToEvaluationTaskResponse attachDataQualityRulesToEvaluationTask(shared_ptr<AttachDataQualityRulesToEvaluationTaskRequest> request);
  BatchUpdateTasksResponse batchUpdateTasksWithOptions(shared_ptr<BatchUpdateTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateTasksResponse batchUpdateTasks(shared_ptr<BatchUpdateTasksRequest> request);
  CloneDataSourceResponse cloneDataSourceWithOptions(shared_ptr<CloneDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneDataSourceResponse cloneDataSource(shared_ptr<CloneDataSourceRequest> request);
  CreateAlertRuleResponse createAlertRuleWithOptions(shared_ptr<CreateAlertRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertRuleResponse createAlertRule(shared_ptr<CreateAlertRuleRequest> request);
  CreateBusinessResponse createBusinessWithOptions(shared_ptr<CreateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBusinessResponse createBusiness(shared_ptr<CreateBusinessRequest> request);
  CreateDIAlarmRuleResponse createDIAlarmRuleWithOptions(shared_ptr<CreateDIAlarmRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDIAlarmRuleResponse createDIAlarmRule(shared_ptr<CreateDIAlarmRuleRequest> request);
  CreateDIJobResponse createDIJobWithOptions(shared_ptr<CreateDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDIJobResponse createDIJob(shared_ptr<CreateDIJobRequest> request);
  CreateDataAssetTagResponse createDataAssetTagWithOptions(shared_ptr<CreateDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataAssetTagResponse createDataAssetTag(shared_ptr<CreateDataAssetTagRequest> request);
  CreateDataQualityEvaluationTaskResponse createDataQualityEvaluationTaskWithOptions(shared_ptr<CreateDataQualityEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityEvaluationTaskResponse createDataQualityEvaluationTask(shared_ptr<CreateDataQualityEvaluationTaskRequest> request);
  CreateDataQualityEvaluationTaskInstanceResponse createDataQualityEvaluationTaskInstanceWithOptions(shared_ptr<CreateDataQualityEvaluationTaskInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityEvaluationTaskInstanceResponse createDataQualityEvaluationTaskInstance(shared_ptr<CreateDataQualityEvaluationTaskInstanceRequest> request);
  CreateDataQualityRuleResponse createDataQualityRuleWithOptions(shared_ptr<CreateDataQualityRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityRuleResponse createDataQualityRule(shared_ptr<CreateDataQualityRuleRequest> request);
  CreateDataQualityRuleTemplateResponse createDataQualityRuleTemplateWithOptions(shared_ptr<CreateDataQualityRuleTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataQualityRuleTemplateResponse createDataQualityRuleTemplate(shared_ptr<CreateDataQualityRuleTemplateRequest> request);
  CreateDataSourceResponse createDataSourceWithOptions(shared_ptr<CreateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request);
  CreateDataSourceSharedRuleResponse createDataSourceSharedRuleWithOptions(shared_ptr<CreateDataSourceSharedRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceSharedRuleResponse createDataSourceSharedRule(shared_ptr<CreateDataSourceSharedRuleRequest> request);
  CreateFileResponse createFileWithOptions(shared_ptr<CreateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileResponse createFile(shared_ptr<CreateFileRequest> request);
  CreateFolderResponse createFolderWithOptions(shared_ptr<CreateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFolderResponse createFolder(shared_ptr<CreateFolderRequest> request);
  CreateFunctionResponse createFunctionWithOptions(shared_ptr<CreateFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFunctionResponse createFunction(shared_ptr<CreateFunctionRequest> request);
  CreateLineageRelationshipResponse createLineageRelationshipWithOptions(shared_ptr<CreateLineageRelationshipRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLineageRelationshipResponse createLineageRelationship(shared_ptr<CreateLineageRelationshipRequest> request);
  CreateMetaCollectionResponse createMetaCollectionWithOptions(shared_ptr<CreateMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetaCollectionResponse createMetaCollection(shared_ptr<CreateMetaCollectionRequest> request);
  CreateNetworkResponse createNetworkWithOptions(shared_ptr<CreateNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkResponse createNetwork(shared_ptr<CreateNetworkRequest> request);
  CreateNodeResponse createNodeWithOptions(shared_ptr<CreateNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNodeResponse createNode(shared_ptr<CreateNodeRequest> request);
  CreatePipelineRunResponse createPipelineRunWithOptions(shared_ptr<CreatePipelineRunRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineRunResponse createPipelineRun(shared_ptr<CreatePipelineRunRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<CreateProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<CreateProjectRequest> request);
  CreateProjectMemberResponse createProjectMemberWithOptions(shared_ptr<CreateProjectMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectMemberResponse createProjectMember(shared_ptr<CreateProjectMemberRequest> request);
  CreateResourceResponse createResourceWithOptions(shared_ptr<CreateResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceResponse createResource(shared_ptr<CreateResourceRequest> request);
  CreateResourceResponse createResourceAdvance(shared_ptr<CreateResourceAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceFileResponse createResourceFileWithOptions(shared_ptr<CreateResourceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceFileResponse createResourceFile(shared_ptr<CreateResourceFileRequest> request);
  CreateResourceFileResponse createResourceFileAdvance(shared_ptr<CreateResourceFileAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceGroupResponse createResourceGroupWithOptions(shared_ptr<CreateResourceGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceGroupResponse createResourceGroup(shared_ptr<CreateResourceGroupRequest> request);
  CreateRouteResponse createRouteWithOptions(shared_ptr<CreateRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteResponse createRoute(shared_ptr<CreateRouteRequest> request);
  CreateUdfFileResponse createUdfFileWithOptions(shared_ptr<CreateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUdfFileResponse createUdfFile(shared_ptr<CreateUdfFileRequest> request);
  CreateWorkflowDefinitionResponse createWorkflowDefinitionWithOptions(shared_ptr<CreateWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkflowDefinitionResponse createWorkflowDefinition(shared_ptr<CreateWorkflowDefinitionRequest> request);
  CreateWorkflowInstancesResponse createWorkflowInstancesWithOptions(shared_ptr<CreateWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkflowInstancesResponse createWorkflowInstances(shared_ptr<CreateWorkflowInstancesRequest> request);
  DeleteAlertRuleResponse deleteAlertRuleWithOptions(shared_ptr<DeleteAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRuleResponse deleteAlertRule(shared_ptr<DeleteAlertRuleRequest> request);
  DeleteBusinessResponse deleteBusinessWithOptions(shared_ptr<DeleteBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBusinessResponse deleteBusiness(shared_ptr<DeleteBusinessRequest> request);
  DeleteCertificateResponse deleteCertificateWithOptions(shared_ptr<DeleteCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCertificateResponse deleteCertificate(shared_ptr<DeleteCertificateRequest> request);
  DeleteDIAlarmRuleResponse deleteDIAlarmRuleWithOptions(shared_ptr<DeleteDIAlarmRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDIAlarmRuleResponse deleteDIAlarmRule(shared_ptr<DeleteDIAlarmRuleRequest> request);
  DeleteDIJobResponse deleteDIJobWithOptions(shared_ptr<DeleteDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDIJobResponse deleteDIJob(shared_ptr<DeleteDIJobRequest> request);
  DeleteDataAssetTagResponse deleteDataAssetTagWithOptions(shared_ptr<DeleteDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataAssetTagResponse deleteDataAssetTag(shared_ptr<DeleteDataAssetTagRequest> request);
  DeleteDataQualityEvaluationTaskResponse deleteDataQualityEvaluationTaskWithOptions(shared_ptr<DeleteDataQualityEvaluationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityEvaluationTaskResponse deleteDataQualityEvaluationTask(shared_ptr<DeleteDataQualityEvaluationTaskRequest> request);
  DeleteDataQualityRuleResponse deleteDataQualityRuleWithOptions(shared_ptr<DeleteDataQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityRuleResponse deleteDataQualityRule(shared_ptr<DeleteDataQualityRuleRequest> request);
  DeleteDataQualityRuleTemplateResponse deleteDataQualityRuleTemplateWithOptions(shared_ptr<DeleteDataQualityRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataQualityRuleTemplateResponse deleteDataQualityRuleTemplate(shared_ptr<DeleteDataQualityRuleTemplateRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteDataSourceSharedRuleResponse deleteDataSourceSharedRuleWithOptions(shared_ptr<DeleteDataSourceSharedRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceSharedRuleResponse deleteDataSourceSharedRule(shared_ptr<DeleteDataSourceSharedRuleRequest> request);
  DeleteFileResponse deleteFileWithOptions(shared_ptr<DeleteFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileResponse deleteFile(shared_ptr<DeleteFileRequest> request);
  DeleteFolderResponse deleteFolderWithOptions(shared_ptr<DeleteFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFolderResponse deleteFolder(shared_ptr<DeleteFolderRequest> request);
  DeleteFunctionResponse deleteFunctionWithOptions(shared_ptr<DeleteFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFunctionResponse deleteFunction(shared_ptr<DeleteFunctionRequest> request);
  DeleteLineageRelationshipResponse deleteLineageRelationshipWithOptions(shared_ptr<DeleteLineageRelationshipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLineageRelationshipResponse deleteLineageRelationship(shared_ptr<DeleteLineageRelationshipRequest> request);
  DeleteMetaCollectionResponse deleteMetaCollectionWithOptions(shared_ptr<DeleteMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetaCollectionResponse deleteMetaCollection(shared_ptr<DeleteMetaCollectionRequest> request);
  DeleteNetworkResponse deleteNetworkWithOptions(shared_ptr<DeleteNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkResponse deleteNetwork(shared_ptr<DeleteNetworkRequest> request);
  DeleteNodeResponse deleteNodeWithOptions(shared_ptr<DeleteNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNodeResponse deleteNode(shared_ptr<DeleteNodeRequest> request);
  DeleteProjectResponse deleteProjectWithOptions(shared_ptr<DeleteProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectResponse deleteProject(shared_ptr<DeleteProjectRequest> request);
  DeleteProjectMemberResponse deleteProjectMemberWithOptions(shared_ptr<DeleteProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectMemberResponse deleteProjectMember(shared_ptr<DeleteProjectMemberRequest> request);
  DeleteResourceResponse deleteResourceWithOptions(shared_ptr<DeleteResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceResponse deleteResource(shared_ptr<DeleteResourceRequest> request);
  DeleteResourceGroupResponse deleteResourceGroupWithOptions(shared_ptr<DeleteResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceGroupResponse deleteResourceGroup(shared_ptr<DeleteResourceGroupRequest> request);
  DeleteRouteResponse deleteRouteWithOptions(shared_ptr<DeleteRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteResponse deleteRoute(shared_ptr<DeleteRouteRequest> request);
  DeleteTaskResponse deleteTaskWithOptions(shared_ptr<DeleteTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskResponse deleteTask(shared_ptr<DeleteTaskRequest> request);
  DeleteWorkflowResponse deleteWorkflowWithOptions(shared_ptr<DeleteWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkflowResponse deleteWorkflow(shared_ptr<DeleteWorkflowRequest> request);
  DeleteWorkflowDefinitionResponse deleteWorkflowDefinitionWithOptions(shared_ptr<DeleteWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkflowDefinitionResponse deleteWorkflowDefinition(shared_ptr<DeleteWorkflowDefinitionRequest> request);
  DeployFileResponse deployFileWithOptions(shared_ptr<DeployFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployFileResponse deployFile(shared_ptr<DeployFileRequest> request);
  DetachDataQualityRulesFromEvaluationTaskResponse detachDataQualityRulesFromEvaluationTaskWithOptions(shared_ptr<DetachDataQualityRulesFromEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDataQualityRulesFromEvaluationTaskResponse detachDataQualityRulesFromEvaluationTask(shared_ptr<DetachDataQualityRulesFromEvaluationTaskRequest> request);
  DissociateProjectFromResourceGroupResponse dissociateProjectFromResourceGroupWithOptions(shared_ptr<DissociateProjectFromResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateProjectFromResourceGroupResponse dissociateProjectFromResourceGroup(shared_ptr<DissociateProjectFromResourceGroupRequest> request);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusinessWithOptions(shared_ptr<EstablishRelationTableToBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusiness(shared_ptr<EstablishRelationTableToBusinessRequest> request);
  ExecPipelineRunStageResponse execPipelineRunStageWithOptions(shared_ptr<ExecPipelineRunStageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecPipelineRunStageResponse execPipelineRunStage(shared_ptr<ExecPipelineRunStageRequest> request);
  ExecuteAdhocWorkflowInstanceResponse executeAdhocWorkflowInstanceWithOptions(shared_ptr<ExecuteAdhocWorkflowInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteAdhocWorkflowInstanceResponse executeAdhocWorkflowInstance(shared_ptr<ExecuteAdhocWorkflowInstanceRequest> request);
  GetAlertRuleResponse getAlertRuleWithOptions(shared_ptr<GetAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlertRuleResponse getAlertRule(shared_ptr<GetAlertRuleRequest> request);
  GetBusinessResponse getBusinessWithOptions(shared_ptr<GetBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBusinessResponse getBusiness(shared_ptr<GetBusinessRequest> request);
  GetCatalogResponse getCatalogWithOptions(shared_ptr<GetCatalogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCatalogResponse getCatalog(shared_ptr<GetCatalogRequest> request);
  GetCertificateResponse getCertificateWithOptions(shared_ptr<GetCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCertificateResponse getCertificate(shared_ptr<GetCertificateRequest> request);
  GetColumnResponse getColumnWithOptions(shared_ptr<GetColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetColumnResponse getColumn(shared_ptr<GetColumnRequest> request);
  GetCreateWorkflowInstancesResultResponse getCreateWorkflowInstancesResultWithOptions(shared_ptr<GetCreateWorkflowInstancesResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCreateWorkflowInstancesResultResponse getCreateWorkflowInstancesResult(shared_ptr<GetCreateWorkflowInstancesResultRequest> request);
  GetDIJobResponse getDIJobWithOptions(shared_ptr<GetDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDIJobResponse getDIJob(shared_ptr<GetDIJobRequest> request);
  GetDIJobLogResponse getDIJobLogWithOptions(shared_ptr<GetDIJobLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDIJobLogResponse getDIJobLog(shared_ptr<GetDIJobLogRequest> request);
  GetDataQualityEvaluationTaskResponse getDataQualityEvaluationTaskWithOptions(shared_ptr<GetDataQualityEvaluationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityEvaluationTaskResponse getDataQualityEvaluationTask(shared_ptr<GetDataQualityEvaluationTaskRequest> request);
  GetDataQualityEvaluationTaskInstanceResponse getDataQualityEvaluationTaskInstanceWithOptions(shared_ptr<GetDataQualityEvaluationTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityEvaluationTaskInstanceResponse getDataQualityEvaluationTaskInstance(shared_ptr<GetDataQualityEvaluationTaskInstanceRequest> request);
  GetDataQualityRuleResponse getDataQualityRuleWithOptions(shared_ptr<GetDataQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityRuleResponse getDataQualityRule(shared_ptr<GetDataQualityRuleRequest> request);
  GetDataQualityRuleTemplateResponse getDataQualityRuleTemplateWithOptions(shared_ptr<GetDataQualityRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataQualityRuleTemplateResponse getDataQualityRuleTemplate(shared_ptr<GetDataQualityRuleTemplateRequest> request);
  GetDataSourceResponse getDataSourceWithOptions(shared_ptr<GetDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataSourceResponse getDataSource(shared_ptr<GetDataSourceRequest> request);
  GetDatabaseResponse getDatabaseWithOptions(shared_ptr<GetDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatabaseResponse getDatabase(shared_ptr<GetDatabaseRequest> request);
  GetDeploymentPackageResponse getDeploymentPackageWithOptions(shared_ptr<GetDeploymentPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeploymentPackageResponse getDeploymentPackage(shared_ptr<GetDeploymentPackageRequest> request);
  GetFileResponse getFileWithOptions(shared_ptr<GetFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileResponse getFile(shared_ptr<GetFileRequest> request);
  GetFileVersionResponse getFileVersionWithOptions(shared_ptr<GetFileVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileVersionResponse getFileVersion(shared_ptr<GetFileVersionRequest> request);
  GetFolderResponse getFolderWithOptions(shared_ptr<GetFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFolderResponse getFolder(shared_ptr<GetFolderRequest> request);
  GetFunctionResponse getFunctionWithOptions(shared_ptr<GetFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFunctionResponse getFunction(shared_ptr<GetFunctionRequest> request);
  GetIDEEventDetailResponse getIDEEventDetailWithOptions(shared_ptr<GetIDEEventDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIDEEventDetailResponse getIDEEventDetail(shared_ptr<GetIDEEventDetailRequest> request);
  GetJobStatusResponse getJobStatusWithOptions(shared_ptr<GetJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobStatusResponse getJobStatus(shared_ptr<GetJobStatusRequest> request);
  GetLineageRelationshipResponse getLineageRelationshipWithOptions(shared_ptr<GetLineageRelationshipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLineageRelationshipResponse getLineageRelationship(shared_ptr<GetLineageRelationshipRequest> request);
  GetMetaCollectionResponse getMetaCollectionWithOptions(shared_ptr<GetMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaCollectionResponse getMetaCollection(shared_ptr<GetMetaCollectionRequest> request);
  GetNetworkResponse getNetworkWithOptions(shared_ptr<GetNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNetworkResponse getNetwork(shared_ptr<GetNetworkRequest> request);
  GetNodeResponse getNodeWithOptions(shared_ptr<GetNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request);
  GetPartitionResponse getPartitionWithOptions(shared_ptr<GetPartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPartitionResponse getPartition(shared_ptr<GetPartitionRequest> request);
  GetPipelineRunResponse getPipelineRunWithOptions(shared_ptr<GetPipelineRunRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineRunResponse getPipelineRun(shared_ptr<GetPipelineRunRequest> request);
  GetProjectResponse getProjectWithOptions(shared_ptr<GetProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectResponse getProject(shared_ptr<GetProjectRequest> request);
  GetProjectMemberResponse getProjectMemberWithOptions(shared_ptr<GetProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectMemberResponse getProjectMember(shared_ptr<GetProjectMemberRequest> request);
  GetProjectRoleResponse getProjectRoleWithOptions(shared_ptr<GetProjectRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectRoleResponse getProjectRole(shared_ptr<GetProjectRoleRequest> request);
  GetResourceResponse getResourceWithOptions(shared_ptr<GetResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceResponse getResource(shared_ptr<GetResourceRequest> request);
  GetResourceGroupResponse getResourceGroupWithOptions(shared_ptr<GetResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceGroupResponse getResourceGroup(shared_ptr<GetResourceGroupRequest> request);
  GetRouteResponse getRouteWithOptions(shared_ptr<GetRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRouteResponse getRoute(shared_ptr<GetRouteRequest> request);
  GetSchemaResponse getSchemaWithOptions(shared_ptr<GetSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSchemaResponse getSchema(shared_ptr<GetSchemaRequest> request);
  GetTableResponse getTableWithOptions(shared_ptr<GetTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTableResponse getTable(shared_ptr<GetTableRequest> request);
  GetTaskResponse getTaskWithOptions(shared_ptr<GetTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskResponse getTask(shared_ptr<GetTaskRequest> request);
  GetTaskInstanceResponse getTaskInstanceWithOptions(shared_ptr<GetTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskInstanceResponse getTaskInstance(shared_ptr<GetTaskInstanceRequest> request);
  GetTaskInstanceLogResponse getTaskInstanceLogWithOptions(shared_ptr<GetTaskInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskInstanceLogResponse getTaskInstanceLog(shared_ptr<GetTaskInstanceLogRequest> request);
  GetWorkflowResponse getWorkflowWithOptions(shared_ptr<GetWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowResponse getWorkflow(shared_ptr<GetWorkflowRequest> request);
  GetWorkflowDefinitionResponse getWorkflowDefinitionWithOptions(shared_ptr<GetWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowDefinitionResponse getWorkflowDefinition(shared_ptr<GetWorkflowDefinitionRequest> request);
  GetWorkflowInstanceResponse getWorkflowInstanceWithOptions(shared_ptr<GetWorkflowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowInstanceResponse getWorkflowInstance(shared_ptr<GetWorkflowInstanceRequest> request);
  GrantMemberProjectRolesResponse grantMemberProjectRolesWithOptions(shared_ptr<GrantMemberProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantMemberProjectRolesResponse grantMemberProjectRoles(shared_ptr<GrantMemberProjectRolesRequest> request);
  ImportCertificateResponse importCertificateWithOptions(shared_ptr<ImportCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportCertificateResponse importCertificate(shared_ptr<ImportCertificateRequest> request);
  ImportCertificateResponse importCertificateAdvance(shared_ptr<ImportCertificateAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportWorkflowDefinitionResponse importWorkflowDefinitionWithOptions(shared_ptr<ImportWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportWorkflowDefinitionResponse importWorkflowDefinition(shared_ptr<ImportWorkflowDefinitionRequest> request);
  ListAlertRulesResponse listAlertRulesWithOptions(shared_ptr<ListAlertRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertRulesResponse listAlertRules(shared_ptr<ListAlertRulesRequest> request);
  ListBusinessResponse listBusinessWithOptions(shared_ptr<ListBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBusinessResponse listBusiness(shared_ptr<ListBusinessRequest> request);
  ListCatalogsResponse listCatalogsWithOptions(shared_ptr<ListCatalogsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCatalogsResponse listCatalogs(shared_ptr<ListCatalogsRequest> request);
  ListCertificatesResponse listCertificatesWithOptions(shared_ptr<ListCertificatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCertificatesResponse listCertificates(shared_ptr<ListCertificatesRequest> request);
  ListColumnsResponse listColumnsWithOptions(shared_ptr<ListColumnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListColumnsResponse listColumns(shared_ptr<ListColumnsRequest> request);
  ListCrawlerTypesResponse listCrawlerTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCrawlerTypesResponse listCrawlerTypes();
  ListDIAlarmRulesResponse listDIAlarmRulesWithOptions(shared_ptr<ListDIAlarmRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIAlarmRulesResponse listDIAlarmRules(shared_ptr<ListDIAlarmRulesRequest> request);
  ListDIJobEventsResponse listDIJobEventsWithOptions(shared_ptr<ListDIJobEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobEventsResponse listDIJobEvents(shared_ptr<ListDIJobEventsRequest> request);
  ListDIJobMetricsResponse listDIJobMetricsWithOptions(shared_ptr<ListDIJobMetricsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobMetricsResponse listDIJobMetrics(shared_ptr<ListDIJobMetricsRequest> request);
  ListDIJobRunDetailsResponse listDIJobRunDetailsWithOptions(shared_ptr<ListDIJobRunDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobRunDetailsResponse listDIJobRunDetails(shared_ptr<ListDIJobRunDetailsRequest> request);
  ListDIJobsResponse listDIJobsWithOptions(shared_ptr<ListDIJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIJobsResponse listDIJobs(shared_ptr<ListDIJobsRequest> request);
  ListDataAssetTagsResponse listDataAssetTagsWithOptions(shared_ptr<ListDataAssetTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataAssetTagsResponse listDataAssetTags(shared_ptr<ListDataAssetTagsRequest> request);
  ListDataAssetsResponse listDataAssetsWithOptions(shared_ptr<ListDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataAssetsResponse listDataAssets(shared_ptr<ListDataAssetsRequest> request);
  ListDataQualityEvaluationTaskInstancesResponse listDataQualityEvaluationTaskInstancesWithOptions(shared_ptr<ListDataQualityEvaluationTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityEvaluationTaskInstancesResponse listDataQualityEvaluationTaskInstances(shared_ptr<ListDataQualityEvaluationTaskInstancesRequest> request);
  ListDataQualityEvaluationTasksResponse listDataQualityEvaluationTasksWithOptions(shared_ptr<ListDataQualityEvaluationTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityEvaluationTasksResponse listDataQualityEvaluationTasks(shared_ptr<ListDataQualityEvaluationTasksRequest> request);
  ListDataQualityResultsResponse listDataQualityResultsWithOptions(shared_ptr<ListDataQualityResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityResultsResponse listDataQualityResults(shared_ptr<ListDataQualityResultsRequest> request);
  ListDataQualityRuleTemplatesResponse listDataQualityRuleTemplatesWithOptions(shared_ptr<ListDataQualityRuleTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityRuleTemplatesResponse listDataQualityRuleTemplates(shared_ptr<ListDataQualityRuleTemplatesRequest> request);
  ListDataQualityRulesResponse listDataQualityRulesWithOptions(shared_ptr<ListDataQualityRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataQualityRulesResponse listDataQualityRules(shared_ptr<ListDataQualityRulesRequest> request);
  ListDataSourceSharedRulesResponse listDataSourceSharedRulesWithOptions(shared_ptr<ListDataSourceSharedRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourceSharedRulesResponse listDataSourceSharedRules(shared_ptr<ListDataSourceSharedRulesRequest> request);
  ListDataSourcesResponse listDataSourcesWithOptions(shared_ptr<ListDataSourcesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourcesResponse listDataSources(shared_ptr<ListDataSourcesRequest> request);
  ListDatabasesResponse listDatabasesWithOptions(shared_ptr<ListDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabasesResponse listDatabases(shared_ptr<ListDatabasesRequest> request);
  ListDeploymentPackageFilesResponse listDeploymentPackageFilesWithOptions(shared_ptr<ListDeploymentPackageFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeploymentPackageFilesResponse listDeploymentPackageFiles(shared_ptr<ListDeploymentPackageFilesRequest> request);
  ListDeploymentPackagesResponse listDeploymentPackagesWithOptions(shared_ptr<ListDeploymentPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeploymentPackagesResponse listDeploymentPackages(shared_ptr<ListDeploymentPackagesRequest> request);
  ListDownstreamTaskInstancesResponse listDownstreamTaskInstancesWithOptions(shared_ptr<ListDownstreamTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDownstreamTaskInstancesResponse listDownstreamTaskInstances(shared_ptr<ListDownstreamTaskInstancesRequest> request);
  ListDownstreamTasksResponse listDownstreamTasksWithOptions(shared_ptr<ListDownstreamTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDownstreamTasksResponse listDownstreamTasks(shared_ptr<ListDownstreamTasksRequest> request);
  ListEntitiesInMetaCollectionResponse listEntitiesInMetaCollectionWithOptions(shared_ptr<ListEntitiesInMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEntitiesInMetaCollectionResponse listEntitiesInMetaCollection(shared_ptr<ListEntitiesInMetaCollectionRequest> request);
  ListFileVersionsResponse listFileVersionsWithOptions(shared_ptr<ListFileVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFileVersionsResponse listFileVersions(shared_ptr<ListFileVersionsRequest> request);
  ListFilesResponse listFilesWithOptions(shared_ptr<ListFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilesResponse listFiles(shared_ptr<ListFilesRequest> request);
  ListFoldersResponse listFoldersWithOptions(shared_ptr<ListFoldersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFoldersResponse listFolders(shared_ptr<ListFoldersRequest> request);
  ListFunctionsResponse listFunctionsWithOptions(shared_ptr<ListFunctionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFunctionsResponse listFunctions(shared_ptr<ListFunctionsRequest> request);
  ListLineageRelationshipsResponse listLineageRelationshipsWithOptions(shared_ptr<ListLineageRelationshipsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLineageRelationshipsResponse listLineageRelationships(shared_ptr<ListLineageRelationshipsRequest> request);
  ListLineagesResponse listLineagesWithOptions(shared_ptr<ListLineagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLineagesResponse listLineages(shared_ptr<ListLineagesRequest> request);
  ListMetaCollectionsResponse listMetaCollectionsWithOptions(shared_ptr<ListMetaCollectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMetaCollectionsResponse listMetaCollections(shared_ptr<ListMetaCollectionsRequest> request);
  ListNetworksResponse listNetworksWithOptions(shared_ptr<ListNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworksResponse listNetworks(shared_ptr<ListNetworksRequest> request);
  ListNodeDependenciesResponse listNodeDependenciesWithOptions(shared_ptr<ListNodeDependenciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeDependenciesResponse listNodeDependencies(shared_ptr<ListNodeDependenciesRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListPartitionsResponse listPartitionsWithOptions(shared_ptr<ListPartitionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPartitionsResponse listPartitions(shared_ptr<ListPartitionsRequest> request);
  ListPipelineRunItemsResponse listPipelineRunItemsWithOptions(shared_ptr<ListPipelineRunItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineRunItemsResponse listPipelineRunItems(shared_ptr<ListPipelineRunItemsRequest> request);
  ListPipelineRunsResponse listPipelineRunsWithOptions(shared_ptr<ListPipelineRunsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineRunsResponse listPipelineRuns(shared_ptr<ListPipelineRunsRequest> request);
  ListProjectMembersResponse listProjectMembersWithOptions(shared_ptr<ListProjectMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectMembersResponse listProjectMembers(shared_ptr<ListProjectMembersRequest> request);
  ListProjectRolesResponse listProjectRolesWithOptions(shared_ptr<ListProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectRolesResponse listProjectRoles(shared_ptr<ListProjectRolesRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<ListProjectsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request);
  ListResourceGroupsResponse listResourceGroupsWithOptions(shared_ptr<ListResourceGroupsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupsResponse listResourceGroups(shared_ptr<ListResourceGroupsRequest> request);
  ListResourcesResponse listResourcesWithOptions(shared_ptr<ListResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcesResponse listResources(shared_ptr<ListResourcesRequest> request);
  ListRoutesResponse listRoutesWithOptions(shared_ptr<ListRoutesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoutesResponse listRoutes(shared_ptr<ListRoutesRequest> request);
  ListSchemasResponse listSchemasWithOptions(shared_ptr<ListSchemasRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSchemasResponse listSchemas(shared_ptr<ListSchemasRequest> request);
  ListTablesResponse listTablesWithOptions(shared_ptr<ListTablesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTablesResponse listTables(shared_ptr<ListTablesRequest> request);
  ListTaskInstanceOperationLogsResponse listTaskInstanceOperationLogsWithOptions(shared_ptr<ListTaskInstanceOperationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskInstanceOperationLogsResponse listTaskInstanceOperationLogs(shared_ptr<ListTaskInstanceOperationLogsRequest> request);
  ListTaskInstancesResponse listTaskInstancesWithOptions(shared_ptr<ListTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskInstancesResponse listTaskInstances(shared_ptr<ListTaskInstancesRequest> request);
  ListTaskOperationLogsResponse listTaskOperationLogsWithOptions(shared_ptr<ListTaskOperationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskOperationLogsResponse listTaskOperationLogs(shared_ptr<ListTaskOperationLogsRequest> request);
  ListTasksResponse listTasksWithOptions(shared_ptr<ListTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTasksResponse listTasks(shared_ptr<ListTasksRequest> request);
  ListUpstreamTaskInstancesResponse listUpstreamTaskInstancesWithOptions(shared_ptr<ListUpstreamTaskInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamTaskInstancesResponse listUpstreamTaskInstances(shared_ptr<ListUpstreamTaskInstancesRequest> request);
  ListUpstreamTasksResponse listUpstreamTasksWithOptions(shared_ptr<ListUpstreamTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamTasksResponse listUpstreamTasks(shared_ptr<ListUpstreamTasksRequest> request);
  ListWorkflowDefinitionsResponse listWorkflowDefinitionsWithOptions(shared_ptr<ListWorkflowDefinitionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowDefinitionsResponse listWorkflowDefinitions(shared_ptr<ListWorkflowDefinitionsRequest> request);
  ListWorkflowInstancesResponse listWorkflowInstancesWithOptions(shared_ptr<ListWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowInstancesResponse listWorkflowInstances(shared_ptr<ListWorkflowInstancesRequest> request);
  ListWorkflowsResponse listWorkflowsWithOptions(shared_ptr<ListWorkflowsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkflowsResponse listWorkflows(shared_ptr<ListWorkflowsRequest> request);
  MoveFunctionResponse moveFunctionWithOptions(shared_ptr<MoveFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveFunctionResponse moveFunction(shared_ptr<MoveFunctionRequest> request);
  MoveNodeResponse moveNodeWithOptions(shared_ptr<MoveNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveNodeResponse moveNode(shared_ptr<MoveNodeRequest> request);
  MoveResourceResponse moveResourceWithOptions(shared_ptr<MoveResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceResponse moveResource(shared_ptr<MoveResourceRequest> request);
  MoveWorkflowDefinitionResponse moveWorkflowDefinitionWithOptions(shared_ptr<MoveWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveWorkflowDefinitionResponse moveWorkflowDefinition(shared_ptr<MoveWorkflowDefinitionRequest> request);
  RemoveEntityFromMetaCollectionResponse removeEntityFromMetaCollectionWithOptions(shared_ptr<RemoveEntityFromMetaCollectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveEntityFromMetaCollectionResponse removeEntityFromMetaCollection(shared_ptr<RemoveEntityFromMetaCollectionRequest> request);
  RemoveTaskInstanceDependenciesResponse removeTaskInstanceDependenciesWithOptions(shared_ptr<RemoveTaskInstanceDependenciesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTaskInstanceDependenciesResponse removeTaskInstanceDependencies(shared_ptr<RemoveTaskInstanceDependenciesRequest> request);
  RenameFunctionResponse renameFunctionWithOptions(shared_ptr<RenameFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameFunctionResponse renameFunction(shared_ptr<RenameFunctionRequest> request);
  RenameNodeResponse renameNodeWithOptions(shared_ptr<RenameNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameNodeResponse renameNode(shared_ptr<RenameNodeRequest> request);
  RenameResourceResponse renameResourceWithOptions(shared_ptr<RenameResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameResourceResponse renameResource(shared_ptr<RenameResourceRequest> request);
  RenameWorkflowDefinitionResponse renameWorkflowDefinitionWithOptions(shared_ptr<RenameWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameWorkflowDefinitionResponse renameWorkflowDefinition(shared_ptr<RenameWorkflowDefinitionRequest> request);
  RerunTaskInstancesResponse rerunTaskInstancesWithOptions(shared_ptr<RerunTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RerunTaskInstancesResponse rerunTaskInstances(shared_ptr<RerunTaskInstancesRequest> request);
  ResumeTaskInstancesResponse resumeTaskInstancesWithOptions(shared_ptr<ResumeTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeTaskInstancesResponse resumeTaskInstances(shared_ptr<ResumeTaskInstancesRequest> request);
  RevokeMemberProjectRolesResponse revokeMemberProjectRolesWithOptions(shared_ptr<RevokeMemberProjectRolesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeMemberProjectRolesResponse revokeMemberProjectRoles(shared_ptr<RevokeMemberProjectRolesRequest> request);
  SetSuccessTaskInstancesResponse setSuccessTaskInstancesWithOptions(shared_ptr<SetSuccessTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSuccessTaskInstancesResponse setSuccessTaskInstances(shared_ptr<SetSuccessTaskInstancesRequest> request);
  StartDIJobResponse startDIJobWithOptions(shared_ptr<StartDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDIJobResponse startDIJob(shared_ptr<StartDIJobRequest> request);
  StartWorkflowInstancesResponse startWorkflowInstancesWithOptions(shared_ptr<StartWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartWorkflowInstancesResponse startWorkflowInstances(shared_ptr<StartWorkflowInstancesRequest> request);
  StopDIJobResponse stopDIJobWithOptions(shared_ptr<StopDIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDIJobResponse stopDIJob(shared_ptr<StopDIJobRequest> request);
  StopTaskInstancesResponse stopTaskInstancesWithOptions(shared_ptr<StopTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopTaskInstancesResponse stopTaskInstances(shared_ptr<StopTaskInstancesRequest> request);
  StopWorkflowInstancesResponse stopWorkflowInstancesWithOptions(shared_ptr<StopWorkflowInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopWorkflowInstancesResponse stopWorkflowInstances(shared_ptr<StopWorkflowInstancesRequest> request);
  SubmitFileResponse submitFileWithOptions(shared_ptr<SubmitFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFileResponse submitFile(shared_ptr<SubmitFileRequest> request);
  SuspendTaskInstancesResponse suspendTaskInstancesWithOptions(shared_ptr<SuspendTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendTaskInstancesResponse suspendTaskInstances(shared_ptr<SuspendTaskInstancesRequest> request);
  TagDataAssetsResponse tagDataAssetsWithOptions(shared_ptr<TagDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagDataAssetsResponse tagDataAssets(shared_ptr<TagDataAssetsRequest> request);
  TestDataSourceConnectivityResponse testDataSourceConnectivityWithOptions(shared_ptr<TestDataSourceConnectivityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TestDataSourceConnectivityResponse testDataSourceConnectivity(shared_ptr<TestDataSourceConnectivityRequest> request);
  TriggerSchedulerTaskInstanceResponse triggerSchedulerTaskInstanceWithOptions(shared_ptr<TriggerSchedulerTaskInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerSchedulerTaskInstanceResponse triggerSchedulerTaskInstance(shared_ptr<TriggerSchedulerTaskInstanceRequest> request);
  UnTagDataAssetsResponse unTagDataAssetsWithOptions(shared_ptr<UnTagDataAssetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnTagDataAssetsResponse unTagDataAssets(shared_ptr<UnTagDataAssetsRequest> request);
  UpdateAlertRuleResponse updateAlertRuleWithOptions(shared_ptr<UpdateAlertRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertRuleResponse updateAlertRule(shared_ptr<UpdateAlertRuleRequest> request);
  UpdateBusinessResponse updateBusinessWithOptions(shared_ptr<UpdateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBusinessResponse updateBusiness(shared_ptr<UpdateBusinessRequest> request);
  UpdateColumnBusinessMetadataResponse updateColumnBusinessMetadataWithOptions(shared_ptr<UpdateColumnBusinessMetadataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateColumnBusinessMetadataResponse updateColumnBusinessMetadata(shared_ptr<UpdateColumnBusinessMetadataRequest> request);
  UpdateDIAlarmRuleResponse updateDIAlarmRuleWithOptions(shared_ptr<UpdateDIAlarmRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDIAlarmRuleResponse updateDIAlarmRule(shared_ptr<UpdateDIAlarmRuleRequest> request);
  UpdateDIJobResponse updateDIJobWithOptions(shared_ptr<UpdateDIJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDIJobResponse updateDIJob(shared_ptr<UpdateDIJobRequest> request);
  UpdateDataAssetTagResponse updateDataAssetTagWithOptions(shared_ptr<UpdateDataAssetTagRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataAssetTagResponse updateDataAssetTag(shared_ptr<UpdateDataAssetTagRequest> request);
  UpdateDataQualityEvaluationTaskResponse updateDataQualityEvaluationTaskWithOptions(shared_ptr<UpdateDataQualityEvaluationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityEvaluationTaskResponse updateDataQualityEvaluationTask(shared_ptr<UpdateDataQualityEvaluationTaskRequest> request);
  UpdateDataQualityRuleResponse updateDataQualityRuleWithOptions(shared_ptr<UpdateDataQualityRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityRuleResponse updateDataQualityRule(shared_ptr<UpdateDataQualityRuleRequest> request);
  UpdateDataQualityRuleTemplateResponse updateDataQualityRuleTemplateWithOptions(shared_ptr<UpdateDataQualityRuleTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataQualityRuleTemplateResponse updateDataQualityRuleTemplate(shared_ptr<UpdateDataQualityRuleTemplateRequest> request);
  UpdateDataSourceResponse updateDataSourceWithOptions(shared_ptr<UpdateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceResponse updateDataSource(shared_ptr<UpdateDataSourceRequest> request);
  UpdateFileResponse updateFileWithOptions(shared_ptr<UpdateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileResponse updateFile(shared_ptr<UpdateFileRequest> request);
  UpdateFolderResponse updateFolderWithOptions(shared_ptr<UpdateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFolderResponse updateFolder(shared_ptr<UpdateFolderRequest> request);
  UpdateFunctionResponse updateFunctionWithOptions(shared_ptr<UpdateFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFunctionResponse updateFunction(shared_ptr<UpdateFunctionRequest> request);
  UpdateIDEEventResultResponse updateIDEEventResultWithOptions(shared_ptr<UpdateIDEEventResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIDEEventResultResponse updateIDEEventResult(shared_ptr<UpdateIDEEventResultRequest> request);
  UpdateMetaCollectionResponse updateMetaCollectionWithOptions(shared_ptr<UpdateMetaCollectionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaCollectionResponse updateMetaCollection(shared_ptr<UpdateMetaCollectionRequest> request);
  UpdateNodeResponse updateNodeWithOptions(shared_ptr<UpdateNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeResponse updateNode(shared_ptr<UpdateNodeRequest> request);
  UpdateProjectResponse updateProjectWithOptions(shared_ptr<UpdateProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectResponse updateProject(shared_ptr<UpdateProjectRequest> request);
  UpdateResourceResponse updateResourceWithOptions(shared_ptr<UpdateResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceResponse updateResource(shared_ptr<UpdateResourceRequest> request);
  UpdateResourceResponse updateResourceAdvance(shared_ptr<UpdateResourceAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceGroupResponse updateResourceGroupWithOptions(shared_ptr<UpdateResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceGroupResponse updateResourceGroup(shared_ptr<UpdateResourceGroupRequest> request);
  UpdateRouteResponse updateRouteWithOptions(shared_ptr<UpdateRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRouteResponse updateRoute(shared_ptr<UpdateRouteRequest> request);
  UpdateTableBusinessMetadataResponse updateTableBusinessMetadataWithOptions(shared_ptr<UpdateTableBusinessMetadataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableBusinessMetadataResponse updateTableBusinessMetadata(shared_ptr<UpdateTableBusinessMetadataRequest> request);
  UpdateTaskResponse updateTaskWithOptions(shared_ptr<UpdateTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskResponse updateTask(shared_ptr<UpdateTaskRequest> request);
  UpdateTaskInstancesResponse updateTaskInstancesWithOptions(shared_ptr<UpdateTaskInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskInstancesResponse updateTaskInstances(shared_ptr<UpdateTaskInstancesRequest> request);
  UpdateUdfFileResponse updateUdfFileWithOptions(shared_ptr<UpdateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUdfFileResponse updateUdfFile(shared_ptr<UpdateUdfFileRequest> request);
  UpdateWorkflowResponse updateWorkflowWithOptions(shared_ptr<UpdateWorkflowRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkflowResponse updateWorkflow(shared_ptr<UpdateWorkflowRequest> request);
  UpdateWorkflowDefinitionResponse updateWorkflowDefinitionWithOptions(shared_ptr<UpdateWorkflowDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkflowDefinitionResponse updateWorkflowDefinition(shared_ptr<UpdateWorkflowDefinitionRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dataworks-public20240518

#endif
