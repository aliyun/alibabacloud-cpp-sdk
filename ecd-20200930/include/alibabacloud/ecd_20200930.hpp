// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ECD20200930_H_
#define ALIBABACLOUD_ECD20200930_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ecd20200930 {
class CdsFileShareLinkModel : public Darabonba::Model {
public:
  shared_ptr<long> accessCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableDownload{};
  shared_ptr<bool> disablePreview{};
  shared_ptr<bool> disableSave{};
  shared_ptr<long> downloadCount{};
  shared_ptr<long> downloadLimit{};
  shared_ptr<string> driveId{};
  shared_ptr<string> expiration{};
  shared_ptr<bool> expired{};
  shared_ptr<string> fileIds{};
  shared_ptr<string> modifiyTime{};
  shared_ptr<long> previewCount{};
  shared_ptr<long> previewLimit{};
  shared_ptr<long> reportCount{};
  shared_ptr<long> saveCount{};
  shared_ptr<long> saveLimit{};
  shared_ptr<string> shareId{};
  shared_ptr<string> shareLink{};
  shared_ptr<string> shareName{};
  shared_ptr<string> sharePwd{};
  shared_ptr<string> status{};
  shared_ptr<long> videoPreviewCount{};

  CdsFileShareLinkModel() {}

  explicit CdsFileShareLinkModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableDownload) {
      res["DisableDownload"] = boost::any(*disableDownload);
    }
    if (disablePreview) {
      res["DisablePreview"] = boost::any(*disablePreview);
    }
    if (disableSave) {
      res["DisableSave"] = boost::any(*disableSave);
    }
    if (downloadCount) {
      res["DownloadCount"] = boost::any(*downloadCount);
    }
    if (downloadLimit) {
      res["DownloadLimit"] = boost::any(*downloadLimit);
    }
    if (driveId) {
      res["DriveId"] = boost::any(*driveId);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (modifiyTime) {
      res["ModifiyTime"] = boost::any(*modifiyTime);
    }
    if (previewCount) {
      res["PreviewCount"] = boost::any(*previewCount);
    }
    if (previewLimit) {
      res["PreviewLimit"] = boost::any(*previewLimit);
    }
    if (reportCount) {
      res["ReportCount"] = boost::any(*reportCount);
    }
    if (saveCount) {
      res["SaveCount"] = boost::any(*saveCount);
    }
    if (saveLimit) {
      res["SaveLimit"] = boost::any(*saveLimit);
    }
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    if (shareLink) {
      res["ShareLink"] = boost::any(*shareLink);
    }
    if (shareName) {
      res["ShareName"] = boost::any(*shareName);
    }
    if (sharePwd) {
      res["SharePwd"] = boost::any(*sharePwd);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (videoPreviewCount) {
      res["VideoPreviewCount"] = boost::any(*videoPreviewCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableDownload") != m.end() && !m["DisableDownload"].empty()) {
      disableDownload = make_shared<bool>(boost::any_cast<bool>(m["DisableDownload"]));
    }
    if (m.find("DisablePreview") != m.end() && !m["DisablePreview"].empty()) {
      disablePreview = make_shared<bool>(boost::any_cast<bool>(m["DisablePreview"]));
    }
    if (m.find("DisableSave") != m.end() && !m["DisableSave"].empty()) {
      disableSave = make_shared<bool>(boost::any_cast<bool>(m["DisableSave"]));
    }
    if (m.find("DownloadCount") != m.end() && !m["DownloadCount"].empty()) {
      downloadCount = make_shared<long>(boost::any_cast<long>(m["DownloadCount"]));
    }
    if (m.find("DownloadLimit") != m.end() && !m["DownloadLimit"].empty()) {
      downloadLimit = make_shared<long>(boost::any_cast<long>(m["DownloadLimit"]));
    }
    if (m.find("DriveId") != m.end() && !m["DriveId"].empty()) {
      driveId = make_shared<string>(boost::any_cast<string>(m["DriveId"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("ModifiyTime") != m.end() && !m["ModifiyTime"].empty()) {
      modifiyTime = make_shared<string>(boost::any_cast<string>(m["ModifiyTime"]));
    }
    if (m.find("PreviewCount") != m.end() && !m["PreviewCount"].empty()) {
      previewCount = make_shared<long>(boost::any_cast<long>(m["PreviewCount"]));
    }
    if (m.find("PreviewLimit") != m.end() && !m["PreviewLimit"].empty()) {
      previewLimit = make_shared<long>(boost::any_cast<long>(m["PreviewLimit"]));
    }
    if (m.find("ReportCount") != m.end() && !m["ReportCount"].empty()) {
      reportCount = make_shared<long>(boost::any_cast<long>(m["ReportCount"]));
    }
    if (m.find("SaveCount") != m.end() && !m["SaveCount"].empty()) {
      saveCount = make_shared<long>(boost::any_cast<long>(m["SaveCount"]));
    }
    if (m.find("SaveLimit") != m.end() && !m["SaveLimit"].empty()) {
      saveLimit = make_shared<long>(boost::any_cast<long>(m["SaveLimit"]));
    }
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
    if (m.find("ShareLink") != m.end() && !m["ShareLink"].empty()) {
      shareLink = make_shared<string>(boost::any_cast<string>(m["ShareLink"]));
    }
    if (m.find("ShareName") != m.end() && !m["ShareName"].empty()) {
      shareName = make_shared<string>(boost::any_cast<string>(m["ShareName"]));
    }
    if (m.find("SharePwd") != m.end() && !m["SharePwd"].empty()) {
      sharePwd = make_shared<string>(boost::any_cast<string>(m["SharePwd"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VideoPreviewCount") != m.end() && !m["VideoPreviewCount"].empty()) {
      videoPreviewCount = make_shared<long>(boost::any_cast<long>(m["VideoPreviewCount"]));
    }
  }


  virtual ~CdsFileShareLinkModel() = default;
};
class FilePermissionMemberCdsIdentity : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  FilePermissionMemberCdsIdentity() {}

  explicit FilePermissionMemberCdsIdentity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~FilePermissionMemberCdsIdentity() = default;
};
class FilePermissionMember : public Darabonba::Model {
public:
  shared_ptr<FilePermissionMemberCdsIdentity> cdsIdentity{};
  shared_ptr<bool> disinheritSubGroup{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> roleId{};

  FilePermissionMember() {}

  explicit FilePermissionMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsIdentity) {
      res["CdsIdentity"] = cdsIdentity ? boost::any(cdsIdentity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (disinheritSubGroup) {
      res["DisinheritSubGroup"] = boost::any(*disinheritSubGroup);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsIdentity") != m.end() && !m["CdsIdentity"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdsIdentity"].type()) {
        FilePermissionMemberCdsIdentity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdsIdentity"]));
        cdsIdentity = make_shared<FilePermissionMemberCdsIdentity>(model1);
      }
    }
    if (m.find("DisinheritSubGroup") != m.end() && !m["DisinheritSubGroup"].empty()) {
      disinheritSubGroup = make_shared<bool>(boost::any_cast<bool>(m["DisinheritSubGroup"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~FilePermissionMember() = default;
};
class Permission : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  Permission() {}

  explicit Permission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~Permission() = default;
};
class ActivateOfficeSiteRequest : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ActivateOfficeSiteRequest() {}

  explicit ActivateOfficeSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ActivateOfficeSiteRequest() = default;
};
class ActivateOfficeSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ActivateOfficeSiteResponseBody() {}

  explicit ActivateOfficeSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateOfficeSiteResponseBody() = default;
};
class ActivateOfficeSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateOfficeSiteResponseBody> body{};

  ActivateOfficeSiteResponse() {}

  explicit ActivateOfficeSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateOfficeSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateOfficeSiteResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateOfficeSiteResponse() = default;
};
class AddDesktopOversoldUserGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddDesktopOversoldUserGroupRequestTag() {}

  explicit AddDesktopOversoldUserGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddDesktopOversoldUserGroupRequestTag() = default;
};
class AddDesktopOversoldUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> name{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<vector<AddDesktopOversoldUserGroupRequestTag>> tag{};

  AddDesktopOversoldUserGroupRequest() {}

  explicit AddDesktopOversoldUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddDesktopOversoldUserGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDesktopOversoldUserGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddDesktopOversoldUserGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~AddDesktopOversoldUserGroupRequest() = default;
};
class AddDesktopOversoldUserGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> userGroupId{};

  AddDesktopOversoldUserGroupResponseBodyData() {}

  explicit AddDesktopOversoldUserGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AddDesktopOversoldUserGroupResponseBodyData() = default;
};
class AddDesktopOversoldUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddDesktopOversoldUserGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  AddDesktopOversoldUserGroupResponseBody() {}

  explicit AddDesktopOversoldUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddDesktopOversoldUserGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddDesktopOversoldUserGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDesktopOversoldUserGroupResponseBody() = default;
};
class AddDesktopOversoldUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDesktopOversoldUserGroupResponseBody> body{};

  AddDesktopOversoldUserGroupResponse() {}

  explicit AddDesktopOversoldUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDesktopOversoldUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDesktopOversoldUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddDesktopOversoldUserGroupResponse() = default;
};
class AddDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<long> clientType{};
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> regionId{};

  AddDevicesRequest() {}

  explicit AddDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddDevicesRequest() = default;
};
class AddDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddDevicesResponseBody() {}

  explicit AddDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDevicesResponseBody() = default;
};
class AddDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDevicesResponseBody> body{};

  AddDevicesResponse() {}

  explicit AddDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~AddDevicesResponse() = default;
};
class AddFilePermissionRequestMemberListCdsIdentity : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  AddFilePermissionRequestMemberListCdsIdentity() {}

  explicit AddFilePermissionRequestMemberListCdsIdentity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddFilePermissionRequestMemberListCdsIdentity() = default;
};
class AddFilePermissionRequestMemberList : public Darabonba::Model {
public:
  shared_ptr<AddFilePermissionRequestMemberListCdsIdentity> cdsIdentity{};
  shared_ptr<bool> disinheritSubGroup{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> roleId{};

  AddFilePermissionRequestMemberList() {}

  explicit AddFilePermissionRequestMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsIdentity) {
      res["CdsIdentity"] = cdsIdentity ? boost::any(cdsIdentity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (disinheritSubGroup) {
      res["DisinheritSubGroup"] = boost::any(*disinheritSubGroup);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsIdentity") != m.end() && !m["CdsIdentity"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdsIdentity"].type()) {
        AddFilePermissionRequestMemberListCdsIdentity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdsIdentity"]));
        cdsIdentity = make_shared<AddFilePermissionRequestMemberListCdsIdentity>(model1);
      }
    }
    if (m.find("DisinheritSubGroup") != m.end() && !m["DisinheritSubGroup"].empty()) {
      disinheritSubGroup = make_shared<bool>(boost::any_cast<bool>(m["DisinheritSubGroup"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~AddFilePermissionRequestMemberList() = default;
};
class AddFilePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<AddFilePermissionRequestMemberList>> memberList{};
  shared_ptr<string> regionId{};

  AddFilePermissionRequest() {}

  explicit AddFilePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (memberList) {
      vector<boost::any> temp1;
      for(auto item1:*memberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MemberList"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["MemberList"].type()) {
        vector<AddFilePermissionRequestMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFilePermissionRequestMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberList = make_shared<vector<AddFilePermissionRequestMemberList>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddFilePermissionRequest() = default;
};
class AddFilePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> memberListShrink{};
  shared_ptr<string> regionId{};

  AddFilePermissionShrinkRequest() {}

  explicit AddFilePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (memberListShrink) {
      res["MemberList"] = boost::any(*memberListShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      memberListShrink = make_shared<string>(boost::any_cast<string>(m["MemberList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddFilePermissionShrinkRequest() = default;
};
class AddFilePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddFilePermissionResponseBody() {}

  explicit AddFilePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddFilePermissionResponseBody() = default;
};
class AddFilePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFilePermissionResponseBody> body{};

  AddFilePermissionResponse() {}

  explicit AddFilePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFilePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFilePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~AddFilePermissionResponse() = default;
};
class AddUserToDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopGroupIds{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userOuPath{};

  AddUserToDesktopGroupRequest() {}

  explicit AddUserToDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupIds) {
      res["DesktopGroupIds"] = boost::any(*desktopGroupIds);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userOuPath) {
      res["UserOuPath"] = boost::any(*userOuPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupIds") != m.end() && !m["DesktopGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserOuPath") != m.end() && !m["UserOuPath"].empty()) {
      userOuPath = make_shared<string>(boost::any_cast<string>(m["UserOuPath"]));
    }
  }


  virtual ~AddUserToDesktopGroupRequest() = default;
};
class AddUserToDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUserToDesktopGroupResponseBody() {}

  explicit AddUserToDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUserToDesktopGroupResponseBody() = default;
};
class AddUserToDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUserToDesktopGroupResponseBody> body{};

  AddUserToDesktopGroupResponse() {}

  explicit AddUserToDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUserToDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUserToDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUserToDesktopGroupResponse() = default;
};
class AddUserToDesktopOversoldUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> addUserAmount{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> userGroupId{};

  AddUserToDesktopOversoldUserGroupRequest() {}

  explicit AddUserToDesktopOversoldUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addUserAmount) {
      res["AddUserAmount"] = boost::any(*addUserAmount);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddUserAmount") != m.end() && !m["AddUserAmount"].empty()) {
      addUserAmount = make_shared<long>(boost::any_cast<long>(m["AddUserAmount"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AddUserToDesktopOversoldUserGroupRequest() = default;
};
class AddUserToDesktopOversoldUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUserToDesktopOversoldUserGroupResponseBody() {}

  explicit AddUserToDesktopOversoldUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUserToDesktopOversoldUserGroupResponseBody() = default;
};
class AddUserToDesktopOversoldUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUserToDesktopOversoldUserGroupResponseBody> body{};

  AddUserToDesktopOversoldUserGroupResponse() {}

  explicit AddUserToDesktopOversoldUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUserToDesktopOversoldUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUserToDesktopOversoldUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUserToDesktopOversoldUserGroupResponse() = default;
};
class ApplyAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  ApplyAutoSnapshotPolicyRequest() {}

  explicit ApplyAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ApplyAutoSnapshotPolicyRequest() = default;
};
class ApplyAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApplyAutoSnapshotPolicyResponseBody() {}

  explicit ApplyAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyAutoSnapshotPolicyResponseBody() = default;
};
class ApplyAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAutoSnapshotPolicyResponseBody> body{};

  ApplyAutoSnapshotPolicyResponse() {}

  explicit ApplyAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAutoSnapshotPolicyResponse() = default;
};
class ApplyCoordinatePrivilegeRequest : public Darabonba::Model {
public:
  shared_ptr<string> coId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userType{};
  shared_ptr<string> uuid{};

  ApplyCoordinatePrivilegeRequest() {}

  explicit ApplyCoordinatePrivilegeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coId) {
      res["CoId"] = boost::any(*coId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoId") != m.end() && !m["CoId"].empty()) {
      coId = make_shared<string>(boost::any_cast<string>(m["CoId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ApplyCoordinatePrivilegeRequest() = default;
};
class ApplyCoordinatePrivilegeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApplyCoordinatePrivilegeResponseBody() {}

  explicit ApplyCoordinatePrivilegeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyCoordinatePrivilegeResponseBody() = default;
};
class ApplyCoordinatePrivilegeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyCoordinatePrivilegeResponseBody> body{};

  ApplyCoordinatePrivilegeResponse() {}

  explicit ApplyCoordinatePrivilegeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyCoordinatePrivilegeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyCoordinatePrivilegeResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyCoordinatePrivilegeResponse() = default;
};
class ApplyCoordinationForMonitoringRequestResourceCandidates : public Darabonba::Model {
public:
  shared_ptr<long> ownerAliUid{};
  shared_ptr<string> ownerEndUserId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceProperties{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};

  ApplyCoordinationForMonitoringRequestResourceCandidates() {}

  explicit ApplyCoordinationForMonitoringRequestResourceCandidates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAliUid) {
      res["OwnerAliUid"] = boost::any(*ownerAliUid);
    }
    if (ownerEndUserId) {
      res["OwnerEndUserId"] = boost::any(*ownerEndUserId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceProperties) {
      res["ResourceProperties"] = boost::any(*resourceProperties);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAliUid") != m.end() && !m["OwnerAliUid"].empty()) {
      ownerAliUid = make_shared<long>(boost::any_cast<long>(m["OwnerAliUid"]));
    }
    if (m.find("OwnerEndUserId") != m.end() && !m["OwnerEndUserId"].empty()) {
      ownerEndUserId = make_shared<string>(boost::any_cast<string>(m["OwnerEndUserId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceProperties") != m.end() && !m["ResourceProperties"].empty()) {
      resourceProperties = make_shared<string>(boost::any_cast<string>(m["ResourceProperties"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ApplyCoordinationForMonitoringRequestResourceCandidates() = default;
};
class ApplyCoordinationForMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> coordinatePolicyType{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> initiatorType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ApplyCoordinationForMonitoringRequestResourceCandidates>> resourceCandidates{};
  shared_ptr<string> uuid{};

  ApplyCoordinationForMonitoringRequest() {}

  explicit ApplyCoordinationForMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coordinatePolicyType) {
      res["CoordinatePolicyType"] = boost::any(*coordinatePolicyType);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (initiatorType) {
      res["InitiatorType"] = boost::any(*initiatorType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceCandidates) {
      vector<boost::any> temp1;
      for(auto item1:*resourceCandidates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceCandidates"] = boost::any(temp1);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoordinatePolicyType") != m.end() && !m["CoordinatePolicyType"].empty()) {
      coordinatePolicyType = make_shared<string>(boost::any_cast<string>(m["CoordinatePolicyType"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("InitiatorType") != m.end() && !m["InitiatorType"].empty()) {
      initiatorType = make_shared<string>(boost::any_cast<string>(m["InitiatorType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceCandidates") != m.end() && !m["ResourceCandidates"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceCandidates"].type()) {
        vector<ApplyCoordinationForMonitoringRequestResourceCandidates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceCandidates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyCoordinationForMonitoringRequestResourceCandidates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceCandidates = make_shared<vector<ApplyCoordinationForMonitoringRequestResourceCandidates>>(expect1);
      }
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ApplyCoordinationForMonitoringRequest() = default;
};
class ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels : public Darabonba::Model {
public:
  shared_ptr<string> coId{};
  shared_ptr<string> coordinateStatus{};
  shared_ptr<string> coordinateTicket{};
  shared_ptr<string> initiatorType{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};

  ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels() {}

  explicit ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coId) {
      res["CoId"] = boost::any(*coId);
    }
    if (coordinateStatus) {
      res["CoordinateStatus"] = boost::any(*coordinateStatus);
    }
    if (coordinateTicket) {
      res["CoordinateTicket"] = boost::any(*coordinateTicket);
    }
    if (initiatorType) {
      res["InitiatorType"] = boost::any(*initiatorType);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoId") != m.end() && !m["CoId"].empty()) {
      coId = make_shared<string>(boost::any_cast<string>(m["CoId"]));
    }
    if (m.find("CoordinateStatus") != m.end() && !m["CoordinateStatus"].empty()) {
      coordinateStatus = make_shared<string>(boost::any_cast<string>(m["CoordinateStatus"]));
    }
    if (m.find("CoordinateTicket") != m.end() && !m["CoordinateTicket"].empty()) {
      coordinateTicket = make_shared<string>(boost::any_cast<string>(m["CoordinateTicket"]));
    }
    if (m.find("InitiatorType") != m.end() && !m["InitiatorType"].empty()) {
      initiatorType = make_shared<string>(boost::any_cast<string>(m["InitiatorType"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
  }


  virtual ~ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels() = default;
};
class ApplyCoordinationForMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels>> coordinateFlowModels{};
  shared_ptr<string> requestId{};

  ApplyCoordinationForMonitoringResponseBody() {}

  explicit ApplyCoordinationForMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coordinateFlowModels) {
      vector<boost::any> temp1;
      for(auto item1:*coordinateFlowModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoordinateFlowModels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoordinateFlowModels") != m.end() && !m["CoordinateFlowModels"].empty()) {
      if (typeid(vector<boost::any>) == m["CoordinateFlowModels"].type()) {
        vector<ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoordinateFlowModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coordinateFlowModels = make_shared<vector<ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyCoordinationForMonitoringResponseBody() = default;
};
class ApplyCoordinationForMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyCoordinationForMonitoringResponseBody> body{};

  ApplyCoordinationForMonitoringResponse() {}

  explicit ApplyCoordinationForMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyCoordinationForMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyCoordinationForMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyCoordinationForMonitoringResponse() = default;
};
class ApproveFotaUpdateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> regionId{};

  ApproveFotaUpdateRequest() {}

  explicit ApproveFotaUpdateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ApproveFotaUpdateRequest() = default;
};
class ApproveFotaUpdateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApproveFotaUpdateResponseBody() {}

  explicit ApproveFotaUpdateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApproveFotaUpdateResponseBody() = default;
};
class ApproveFotaUpdateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApproveFotaUpdateResponseBody> body{};

  ApproveFotaUpdateResponse() {}

  explicit ApproveFotaUpdateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApproveFotaUpdateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApproveFotaUpdateResponseBody>(model1);
      }
    }
  }


  virtual ~ApproveFotaUpdateResponse() = default;
};
class AssociateNetworkPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  AssociateNetworkPackageRequest() {}

  explicit AssociateNetworkPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AssociateNetworkPackageRequest() = default;
};
class AssociateNetworkPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateNetworkPackageResponseBody() {}

  explicit AssociateNetworkPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateNetworkPackageResponseBody() = default;
};
class AssociateNetworkPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateNetworkPackageResponseBody> body{};

  AssociateNetworkPackageResponse() {}

  explicit AssociateNetworkPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateNetworkPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateNetworkPackageResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateNetworkPackageResponse() = default;
};
class AttachCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> verifyCode{};

  AttachCenRequest() {}

  explicit AttachCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
  }


  virtual ~AttachCenRequest() = default;
};
class AttachCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachCenResponseBody() {}

  explicit AttachCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachCenResponseBody() = default;
};
class AttachCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachCenResponseBody> body{};

  AttachCenResponse() {}

  explicit AttachCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachCenResponseBody>(model1);
      }
    }
  }


  virtual ~AttachCenResponse() = default;
};
class AttachEndUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> adDomain{};
  shared_ptr<long> clientType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userType{};

  AttachEndUserRequest() {}

  explicit AttachEndUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adDomain) {
      res["AdDomain"] = boost::any(*adDomain);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdDomain") != m.end() && !m["AdDomain"].empty()) {
      adDomain = make_shared<string>(boost::any_cast<string>(m["AdDomain"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~AttachEndUserRequest() = default;
};
class AttachEndUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachEndUserResponseBody() {}

  explicit AttachEndUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachEndUserResponseBody() = default;
};
class AttachEndUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachEndUserResponseBody> body{};

  AttachEndUserResponse() {}

  explicit AttachEndUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachEndUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachEndUserResponseBody>(model1);
      }
    }
  }


  virtual ~AttachEndUserResponse() = default;
};
class BindConfigGroupRequestResourceInfos : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};

  BindConfigGroupRequestResourceInfos() {}

  explicit BindConfigGroupRequestResourceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~BindConfigGroupRequestResourceInfos() = default;
};
class BindConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<BindConfigGroupRequestResourceInfos>> resourceInfos{};

  BindConfigGroupRequest() {}

  explicit BindConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInfos") != m.end() && !m["ResourceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInfos"].type()) {
        vector<BindConfigGroupRequestResourceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BindConfigGroupRequestResourceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInfos = make_shared<vector<BindConfigGroupRequestResourceInfos>>(expect1);
      }
    }
  }


  virtual ~BindConfigGroupRequest() = default;
};
class BindConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  BindConfigGroupResponseBody() {}

  explicit BindConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindConfigGroupResponseBody() = default;
};
class BindConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindConfigGroupResponseBody> body{};

  BindConfigGroupResponse() {}

  explicit BindConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~BindConfigGroupResponse() = default;
};
class CancelAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  CancelAutoSnapshotPolicyRequest() {}

  explicit CancelAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CancelAutoSnapshotPolicyRequest() = default;
};
class CancelAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelAutoSnapshotPolicyResponseBody() {}

  explicit CancelAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelAutoSnapshotPolicyResponseBody() = default;
};
class CancelAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelAutoSnapshotPolicyResponseBody> body{};

  CancelAutoSnapshotPolicyResponse() {}

  explicit CancelAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CancelAutoSnapshotPolicyResponse() = default;
};
class CancelCdsFileShareLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> shareId{};

  CancelCdsFileShareLinkRequest() {}

  explicit CancelCdsFileShareLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
  }


  virtual ~CancelCdsFileShareLinkRequest() = default;
};
class CancelCdsFileShareLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelCdsFileShareLinkResponseBody() {}

  explicit CancelCdsFileShareLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelCdsFileShareLinkResponseBody() = default;
};
class CancelCdsFileShareLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelCdsFileShareLinkResponseBody> body{};

  CancelCdsFileShareLinkResponse() {}

  explicit CancelCdsFileShareLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelCdsFileShareLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelCdsFileShareLinkResponseBody>(model1);
      }
    }
  }


  virtual ~CancelCdsFileShareLinkResponse() = default;
};
class CancelCoordinationForMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> coIds{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userType{};

  CancelCoordinationForMonitoringRequest() {}

  explicit CancelCoordinationForMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coIds) {
      res["CoIds"] = boost::any(*coIds);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoIds") != m.end() && !m["CoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      coIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~CancelCoordinationForMonitoringRequest() = default;
};
class CancelCoordinationForMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelCoordinationForMonitoringResponseBody() {}

  explicit CancelCoordinationForMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelCoordinationForMonitoringResponseBody() = default;
};
class CancelCoordinationForMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelCoordinationForMonitoringResponseBody> body{};

  CancelCoordinationForMonitoringResponse() {}

  explicit CancelCoordinationForMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelCoordinationForMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelCoordinationForMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~CancelCoordinationForMonitoringResponse() = default;
};
class CancelCopyImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};

  CancelCopyImageRequest() {}

  explicit CancelCopyImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CancelCopyImageRequest() = default;
};
class CancelCopyImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelCopyImageResponseBody() {}

  explicit CancelCopyImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelCopyImageResponseBody() = default;
};
class CancelCopyImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelCopyImageResponseBody> body{};

  CancelCopyImageResponse() {}

  explicit CancelCopyImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelCopyImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelCopyImageResponseBody>(model1);
      }
    }
  }


  virtual ~CancelCopyImageResponse() = default;
};
class CloneCenterPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessType{};
  shared_ptr<string> name{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  CloneCenterPolicyRequest() {}

  explicit CloneCenterPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~CloneCenterPolicyRequest() = default;
};
class CloneCenterPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> requestId{};

  CloneCenterPolicyResponseBody() {}

  explicit CloneCenterPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneCenterPolicyResponseBody() = default;
};
class CloneCenterPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneCenterPolicyResponseBody> body{};

  CloneCenterPolicyResponse() {}

  explicit CloneCenterPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneCenterPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneCenterPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CloneCenterPolicyResponse() = default;
};
class ClonePolicyGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> regionId{};

  ClonePolicyGroupRequest() {}

  explicit ClonePolicyGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ClonePolicyGroupRequest() = default;
};
class ClonePolicyGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> requestId{};

  ClonePolicyGroupResponseBody() {}

  explicit ClonePolicyGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClonePolicyGroupResponseBody() = default;
};
class ClonePolicyGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClonePolicyGroupResponseBody> body{};

  ClonePolicyGroupResponse() {}

  explicit ClonePolicyGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClonePolicyGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClonePolicyGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ClonePolicyGroupResponse() = default;
};
class CompleteCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uploadId{};

  CompleteCdsFileRequest() {}

  explicit CompleteCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uploadId) {
      res["UploadId"] = boost::any(*uploadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UploadId") != m.end() && !m["UploadId"].empty()) {
      uploadId = make_shared<string>(boost::any_cast<string>(m["UploadId"]));
    }
  }


  virtual ~CompleteCdsFileRequest() = default;
};
class CompleteCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CompleteCdsFileResponseBody() {}

  explicit CompleteCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CompleteCdsFileResponseBody() = default;
};
class CompleteCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompleteCdsFileResponseBody> body{};

  CompleteCdsFileResponse() {}

  explicit CompleteCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompleteCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompleteCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~CompleteCdsFileResponse() = default;
};
class ConfigADConnectorTrustRequest : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<bool> rdsLicenseDomain{};
  shared_ptr<string> regionId{};
  shared_ptr<string> trustKey{};

  ConfigADConnectorTrustRequest() {}

  explicit ConfigADConnectorTrustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (rdsLicenseDomain) {
      res["RdsLicenseDomain"] = boost::any(*rdsLicenseDomain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (trustKey) {
      res["TrustKey"] = boost::any(*trustKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RdsLicenseDomain") != m.end() && !m["RdsLicenseDomain"].empty()) {
      rdsLicenseDomain = make_shared<bool>(boost::any_cast<bool>(m["RdsLicenseDomain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TrustKey") != m.end() && !m["TrustKey"].empty()) {
      trustKey = make_shared<string>(boost::any_cast<string>(m["TrustKey"]));
    }
  }


  virtual ~ConfigADConnectorTrustRequest() = default;
};
class ConfigADConnectorTrustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigADConnectorTrustResponseBody() {}

  explicit ConfigADConnectorTrustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigADConnectorTrustResponseBody() = default;
};
class ConfigADConnectorTrustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigADConnectorTrustResponseBody> body{};

  ConfigADConnectorTrustResponse() {}

  explicit ConfigADConnectorTrustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigADConnectorTrustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigADConnectorTrustResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigADConnectorTrustResponse() = default;
};
class ConfigADConnectorUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<string> OUName{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ConfigADConnectorUserRequest() {}

  explicit ConfigADConnectorUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (OUName) {
      res["OUName"] = boost::any(*OUName);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("OUName") != m.end() && !m["OUName"].empty()) {
      OUName = make_shared<string>(boost::any_cast<string>(m["OUName"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigADConnectorUserRequest() = default;
};
class ConfigADConnectorUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigADConnectorUserResponseBody() {}

  explicit ConfigADConnectorUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigADConnectorUserResponseBody() = default;
};
class ConfigADConnectorUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigADConnectorUserResponseBody> body{};

  ConfigADConnectorUserResponse() {}

  explicit ConfigADConnectorUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigADConnectorUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigADConnectorUserResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigADConnectorUserResponse() = default;
};
class CopyCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRename{};
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> fileReceiverId{};
  shared_ptr<string> fileReceiverType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> parentFolderId{};
  shared_ptr<string> regionId{};

  CopyCdsFileRequest() {}

  explicit CopyCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRename) {
      res["AutoRename"] = boost::any(*autoRename);
    }
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileReceiverId) {
      res["FileReceiverId"] = boost::any(*fileReceiverId);
    }
    if (fileReceiverType) {
      res["FileReceiverType"] = boost::any(*fileReceiverType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (parentFolderId) {
      res["ParentFolderId"] = boost::any(*parentFolderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRename") != m.end() && !m["AutoRename"].empty()) {
      autoRename = make_shared<bool>(boost::any_cast<bool>(m["AutoRename"]));
    }
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileReceiverId") != m.end() && !m["FileReceiverId"].empty()) {
      fileReceiverId = make_shared<string>(boost::any_cast<string>(m["FileReceiverId"]));
    }
    if (m.find("FileReceiverType") != m.end() && !m["FileReceiverType"].empty()) {
      fileReceiverType = make_shared<string>(boost::any_cast<string>(m["FileReceiverType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ParentFolderId") != m.end() && !m["ParentFolderId"].empty()) {
      parentFolderId = make_shared<string>(boost::any_cast<string>(m["ParentFolderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CopyCdsFileRequest() = default;
};
class CopyCdsFileResponseBodyCopyCdsFileModel : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> fileId{};

  CopyCdsFileResponseBodyCopyCdsFileModel() {}

  explicit CopyCdsFileResponseBodyCopyCdsFileModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~CopyCdsFileResponseBodyCopyCdsFileModel() = default;
};
class CopyCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CopyCdsFileResponseBodyCopyCdsFileModel> copyCdsFileModel{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CopyCdsFileResponseBody() {}

  explicit CopyCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (copyCdsFileModel) {
      res["CopyCdsFileModel"] = copyCdsFileModel ? boost::any(copyCdsFileModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CopyCdsFileModel") != m.end() && !m["CopyCdsFileModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CopyCdsFileModel"].type()) {
        CopyCdsFileResponseBodyCopyCdsFileModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CopyCdsFileModel"]));
        copyCdsFileModel = make_shared<CopyCdsFileResponseBodyCopyCdsFileModel>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CopyCdsFileResponseBody() = default;
};
class CopyCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCdsFileResponseBody> body{};

  CopyCdsFileResponse() {}

  explicit CopyCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCdsFileResponse() = default;
};
class CopyImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationDescription{};
  shared_ptr<string> destinationImageName{};
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};

  CopyImageRequest() {}

  explicit CopyImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationDescription) {
      res["DestinationDescription"] = boost::any(*destinationDescription);
    }
    if (destinationImageName) {
      res["DestinationImageName"] = boost::any(*destinationImageName);
    }
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationDescription") != m.end() && !m["DestinationDescription"].empty()) {
      destinationDescription = make_shared<string>(boost::any_cast<string>(m["DestinationDescription"]));
    }
    if (m.find("DestinationImageName") != m.end() && !m["DestinationImageName"].empty()) {
      destinationImageName = make_shared<string>(boost::any_cast<string>(m["DestinationImageName"]));
    }
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CopyImageRequest() = default;
};
class CopyImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CopyImageResponseBody() {}

  explicit CopyImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyImageResponseBody() = default;
};
class CopyImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyImageResponseBody> body{};

  CopyImageResponse() {}

  explicit CopyImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyImageResponseBody>(model1);
      }
    }
  }


  virtual ~CopyImageResponse() = default;
};
class CreateADConnectorDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopAccessType{};
  shared_ptr<string> directoryName{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> regionId{};
  shared_ptr<long> specification{};
  shared_ptr<vector<string>> subDomainDnsAddress{};
  shared_ptr<string> subDomainName{};
  shared_ptr<vector<string>> vSwitchId{};

  CreateADConnectorDirectoryRequest() {}

  explicit CreateADConnectorDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (directoryName) {
      res["DirectoryName"] = boost::any(*directoryName);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (subDomainDnsAddress) {
      res["SubDomainDnsAddress"] = boost::any(*subDomainDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("DirectoryName") != m.end() && !m["DirectoryName"].empty()) {
      directoryName = make_shared<string>(boost::any_cast<string>(m["DirectoryName"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("SubDomainDnsAddress") != m.end() && !m["SubDomainDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDomainDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDomainDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDomainDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateADConnectorDirectoryRequest() = default;
};
class CreateADConnectorDirectoryResponseBodyAdConnectors : public Darabonba::Model {
public:
  shared_ptr<string> address{};

  CreateADConnectorDirectoryResponseBodyAdConnectors() {}

  explicit CreateADConnectorDirectoryResponseBodyAdConnectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
  }


  virtual ~CreateADConnectorDirectoryResponseBodyAdConnectors() = default;
};
class CreateADConnectorDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateADConnectorDirectoryResponseBodyAdConnectors>> adConnectors{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> trustPassword{};

  CreateADConnectorDirectoryResponseBody() {}

  explicit CreateADConnectorDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adConnectors) {
      vector<boost::any> temp1;
      for(auto item1:*adConnectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdConnectors"] = boost::any(temp1);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trustPassword) {
      res["TrustPassword"] = boost::any(*trustPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdConnectors") != m.end() && !m["AdConnectors"].empty()) {
      if (typeid(vector<boost::any>) == m["AdConnectors"].type()) {
        vector<CreateADConnectorDirectoryResponseBodyAdConnectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdConnectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateADConnectorDirectoryResponseBodyAdConnectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adConnectors = make_shared<vector<CreateADConnectorDirectoryResponseBodyAdConnectors>>(expect1);
      }
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrustPassword") != m.end() && !m["TrustPassword"].empty()) {
      trustPassword = make_shared<string>(boost::any_cast<string>(m["TrustPassword"]));
    }
  }


  virtual ~CreateADConnectorDirectoryResponseBody() = default;
};
class CreateADConnectorDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateADConnectorDirectoryResponseBody> body{};

  CreateADConnectorDirectoryResponse() {}

  explicit CreateADConnectorDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateADConnectorDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateADConnectorDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateADConnectorDirectoryResponse() = default;
};
class CreateADConnectorOfficeSiteRequest : public Darabonba::Model {
public:
  shared_ptr<string> adHostname{};
  shared_ptr<string> backupDCHostname{};
  shared_ptr<string> backupDns{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> desktopAccessType{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> enableInternetAccess{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> specification{};
  shared_ptr<vector<string>> subDomainDnsAddress{};
  shared_ptr<string> subDomainName{};
  shared_ptr<vector<string>> vSwitchId{};
  shared_ptr<string> verifyCode{};

  CreateADConnectorOfficeSiteRequest() {}

  explicit CreateADConnectorOfficeSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (backupDCHostname) {
      res["BackupDCHostname"] = boost::any(*backupDCHostname);
    }
    if (backupDns) {
      res["BackupDns"] = boost::any(*backupDns);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (enableInternetAccess) {
      res["EnableInternetAccess"] = boost::any(*enableInternetAccess);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (subDomainDnsAddress) {
      res["SubDomainDnsAddress"] = boost::any(*subDomainDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("BackupDCHostname") != m.end() && !m["BackupDCHostname"].empty()) {
      backupDCHostname = make_shared<string>(boost::any_cast<string>(m["BackupDCHostname"]));
    }
    if (m.find("BackupDns") != m.end() && !m["BackupDns"].empty()) {
      backupDns = make_shared<string>(boost::any_cast<string>(m["BackupDns"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("EnableInternetAccess") != m.end() && !m["EnableInternetAccess"].empty()) {
      enableInternetAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAccess"]));
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("SubDomainDnsAddress") != m.end() && !m["SubDomainDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDomainDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDomainDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDomainDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
  }


  virtual ~CreateADConnectorOfficeSiteRequest() = default;
};
class CreateADConnectorOfficeSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> requestId{};

  CreateADConnectorOfficeSiteResponseBody() {}

  explicit CreateADConnectorOfficeSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateADConnectorOfficeSiteResponseBody() = default;
};
class CreateADConnectorOfficeSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateADConnectorOfficeSiteResponseBody> body{};

  CreateADConnectorOfficeSiteResponse() {}

  explicit CreateADConnectorOfficeSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateADConnectorOfficeSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateADConnectorOfficeSiteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateADConnectorOfficeSiteResponse() = default;
};
class CreateAndBindNasFileSystemRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<long> encryptType{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageType{};

  CreateAndBindNasFileSystemRequest() {}

  explicit CreateAndBindNasFileSystemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<long>(boost::any_cast<long>(m["EncryptType"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~CreateAndBindNasFileSystemRequest() = default;
};
class CreateAndBindNasFileSystemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAndBindNasFileSystemResponseBody() {}

  explicit CreateAndBindNasFileSystemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAndBindNasFileSystemResponseBody() = default;
};
class CreateAndBindNasFileSystemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAndBindNasFileSystemResponseBody> body{};

  CreateAndBindNasFileSystemResponse() {}

  explicit CreateAndBindNasFileSystemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAndBindNasFileSystemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAndBindNasFileSystemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAndBindNasFileSystemResponse() = default;
};
class CreateAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<string> policyName{};
  shared_ptr<string> regionId{};
  shared_ptr<long> retentionDays{};

  CreateAutoSnapshotPolicyRequest() {}

  explicit CreateAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
  }


  virtual ~CreateAutoSnapshotPolicyRequest() = default;
};
class CreateAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};
  shared_ptr<string> requestId{};

  CreateAutoSnapshotPolicyResponseBody() {}

  explicit CreateAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAutoSnapshotPolicyResponseBody() = default;
};
class CreateAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAutoSnapshotPolicyResponseBody> body{};

  CreateAutoSnapshotPolicyResponse() {}

  explicit CreateAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAutoSnapshotPolicyResponse() = default;
};
class CreateBandwidthResourcePackagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoPay{};
  shared_ptr<long> packageSize{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};

  CreateBandwidthResourcePackagesRequest() {}

  explicit CreateBandwidthResourcePackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (packageSize) {
      res["PackageSize"] = boost::any(*packageSize);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("PackageSize") != m.end() && !m["PackageSize"].empty()) {
      packageSize = make_shared<long>(boost::any_cast<long>(m["PackageSize"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBandwidthResourcePackagesRequest() = default;
};
class CreateBandwidthResourcePackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};

  CreateBandwidthResourcePackagesResponseBody() {}

  explicit CreateBandwidthResourcePackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBandwidthResourcePackagesResponseBody() = default;
};
class CreateBandwidthResourcePackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBandwidthResourcePackagesResponseBody> body{};

  CreateBandwidthResourcePackagesResponse() {}

  explicit CreateBandwidthResourcePackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBandwidthResourcePackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBandwidthResourcePackagesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBandwidthResourcePackagesResponse() = default;
};
class CreateBundleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bundleName{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> imageId{};
  shared_ptr<string> language{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rootDiskPerformanceLevel{};
  shared_ptr<long> rootDiskSizeGib{};
  shared_ptr<string> userDiskPerformanceLevel{};
  shared_ptr<vector<long>> userDiskSizeGib{};

  CreateBundleRequest() {}

  explicit CreateBundleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleName) {
      res["BundleName"] = boost::any(*bundleName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rootDiskPerformanceLevel) {
      res["RootDiskPerformanceLevel"] = boost::any(*rootDiskPerformanceLevel);
    }
    if (rootDiskSizeGib) {
      res["RootDiskSizeGib"] = boost::any(*rootDiskSizeGib);
    }
    if (userDiskPerformanceLevel) {
      res["UserDiskPerformanceLevel"] = boost::any(*userDiskPerformanceLevel);
    }
    if (userDiskSizeGib) {
      res["UserDiskSizeGib"] = boost::any(*userDiskSizeGib);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleName") != m.end() && !m["BundleName"].empty()) {
      bundleName = make_shared<string>(boost::any_cast<string>(m["BundleName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RootDiskPerformanceLevel") != m.end() && !m["RootDiskPerformanceLevel"].empty()) {
      rootDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["RootDiskPerformanceLevel"]));
    }
    if (m.find("RootDiskSizeGib") != m.end() && !m["RootDiskSizeGib"].empty()) {
      rootDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["RootDiskSizeGib"]));
    }
    if (m.find("UserDiskPerformanceLevel") != m.end() && !m["UserDiskPerformanceLevel"].empty()) {
      userDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["UserDiskPerformanceLevel"]));
    }
    if (m.find("UserDiskSizeGib") != m.end() && !m["UserDiskSizeGib"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["UserDiskSizeGib"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserDiskSizeGib"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      userDiskSizeGib = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateBundleRequest() = default;
};
class CreateBundleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bundleId{};
  shared_ptr<string> requestId{};

  CreateBundleResponseBody() {}

  explicit CreateBundleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBundleResponseBody() = default;
};
class CreateBundleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBundleResponseBody> body{};

  CreateBundleResponse() {}

  explicit CreateBundleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBundleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBundleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBundleResponse() = default;
};
class CreateCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> conflictPolicy{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileHash{};
  shared_ptr<long> fileLength{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> parentFileId{};
  shared_ptr<string> regionId{};

  CreateCdsFileRequest() {}

  explicit CreateCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (conflictPolicy) {
      res["ConflictPolicy"] = boost::any(*conflictPolicy);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileHash) {
      res["FileHash"] = boost::any(*fileHash);
    }
    if (fileLength) {
      res["FileLength"] = boost::any(*fileLength);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (parentFileId) {
      res["ParentFileId"] = boost::any(*parentFileId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("ConflictPolicy") != m.end() && !m["ConflictPolicy"].empty()) {
      conflictPolicy = make_shared<string>(boost::any_cast<string>(m["ConflictPolicy"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileHash") != m.end() && !m["FileHash"].empty()) {
      fileHash = make_shared<string>(boost::any_cast<string>(m["FileHash"]));
    }
    if (m.find("FileLength") != m.end() && !m["FileLength"].empty()) {
      fileLength = make_shared<long>(boost::any_cast<long>(m["FileLength"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ParentFileId") != m.end() && !m["ParentFileId"].empty()) {
      parentFileId = make_shared<string>(boost::any_cast<string>(m["ParentFileId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCdsFileRequest() = default;
};
class CreateCdsFileResponseBodyFileModel : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> uploadId{};
  shared_ptr<string> uploadUrl{};

  CreateCdsFileResponseBodyFileModel() {}

  explicit CreateCdsFileResponseBodyFileModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (uploadId) {
      res["UploadId"] = boost::any(*uploadId);
    }
    if (uploadUrl) {
      res["UploadUrl"] = boost::any(*uploadUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("UploadId") != m.end() && !m["UploadId"].empty()) {
      uploadId = make_shared<string>(boost::any_cast<string>(m["UploadId"]));
    }
    if (m.find("UploadUrl") != m.end() && !m["UploadUrl"].empty()) {
      uploadUrl = make_shared<string>(boost::any_cast<string>(m["UploadUrl"]));
    }
  }


  virtual ~CreateCdsFileResponseBodyFileModel() = default;
};
class CreateCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateCdsFileResponseBodyFileModel> fileModel{};
  shared_ptr<string> requestId{};

  CreateCdsFileResponseBody() {}

  explicit CreateCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileModel) {
      res["FileModel"] = fileModel ? boost::any(fileModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileModel") != m.end() && !m["FileModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileModel"].type()) {
        CreateCdsFileResponseBodyFileModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileModel"]));
        fileModel = make_shared<CreateCdsFileResponseBodyFileModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCdsFileResponseBody() = default;
};
class CreateCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCdsFileResponseBody> body{};

  CreateCdsFileResponse() {}

  explicit CreateCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCdsFileResponse() = default;
};
class CreateCdsFileShareLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableDownload{};
  shared_ptr<bool> disablePreview{};
  shared_ptr<bool> disableSave{};
  shared_ptr<long> downloadLimit{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> expiration{};
  shared_ptr<vector<string>> fileIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> previewLimit{};
  shared_ptr<long> saveLimit{};
  shared_ptr<string> shareName{};
  shared_ptr<string> sharePwd{};

  CreateCdsFileShareLinkRequest() {}

  explicit CreateCdsFileShareLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableDownload) {
      res["DisableDownload"] = boost::any(*disableDownload);
    }
    if (disablePreview) {
      res["DisablePreview"] = boost::any(*disablePreview);
    }
    if (disableSave) {
      res["DisableSave"] = boost::any(*disableSave);
    }
    if (downloadLimit) {
      res["DownloadLimit"] = boost::any(*downloadLimit);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (previewLimit) {
      res["PreviewLimit"] = boost::any(*previewLimit);
    }
    if (saveLimit) {
      res["SaveLimit"] = boost::any(*saveLimit);
    }
    if (shareName) {
      res["ShareName"] = boost::any(*shareName);
    }
    if (sharePwd) {
      res["SharePwd"] = boost::any(*sharePwd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableDownload") != m.end() && !m["DisableDownload"].empty()) {
      disableDownload = make_shared<bool>(boost::any_cast<bool>(m["DisableDownload"]));
    }
    if (m.find("DisablePreview") != m.end() && !m["DisablePreview"].empty()) {
      disablePreview = make_shared<bool>(boost::any_cast<bool>(m["DisablePreview"]));
    }
    if (m.find("DisableSave") != m.end() && !m["DisableSave"].empty()) {
      disableSave = make_shared<bool>(boost::any_cast<bool>(m["DisableSave"]));
    }
    if (m.find("DownloadLimit") != m.end() && !m["DownloadLimit"].empty()) {
      downloadLimit = make_shared<long>(boost::any_cast<long>(m["DownloadLimit"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PreviewLimit") != m.end() && !m["PreviewLimit"].empty()) {
      previewLimit = make_shared<long>(boost::any_cast<long>(m["PreviewLimit"]));
    }
    if (m.find("SaveLimit") != m.end() && !m["SaveLimit"].empty()) {
      saveLimit = make_shared<long>(boost::any_cast<long>(m["SaveLimit"]));
    }
    if (m.find("ShareName") != m.end() && !m["ShareName"].empty()) {
      shareName = make_shared<string>(boost::any_cast<string>(m["ShareName"]));
    }
    if (m.find("SharePwd") != m.end() && !m["SharePwd"].empty()) {
      sharePwd = make_shared<string>(boost::any_cast<string>(m["SharePwd"]));
    }
  }


  virtual ~CreateCdsFileShareLinkRequest() = default;
};
class CreateCdsFileShareLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CdsFileShareLinkModel> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCdsFileShareLinkResponseBody() {}

  explicit CreateCdsFileShareLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CdsFileShareLinkModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CdsFileShareLinkModel>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCdsFileShareLinkResponseBody() = default;
};
class CreateCdsFileShareLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCdsFileShareLinkResponseBody> body{};

  CreateCdsFileShareLinkResponse() {}

  explicit CreateCdsFileShareLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCdsFileShareLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCdsFileShareLinkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCdsFileShareLinkResponse() = default;
};
class CreateCenterPolicyRequestAuthorizeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  CreateCenterPolicyRequestAuthorizeAccessPolicyRule() {}

  explicit CreateCenterPolicyRequestAuthorizeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateCenterPolicyRequestAuthorizeAccessPolicyRule() = default;
};
class CreateCenterPolicyRequestAuthorizeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  CreateCenterPolicyRequestAuthorizeSecurityPolicyRule() {}

  explicit CreateCenterPolicyRequestAuthorizeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCenterPolicyRequestAuthorizeSecurityPolicyRule() = default;
};
class CreateCenterPolicyRequestClientType : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  CreateCenterPolicyRequestClientType() {}

  explicit CreateCenterPolicyRequestClientType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateCenterPolicyRequestClientType() = default;
};
class CreateCenterPolicyRequestDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  CreateCenterPolicyRequestDeviceRedirects() {}

  explicit CreateCenterPolicyRequestDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~CreateCenterPolicyRequestDeviceRedirects() = default;
};
class CreateCenterPolicyRequestDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  CreateCenterPolicyRequestDeviceRules() {}

  explicit CreateCenterPolicyRequestDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~CreateCenterPolicyRequestDeviceRules() = default;
};
class CreateCenterPolicyRequestDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  CreateCenterPolicyRequestDomainResolveRule() {}

  explicit CreateCenterPolicyRequestDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~CreateCenterPolicyRequestDomainResolveRule() = default;
};
class CreateCenterPolicyRequestNetRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};
  shared_ptr<string> ruleType{};

  CreateCenterPolicyRequestNetRedirectRule() {}

  explicit CreateCenterPolicyRequestNetRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~CreateCenterPolicyRequestNetRedirectRule() = default;
};
class CreateCenterPolicyRequestUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> productId{};
  shared_ptr<string> usbRedirectType{};
  shared_ptr<string> usbRuleType{};
  shared_ptr<string> vendorId{};

  CreateCenterPolicyRequestUsbSupplyRedirectRule() {}

  explicit CreateCenterPolicyRequestUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<string>(boost::any_cast<string>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<string>(boost::any_cast<string>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~CreateCenterPolicyRequestUsbSupplyRedirectRule() = default;
};
class CreateCenterPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<CreateCenterPolicyRequestAuthorizeAccessPolicyRule>> authorizeAccessPolicyRule{};
  shared_ptr<vector<CreateCenterPolicyRequestAuthorizeSecurityPolicyRule>> authorizeSecurityPolicyRule{};
  shared_ptr<long> businessType{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<CreateCenterPolicyRequestClientType>> clientType{};
  shared_ptr<string> clipboard{};
  shared_ptr<string> colorEnhancement{};
  shared_ptr<long> cpuDownGradeDuration{};
  shared_ptr<vector<string>> cpuProcessors{};
  shared_ptr<string> cpuProtectedMode{};
  shared_ptr<long> cpuRateLimit{};
  shared_ptr<long> cpuSampleDuration{};
  shared_ptr<long> cpuSingleRateLimit{};
  shared_ptr<string> deviceConnectHint{};
  shared_ptr<vector<CreateCenterPolicyRequestDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<CreateCenterPolicyRequestDeviceRules>> deviceRules{};
  shared_ptr<string> disconnectKeepSession{};
  shared_ptr<long> disconnectKeepSessionTime{};
  shared_ptr<string> displayMode{};
  shared_ptr<vector<CreateCenterPolicyRequestDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<string> enableSessionRateLimiting{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> fileMigrate{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> internetPrinter{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<long> memoryDownGradeDuration{};
  shared_ptr<vector<string>> memoryProcessors{};
  shared_ptr<string> memoryProtectedMode{};
  shared_ptr<long> memoryRateLimit{};
  shared_ptr<long> memorySampleDuration{};
  shared_ptr<long> memorySingleRateLimit{};
  shared_ptr<string> mobileRestart{};
  shared_ptr<string> mobileShutdown{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<vector<CreateCenterPolicyRequestNetRedirectRule>> netRedirectRule{};
  shared_ptr<string> noOperationDisconnect{};
  shared_ptr<long> noOperationDisconnectTime{};
  shared_ptr<string> printerRedirect{};
  shared_ptr<string> qualityEnhancement{};
  shared_ptr<long> recordEventDuration{};
  shared_ptr<vector<string>> recordEventFilePaths{};
  shared_ptr<vector<string>> recordEventRegisters{};
  shared_ptr<vector<string>> recordEvents{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<string> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<string> resetDesktop{};
  shared_ptr<long> resolutionHeight{};
  shared_ptr<string> resolutionModel{};
  shared_ptr<long> resolutionWidth{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> safeMenu{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<long> sessionMaxRateKbps{};
  shared_ptr<string> smoothEnhancement{};
  shared_ptr<string> statusMonitor{};
  shared_ptr<string> streamingMode{};
  shared_ptr<long> targetFps{};
  shared_ptr<string> taskbar{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<CreateCenterPolicyRequestUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<long> videoEncAvgKbps{};
  shared_ptr<long> videoEncMaxQP{};
  shared_ptr<long> videoEncMinQP{};
  shared_ptr<long> videoEncPeakKbps{};
  shared_ptr<string> videoEncPolicy{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<long> watermarkColumnAmount{};
  shared_ptr<string> watermarkCustomText{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wuyingKeeper{};
  shared_ptr<string> wyAssistant{};

  CreateCenterPolicyRequest() {}

  explicit CreateCenterPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRule"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientType) {
      vector<boost::any> temp1;
      for(auto item1:*clientType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientType"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (colorEnhancement) {
      res["ColorEnhancement"] = boost::any(*colorEnhancement);
    }
    if (cpuDownGradeDuration) {
      res["CpuDownGradeDuration"] = boost::any(*cpuDownGradeDuration);
    }
    if (cpuProcessors) {
      res["CpuProcessors"] = boost::any(*cpuProcessors);
    }
    if (cpuProtectedMode) {
      res["CpuProtectedMode"] = boost::any(*cpuProtectedMode);
    }
    if (cpuRateLimit) {
      res["CpuRateLimit"] = boost::any(*cpuRateLimit);
    }
    if (cpuSampleDuration) {
      res["CpuSampleDuration"] = boost::any(*cpuSampleDuration);
    }
    if (cpuSingleRateLimit) {
      res["CpuSingleRateLimit"] = boost::any(*cpuSingleRateLimit);
    }
    if (deviceConnectHint) {
      res["DeviceConnectHint"] = boost::any(*deviceConnectHint);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (disconnectKeepSession) {
      res["DisconnectKeepSession"] = boost::any(*disconnectKeepSession);
    }
    if (disconnectKeepSessionTime) {
      res["DisconnectKeepSessionTime"] = boost::any(*disconnectKeepSessionTime);
    }
    if (displayMode) {
      res["DisplayMode"] = boost::any(*displayMode);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (enableSessionRateLimiting) {
      res["EnableSessionRateLimiting"] = boost::any(*enableSessionRateLimiting);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (fileMigrate) {
      res["FileMigrate"] = boost::any(*fileMigrate);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (internetPrinter) {
      res["InternetPrinter"] = boost::any(*internetPrinter);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (memoryDownGradeDuration) {
      res["MemoryDownGradeDuration"] = boost::any(*memoryDownGradeDuration);
    }
    if (memoryProcessors) {
      res["MemoryProcessors"] = boost::any(*memoryProcessors);
    }
    if (memoryProtectedMode) {
      res["MemoryProtectedMode"] = boost::any(*memoryProtectedMode);
    }
    if (memoryRateLimit) {
      res["MemoryRateLimit"] = boost::any(*memoryRateLimit);
    }
    if (memorySampleDuration) {
      res["MemorySampleDuration"] = boost::any(*memorySampleDuration);
    }
    if (memorySingleRateLimit) {
      res["MemorySingleRateLimit"] = boost::any(*memorySingleRateLimit);
    }
    if (mobileRestart) {
      res["MobileRestart"] = boost::any(*mobileRestart);
    }
    if (mobileShutdown) {
      res["MobileShutdown"] = boost::any(*mobileShutdown);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (netRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*netRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetRedirectRule"] = boost::any(temp1);
    }
    if (noOperationDisconnect) {
      res["NoOperationDisconnect"] = boost::any(*noOperationDisconnect);
    }
    if (noOperationDisconnectTime) {
      res["NoOperationDisconnectTime"] = boost::any(*noOperationDisconnectTime);
    }
    if (printerRedirect) {
      res["PrinterRedirect"] = boost::any(*printerRedirect);
    }
    if (qualityEnhancement) {
      res["QualityEnhancement"] = boost::any(*qualityEnhancement);
    }
    if (recordEventDuration) {
      res["RecordEventDuration"] = boost::any(*recordEventDuration);
    }
    if (recordEventFilePaths) {
      res["RecordEventFilePaths"] = boost::any(*recordEventFilePaths);
    }
    if (recordEventRegisters) {
      res["RecordEventRegisters"] = boost::any(*recordEventRegisters);
    }
    if (recordEvents) {
      res["RecordEvents"] = boost::any(*recordEvents);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (resetDesktop) {
      res["ResetDesktop"] = boost::any(*resetDesktop);
    }
    if (resolutionHeight) {
      res["ResolutionHeight"] = boost::any(*resolutionHeight);
    }
    if (resolutionModel) {
      res["ResolutionModel"] = boost::any(*resolutionModel);
    }
    if (resolutionWidth) {
      res["ResolutionWidth"] = boost::any(*resolutionWidth);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (safeMenu) {
      res["SafeMenu"] = boost::any(*safeMenu);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (sessionMaxRateKbps) {
      res["SessionMaxRateKbps"] = boost::any(*sessionMaxRateKbps);
    }
    if (smoothEnhancement) {
      res["SmoothEnhancement"] = boost::any(*smoothEnhancement);
    }
    if (statusMonitor) {
      res["StatusMonitor"] = boost::any(*statusMonitor);
    }
    if (streamingMode) {
      res["StreamingMode"] = boost::any(*streamingMode);
    }
    if (targetFps) {
      res["TargetFps"] = boost::any(*targetFps);
    }
    if (taskbar) {
      res["Taskbar"] = boost::any(*taskbar);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoEncAvgKbps) {
      res["VideoEncAvgKbps"] = boost::any(*videoEncAvgKbps);
    }
    if (videoEncMaxQP) {
      res["VideoEncMaxQP"] = boost::any(*videoEncMaxQP);
    }
    if (videoEncMinQP) {
      res["VideoEncMinQP"] = boost::any(*videoEncMinQP);
    }
    if (videoEncPeakKbps) {
      res["VideoEncPeakKbps"] = boost::any(*videoEncPeakKbps);
    }
    if (videoEncPolicy) {
      res["VideoEncPolicy"] = boost::any(*videoEncPolicy);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkColumnAmount) {
      res["WatermarkColumnAmount"] = boost::any(*watermarkColumnAmount);
    }
    if (watermarkCustomText) {
      res["WatermarkCustomText"] = boost::any(*watermarkCustomText);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wuyingKeeper) {
      res["WuyingKeeper"] = boost::any(*wuyingKeeper);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRule") != m.end() && !m["AuthorizeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRule"].type()) {
        vector<CreateCenterPolicyRequestAuthorizeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestAuthorizeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRule = make_shared<vector<CreateCenterPolicyRequestAuthorizeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRule") != m.end() && !m["AuthorizeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRule"].type()) {
        vector<CreateCenterPolicyRequestAuthorizeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestAuthorizeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRule = make_shared<vector<CreateCenterPolicyRequestAuthorizeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientType"].type()) {
        vector<CreateCenterPolicyRequestClientType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestClientType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientType = make_shared<vector<CreateCenterPolicyRequestClientType>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("ColorEnhancement") != m.end() && !m["ColorEnhancement"].empty()) {
      colorEnhancement = make_shared<string>(boost::any_cast<string>(m["ColorEnhancement"]));
    }
    if (m.find("CpuDownGradeDuration") != m.end() && !m["CpuDownGradeDuration"].empty()) {
      cpuDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["CpuDownGradeDuration"]));
    }
    if (m.find("CpuProcessors") != m.end() && !m["CpuProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CpuProtectedMode") != m.end() && !m["CpuProtectedMode"].empty()) {
      cpuProtectedMode = make_shared<string>(boost::any_cast<string>(m["CpuProtectedMode"]));
    }
    if (m.find("CpuRateLimit") != m.end() && !m["CpuRateLimit"].empty()) {
      cpuRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuRateLimit"]));
    }
    if (m.find("CpuSampleDuration") != m.end() && !m["CpuSampleDuration"].empty()) {
      cpuSampleDuration = make_shared<long>(boost::any_cast<long>(m["CpuSampleDuration"]));
    }
    if (m.find("CpuSingleRateLimit") != m.end() && !m["CpuSingleRateLimit"].empty()) {
      cpuSingleRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuSingleRateLimit"]));
    }
    if (m.find("DeviceConnectHint") != m.end() && !m["DeviceConnectHint"].empty()) {
      deviceConnectHint = make_shared<string>(boost::any_cast<string>(m["DeviceConnectHint"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<CreateCenterPolicyRequestDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<CreateCenterPolicyRequestDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<CreateCenterPolicyRequestDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<CreateCenterPolicyRequestDeviceRules>>(expect1);
      }
    }
    if (m.find("DisconnectKeepSession") != m.end() && !m["DisconnectKeepSession"].empty()) {
      disconnectKeepSession = make_shared<string>(boost::any_cast<string>(m["DisconnectKeepSession"]));
    }
    if (m.find("DisconnectKeepSessionTime") != m.end() && !m["DisconnectKeepSessionTime"].empty()) {
      disconnectKeepSessionTime = make_shared<long>(boost::any_cast<long>(m["DisconnectKeepSessionTime"]));
    }
    if (m.find("DisplayMode") != m.end() && !m["DisplayMode"].empty()) {
      displayMode = make_shared<string>(boost::any_cast<string>(m["DisplayMode"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<CreateCenterPolicyRequestDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<CreateCenterPolicyRequestDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EnableSessionRateLimiting") != m.end() && !m["EnableSessionRateLimiting"].empty()) {
      enableSessionRateLimiting = make_shared<string>(boost::any_cast<string>(m["EnableSessionRateLimiting"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("FileMigrate") != m.end() && !m["FileMigrate"].empty()) {
      fileMigrate = make_shared<string>(boost::any_cast<string>(m["FileMigrate"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("InternetPrinter") != m.end() && !m["InternetPrinter"].empty()) {
      internetPrinter = make_shared<string>(boost::any_cast<string>(m["InternetPrinter"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("MemoryDownGradeDuration") != m.end() && !m["MemoryDownGradeDuration"].empty()) {
      memoryDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["MemoryDownGradeDuration"]));
    }
    if (m.find("MemoryProcessors") != m.end() && !m["MemoryProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemoryProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemoryProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memoryProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemoryProtectedMode") != m.end() && !m["MemoryProtectedMode"].empty()) {
      memoryProtectedMode = make_shared<string>(boost::any_cast<string>(m["MemoryProtectedMode"]));
    }
    if (m.find("MemoryRateLimit") != m.end() && !m["MemoryRateLimit"].empty()) {
      memoryRateLimit = make_shared<long>(boost::any_cast<long>(m["MemoryRateLimit"]));
    }
    if (m.find("MemorySampleDuration") != m.end() && !m["MemorySampleDuration"].empty()) {
      memorySampleDuration = make_shared<long>(boost::any_cast<long>(m["MemorySampleDuration"]));
    }
    if (m.find("MemorySingleRateLimit") != m.end() && !m["MemorySingleRateLimit"].empty()) {
      memorySingleRateLimit = make_shared<long>(boost::any_cast<long>(m["MemorySingleRateLimit"]));
    }
    if (m.find("MobileRestart") != m.end() && !m["MobileRestart"].empty()) {
      mobileRestart = make_shared<string>(boost::any_cast<string>(m["MobileRestart"]));
    }
    if (m.find("MobileShutdown") != m.end() && !m["MobileShutdown"].empty()) {
      mobileShutdown = make_shared<string>(boost::any_cast<string>(m["MobileShutdown"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("NetRedirectRule") != m.end() && !m["NetRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["NetRedirectRule"].type()) {
        vector<CreateCenterPolicyRequestNetRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestNetRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        netRedirectRule = make_shared<vector<CreateCenterPolicyRequestNetRedirectRule>>(expect1);
      }
    }
    if (m.find("NoOperationDisconnect") != m.end() && !m["NoOperationDisconnect"].empty()) {
      noOperationDisconnect = make_shared<string>(boost::any_cast<string>(m["NoOperationDisconnect"]));
    }
    if (m.find("NoOperationDisconnectTime") != m.end() && !m["NoOperationDisconnectTime"].empty()) {
      noOperationDisconnectTime = make_shared<long>(boost::any_cast<long>(m["NoOperationDisconnectTime"]));
    }
    if (m.find("PrinterRedirect") != m.end() && !m["PrinterRedirect"].empty()) {
      printerRedirect = make_shared<string>(boost::any_cast<string>(m["PrinterRedirect"]));
    }
    if (m.find("QualityEnhancement") != m.end() && !m["QualityEnhancement"].empty()) {
      qualityEnhancement = make_shared<string>(boost::any_cast<string>(m["QualityEnhancement"]));
    }
    if (m.find("RecordEventDuration") != m.end() && !m["RecordEventDuration"].empty()) {
      recordEventDuration = make_shared<long>(boost::any_cast<long>(m["RecordEventDuration"]));
    }
    if (m.find("RecordEventFilePaths") != m.end() && !m["RecordEventFilePaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventFilePaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventFilePaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventFilePaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEventRegisters") != m.end() && !m["RecordEventRegisters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventRegisters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventRegisters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventRegisters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEvents") != m.end() && !m["RecordEvents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEvents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEvents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEvents = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<string>(boost::any_cast<string>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("ResetDesktop") != m.end() && !m["ResetDesktop"].empty()) {
      resetDesktop = make_shared<string>(boost::any_cast<string>(m["ResetDesktop"]));
    }
    if (m.find("ResolutionHeight") != m.end() && !m["ResolutionHeight"].empty()) {
      resolutionHeight = make_shared<long>(boost::any_cast<long>(m["ResolutionHeight"]));
    }
    if (m.find("ResolutionModel") != m.end() && !m["ResolutionModel"].empty()) {
      resolutionModel = make_shared<string>(boost::any_cast<string>(m["ResolutionModel"]));
    }
    if (m.find("ResolutionWidth") != m.end() && !m["ResolutionWidth"].empty()) {
      resolutionWidth = make_shared<long>(boost::any_cast<long>(m["ResolutionWidth"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SafeMenu") != m.end() && !m["SafeMenu"].empty()) {
      safeMenu = make_shared<string>(boost::any_cast<string>(m["SafeMenu"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SessionMaxRateKbps") != m.end() && !m["SessionMaxRateKbps"].empty()) {
      sessionMaxRateKbps = make_shared<long>(boost::any_cast<long>(m["SessionMaxRateKbps"]));
    }
    if (m.find("SmoothEnhancement") != m.end() && !m["SmoothEnhancement"].empty()) {
      smoothEnhancement = make_shared<string>(boost::any_cast<string>(m["SmoothEnhancement"]));
    }
    if (m.find("StatusMonitor") != m.end() && !m["StatusMonitor"].empty()) {
      statusMonitor = make_shared<string>(boost::any_cast<string>(m["StatusMonitor"]));
    }
    if (m.find("StreamingMode") != m.end() && !m["StreamingMode"].empty()) {
      streamingMode = make_shared<string>(boost::any_cast<string>(m["StreamingMode"]));
    }
    if (m.find("TargetFps") != m.end() && !m["TargetFps"].empty()) {
      targetFps = make_shared<long>(boost::any_cast<long>(m["TargetFps"]));
    }
    if (m.find("Taskbar") != m.end() && !m["Taskbar"].empty()) {
      taskbar = make_shared<string>(boost::any_cast<string>(m["Taskbar"]));
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<CreateCenterPolicyRequestUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCenterPolicyRequestUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<CreateCenterPolicyRequestUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoEncAvgKbps") != m.end() && !m["VideoEncAvgKbps"].empty()) {
      videoEncAvgKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncAvgKbps"]));
    }
    if (m.find("VideoEncMaxQP") != m.end() && !m["VideoEncMaxQP"].empty()) {
      videoEncMaxQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMaxQP"]));
    }
    if (m.find("VideoEncMinQP") != m.end() && !m["VideoEncMinQP"].empty()) {
      videoEncMinQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMinQP"]));
    }
    if (m.find("VideoEncPeakKbps") != m.end() && !m["VideoEncPeakKbps"].empty()) {
      videoEncPeakKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncPeakKbps"]));
    }
    if (m.find("VideoEncPolicy") != m.end() && !m["VideoEncPolicy"].empty()) {
      videoEncPolicy = make_shared<string>(boost::any_cast<string>(m["VideoEncPolicy"]));
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkColumnAmount") != m.end() && !m["WatermarkColumnAmount"].empty()) {
      watermarkColumnAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkColumnAmount"]));
    }
    if (m.find("WatermarkCustomText") != m.end() && !m["WatermarkCustomText"].empty()) {
      watermarkCustomText = make_shared<string>(boost::any_cast<string>(m["WatermarkCustomText"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WuyingKeeper") != m.end() && !m["WuyingKeeper"].empty()) {
      wuyingKeeper = make_shared<string>(boost::any_cast<string>(m["WuyingKeeper"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~CreateCenterPolicyRequest() = default;
};
class CreateCenterPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> requestId{};

  CreateCenterPolicyResponseBody() {}

  explicit CreateCenterPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCenterPolicyResponseBody() = default;
};
class CreateCenterPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCenterPolicyResponseBody> body{};

  CreateCenterPolicyResponse() {}

  explicit CreateCenterPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCenterPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCenterPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCenterPolicyResponse() = default;
};
class CreateCloudDriveServiceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> bizType{};
  shared_ptr<string> cdsChargeType{};
  shared_ptr<string> cenId{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<long> maxSize{};
  shared_ptr<string> name{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> solutionId{};
  shared_ptr<long> userCount{};
  shared_ptr<long> userMaxSize{};

  CreateCloudDriveServiceRequest() {}

  explicit CreateCloudDriveServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (cdsChargeType) {
      res["CdsChargeType"] = boost::any(*cdsChargeType);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (solutionId) {
      res["SolutionId"] = boost::any(*solutionId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (userMaxSize) {
      res["UserMaxSize"] = boost::any(*userMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("CdsChargeType") != m.end() && !m["CdsChargeType"].empty()) {
      cdsChargeType = make_shared<string>(boost::any_cast<string>(m["CdsChargeType"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SolutionId") != m.end() && !m["SolutionId"].empty()) {
      solutionId = make_shared<string>(boost::any_cast<string>(m["SolutionId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("UserMaxSize") != m.end() && !m["UserMaxSize"].empty()) {
      userMaxSize = make_shared<long>(boost::any_cast<long>(m["UserMaxSize"]));
    }
  }


  virtual ~CreateCloudDriveServiceRequest() = default;
};
class CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> regionId{};

  CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds() {}

  explicit CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds() = default;
};
class CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> regionId{};

  CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder() {}

  explicit CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder() = default;
};
class CreateCloudDriveServiceResponseBodyConflictCdsAndOrder : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds>> conflictCds{};
  shared_ptr<vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder>> conflictOrder{};

  CreateCloudDriveServiceResponseBodyConflictCdsAndOrder() {}

  explicit CreateCloudDriveServiceResponseBodyConflictCdsAndOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conflictCds) {
      vector<boost::any> temp1;
      for(auto item1:*conflictCds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConflictCds"] = boost::any(temp1);
    }
    if (conflictOrder) {
      vector<boost::any> temp1;
      for(auto item1:*conflictOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConflictOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConflictCds") != m.end() && !m["ConflictCds"].empty()) {
      if (typeid(vector<boost::any>) == m["ConflictCds"].type()) {
        vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConflictCds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conflictCds = make_shared<vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictCds>>(expect1);
      }
    }
    if (m.find("ConflictOrder") != m.end() && !m["ConflictOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["ConflictOrder"].type()) {
        vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConflictOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conflictOrder = make_shared<vector<CreateCloudDriveServiceResponseBodyConflictCdsAndOrderConflictOrder>>(expect1);
      }
    }
  }


  virtual ~CreateCloudDriveServiceResponseBodyConflictCdsAndOrder() = default;
};
class CreateCloudDriveServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> cdsName{};
  shared_ptr<string> cenId{};
  shared_ptr<CreateCloudDriveServiceResponseBodyConflictCdsAndOrder> conflictCdsAndOrder{};
  shared_ptr<string> domainName{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> maxSize{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateCloudDriveServiceResponseBody() {}

  explicit CreateCloudDriveServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (cdsName) {
      res["CdsName"] = boost::any(*cdsName);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (conflictCdsAndOrder) {
      res["ConflictCdsAndOrder"] = conflictCdsAndOrder ? boost::any(conflictCdsAndOrder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("CdsName") != m.end() && !m["CdsName"].empty()) {
      cdsName = make_shared<string>(boost::any_cast<string>(m["CdsName"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("ConflictCdsAndOrder") != m.end() && !m["ConflictCdsAndOrder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConflictCdsAndOrder"].type()) {
        CreateCloudDriveServiceResponseBodyConflictCdsAndOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConflictCdsAndOrder"]));
        conflictCdsAndOrder = make_shared<CreateCloudDriveServiceResponseBodyConflictCdsAndOrder>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<string>(boost::any_cast<string>(m["MaxSize"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCloudDriveServiceResponseBody() = default;
};
class CreateCloudDriveServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudDriveServiceResponseBody> body{};

  CreateCloudDriveServiceResponse() {}

  explicit CreateCloudDriveServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudDriveServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudDriveServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudDriveServiceResponse() = default;
};
class CreateCloudDriveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> userMaxSize{};

  CreateCloudDriveUsersRequest() {}

  explicit CreateCloudDriveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userMaxSize) {
      res["UserMaxSize"] = boost::any(*userMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserMaxSize") != m.end() && !m["UserMaxSize"].empty()) {
      userMaxSize = make_shared<long>(boost::any_cast<long>(m["UserMaxSize"]));
    }
  }


  virtual ~CreateCloudDriveUsersRequest() = default;
};
class CreateCloudDriveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCloudDriveUsersResponseBody() {}

  explicit CreateCloudDriveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCloudDriveUsersResponseBody() = default;
};
class CreateCloudDriveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudDriveUsersResponseBody> body{};

  CreateCloudDriveUsersResponse() {}

  explicit CreateCloudDriveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudDriveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudDriveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudDriveUsersResponse() = default;
};
class CreateConfigGroupRequestConfigTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<long> notificationTime{};
  shared_ptr<string> operationType{};
  shared_ptr<vector<string>> processWhitelist{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};
  shared_ptr<string> triggerType{};

  CreateConfigGroupRequestConfigTimers() {}

  explicit CreateConfigGroupRequestConfigTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (notificationTime) {
      res["NotificationTime"] = boost::any(*notificationTime);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (processWhitelist) {
      res["ProcessWhitelist"] = boost::any(*processWhitelist);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("NotificationTime") != m.end() && !m["NotificationTime"].empty()) {
      notificationTime = make_shared<long>(boost::any_cast<long>(m["NotificationTime"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ProcessWhitelist") != m.end() && !m["ProcessWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~CreateConfigGroupRequestConfigTimers() = default;
};
class CreateConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateConfigGroupRequestConfigTimers>> configTimers{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  CreateConfigGroupRequest() {}

  explicit CreateConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configTimers) {
      vector<boost::any> temp1;
      for(auto item1:*configTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTimers"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigTimers") != m.end() && !m["ConfigTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTimers"].type()) {
        vector<CreateConfigGroupRequestConfigTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConfigGroupRequestConfigTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTimers = make_shared<vector<CreateConfigGroupRequestConfigTimers>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateConfigGroupRequest() = default;
};
class CreateConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateConfigGroupResponseBody() {}

  explicit CreateConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigGroupResponseBody() = default;
};
class CreateConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigGroupResponseBody> body{};

  CreateConfigGroupResponse() {}

  explicit CreateConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigGroupResponse() = default;
};
class CreateDesktopGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDesktopGroupRequestTag() {}

  explicit CreateDesktopGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDesktopGroupRequestTag() = default;
};
class CreateDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allClassifyUsers{};
  shared_ptr<long> allowAutoSetup{};
  shared_ptr<long> allowBufferCount{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> bindAmount{};
  shared_ptr<string> bundleId{};
  shared_ptr<long> buyDesktopsCount{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> classify{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> comments{};
  shared_ptr<long> connectDuration{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> dataDiskPerLevel{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<long> defaultInitDesktopCount{};
  shared_ptr<string> defaultLanguage{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> directoryId{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> exclusiveType{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<long> groupAmount{};
  shared_ptr<long> groupVersion{};
  shared_ptr<string> hostname{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxDesktopsCount{};
  shared_ptr<long> minDesktopsCount{};
  shared_ptr<bool> multiResource{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> ownType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<bool> profileFollowSwitch{};
  shared_ptr<string> promotionId{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resetType{};
  shared_ptr<string> scaleStrategyId{};
  shared_ptr<string> sessionType{};
  shared_ptr<string> snapshotPolicyId{};
  shared_ptr<long> stopDuration{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskPerLevel{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<CreateDesktopGroupRequestTag>> tag{};
  shared_ptr<string> timerGroupId{};
  shared_ptr<string> userOuPath{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};
  shared_ptr<string> vpcId{};

  CreateDesktopGroupRequest() {}

  explicit CreateDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allClassifyUsers) {
      res["AllClassifyUsers"] = boost::any(*allClassifyUsers);
    }
    if (allowAutoSetup) {
      res["AllowAutoSetup"] = boost::any(*allowAutoSetup);
    }
    if (allowBufferCount) {
      res["AllowBufferCount"] = boost::any(*allowBufferCount);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bindAmount) {
      res["BindAmount"] = boost::any(*bindAmount);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (buyDesktopsCount) {
      res["BuyDesktopsCount"] = boost::any(*buyDesktopsCount);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (connectDuration) {
      res["ConnectDuration"] = boost::any(*connectDuration);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskPerLevel) {
      res["DataDiskPerLevel"] = boost::any(*dataDiskPerLevel);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (defaultInitDesktopCount) {
      res["DefaultInitDesktopCount"] = boost::any(*defaultInitDesktopCount);
    }
    if (defaultLanguage) {
      res["DefaultLanguage"] = boost::any(*defaultLanguage);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (exclusiveType) {
      res["ExclusiveType"] = boost::any(*exclusiveType);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (groupAmount) {
      res["GroupAmount"] = boost::any(*groupAmount);
    }
    if (groupVersion) {
      res["GroupVersion"] = boost::any(*groupVersion);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxDesktopsCount) {
      res["MaxDesktopsCount"] = boost::any(*maxDesktopsCount);
    }
    if (minDesktopsCount) {
      res["MinDesktopsCount"] = boost::any(*minDesktopsCount);
    }
    if (multiResource) {
      res["MultiResource"] = boost::any(*multiResource);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (profileFollowSwitch) {
      res["ProfileFollowSwitch"] = boost::any(*profileFollowSwitch);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (scaleStrategyId) {
      res["ScaleStrategyId"] = boost::any(*scaleStrategyId);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    if (snapshotPolicyId) {
      res["SnapshotPolicyId"] = boost::any(*snapshotPolicyId);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskPerLevel) {
      res["SystemDiskPerLevel"] = boost::any(*systemDiskPerLevel);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (timerGroupId) {
      res["TimerGroupId"] = boost::any(*timerGroupId);
    }
    if (userOuPath) {
      res["UserOuPath"] = boost::any(*userOuPath);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllClassifyUsers") != m.end() && !m["AllClassifyUsers"].empty()) {
      allClassifyUsers = make_shared<bool>(boost::any_cast<bool>(m["AllClassifyUsers"]));
    }
    if (m.find("AllowAutoSetup") != m.end() && !m["AllowAutoSetup"].empty()) {
      allowAutoSetup = make_shared<long>(boost::any_cast<long>(m["AllowAutoSetup"]));
    }
    if (m.find("AllowBufferCount") != m.end() && !m["AllowBufferCount"].empty()) {
      allowBufferCount = make_shared<long>(boost::any_cast<long>(m["AllowBufferCount"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BindAmount") != m.end() && !m["BindAmount"].empty()) {
      bindAmount = make_shared<long>(boost::any_cast<long>(m["BindAmount"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BuyDesktopsCount") != m.end() && !m["BuyDesktopsCount"].empty()) {
      buyDesktopsCount = make_shared<long>(boost::any_cast<long>(m["BuyDesktopsCount"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("ConnectDuration") != m.end() && !m["ConnectDuration"].empty()) {
      connectDuration = make_shared<long>(boost::any_cast<long>(m["ConnectDuration"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskPerLevel") != m.end() && !m["DataDiskPerLevel"].empty()) {
      dataDiskPerLevel = make_shared<string>(boost::any_cast<string>(m["DataDiskPerLevel"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DefaultInitDesktopCount") != m.end() && !m["DefaultInitDesktopCount"].empty()) {
      defaultInitDesktopCount = make_shared<long>(boost::any_cast<long>(m["DefaultInitDesktopCount"]));
    }
    if (m.find("DefaultLanguage") != m.end() && !m["DefaultLanguage"].empty()) {
      defaultLanguage = make_shared<string>(boost::any_cast<string>(m["DefaultLanguage"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExclusiveType") != m.end() && !m["ExclusiveType"].empty()) {
      exclusiveType = make_shared<string>(boost::any_cast<string>(m["ExclusiveType"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("GroupAmount") != m.end() && !m["GroupAmount"].empty()) {
      groupAmount = make_shared<long>(boost::any_cast<long>(m["GroupAmount"]));
    }
    if (m.find("GroupVersion") != m.end() && !m["GroupVersion"].empty()) {
      groupVersion = make_shared<long>(boost::any_cast<long>(m["GroupVersion"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxDesktopsCount") != m.end() && !m["MaxDesktopsCount"].empty()) {
      maxDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MaxDesktopsCount"]));
    }
    if (m.find("MinDesktopsCount") != m.end() && !m["MinDesktopsCount"].empty()) {
      minDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MinDesktopsCount"]));
    }
    if (m.find("MultiResource") != m.end() && !m["MultiResource"].empty()) {
      multiResource = make_shared<bool>(boost::any_cast<bool>(m["MultiResource"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("ProfileFollowSwitch") != m.end() && !m["ProfileFollowSwitch"].empty()) {
      profileFollowSwitch = make_shared<bool>(boost::any_cast<bool>(m["ProfileFollowSwitch"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<long>(boost::any_cast<long>(m["ResetType"]));
    }
    if (m.find("ScaleStrategyId") != m.end() && !m["ScaleStrategyId"].empty()) {
      scaleStrategyId = make_shared<string>(boost::any_cast<string>(m["ScaleStrategyId"]));
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
    if (m.find("SnapshotPolicyId") != m.end() && !m["SnapshotPolicyId"].empty()) {
      snapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyId"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskPerLevel") != m.end() && !m["SystemDiskPerLevel"].empty()) {
      systemDiskPerLevel = make_shared<string>(boost::any_cast<string>(m["SystemDiskPerLevel"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDesktopGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDesktopGroupRequestTag>>(expect1);
      }
    }
    if (m.find("TimerGroupId") != m.end() && !m["TimerGroupId"].empty()) {
      timerGroupId = make_shared<string>(boost::any_cast<string>(m["TimerGroupId"]));
    }
    if (m.find("UserOuPath") != m.end() && !m["UserOuPath"].empty()) {
      userOuPath = make_shared<string>(boost::any_cast<string>(m["UserOuPath"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateDesktopGroupRequest() = default;
};
class CreateDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopGroupIds{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<string> requestId{};

  CreateDesktopGroupResponseBody() {}

  explicit CreateDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupIds) {
      res["DesktopGroupIds"] = boost::any(*desktopGroupIds);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupIds") != m.end() && !m["DesktopGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDesktopGroupResponseBody() = default;
};
class CreateDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDesktopGroupResponseBody> body{};

  CreateDesktopGroupResponse() {}

  explicit CreateDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDesktopGroupResponse() = default;
};
class CreateDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> directoryId{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<long> keepDuration{};
  shared_ptr<string> name{};
  shared_ptr<long> oversoldUserCount{};
  shared_ptr<long> oversoldWarn{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<long> stopDuration{};
  shared_ptr<long> systemDiskSize{};

  CreateDesktopOversoldGroupRequest() {}

  explicit CreateDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    if (oversoldWarn) {
      res["OversoldWarn"] = boost::any(*oversoldWarn);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
    if (m.find("OversoldWarn") != m.end() && !m["OversoldWarn"].empty()) {
      oversoldWarn = make_shared<long>(boost::any_cast<long>(m["OversoldWarn"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~CreateDesktopOversoldGroupRequest() = default;
};
class CreateDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> oversoldGroupId{};

  CreateDesktopOversoldGroupResponseBodyData() {}

  explicit CreateDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
  }


  virtual ~CreateDesktopOversoldGroupResponseBodyData() = default;
};
class CreateDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDesktopOversoldGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateDesktopOversoldGroupResponseBody() {}

  explicit CreateDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDesktopOversoldGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDesktopOversoldGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDesktopOversoldGroupResponseBody() = default;
};
class CreateDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDesktopOversoldGroupResponseBody> body{};

  CreateDesktopOversoldGroupResponse() {}

  explicit CreateDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDesktopOversoldGroupResponse() = default;
};
class CreateDesktopsRequestBundleModels : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> bundleId{};
  shared_ptr<string> desktopName{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> hostname{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  CreateDesktopsRequestBundleModels() {}

  explicit CreateDesktopsRequestBundleModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~CreateDesktopsRequestBundleModels() = default;
};
class CreateDesktopsRequestDesktopAttachment : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> dataDiskPerLevel{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> defaultLanguage{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> imageId{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskPerLevel{};
  shared_ptr<long> systemDiskSize{};

  CreateDesktopsRequestDesktopAttachment() {}

  explicit CreateDesktopsRequestDesktopAttachment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskPerLevel) {
      res["DataDiskPerLevel"] = boost::any(*dataDiskPerLevel);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (defaultLanguage) {
      res["DefaultLanguage"] = boost::any(*defaultLanguage);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskPerLevel) {
      res["SystemDiskPerLevel"] = boost::any(*systemDiskPerLevel);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskPerLevel") != m.end() && !m["DataDiskPerLevel"].empty()) {
      dataDiskPerLevel = make_shared<string>(boost::any_cast<string>(m["DataDiskPerLevel"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DefaultLanguage") != m.end() && !m["DefaultLanguage"].empty()) {
      defaultLanguage = make_shared<string>(boost::any_cast<string>(m["DefaultLanguage"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskPerLevel") != m.end() && !m["SystemDiskPerLevel"].empty()) {
      systemDiskPerLevel = make_shared<string>(boost::any_cast<string>(m["SystemDiskPerLevel"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~CreateDesktopsRequestDesktopAttachment() = default;
};
class CreateDesktopsRequestDesktopTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<string> operationType{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};

  CreateDesktopsRequestDesktopTimers() {}

  explicit CreateDesktopsRequestDesktopTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
  }


  virtual ~CreateDesktopsRequestDesktopTimers() = default;
};
class CreateDesktopsRequestMonthDesktopSetting : public Darabonba::Model {
public:
  shared_ptr<long> buyerId{};
  shared_ptr<string> desktopId{};
  shared_ptr<long> useDuration{};

  CreateDesktopsRequestMonthDesktopSetting() {}

  explicit CreateDesktopsRequestMonthDesktopSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyerId) {
      res["BuyerId"] = boost::any(*buyerId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (useDuration) {
      res["UseDuration"] = boost::any(*useDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyerId") != m.end() && !m["BuyerId"].empty()) {
      buyerId = make_shared<long>(boost::any_cast<long>(m["BuyerId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("UseDuration") != m.end() && !m["UseDuration"].empty()) {
      useDuration = make_shared<long>(boost::any_cast<long>(m["UseDuration"]));
    }
  }


  virtual ~CreateDesktopsRequestMonthDesktopSetting() = default;
};
class CreateDesktopsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDesktopsRequestTag() {}

  explicit CreateDesktopsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDesktopsRequestTag() = default;
};
class CreateDesktopsRequestUserCommands : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> contentType{};

  CreateDesktopsRequestUserCommands() {}

  explicit CreateDesktopsRequestUserCommands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
  }


  virtual ~CreateDesktopsRequestUserCommands() = default;
};
class CreateDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> bundleId{};
  shared_ptr<vector<CreateDesktopsRequestBundleModels>> bundleModels{};
  shared_ptr<string> chargeType{};
  shared_ptr<CreateDesktopsRequestDesktopAttachment> desktopAttachment{};
  shared_ptr<string> desktopMemberIp{};
  shared_ptr<string> desktopName{};
  shared_ptr<bool> desktopNameSuffix{};
  shared_ptr<vector<CreateDesktopsRequestDesktopTimers>> desktopTimers{};
  shared_ptr<string> directoryId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostname{};
  shared_ptr<CreateDesktopsRequestMonthDesktopSetting> monthDesktopSetting{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> savingPlanId{};
  shared_ptr<string> snapshotPolicyId{};
  shared_ptr<vector<CreateDesktopsRequestTag>> tag{};
  shared_ptr<string> timerGroupId{};
  shared_ptr<string> userAssignMode{};
  shared_ptr<vector<CreateDesktopsRequestUserCommands>> userCommands{};
  shared_ptr<string> userName{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};
  shared_ptr<string> vpcId{};

  CreateDesktopsRequest() {}

  explicit CreateDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleModels) {
      vector<boost::any> temp1;
      for(auto item1:*bundleModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BundleModels"] = boost::any(temp1);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopAttachment) {
      res["DesktopAttachment"] = desktopAttachment ? boost::any(desktopAttachment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (desktopMemberIp) {
      res["DesktopMemberIp"] = boost::any(*desktopMemberIp);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopNameSuffix) {
      res["DesktopNameSuffix"] = boost::any(*desktopNameSuffix);
    }
    if (desktopTimers) {
      vector<boost::any> temp1;
      for(auto item1:*desktopTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopTimers"] = boost::any(temp1);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (monthDesktopSetting) {
      res["MonthDesktopSetting"] = monthDesktopSetting ? boost::any(monthDesktopSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (savingPlanId) {
      res["SavingPlanId"] = boost::any(*savingPlanId);
    }
    if (snapshotPolicyId) {
      res["SnapshotPolicyId"] = boost::any(*snapshotPolicyId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (timerGroupId) {
      res["TimerGroupId"] = boost::any(*timerGroupId);
    }
    if (userAssignMode) {
      res["UserAssignMode"] = boost::any(*userAssignMode);
    }
    if (userCommands) {
      vector<boost::any> temp1;
      for(auto item1:*userCommands){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserCommands"] = boost::any(temp1);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BundleModels") != m.end() && !m["BundleModels"].empty()) {
      if (typeid(vector<boost::any>) == m["BundleModels"].type()) {
        vector<CreateDesktopsRequestBundleModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BundleModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsRequestBundleModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bundleModels = make_shared<vector<CreateDesktopsRequestBundleModels>>(expect1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopAttachment") != m.end() && !m["DesktopAttachment"].empty()) {
      if (typeid(map<string, boost::any>) == m["DesktopAttachment"].type()) {
        CreateDesktopsRequestDesktopAttachment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DesktopAttachment"]));
        desktopAttachment = make_shared<CreateDesktopsRequestDesktopAttachment>(model1);
      }
    }
    if (m.find("DesktopMemberIp") != m.end() && !m["DesktopMemberIp"].empty()) {
      desktopMemberIp = make_shared<string>(boost::any_cast<string>(m["DesktopMemberIp"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopNameSuffix") != m.end() && !m["DesktopNameSuffix"].empty()) {
      desktopNameSuffix = make_shared<bool>(boost::any_cast<bool>(m["DesktopNameSuffix"]));
    }
    if (m.find("DesktopTimers") != m.end() && !m["DesktopTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopTimers"].type()) {
        vector<CreateDesktopsRequestDesktopTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsRequestDesktopTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopTimers = make_shared<vector<CreateDesktopsRequestDesktopTimers>>(expect1);
      }
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("MonthDesktopSetting") != m.end() && !m["MonthDesktopSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonthDesktopSetting"].type()) {
        CreateDesktopsRequestMonthDesktopSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonthDesktopSetting"]));
        monthDesktopSetting = make_shared<CreateDesktopsRequestMonthDesktopSetting>(model1);
      }
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SavingPlanId") != m.end() && !m["SavingPlanId"].empty()) {
      savingPlanId = make_shared<string>(boost::any_cast<string>(m["SavingPlanId"]));
    }
    if (m.find("SnapshotPolicyId") != m.end() && !m["SnapshotPolicyId"].empty()) {
      snapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDesktopsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDesktopsRequestTag>>(expect1);
      }
    }
    if (m.find("TimerGroupId") != m.end() && !m["TimerGroupId"].empty()) {
      timerGroupId = make_shared<string>(boost::any_cast<string>(m["TimerGroupId"]));
    }
    if (m.find("UserAssignMode") != m.end() && !m["UserAssignMode"].empty()) {
      userAssignMode = make_shared<string>(boost::any_cast<string>(m["UserAssignMode"]));
    }
    if (m.find("UserCommands") != m.end() && !m["UserCommands"].empty()) {
      if (typeid(vector<boost::any>) == m["UserCommands"].type()) {
        vector<CreateDesktopsRequestUserCommands> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserCommands"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsRequestUserCommands model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userCommands = make_shared<vector<CreateDesktopsRequestUserCommands>>(expect1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateDesktopsRequest() = default;
};
class CreateDesktopsShrinkRequestBundleModels : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> bundleId{};
  shared_ptr<string> desktopName{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> hostname{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  CreateDesktopsShrinkRequestBundleModels() {}

  explicit CreateDesktopsShrinkRequestBundleModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequestBundleModels() = default;
};
class CreateDesktopsShrinkRequestDesktopTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<string> operationType{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};

  CreateDesktopsShrinkRequestDesktopTimers() {}

  explicit CreateDesktopsShrinkRequestDesktopTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequestDesktopTimers() = default;
};
class CreateDesktopsShrinkRequestMonthDesktopSetting : public Darabonba::Model {
public:
  shared_ptr<long> buyerId{};
  shared_ptr<string> desktopId{};
  shared_ptr<long> useDuration{};

  CreateDesktopsShrinkRequestMonthDesktopSetting() {}

  explicit CreateDesktopsShrinkRequestMonthDesktopSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyerId) {
      res["BuyerId"] = boost::any(*buyerId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (useDuration) {
      res["UseDuration"] = boost::any(*useDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyerId") != m.end() && !m["BuyerId"].empty()) {
      buyerId = make_shared<long>(boost::any_cast<long>(m["BuyerId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("UseDuration") != m.end() && !m["UseDuration"].empty()) {
      useDuration = make_shared<long>(boost::any_cast<long>(m["UseDuration"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequestMonthDesktopSetting() = default;
};
class CreateDesktopsShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDesktopsShrinkRequestTag() {}

  explicit CreateDesktopsShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequestTag() = default;
};
class CreateDesktopsShrinkRequestUserCommands : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> contentType{};

  CreateDesktopsShrinkRequestUserCommands() {}

  explicit CreateDesktopsShrinkRequestUserCommands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequestUserCommands() = default;
};
class CreateDesktopsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> bundleId{};
  shared_ptr<vector<CreateDesktopsShrinkRequestBundleModels>> bundleModels{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> desktopAttachmentShrink{};
  shared_ptr<string> desktopMemberIp{};
  shared_ptr<string> desktopName{};
  shared_ptr<bool> desktopNameSuffix{};
  shared_ptr<vector<CreateDesktopsShrinkRequestDesktopTimers>> desktopTimers{};
  shared_ptr<string> directoryId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostname{};
  shared_ptr<CreateDesktopsShrinkRequestMonthDesktopSetting> monthDesktopSetting{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> savingPlanId{};
  shared_ptr<string> snapshotPolicyId{};
  shared_ptr<vector<CreateDesktopsShrinkRequestTag>> tag{};
  shared_ptr<string> timerGroupId{};
  shared_ptr<string> userAssignMode{};
  shared_ptr<vector<CreateDesktopsShrinkRequestUserCommands>> userCommands{};
  shared_ptr<string> userName{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};
  shared_ptr<string> vpcId{};

  CreateDesktopsShrinkRequest() {}

  explicit CreateDesktopsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleModels) {
      vector<boost::any> temp1;
      for(auto item1:*bundleModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BundleModels"] = boost::any(temp1);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopAttachmentShrink) {
      res["DesktopAttachment"] = boost::any(*desktopAttachmentShrink);
    }
    if (desktopMemberIp) {
      res["DesktopMemberIp"] = boost::any(*desktopMemberIp);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopNameSuffix) {
      res["DesktopNameSuffix"] = boost::any(*desktopNameSuffix);
    }
    if (desktopTimers) {
      vector<boost::any> temp1;
      for(auto item1:*desktopTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopTimers"] = boost::any(temp1);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (monthDesktopSetting) {
      res["MonthDesktopSetting"] = monthDesktopSetting ? boost::any(monthDesktopSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (savingPlanId) {
      res["SavingPlanId"] = boost::any(*savingPlanId);
    }
    if (snapshotPolicyId) {
      res["SnapshotPolicyId"] = boost::any(*snapshotPolicyId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (timerGroupId) {
      res["TimerGroupId"] = boost::any(*timerGroupId);
    }
    if (userAssignMode) {
      res["UserAssignMode"] = boost::any(*userAssignMode);
    }
    if (userCommands) {
      vector<boost::any> temp1;
      for(auto item1:*userCommands){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserCommands"] = boost::any(temp1);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BundleModels") != m.end() && !m["BundleModels"].empty()) {
      if (typeid(vector<boost::any>) == m["BundleModels"].type()) {
        vector<CreateDesktopsShrinkRequestBundleModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BundleModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsShrinkRequestBundleModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bundleModels = make_shared<vector<CreateDesktopsShrinkRequestBundleModels>>(expect1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopAttachment") != m.end() && !m["DesktopAttachment"].empty()) {
      desktopAttachmentShrink = make_shared<string>(boost::any_cast<string>(m["DesktopAttachment"]));
    }
    if (m.find("DesktopMemberIp") != m.end() && !m["DesktopMemberIp"].empty()) {
      desktopMemberIp = make_shared<string>(boost::any_cast<string>(m["DesktopMemberIp"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopNameSuffix") != m.end() && !m["DesktopNameSuffix"].empty()) {
      desktopNameSuffix = make_shared<bool>(boost::any_cast<bool>(m["DesktopNameSuffix"]));
    }
    if (m.find("DesktopTimers") != m.end() && !m["DesktopTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopTimers"].type()) {
        vector<CreateDesktopsShrinkRequestDesktopTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsShrinkRequestDesktopTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopTimers = make_shared<vector<CreateDesktopsShrinkRequestDesktopTimers>>(expect1);
      }
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("MonthDesktopSetting") != m.end() && !m["MonthDesktopSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonthDesktopSetting"].type()) {
        CreateDesktopsShrinkRequestMonthDesktopSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonthDesktopSetting"]));
        monthDesktopSetting = make_shared<CreateDesktopsShrinkRequestMonthDesktopSetting>(model1);
      }
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SavingPlanId") != m.end() && !m["SavingPlanId"].empty()) {
      savingPlanId = make_shared<string>(boost::any_cast<string>(m["SavingPlanId"]));
    }
    if (m.find("SnapshotPolicyId") != m.end() && !m["SnapshotPolicyId"].empty()) {
      snapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDesktopsShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDesktopsShrinkRequestTag>>(expect1);
      }
    }
    if (m.find("TimerGroupId") != m.end() && !m["TimerGroupId"].empty()) {
      timerGroupId = make_shared<string>(boost::any_cast<string>(m["TimerGroupId"]));
    }
    if (m.find("UserAssignMode") != m.end() && !m["UserAssignMode"].empty()) {
      userAssignMode = make_shared<string>(boost::any_cast<string>(m["UserAssignMode"]));
    }
    if (m.find("UserCommands") != m.end() && !m["UserCommands"].empty()) {
      if (typeid(vector<boost::any>) == m["UserCommands"].type()) {
        vector<CreateDesktopsShrinkRequestUserCommands> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserCommands"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDesktopsShrinkRequestUserCommands model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userCommands = make_shared<vector<CreateDesktopsShrinkRequestUserCommands>>(expect1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateDesktopsShrinkRequest() = default;
};
class CreateDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateDesktopsResponseBody() {}

  explicit CreateDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDesktopsResponseBody() = default;
};
class CreateDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDesktopsResponseBody> body{};

  CreateDesktopsResponse() {}

  explicit CreateDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDesktopsResponse() = default;
};
class CreateDiskEncryptionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  CreateDiskEncryptionServiceRequest() {}

  explicit CreateDiskEncryptionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDiskEncryptionServiceRequest() = default;
};
class CreateDiskEncryptionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDiskEncryptionServiceResponseBody() {}

  explicit CreateDiskEncryptionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDiskEncryptionServiceResponseBody() = default;
};
class CreateDiskEncryptionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiskEncryptionServiceResponseBody> body{};

  CreateDiskEncryptionServiceResponse() {}

  explicit CreateDiskEncryptionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskEncryptionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskEncryptionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskEncryptionServiceResponse() = default;
};
class CreateImageRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoCleanUserdata{};
  shared_ptr<vector<string>> dataSnapshotIds{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> diskType{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageResourceType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<vector<string>> snapshotIds{};

  CreateImageRequest() {}

  explicit CreateImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoCleanUserdata) {
      res["AutoCleanUserdata"] = boost::any(*autoCleanUserdata);
    }
    if (dataSnapshotIds) {
      res["DataSnapshotIds"] = boost::any(*dataSnapshotIds);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageResourceType) {
      res["ImageResourceType"] = boost::any(*imageResourceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotIds) {
      res["SnapshotIds"] = boost::any(*snapshotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoCleanUserdata") != m.end() && !m["AutoCleanUserdata"].empty()) {
      autoCleanUserdata = make_shared<bool>(boost::any_cast<bool>(m["AutoCleanUserdata"]));
    }
    if (m.find("DataSnapshotIds") != m.end() && !m["DataSnapshotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataSnapshotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataSnapshotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataSnapshotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageResourceType") != m.end() && !m["ImageResourceType"].empty()) {
      imageResourceType = make_shared<string>(boost::any_cast<string>(m["ImageResourceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotIds") != m.end() && !m["SnapshotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapshotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapshotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateImageRequest() = default;
};
class CreateImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CreateImageResponseBody() {}

  explicit CreateImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageResponseBody() = default;
};
class CreateImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageResponseBody> body{};

  CreateImageResponse() {}

  explicit CreateImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageResponse() = default;
};
class CreateNASFileSystemRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> name{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageType{};

  CreateNASFileSystemRequest() {}

  explicit CreateNASFileSystemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~CreateNASFileSystemRequest() = default;
};
class CreateNASFileSystemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> requestId{};

  CreateNASFileSystemResponseBody() {}

  explicit CreateNASFileSystemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNASFileSystemResponseBody() = default;
};
class CreateNASFileSystemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNASFileSystemResponseBody> body{};

  CreateNASFileSystemResponse() {}

  explicit CreateNASFileSystemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNASFileSystemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNASFileSystemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNASFileSystemResponse() = default;
};
class CreateNetworkPackageRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> payType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};

  CreateNetworkPackageRequest() {}

  explicit CreateNetworkPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateNetworkPackageRequest() = default;
};
class CreateNetworkPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateNetworkPackageResponseBody() {}

  explicit CreateNetworkPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkPackageResponseBody() = default;
};
class CreateNetworkPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkPackageResponseBody> body{};

  CreateNetworkPackageResponse() {}

  explicit CreateNetworkPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkPackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkPackageResponse() = default;
};
class CreatePolicyGroupRequestAuthorizeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  CreatePolicyGroupRequestAuthorizeAccessPolicyRule() {}

  explicit CreatePolicyGroupRequestAuthorizeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreatePolicyGroupRequestAuthorizeAccessPolicyRule() = default;
};
class CreatePolicyGroupRequestAuthorizeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  CreatePolicyGroupRequestAuthorizeSecurityPolicyRule() {}

  explicit CreatePolicyGroupRequestAuthorizeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePolicyGroupRequestAuthorizeSecurityPolicyRule() = default;
};
class CreatePolicyGroupRequestClientType : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  CreatePolicyGroupRequestClientType() {}

  explicit CreatePolicyGroupRequestClientType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreatePolicyGroupRequestClientType() = default;
};
class CreatePolicyGroupRequestDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  CreatePolicyGroupRequestDeviceRedirects() {}

  explicit CreatePolicyGroupRequestDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~CreatePolicyGroupRequestDeviceRedirects() = default;
};
class CreatePolicyGroupRequestDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  CreatePolicyGroupRequestDeviceRules() {}

  explicit CreatePolicyGroupRequestDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~CreatePolicyGroupRequestDeviceRules() = default;
};
class CreatePolicyGroupRequestDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  CreatePolicyGroupRequestDomainResolveRule() {}

  explicit CreatePolicyGroupRequestDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~CreatePolicyGroupRequestDomainResolveRule() = default;
};
class CreatePolicyGroupRequestUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> deviceClass{};
  shared_ptr<string> deviceSubclass{};
  shared_ptr<string> productId{};
  shared_ptr<long> usbRedirectType{};
  shared_ptr<long> usbRuleType{};
  shared_ptr<string> vendorId{};

  CreatePolicyGroupRequestUsbSupplyRedirectRule() {}

  explicit CreatePolicyGroupRequestUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceClass) {
      res["DeviceClass"] = boost::any(*deviceClass);
    }
    if (deviceSubclass) {
      res["DeviceSubclass"] = boost::any(*deviceSubclass);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceClass") != m.end() && !m["DeviceClass"].empty()) {
      deviceClass = make_shared<string>(boost::any_cast<string>(m["DeviceClass"]));
    }
    if (m.find("DeviceSubclass") != m.end() && !m["DeviceSubclass"].empty()) {
      deviceSubclass = make_shared<string>(boost::any_cast<string>(m["DeviceSubclass"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<long>(boost::any_cast<long>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<long>(boost::any_cast<long>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~CreatePolicyGroupRequestUsbSupplyRedirectRule() = default;
};
class CreatePolicyGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<CreatePolicyGroupRequestAuthorizeAccessPolicyRule>> authorizeAccessPolicyRule{};
  shared_ptr<vector<CreatePolicyGroupRequestAuthorizeSecurityPolicyRule>> authorizeSecurityPolicyRule{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<CreatePolicyGroupRequestClientType>> clientType{};
  shared_ptr<string> clipboard{};
  shared_ptr<vector<CreatePolicyGroupRequestDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<CreatePolicyGroupRequestDeviceRules>> deviceRules{};
  shared_ptr<string> domainList{};
  shared_ptr<vector<CreatePolicyGroupRequestDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5Access{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<string> preemptLogin{};
  shared_ptr<vector<string>> preemptLoginUser{};
  shared_ptr<string> printerRedirection{};
  shared_ptr<string> recordContent{};
  shared_ptr<long> recordContentExpires{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<long> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<CreatePolicyGroupRequestUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<string> watermarkTransparency{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wyAssistant{};

  CreatePolicyGroupRequest() {}

  explicit CreatePolicyGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRule"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientType) {
      vector<boost::any> temp1;
      for(auto item1:*clientType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientType"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5Access) {
      res["Html5Access"] = boost::any(*html5Access);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (preemptLogin) {
      res["PreemptLogin"] = boost::any(*preemptLogin);
    }
    if (preemptLoginUser) {
      res["PreemptLoginUser"] = boost::any(*preemptLoginUser);
    }
    if (printerRedirection) {
      res["PrinterRedirection"] = boost::any(*printerRedirection);
    }
    if (recordContent) {
      res["RecordContent"] = boost::any(*recordContent);
    }
    if (recordContentExpires) {
      res["RecordContentExpires"] = boost::any(*recordContentExpires);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparency) {
      res["WatermarkTransparency"] = boost::any(*watermarkTransparency);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRule") != m.end() && !m["AuthorizeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRule"].type()) {
        vector<CreatePolicyGroupRequestAuthorizeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestAuthorizeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRule = make_shared<vector<CreatePolicyGroupRequestAuthorizeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRule") != m.end() && !m["AuthorizeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRule"].type()) {
        vector<CreatePolicyGroupRequestAuthorizeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestAuthorizeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRule = make_shared<vector<CreatePolicyGroupRequestAuthorizeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientType"].type()) {
        vector<CreatePolicyGroupRequestClientType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestClientType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientType = make_shared<vector<CreatePolicyGroupRequestClientType>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<CreatePolicyGroupRequestDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<CreatePolicyGroupRequestDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<CreatePolicyGroupRequestDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<CreatePolicyGroupRequestDeviceRules>>(expect1);
      }
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<CreatePolicyGroupRequestDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<CreatePolicyGroupRequestDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5Access") != m.end() && !m["Html5Access"].empty()) {
      html5Access = make_shared<string>(boost::any_cast<string>(m["Html5Access"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("PreemptLogin") != m.end() && !m["PreemptLogin"].empty()) {
      preemptLogin = make_shared<string>(boost::any_cast<string>(m["PreemptLogin"]));
    }
    if (m.find("PreemptLoginUser") != m.end() && !m["PreemptLoginUser"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PreemptLoginUser"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreemptLoginUser"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      preemptLoginUser = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrinterRedirection") != m.end() && !m["PrinterRedirection"].empty()) {
      printerRedirection = make_shared<string>(boost::any_cast<string>(m["PrinterRedirection"]));
    }
    if (m.find("RecordContent") != m.end() && !m["RecordContent"].empty()) {
      recordContent = make_shared<string>(boost::any_cast<string>(m["RecordContent"]));
    }
    if (m.find("RecordContentExpires") != m.end() && !m["RecordContentExpires"].empty()) {
      recordContentExpires = make_shared<long>(boost::any_cast<long>(m["RecordContentExpires"]));
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<long>(boost::any_cast<long>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<CreatePolicyGroupRequestUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePolicyGroupRequestUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<CreatePolicyGroupRequestUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparency") != m.end() && !m["WatermarkTransparency"].empty()) {
      watermarkTransparency = make_shared<string>(boost::any_cast<string>(m["WatermarkTransparency"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~CreatePolicyGroupRequest() = default;
};
class CreatePolicyGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> requestId{};

  CreatePolicyGroupResponseBody() {}

  explicit CreatePolicyGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePolicyGroupResponseBody() = default;
};
class CreatePolicyGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePolicyGroupResponseBody> body{};

  CreatePolicyGroupResponse() {}

  explicit CreatePolicyGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePolicyGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePolicyGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePolicyGroupResponse() = default;
};
class CreateRAMDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopAccessType{};
  shared_ptr<string> directoryName{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> enableInternetAccess{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> vSwitchId{};

  CreateRAMDirectoryRequest() {}

  explicit CreateRAMDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (directoryName) {
      res["DirectoryName"] = boost::any(*directoryName);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (enableInternetAccess) {
      res["EnableInternetAccess"] = boost::any(*enableInternetAccess);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("DirectoryName") != m.end() && !m["DirectoryName"].empty()) {
      directoryName = make_shared<string>(boost::any_cast<string>(m["DirectoryName"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("EnableInternetAccess") != m.end() && !m["EnableInternetAccess"].empty()) {
      enableInternetAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAccess"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateRAMDirectoryRequest() = default;
};
class CreateRAMDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> directoryId{};
  shared_ptr<string> requestId{};

  CreateRAMDirectoryResponseBody() {}

  explicit CreateRAMDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRAMDirectoryResponseBody() = default;
};
class CreateRAMDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRAMDirectoryResponseBody> body{};

  CreateRAMDirectoryResponse() {}

  explicit CreateRAMDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRAMDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRAMDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRAMDirectoryResponse() = default;
};
class CreateSimpleOfficeSiteRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<bool> cloudBoxOfficeSite{};
  shared_ptr<string> desktopAccessType{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> enableInternetAccess{};
  shared_ptr<bool> needVerifyZeroDevice{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> vSwitchId{};
  shared_ptr<string> verifyCode{};
  shared_ptr<string> vpcType{};

  CreateSimpleOfficeSiteRequest() {}

  explicit CreateSimpleOfficeSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (cloudBoxOfficeSite) {
      res["CloudBoxOfficeSite"] = boost::any(*cloudBoxOfficeSite);
    }
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (enableInternetAccess) {
      res["EnableInternetAccess"] = boost::any(*enableInternetAccess);
    }
    if (needVerifyZeroDevice) {
      res["NeedVerifyZeroDevice"] = boost::any(*needVerifyZeroDevice);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    if (vpcType) {
      res["VpcType"] = boost::any(*vpcType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CloudBoxOfficeSite") != m.end() && !m["CloudBoxOfficeSite"].empty()) {
      cloudBoxOfficeSite = make_shared<bool>(boost::any_cast<bool>(m["CloudBoxOfficeSite"]));
    }
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("EnableInternetAccess") != m.end() && !m["EnableInternetAccess"].empty()) {
      enableInternetAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAccess"]));
    }
    if (m.find("NeedVerifyZeroDevice") != m.end() && !m["NeedVerifyZeroDevice"].empty()) {
      needVerifyZeroDevice = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyZeroDevice"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
    if (m.find("VpcType") != m.end() && !m["VpcType"].empty()) {
      vpcType = make_shared<string>(boost::any_cast<string>(m["VpcType"]));
    }
  }


  virtual ~CreateSimpleOfficeSiteRequest() = default;
};
class CreateSimpleOfficeSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> requestId{};

  CreateSimpleOfficeSiteResponseBody() {}

  explicit CreateSimpleOfficeSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSimpleOfficeSiteResponseBody() = default;
};
class CreateSimpleOfficeSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSimpleOfficeSiteResponseBody> body{};

  CreateSimpleOfficeSiteResponse() {}

  explicit CreateSimpleOfficeSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimpleOfficeSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimpleOfficeSiteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimpleOfficeSiteResponse() = default;
};
class CreateSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> sourceDiskType{};

  CreateSnapshotRequest() {}

  explicit CreateSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
  }


  virtual ~CreateSnapshotRequest() = default;
};
class CreateSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> snapshotId{};

  CreateSnapshotResponseBody() {}

  explicit CreateSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~CreateSnapshotResponseBody() = default;
};
class CreateSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSnapshotResponseBody> body{};

  CreateSnapshotResponse() {}

  explicit CreateSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnapshotResponse() = default;
};
class DeleteAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> policyId{};
  shared_ptr<string> regionId{};

  DeleteAutoSnapshotPolicyRequest() {}

  explicit DeleteAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAutoSnapshotPolicyRequest() = default;
};
class DeleteAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAutoSnapshotPolicyResponseBody() {}

  explicit DeleteAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAutoSnapshotPolicyResponseBody() = default;
};
class DeleteAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAutoSnapshotPolicyResponseBody> body{};

  DeleteAutoSnapshotPolicyResponse() {}

  explicit DeleteAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAutoSnapshotPolicyResponse() = default;
};
class DeleteBundlesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bundleId{};
  shared_ptr<string> regionId{};

  DeleteBundlesRequest() {}

  explicit DeleteBundlesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BundleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BundleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bundleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBundlesRequest() = default;
};
class DeleteBundlesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBundlesResponseBody() {}

  explicit DeleteBundlesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBundlesResponseBody() = default;
};
class DeleteBundlesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBundlesResponseBody> body{};

  DeleteBundlesResponse() {}

  explicit DeleteBundlesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBundlesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBundlesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBundlesResponse() = default;
};
class DeleteCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};

  DeleteCdsFileRequest() {}

  explicit DeleteCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCdsFileRequest() = default;
};
class DeleteCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCdsFileResponseBody() {}

  explicit DeleteCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCdsFileResponseBody() = default;
};
class DeleteCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCdsFileResponseBody> body{};

  DeleteCdsFileResponse() {}

  explicit DeleteCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCdsFileResponse() = default;
};
class DeleteCenterPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessType{};
  shared_ptr<vector<string>> policyGroupIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  DeleteCenterPolicyRequest() {}

  explicit DeleteCenterPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (policyGroupIds) {
      res["PolicyGroupIds"] = boost::any(*policyGroupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("PolicyGroupIds") != m.end() && !m["PolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DeleteCenterPolicyRequest() = default;
};
class DeleteCenterPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCenterPolicyResponseBody() {}

  explicit DeleteCenterPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCenterPolicyResponseBody() = default;
};
class DeleteCenterPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCenterPolicyResponseBody> body{};

  DeleteCenterPolicyResponse() {}

  explicit DeleteCenterPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCenterPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCenterPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCenterPolicyResponse() = default;
};
class DeleteCloudDriveGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> groupId{};
  shared_ptr<string> regionId{};

  DeleteCloudDriveGroupsRequest() {}

  explicit DeleteCloudDriveGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCloudDriveGroupsRequest() = default;
};
class DeleteCloudDriveGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCloudDriveGroupsResponseBody() {}

  explicit DeleteCloudDriveGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCloudDriveGroupsResponseBody() = default;
};
class DeleteCloudDriveGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudDriveGroupsResponseBody> body{};

  DeleteCloudDriveGroupsResponse() {}

  explicit DeleteCloudDriveGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudDriveGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudDriveGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudDriveGroupsResponse() = default;
};
class DeleteCloudDriveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> regionId{};

  DeleteCloudDriveUsersRequest() {}

  explicit DeleteCloudDriveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCloudDriveUsersRequest() = default;
};
class DeleteCloudDriveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCloudDriveUsersResponseBody() {}

  explicit DeleteCloudDriveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCloudDriveUsersResponseBody() = default;
};
class DeleteCloudDriveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudDriveUsersResponseBody> body{};

  DeleteCloudDriveUsersResponse() {}

  explicit DeleteCloudDriveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudDriveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudDriveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudDriveUsersResponse() = default;
};
class DeleteConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> regionId{};

  DeleteConfigGroupRequest() {}

  explicit DeleteConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteConfigGroupRequest() = default;
};
class DeleteConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteConfigGroupResponseBody() {}

  explicit DeleteConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigGroupResponseBody() = default;
};
class DeleteConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigGroupResponseBody> body{};

  DeleteConfigGroupResponse() {}

  explicit DeleteConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigGroupResponse() = default;
};
class DeleteDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};

  DeleteDesktopGroupRequest() {}

  explicit DeleteDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDesktopGroupRequest() = default;
};
class DeleteDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDesktopGroupResponseBody() {}

  explicit DeleteDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDesktopGroupResponseBody() = default;
};
class DeleteDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDesktopGroupResponseBody> body{};

  DeleteDesktopGroupResponse() {}

  explicit DeleteDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDesktopGroupResponse() = default;
};
class DeleteDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};

  DeleteDesktopsRequest() {}

  explicit DeleteDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDesktopsRequest() = default;
};
class DeleteDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDesktopsResponseBody() {}

  explicit DeleteDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDesktopsResponseBody() = default;
};
class DeleteDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDesktopsResponseBody> body{};

  DeleteDesktopsResponse() {}

  explicit DeleteDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDesktopsResponse() = default;
};
class DeleteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<long> clientType{};
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<long> force{};
  shared_ptr<string> regionId{};

  DeleteDevicesRequest() {}

  explicit DeleteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<long>(boost::any_cast<long>(m["Force"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDevicesRequest() = default;
};
class DeleteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDevicesResponseBody() {}

  explicit DeleteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDevicesResponseBody() = default;
};
class DeleteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDevicesResponseBody> body{};

  DeleteDevicesResponse() {}

  explicit DeleteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDevicesResponse() = default;
};
class DeleteDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> directoryId{};
  shared_ptr<string> regionId{};

  DeleteDirectoriesRequest() {}

  explicit DeleteDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DirectoryId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DirectoryId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      directoryId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDirectoriesRequest() = default;
};
class DeleteDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDirectoriesResponseBody() {}

  explicit DeleteDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDirectoriesResponseBody() = default;
};
class DeleteDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDirectoriesResponseBody> body{};

  DeleteDirectoriesResponse() {}

  explicit DeleteDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDirectoriesResponse() = default;
};
class DeleteEduRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> eduRoomId{};
  shared_ptr<string> regionId{};

  DeleteEduRoomRequest() {}

  explicit DeleteEduRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eduRoomId) {
      res["EduRoomId"] = boost::any(*eduRoomId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EduRoomId") != m.end() && !m["EduRoomId"].empty()) {
      eduRoomId = make_shared<string>(boost::any_cast<string>(m["EduRoomId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEduRoomRequest() = default;
};
class DeleteEduRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEduRoomResponseBody() {}

  explicit DeleteEduRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEduRoomResponseBody() = default;
};
class DeleteEduRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEduRoomResponseBody> body{};

  DeleteEduRoomResponse() {}

  explicit DeleteEduRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEduRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEduRoomResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEduRoomResponse() = default;
};
class DeleteImagesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deleteCascadedBundle{};
  shared_ptr<vector<string>> imageId{};
  shared_ptr<string> regionId{};

  DeleteImagesRequest() {}

  explicit DeleteImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteCascadedBundle) {
      res["DeleteCascadedBundle"] = boost::any(*deleteCascadedBundle);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteCascadedBundle") != m.end() && !m["DeleteCascadedBundle"].empty()) {
      deleteCascadedBundle = make_shared<bool>(boost::any_cast<bool>(m["DeleteCascadedBundle"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteImagesRequest() = default;
};
class DeleteImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImagesResponseBody() {}

  explicit DeleteImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImagesResponseBody() = default;
};
class DeleteImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteImagesResponseBody> body{};

  DeleteImagesResponse() {}

  explicit DeleteImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImagesResponse() = default;
};
class DeleteNASFileSystemsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileSystemId{};
  shared_ptr<string> regionId{};

  DeleteNASFileSystemsRequest() {}

  explicit DeleteNASFileSystemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileSystemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileSystemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileSystemId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteNASFileSystemsRequest() = default;
};
class DeleteNASFileSystemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNASFileSystemsResponseBody() {}

  explicit DeleteNASFileSystemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNASFileSystemsResponseBody() = default;
};
class DeleteNASFileSystemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNASFileSystemsResponseBody> body{};

  DeleteNASFileSystemsResponse() {}

  explicit DeleteNASFileSystemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNASFileSystemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNASFileSystemsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNASFileSystemsResponse() = default;
};
class DeleteNetworkPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkPackageId{};
  shared_ptr<string> regionId{};

  DeleteNetworkPackagesRequest() {}

  explicit DeleteNetworkPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkPackageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkPackageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkPackageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteNetworkPackagesRequest() = default;
};
class DeleteNetworkPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkPackagesResponseBody() {}

  explicit DeleteNetworkPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkPackagesResponseBody() = default;
};
class DeleteNetworkPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkPackagesResponseBody> body{};

  DeleteNetworkPackagesResponse() {}

  explicit DeleteNetworkPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkPackagesResponse() = default;
};
class DeleteOfficeSitesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> officeSiteId{};
  shared_ptr<string> regionId{};

  DeleteOfficeSitesRequest() {}

  explicit DeleteOfficeSitesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OfficeSiteId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OfficeSiteId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      officeSiteId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteOfficeSitesRequest() = default;
};
class DeleteOfficeSitesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOfficeSitesResponseBody() {}

  explicit DeleteOfficeSitesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOfficeSitesResponseBody() = default;
};
class DeleteOfficeSitesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOfficeSitesResponseBody> body{};

  DeleteOfficeSitesResponse() {}

  explicit DeleteOfficeSitesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOfficeSitesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOfficeSitesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOfficeSitesResponse() = default;
};
class DeletePolicyGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> policyGroupId{};
  shared_ptr<string> regionId{};

  DeletePolicyGroupsRequest() {}

  explicit DeletePolicyGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePolicyGroupsRequest() = default;
};
class DeletePolicyGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePolicyGroupsResponseBody() {}

  explicit DeletePolicyGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePolicyGroupsResponseBody() = default;
};
class DeletePolicyGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePolicyGroupsResponseBody> body{};

  DeletePolicyGroupsResponse() {}

  explicit DeletePolicyGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePolicyGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePolicyGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePolicyGroupsResponse() = default;
};
class DeleteSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> snapshotId{};

  DeleteSnapshotRequest() {}

  explicit DeleteSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapshotId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapshotId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshotId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSnapshotRequest() = default;
};
class DeleteSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnapshotResponseBody() {}

  explicit DeleteSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnapshotResponseBody() = default;
};
class DeleteSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotResponseBody> body{};

  DeleteSnapshotResponse() {}

  explicit DeleteSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotResponse() = default;
};
class DeleteVirtualMFADeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumber{};

  DeleteVirtualMFADeviceRequest() {}

  explicit DeleteVirtualMFADeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~DeleteVirtualMFADeviceRequest() = default;
};
class DeleteVirtualMFADeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVirtualMFADeviceResponseBody() {}

  explicit DeleteVirtualMFADeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVirtualMFADeviceResponseBody() = default;
};
class DeleteVirtualMFADeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVirtualMFADeviceResponseBody> body{};

  DeleteVirtualMFADeviceResponse() {}

  explicit DeleteVirtualMFADeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVirtualMFADeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVirtualMFADeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVirtualMFADeviceResponse() = default;
};
class DescribeAclEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};

  DescribeAclEntriesRequest() {}

  explicit DescribeAclEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~DescribeAclEntriesRequest() = default;
};
class DescribeAclEntriesResponseBodyAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> policy{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};

  DescribeAclEntriesResponseBodyAclEntries() {}

  explicit DescribeAclEntriesResponseBodyAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~DescribeAclEntriesResponseBodyAclEntries() = default;
};
class DescribeAclEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAclEntriesResponseBodyAclEntries>> aclEntries{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeAclEntriesResponseBody() {}

  explicit DescribeAclEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntries"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntries"].type()) {
        vector<DescribeAclEntriesResponseBodyAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAclEntriesResponseBodyAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<DescribeAclEntriesResponseBodyAclEntries>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAclEntriesResponseBody() = default;
};
class DescribeAclEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAclEntriesResponseBody> body{};

  DescribeAclEntriesResponse() {}

  explicit DescribeAclEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAclEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAclEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAclEntriesResponse() = default;
};
class DescribeAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> regionId{};

  DescribeAutoSnapshotPolicyRequest() {}

  explicit DescribeAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAutoSnapshotPolicyRequest() = default;
};
class DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> cronExpression{};
  shared_ptr<long> desktopNum{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> retentionDays{};
  shared_ptr<string> status{};
  shared_ptr<string> timePoints{};

  DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies() {}

  explicit DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (desktopNum) {
      res["DesktopNum"] = boost::any(*desktopNum);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timePoints) {
      res["TimePoints"] = boost::any(*timePoints);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("DesktopNum") != m.end() && !m["DesktopNum"].empty()) {
      desktopNum = make_shared<long>(boost::any_cast<long>(m["DesktopNum"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<string>(boost::any_cast<string>(m["RetentionDays"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimePoints") != m.end() && !m["TimePoints"].empty()) {
      timePoints = make_shared<string>(boost::any_cast<string>(m["TimePoints"]));
    }
  }


  virtual ~DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies() = default;
};
class DescribeAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies>> autoSnapshotPolicies{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeAutoSnapshotPolicyResponseBody() {}

  explicit DescribeAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*autoSnapshotPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoSnapshotPolicies"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicies") != m.end() && !m["AutoSnapshotPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoSnapshotPolicies"].type()) {
        vector<DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoSnapshotPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoSnapshotPolicies = make_shared<vector<DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAutoSnapshotPolicyResponseBody() = default;
};
class DescribeAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoSnapshotPolicyResponseBody> body{};

  DescribeAutoSnapshotPolicyResponse() {}

  explicit DescribeAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoSnapshotPolicyResponse() = default;
};
class DescribeBundlesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bundleId{};
  shared_ptr<string> bundleType{};
  shared_ptr<bool> checkStock{};
  shared_ptr<long> cpuCount{};
  shared_ptr<string> desktopTypeFamily{};
  shared_ptr<string> fotaChannel{};
  shared_ptr<bool> fromDesktopGroup{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuDriverType{};
  shared_ptr<vector<string>> imageId{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> osType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scope{};
  shared_ptr<bool> selectedBundle{};
  shared_ptr<string> sessionType{};
  shared_ptr<bool> supportMultiSession{};
  shared_ptr<bool> volumeEncryptionEnabled{};

  DescribeBundlesRequest() {}

  explicit DescribeBundlesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleType) {
      res["BundleType"] = boost::any(*bundleType);
    }
    if (checkStock) {
      res["CheckStock"] = boost::any(*checkStock);
    }
    if (cpuCount) {
      res["CpuCount"] = boost::any(*cpuCount);
    }
    if (desktopTypeFamily) {
      res["DesktopTypeFamily"] = boost::any(*desktopTypeFamily);
    }
    if (fotaChannel) {
      res["FotaChannel"] = boost::any(*fotaChannel);
    }
    if (fromDesktopGroup) {
      res["FromDesktopGroup"] = boost::any(*fromDesktopGroup);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuDriverType) {
      res["GpuDriverType"] = boost::any(*gpuDriverType);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (selectedBundle) {
      res["SelectedBundle"] = boost::any(*selectedBundle);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    if (supportMultiSession) {
      res["SupportMultiSession"] = boost::any(*supportMultiSession);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BundleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BundleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bundleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BundleType") != m.end() && !m["BundleType"].empty()) {
      bundleType = make_shared<string>(boost::any_cast<string>(m["BundleType"]));
    }
    if (m.find("CheckStock") != m.end() && !m["CheckStock"].empty()) {
      checkStock = make_shared<bool>(boost::any_cast<bool>(m["CheckStock"]));
    }
    if (m.find("CpuCount") != m.end() && !m["CpuCount"].empty()) {
      cpuCount = make_shared<long>(boost::any_cast<long>(m["CpuCount"]));
    }
    if (m.find("DesktopTypeFamily") != m.end() && !m["DesktopTypeFamily"].empty()) {
      desktopTypeFamily = make_shared<string>(boost::any_cast<string>(m["DesktopTypeFamily"]));
    }
    if (m.find("FotaChannel") != m.end() && !m["FotaChannel"].empty()) {
      fotaChannel = make_shared<string>(boost::any_cast<string>(m["FotaChannel"]));
    }
    if (m.find("FromDesktopGroup") != m.end() && !m["FromDesktopGroup"].empty()) {
      fromDesktopGroup = make_shared<bool>(boost::any_cast<bool>(m["FromDesktopGroup"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuDriverType") != m.end() && !m["GpuDriverType"].empty()) {
      gpuDriverType = make_shared<string>(boost::any_cast<string>(m["GpuDriverType"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SelectedBundle") != m.end() && !m["SelectedBundle"].empty()) {
      selectedBundle = make_shared<bool>(boost::any_cast<bool>(m["SelectedBundle"]));
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
    if (m.find("SupportMultiSession") != m.end() && !m["SupportMultiSession"].empty()) {
      supportMultiSession = make_shared<bool>(boost::any_cast<bool>(m["SupportMultiSession"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
  }


  virtual ~DescribeBundlesRequest() = default;
};
class DescribeBundlesResponseBodyBundlesDesktopTypeAttribute : public Darabonba::Model {
public:
  shared_ptr<long> cpuCount{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<long> memorySize{};

  DescribeBundlesResponseBodyBundlesDesktopTypeAttribute() {}

  explicit DescribeBundlesResponseBodyBundlesDesktopTypeAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuCount) {
      res["CpuCount"] = boost::any(*cpuCount);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuCount") != m.end() && !m["CpuCount"].empty()) {
      cpuCount = make_shared<long>(boost::any_cast<long>(m["CpuCount"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
  }


  virtual ~DescribeBundlesResponseBodyBundlesDesktopTypeAttribute() = default;
};
class DescribeBundlesResponseBodyBundlesDisks : public Darabonba::Model {
public:
  shared_ptr<string> diskPerformanceLevel{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> diskType{};

  DescribeBundlesResponseBodyBundlesDisks() {}

  explicit DescribeBundlesResponseBodyBundlesDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskPerformanceLevel) {
      res["DiskPerformanceLevel"] = boost::any(*diskPerformanceLevel);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskPerformanceLevel") != m.end() && !m["DiskPerformanceLevel"].empty()) {
      diskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["DiskPerformanceLevel"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
  }


  virtual ~DescribeBundlesResponseBodyBundlesDisks() = default;
};
class DescribeBundlesResponseBodyBundles : public Darabonba::Model {
public:
  shared_ptr<string> bundleId{};
  shared_ptr<string> bundleName{};
  shared_ptr<string> bundleType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopType{};
  shared_ptr<DescribeBundlesResponseBodyBundlesDesktopTypeAttribute> desktopTypeAttribute{};
  shared_ptr<string> desktopTypeFamily{};
  shared_ptr<vector<DescribeBundlesResponseBodyBundlesDisks>> disks{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageStatus{};
  shared_ptr<string> language{};
  shared_ptr<string> osType{};
  shared_ptr<string> platform{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> sessionType{};
  shared_ptr<string> stockState{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  DescribeBundlesResponseBodyBundles() {}

  explicit DescribeBundlesResponseBodyBundles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleName) {
      res["BundleName"] = boost::any(*bundleName);
    }
    if (bundleType) {
      res["BundleType"] = boost::any(*bundleType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (desktopTypeAttribute) {
      res["DesktopTypeAttribute"] = desktopTypeAttribute ? boost::any(desktopTypeAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (desktopTypeFamily) {
      res["DesktopTypeFamily"] = boost::any(*desktopTypeFamily);
    }
    if (disks) {
      vector<boost::any> temp1;
      for(auto item1:*disks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disks"] = boost::any(temp1);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageStatus) {
      res["ImageStatus"] = boost::any(*imageStatus);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    if (stockState) {
      res["StockState"] = boost::any(*stockState);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BundleName") != m.end() && !m["BundleName"].empty()) {
      bundleName = make_shared<string>(boost::any_cast<string>(m["BundleName"]));
    }
    if (m.find("BundleType") != m.end() && !m["BundleType"].empty()) {
      bundleType = make_shared<string>(boost::any_cast<string>(m["BundleType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DesktopTypeAttribute") != m.end() && !m["DesktopTypeAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["DesktopTypeAttribute"].type()) {
        DescribeBundlesResponseBodyBundlesDesktopTypeAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DesktopTypeAttribute"]));
        desktopTypeAttribute = make_shared<DescribeBundlesResponseBodyBundlesDesktopTypeAttribute>(model1);
      }
    }
    if (m.find("DesktopTypeFamily") != m.end() && !m["DesktopTypeFamily"].empty()) {
      desktopTypeFamily = make_shared<string>(boost::any_cast<string>(m["DesktopTypeFamily"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(vector<boost::any>) == m["Disks"].type()) {
        vector<DescribeBundlesResponseBodyBundlesDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBundlesResponseBodyBundlesDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disks = make_shared<vector<DescribeBundlesResponseBodyBundlesDisks>>(expect1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageStatus") != m.end() && !m["ImageStatus"].empty()) {
      imageStatus = make_shared<string>(boost::any_cast<string>(m["ImageStatus"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
    if (m.find("StockState") != m.end() && !m["StockState"].empty()) {
      stockState = make_shared<string>(boost::any_cast<string>(m["StockState"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~DescribeBundlesResponseBodyBundles() = default;
};
class DescribeBundlesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBundlesResponseBodyBundles>> bundles{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeBundlesResponseBody() {}

  explicit DescribeBundlesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundles) {
      vector<boost::any> temp1;
      for(auto item1:*bundles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bundles"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bundles") != m.end() && !m["Bundles"].empty()) {
      if (typeid(vector<boost::any>) == m["Bundles"].type()) {
        vector<DescribeBundlesResponseBodyBundles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bundles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBundlesResponseBodyBundles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bundles = make_shared<vector<DescribeBundlesResponseBodyBundles>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBundlesResponseBody() = default;
};
class DescribeBundlesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBundlesResponseBody> body{};

  DescribeBundlesResponse() {}

  explicit DescribeBundlesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBundlesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBundlesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBundlesResponse() = default;
};
class DescribeCdsFileShareLinksRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> creators{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> shareId{};
  shared_ptr<string> shareName{};
  shared_ptr<string> status{};

  DescribeCdsFileShareLinksRequest() {}

  explicit DescribeCdsFileShareLinksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (creators) {
      res["Creators"] = boost::any(*creators);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    if (shareName) {
      res["ShareName"] = boost::any(*shareName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("Creators") != m.end() && !m["Creators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Creators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Creators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      creators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
    if (m.find("ShareName") != m.end() && !m["ShareName"].empty()) {
      shareName = make_shared<string>(boost::any_cast<string>(m["ShareName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCdsFileShareLinksRequest() = default;
};
class DescribeCdsFileShareLinksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CdsFileShareLinkModel>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeCdsFileShareLinksResponseBody() {}

  explicit DescribeCdsFileShareLinksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<CdsFileShareLinkModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CdsFileShareLinkModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<CdsFileShareLinkModel>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCdsFileShareLinksResponseBody() = default;
};
class DescribeCdsFileShareLinksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdsFileShareLinksResponseBody> body{};

  DescribeCdsFileShareLinksResponse() {}

  explicit DescribeCdsFileShareLinksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdsFileShareLinksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdsFileShareLinksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdsFileShareLinksResponse() = default;
};
class DescribeCensRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeCensRequest() {}

  explicit DescribeCensRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCensRequest() = default;
};
class DescribeCensResponseBodyCensPackageIds : public Darabonba::Model {
public:
  shared_ptr<string> packageId{};

  DescribeCensResponseBodyCensPackageIds() {}

  explicit DescribeCensResponseBodyCensPackageIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<string>(boost::any_cast<string>(m["PackageId"]));
    }
  }


  virtual ~DescribeCensResponseBodyCensPackageIds() = default;
};
class DescribeCensResponseBodyCensTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCensResponseBodyCensTags() {}

  explicit DescribeCensResponseBodyCensTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCensResponseBodyCensTags() = default;
};
class DescribeCensResponseBodyCens : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ipv6Level{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeCensResponseBodyCensPackageIds>> packageIds{};
  shared_ptr<string> protectionLevel{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeCensResponseBodyCensTags>> tags{};

  DescribeCensResponseBodyCens() {}

  explicit DescribeCensResponseBodyCens(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipv6Level) {
      res["Ipv6Level"] = boost::any(*ipv6Level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (packageIds) {
      vector<boost::any> temp1;
      for(auto item1:*packageIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageIds"] = boost::any(temp1);
    }
    if (protectionLevel) {
      res["ProtectionLevel"] = boost::any(*protectionLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ipv6Level") != m.end() && !m["Ipv6Level"].empty()) {
      ipv6Level = make_shared<string>(boost::any_cast<string>(m["Ipv6Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PackageIds") != m.end() && !m["PackageIds"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageIds"].type()) {
        vector<DescribeCensResponseBodyCensPackageIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCensResponseBodyCensPackageIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageIds = make_shared<vector<DescribeCensResponseBodyCensPackageIds>>(expect1);
      }
    }
    if (m.find("ProtectionLevel") != m.end() && !m["ProtectionLevel"].empty()) {
      protectionLevel = make_shared<string>(boost::any_cast<string>(m["ProtectionLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeCensResponseBodyCensTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCensResponseBodyCensTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeCensResponseBodyCensTags>>(expect1);
      }
    }
  }


  virtual ~DescribeCensResponseBodyCens() = default;
};
class DescribeCensResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCensResponseBodyCens>> cens{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCensResponseBody() {}

  explicit DescribeCensResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cens) {
      vector<boost::any> temp1;
      for(auto item1:*cens){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cens"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cens") != m.end() && !m["Cens"].empty()) {
      if (typeid(vector<boost::any>) == m["Cens"].type()) {
        vector<DescribeCensResponseBodyCens> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cens"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCensResponseBodyCens model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cens = make_shared<vector<DescribeCensResponseBodyCens>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCensResponseBody() = default;
};
class DescribeCensResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCensResponseBody> body{};

  DescribeCensResponse() {}

  explicit DescribeCensResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCensResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCensResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCensResponse() = default;
};
class DescribeCenterPolicyListRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> policyGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};

  DescribeCenterPolicyListRequest() {}

  explicit DescribeCenterPolicyListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeCenterPolicyListRequest() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};
  shared_ptr<string> ruleType{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> productId{};
  shared_ptr<long> usbRedirectType{};
  shared_ptr<long> usbRuleType{};
  shared_ptr<string> vendorId{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<long>(boost::any_cast<long>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<long>(boost::any_cast<long>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule() = default;
};
class DescribeCenterPolicyListResponseBodyDescribePolicyGroups : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules>> authorizeAccessPolicyRules{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules>> authorizeSecurityPolicyRules{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes>> clientTypes{};
  shared_ptr<string> clipboard{};
  shared_ptr<string> colorEnhancement{};
  shared_ptr<long> cpuDownGradeDuration{};
  shared_ptr<vector<string>> cpuProcessors{};
  shared_ptr<string> cpuProtectedMode{};
  shared_ptr<long> cpuRateLimit{};
  shared_ptr<long> cpuSampleDuration{};
  shared_ptr<long> cpuSingleRateLimit{};
  shared_ptr<long> desktopCount{};
  shared_ptr<long> desktopGroupCount{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules>> deviceRules{};
  shared_ptr<string> disconnectKeepSession{};
  shared_ptr<long> disconnectKeepSessionTime{};
  shared_ptr<string> displayMode{};
  shared_ptr<string> domainRegisterValue{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5Access{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> internetPrinter{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<long> memoryDownGradeDuration{};
  shared_ptr<vector<string>> memoryProcessors{};
  shared_ptr<string> memoryProtectedMode{};
  shared_ptr<long> memoryRateLimit{};
  shared_ptr<long> memorySampleDuration{};
  shared_ptr<long> memorySingleRateLimit{};
  shared_ptr<string> mobileRestart{};
  shared_ptr<string> mobileShutdown{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule>> netRedirectRule{};
  shared_ptr<string> noOperationDisconnect{};
  shared_ptr<long> noOperationDisconnectTime{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> policyGroupType{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> printerRedirection{};
  shared_ptr<string> qualityEnhancement{};
  shared_ptr<string> recordContent{};
  shared_ptr<long> recordContentExpires{};
  shared_ptr<long> recordEventDuration{};
  shared_ptr<vector<string>> recordEventFilePaths{};
  shared_ptr<vector<string>> recordEventRegisters{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<long> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<long> resolutionHeight{};
  shared_ptr<string> resolutionModel{};
  shared_ptr<long> resolutionWidth{};
  shared_ptr<long> resourceGroupCount{};
  shared_ptr<string> safeMenu{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<string> smoothEnhancement{};
  shared_ptr<string> statusMonitor{};
  shared_ptr<string> streamingMode{};
  shared_ptr<long> targetFps{};
  shared_ptr<string> taskbar{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<long> videoEncAvgKbps{};
  shared_ptr<long> videoEncMaxQP{};
  shared_ptr<long> videoEncMinQP{};
  shared_ptr<long> videoEncPeakKbps{};
  shared_ptr<string> videoEncPolicy{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<string> watermarkCustomText{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wyAssistant{};

  DescribeCenterPolicyListResponseBodyDescribePolicyGroups() {}

  explicit DescribeCenterPolicyListResponseBodyDescribePolicyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRules) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRules"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRules) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRules"] = boost::any(temp1);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientTypes) {
      vector<boost::any> temp1;
      for(auto item1:*clientTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientTypes"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (colorEnhancement) {
      res["ColorEnhancement"] = boost::any(*colorEnhancement);
    }
    if (cpuDownGradeDuration) {
      res["CpuDownGradeDuration"] = boost::any(*cpuDownGradeDuration);
    }
    if (cpuProcessors) {
      res["CpuProcessors"] = boost::any(*cpuProcessors);
    }
    if (cpuProtectedMode) {
      res["CpuProtectedMode"] = boost::any(*cpuProtectedMode);
    }
    if (cpuRateLimit) {
      res["CpuRateLimit"] = boost::any(*cpuRateLimit);
    }
    if (cpuSampleDuration) {
      res["CpuSampleDuration"] = boost::any(*cpuSampleDuration);
    }
    if (cpuSingleRateLimit) {
      res["CpuSingleRateLimit"] = boost::any(*cpuSingleRateLimit);
    }
    if (desktopCount) {
      res["DesktopCount"] = boost::any(*desktopCount);
    }
    if (desktopGroupCount) {
      res["DesktopGroupCount"] = boost::any(*desktopGroupCount);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (disconnectKeepSession) {
      res["DisconnectKeepSession"] = boost::any(*disconnectKeepSession);
    }
    if (disconnectKeepSessionTime) {
      res["DisconnectKeepSessionTime"] = boost::any(*disconnectKeepSessionTime);
    }
    if (displayMode) {
      res["DisplayMode"] = boost::any(*displayMode);
    }
    if (domainRegisterValue) {
      res["DomainRegisterValue"] = boost::any(*domainRegisterValue);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5Access) {
      res["Html5Access"] = boost::any(*html5Access);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (internetPrinter) {
      res["InternetPrinter"] = boost::any(*internetPrinter);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (memoryDownGradeDuration) {
      res["MemoryDownGradeDuration"] = boost::any(*memoryDownGradeDuration);
    }
    if (memoryProcessors) {
      res["MemoryProcessors"] = boost::any(*memoryProcessors);
    }
    if (memoryProtectedMode) {
      res["MemoryProtectedMode"] = boost::any(*memoryProtectedMode);
    }
    if (memoryRateLimit) {
      res["MemoryRateLimit"] = boost::any(*memoryRateLimit);
    }
    if (memorySampleDuration) {
      res["MemorySampleDuration"] = boost::any(*memorySampleDuration);
    }
    if (memorySingleRateLimit) {
      res["MemorySingleRateLimit"] = boost::any(*memorySingleRateLimit);
    }
    if (mobileRestart) {
      res["MobileRestart"] = boost::any(*mobileRestart);
    }
    if (mobileShutdown) {
      res["MobileShutdown"] = boost::any(*mobileShutdown);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (netRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*netRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetRedirectRule"] = boost::any(temp1);
    }
    if (noOperationDisconnect) {
      res["NoOperationDisconnect"] = boost::any(*noOperationDisconnect);
    }
    if (noOperationDisconnectTime) {
      res["NoOperationDisconnectTime"] = boost::any(*noOperationDisconnectTime);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupType) {
      res["PolicyGroupType"] = boost::any(*policyGroupType);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (printerRedirection) {
      res["PrinterRedirection"] = boost::any(*printerRedirection);
    }
    if (qualityEnhancement) {
      res["QualityEnhancement"] = boost::any(*qualityEnhancement);
    }
    if (recordContent) {
      res["RecordContent"] = boost::any(*recordContent);
    }
    if (recordContentExpires) {
      res["RecordContentExpires"] = boost::any(*recordContentExpires);
    }
    if (recordEventDuration) {
      res["RecordEventDuration"] = boost::any(*recordEventDuration);
    }
    if (recordEventFilePaths) {
      res["RecordEventFilePaths"] = boost::any(*recordEventFilePaths);
    }
    if (recordEventRegisters) {
      res["RecordEventRegisters"] = boost::any(*recordEventRegisters);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (resolutionHeight) {
      res["ResolutionHeight"] = boost::any(*resolutionHeight);
    }
    if (resolutionModel) {
      res["ResolutionModel"] = boost::any(*resolutionModel);
    }
    if (resolutionWidth) {
      res["ResolutionWidth"] = boost::any(*resolutionWidth);
    }
    if (resourceGroupCount) {
      res["ResourceGroupCount"] = boost::any(*resourceGroupCount);
    }
    if (safeMenu) {
      res["SafeMenu"] = boost::any(*safeMenu);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (smoothEnhancement) {
      res["SmoothEnhancement"] = boost::any(*smoothEnhancement);
    }
    if (statusMonitor) {
      res["StatusMonitor"] = boost::any(*statusMonitor);
    }
    if (streamingMode) {
      res["StreamingMode"] = boost::any(*streamingMode);
    }
    if (targetFps) {
      res["TargetFps"] = boost::any(*targetFps);
    }
    if (taskbar) {
      res["Taskbar"] = boost::any(*taskbar);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoEncAvgKbps) {
      res["VideoEncAvgKbps"] = boost::any(*videoEncAvgKbps);
    }
    if (videoEncMaxQP) {
      res["VideoEncMaxQP"] = boost::any(*videoEncMaxQP);
    }
    if (videoEncMinQP) {
      res["VideoEncMinQP"] = boost::any(*videoEncMinQP);
    }
    if (videoEncPeakKbps) {
      res["VideoEncPeakKbps"] = boost::any(*videoEncPeakKbps);
    }
    if (videoEncPolicy) {
      res["VideoEncPolicy"] = boost::any(*videoEncPolicy);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkCustomText) {
      res["WatermarkCustomText"] = boost::any(*watermarkCustomText);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRules") != m.end() && !m["AuthorizeAccessPolicyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRules"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRules = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRules") != m.end() && !m["AuthorizeSecurityPolicyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRules"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRules = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules>>(expect1);
      }
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientTypes") != m.end() && !m["ClientTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientTypes"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientTypes = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsClientTypes>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("ColorEnhancement") != m.end() && !m["ColorEnhancement"].empty()) {
      colorEnhancement = make_shared<string>(boost::any_cast<string>(m["ColorEnhancement"]));
    }
    if (m.find("CpuDownGradeDuration") != m.end() && !m["CpuDownGradeDuration"].empty()) {
      cpuDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["CpuDownGradeDuration"]));
    }
    if (m.find("CpuProcessors") != m.end() && !m["CpuProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CpuProtectedMode") != m.end() && !m["CpuProtectedMode"].empty()) {
      cpuProtectedMode = make_shared<string>(boost::any_cast<string>(m["CpuProtectedMode"]));
    }
    if (m.find("CpuRateLimit") != m.end() && !m["CpuRateLimit"].empty()) {
      cpuRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuRateLimit"]));
    }
    if (m.find("CpuSampleDuration") != m.end() && !m["CpuSampleDuration"].empty()) {
      cpuSampleDuration = make_shared<long>(boost::any_cast<long>(m["CpuSampleDuration"]));
    }
    if (m.find("CpuSingleRateLimit") != m.end() && !m["CpuSingleRateLimit"].empty()) {
      cpuSingleRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuSingleRateLimit"]));
    }
    if (m.find("DesktopCount") != m.end() && !m["DesktopCount"].empty()) {
      desktopCount = make_shared<long>(boost::any_cast<long>(m["DesktopCount"]));
    }
    if (m.find("DesktopGroupCount") != m.end() && !m["DesktopGroupCount"].empty()) {
      desktopGroupCount = make_shared<long>(boost::any_cast<long>(m["DesktopGroupCount"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDeviceRules>>(expect1);
      }
    }
    if (m.find("DisconnectKeepSession") != m.end() && !m["DisconnectKeepSession"].empty()) {
      disconnectKeepSession = make_shared<string>(boost::any_cast<string>(m["DisconnectKeepSession"]));
    }
    if (m.find("DisconnectKeepSessionTime") != m.end() && !m["DisconnectKeepSessionTime"].empty()) {
      disconnectKeepSessionTime = make_shared<long>(boost::any_cast<long>(m["DisconnectKeepSessionTime"]));
    }
    if (m.find("DisplayMode") != m.end() && !m["DisplayMode"].empty()) {
      displayMode = make_shared<string>(boost::any_cast<string>(m["DisplayMode"]));
    }
    if (m.find("DomainRegisterValue") != m.end() && !m["DomainRegisterValue"].empty()) {
      domainRegisterValue = make_shared<string>(boost::any_cast<string>(m["DomainRegisterValue"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5Access") != m.end() && !m["Html5Access"].empty()) {
      html5Access = make_shared<string>(boost::any_cast<string>(m["Html5Access"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("InternetPrinter") != m.end() && !m["InternetPrinter"].empty()) {
      internetPrinter = make_shared<string>(boost::any_cast<string>(m["InternetPrinter"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("MemoryDownGradeDuration") != m.end() && !m["MemoryDownGradeDuration"].empty()) {
      memoryDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["MemoryDownGradeDuration"]));
    }
    if (m.find("MemoryProcessors") != m.end() && !m["MemoryProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemoryProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemoryProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memoryProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemoryProtectedMode") != m.end() && !m["MemoryProtectedMode"].empty()) {
      memoryProtectedMode = make_shared<string>(boost::any_cast<string>(m["MemoryProtectedMode"]));
    }
    if (m.find("MemoryRateLimit") != m.end() && !m["MemoryRateLimit"].empty()) {
      memoryRateLimit = make_shared<long>(boost::any_cast<long>(m["MemoryRateLimit"]));
    }
    if (m.find("MemorySampleDuration") != m.end() && !m["MemorySampleDuration"].empty()) {
      memorySampleDuration = make_shared<long>(boost::any_cast<long>(m["MemorySampleDuration"]));
    }
    if (m.find("MemorySingleRateLimit") != m.end() && !m["MemorySingleRateLimit"].empty()) {
      memorySingleRateLimit = make_shared<long>(boost::any_cast<long>(m["MemorySingleRateLimit"]));
    }
    if (m.find("MobileRestart") != m.end() && !m["MobileRestart"].empty()) {
      mobileRestart = make_shared<string>(boost::any_cast<string>(m["MobileRestart"]));
    }
    if (m.find("MobileShutdown") != m.end() && !m["MobileShutdown"].empty()) {
      mobileShutdown = make_shared<string>(boost::any_cast<string>(m["MobileShutdown"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("NetRedirectRule") != m.end() && !m["NetRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["NetRedirectRule"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        netRedirectRule = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsNetRedirectRule>>(expect1);
      }
    }
    if (m.find("NoOperationDisconnect") != m.end() && !m["NoOperationDisconnect"].empty()) {
      noOperationDisconnect = make_shared<string>(boost::any_cast<string>(m["NoOperationDisconnect"]));
    }
    if (m.find("NoOperationDisconnectTime") != m.end() && !m["NoOperationDisconnectTime"].empty()) {
      noOperationDisconnectTime = make_shared<long>(boost::any_cast<long>(m["NoOperationDisconnectTime"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupType") != m.end() && !m["PolicyGroupType"].empty()) {
      policyGroupType = make_shared<string>(boost::any_cast<string>(m["PolicyGroupType"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("PrinterRedirection") != m.end() && !m["PrinterRedirection"].empty()) {
      printerRedirection = make_shared<string>(boost::any_cast<string>(m["PrinterRedirection"]));
    }
    if (m.find("QualityEnhancement") != m.end() && !m["QualityEnhancement"].empty()) {
      qualityEnhancement = make_shared<string>(boost::any_cast<string>(m["QualityEnhancement"]));
    }
    if (m.find("RecordContent") != m.end() && !m["RecordContent"].empty()) {
      recordContent = make_shared<string>(boost::any_cast<string>(m["RecordContent"]));
    }
    if (m.find("RecordContentExpires") != m.end() && !m["RecordContentExpires"].empty()) {
      recordContentExpires = make_shared<long>(boost::any_cast<long>(m["RecordContentExpires"]));
    }
    if (m.find("RecordEventDuration") != m.end() && !m["RecordEventDuration"].empty()) {
      recordEventDuration = make_shared<long>(boost::any_cast<long>(m["RecordEventDuration"]));
    }
    if (m.find("RecordEventFilePaths") != m.end() && !m["RecordEventFilePaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventFilePaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventFilePaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventFilePaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEventRegisters") != m.end() && !m["RecordEventRegisters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventRegisters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventRegisters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventRegisters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<long>(boost::any_cast<long>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("ResolutionHeight") != m.end() && !m["ResolutionHeight"].empty()) {
      resolutionHeight = make_shared<long>(boost::any_cast<long>(m["ResolutionHeight"]));
    }
    if (m.find("ResolutionModel") != m.end() && !m["ResolutionModel"].empty()) {
      resolutionModel = make_shared<string>(boost::any_cast<string>(m["ResolutionModel"]));
    }
    if (m.find("ResolutionWidth") != m.end() && !m["ResolutionWidth"].empty()) {
      resolutionWidth = make_shared<long>(boost::any_cast<long>(m["ResolutionWidth"]));
    }
    if (m.find("ResourceGroupCount") != m.end() && !m["ResourceGroupCount"].empty()) {
      resourceGroupCount = make_shared<long>(boost::any_cast<long>(m["ResourceGroupCount"]));
    }
    if (m.find("SafeMenu") != m.end() && !m["SafeMenu"].empty()) {
      safeMenu = make_shared<string>(boost::any_cast<string>(m["SafeMenu"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SmoothEnhancement") != m.end() && !m["SmoothEnhancement"].empty()) {
      smoothEnhancement = make_shared<string>(boost::any_cast<string>(m["SmoothEnhancement"]));
    }
    if (m.find("StatusMonitor") != m.end() && !m["StatusMonitor"].empty()) {
      statusMonitor = make_shared<string>(boost::any_cast<string>(m["StatusMonitor"]));
    }
    if (m.find("StreamingMode") != m.end() && !m["StreamingMode"].empty()) {
      streamingMode = make_shared<string>(boost::any_cast<string>(m["StreamingMode"]));
    }
    if (m.find("TargetFps") != m.end() && !m["TargetFps"].empty()) {
      targetFps = make_shared<long>(boost::any_cast<long>(m["TargetFps"]));
    }
    if (m.find("Taskbar") != m.end() && !m["Taskbar"].empty()) {
      taskbar = make_shared<string>(boost::any_cast<string>(m["Taskbar"]));
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoEncAvgKbps") != m.end() && !m["VideoEncAvgKbps"].empty()) {
      videoEncAvgKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncAvgKbps"]));
    }
    if (m.find("VideoEncMaxQP") != m.end() && !m["VideoEncMaxQP"].empty()) {
      videoEncMaxQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMaxQP"]));
    }
    if (m.find("VideoEncMinQP") != m.end() && !m["VideoEncMinQP"].empty()) {
      videoEncMinQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMinQP"]));
    }
    if (m.find("VideoEncPeakKbps") != m.end() && !m["VideoEncPeakKbps"].empty()) {
      videoEncPeakKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncPeakKbps"]));
    }
    if (m.find("VideoEncPolicy") != m.end() && !m["VideoEncPolicy"].empty()) {
      videoEncPolicy = make_shared<string>(boost::any_cast<string>(m["VideoEncPolicy"]));
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkCustomText") != m.end() && !m["WatermarkCustomText"].empty()) {
      watermarkCustomText = make_shared<string>(boost::any_cast<string>(m["WatermarkCustomText"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBodyDescribePolicyGroups() = default;
};
class DescribeCenterPolicyListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroups>> describePolicyGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCenterPolicyListResponseBody() {}

  explicit DescribeCenterPolicyListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describePolicyGroups) {
      vector<boost::any> temp1;
      for(auto item1:*describePolicyGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribePolicyGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribePolicyGroups") != m.end() && !m["DescribePolicyGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribePolicyGroups"].type()) {
        vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribePolicyGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCenterPolicyListResponseBodyDescribePolicyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describePolicyGroups = make_shared<vector<DescribeCenterPolicyListResponseBodyDescribePolicyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCenterPolicyListResponseBody() = default;
};
class DescribeCenterPolicyListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCenterPolicyListResponseBody> body{};

  DescribeCenterPolicyListResponse() {}

  explicit DescribeCenterPolicyListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCenterPolicyListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCenterPolicyListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCenterPolicyListResponse() = default;
};
class DescribeClientEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopIp{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> eventType{};
  shared_ptr<vector<string>> eventTypes{};
  shared_ptr<bool> fillHardwareInfo{};
  shared_ptr<string> language{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeClientEventsRequest() {}

  explicit DescribeClientEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopIp) {
      res["DesktopIp"] = boost::any(*desktopIp);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (eventTypes) {
      res["EventTypes"] = boost::any(*eventTypes);
    }
    if (fillHardwareInfo) {
      res["FillHardwareInfo"] = boost::any(*fillHardwareInfo);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopIp") != m.end() && !m["DesktopIp"].empty()) {
      desktopIp = make_shared<string>(boost::any_cast<string>(m["DesktopIp"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("EventTypes") != m.end() && !m["EventTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FillHardwareInfo") != m.end() && !m["FillHardwareInfo"].empty()) {
      fillHardwareInfo = make_shared<bool>(boost::any_cast<bool>(m["FillHardwareInfo"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeClientEventsRequest() = default;
};
class DescribeClientEventsResponseBodyEventsTerminalInfo : public Darabonba::Model {
public:
  shared_ptr<string> model{};
  shared_ptr<string> productName{};
  shared_ptr<string> serialNumber{};

  DescribeClientEventsResponseBodyEventsTerminalInfo() {}

  explicit DescribeClientEventsResponseBodyEventsTerminalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~DescribeClientEventsResponseBodyEventsTerminalInfo() = default;
};
class DescribeClientEventsResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> bytesReceived{};
  shared_ptr<string> bytesSend{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientOS{};
  shared_ptr<string> clientVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopIp{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryType{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeClientEventsResponseBodyEventsTerminalInfo> terminalInfo{};

  DescribeClientEventsResponseBodyEvents() {}

  explicit DescribeClientEventsResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (bytesReceived) {
      res["BytesReceived"] = boost::any(*bytesReceived);
    }
    if (bytesSend) {
      res["BytesSend"] = boost::any(*bytesSend);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientOS) {
      res["ClientOS"] = boost::any(*clientOS);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopIp) {
      res["DesktopIp"] = boost::any(*desktopIp);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryType) {
      res["DirectoryType"] = boost::any(*directoryType);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (terminalInfo) {
      res["TerminalInfo"] = terminalInfo ? boost::any(terminalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("BytesReceived") != m.end() && !m["BytesReceived"].empty()) {
      bytesReceived = make_shared<string>(boost::any_cast<string>(m["BytesReceived"]));
    }
    if (m.find("BytesSend") != m.end() && !m["BytesSend"].empty()) {
      bytesSend = make_shared<string>(boost::any_cast<string>(m["BytesSend"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientOS") != m.end() && !m["ClientOS"].empty()) {
      clientOS = make_shared<string>(boost::any_cast<string>(m["ClientOS"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopIp") != m.end() && !m["DesktopIp"].empty()) {
      desktopIp = make_shared<string>(boost::any_cast<string>(m["DesktopIp"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryType") != m.end() && !m["DirectoryType"].empty()) {
      directoryType = make_shared<string>(boost::any_cast<string>(m["DirectoryType"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["EventTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TerminalInfo") != m.end() && !m["TerminalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerminalInfo"].type()) {
        DescribeClientEventsResponseBodyEventsTerminalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerminalInfo"]));
        terminalInfo = make_shared<DescribeClientEventsResponseBodyEventsTerminalInfo>(model1);
      }
    }
  }


  virtual ~DescribeClientEventsResponseBodyEvents() = default;
};
class DescribeClientEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClientEventsResponseBodyEvents>> events{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeClientEventsResponseBody() {}

  explicit DescribeClientEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Events"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<DescribeClientEventsResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClientEventsResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<DescribeClientEventsResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClientEventsResponseBody() = default;
};
class DescribeClientEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClientEventsResponseBody> body{};

  DescribeClientEventsResponse() {}

  explicit DescribeClientEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClientEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClientEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClientEventsResponse() = default;
};
class DescribeCloudDriveGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryName{};
  shared_ptr<string> driveStatus{};
  shared_ptr<string> driveType{};
  shared_ptr<vector<string>> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentGroupId{};
  shared_ptr<string> regionId{};

  DescribeCloudDriveGroupsRequest() {}

  explicit DescribeCloudDriveGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryName) {
      res["DirectoryName"] = boost::any(*directoryName);
    }
    if (driveStatus) {
      res["DriveStatus"] = boost::any(*driveStatus);
    }
    if (driveType) {
      res["DriveType"] = boost::any(*driveType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentGroupId) {
      res["ParentGroupId"] = boost::any(*parentGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryName") != m.end() && !m["DirectoryName"].empty()) {
      directoryName = make_shared<string>(boost::any_cast<string>(m["DirectoryName"]));
    }
    if (m.find("DriveStatus") != m.end() && !m["DriveStatus"].empty()) {
      driveStatus = make_shared<string>(boost::any_cast<string>(m["DriveStatus"]));
    }
    if (m.find("DriveType") != m.end() && !m["DriveType"].empty()) {
      driveType = make_shared<string>(boost::any_cast<string>(m["DriveType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentGroupId") != m.end() && !m["ParentGroupId"].empty()) {
      parentGroupId = make_shared<string>(boost::any_cast<string>(m["ParentGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCloudDriveGroupsRequest() = default;
};
class DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> jobNumber{};
  shared_ptr<string> nickName{};
  shared_ptr<string> phone{};
  shared_ptr<string> realNickName{};
  shared_ptr<string> remark{};

  DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos() {}

  explicit DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (jobNumber) {
      res["JobNumber"] = boost::any(*jobNumber);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (realNickName) {
      res["RealNickName"] = boost::any(*realNickName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("JobNumber") != m.end() && !m["JobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["JobNumber"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RealNickName") != m.end() && !m["RealNickName"].empty()) {
      realNickName = make_shared<string>(boost::any_cast<string>(m["RealNickName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos() = default;
};
class DescribeCloudDriveGroupsResponseBodyCloudDriveGroups : public Darabonba::Model {
public:
  shared_ptr<string> adminUserIds{};
  shared_ptr<vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos>> adminUserInfos{};
  shared_ptr<string> createTime{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> driveId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> orgId{};
  shared_ptr<string> recycleBinSize{};
  shared_ptr<string> status{};
  shared_ptr<long> totalSize{};
  shared_ptr<string> usedSize{};

  DescribeCloudDriveGroupsResponseBodyCloudDriveGroups() {}

  explicit DescribeCloudDriveGroupsResponseBodyCloudDriveGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminUserIds) {
      res["AdminUserIds"] = boost::any(*adminUserIds);
    }
    if (adminUserInfos) {
      vector<boost::any> temp1;
      for(auto item1:*adminUserInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminUserInfos"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (driveId) {
      res["DriveId"] = boost::any(*driveId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (orgId) {
      res["OrgId"] = boost::any(*orgId);
    }
    if (recycleBinSize) {
      res["RecycleBinSize"] = boost::any(*recycleBinSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (usedSize) {
      res["UsedSize"] = boost::any(*usedSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminUserIds") != m.end() && !m["AdminUserIds"].empty()) {
      adminUserIds = make_shared<string>(boost::any_cast<string>(m["AdminUserIds"]));
    }
    if (m.find("AdminUserInfos") != m.end() && !m["AdminUserInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminUserInfos"].type()) {
        vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminUserInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminUserInfos = make_shared<vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DriveId") != m.end() && !m["DriveId"].empty()) {
      driveId = make_shared<string>(boost::any_cast<string>(m["DriveId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OrgId") != m.end() && !m["OrgId"].empty()) {
      orgId = make_shared<string>(boost::any_cast<string>(m["OrgId"]));
    }
    if (m.find("RecycleBinSize") != m.end() && !m["RecycleBinSize"].empty()) {
      recycleBinSize = make_shared<string>(boost::any_cast<string>(m["RecycleBinSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("UsedSize") != m.end() && !m["UsedSize"].empty()) {
      usedSize = make_shared<string>(boost::any_cast<string>(m["UsedSize"]));
    }
  }


  virtual ~DescribeCloudDriveGroupsResponseBodyCloudDriveGroups() = default;
};
class DescribeCloudDriveGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroups>> cloudDriveGroups{};
  shared_ptr<long> count{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeCloudDriveGroupsResponseBody() {}

  explicit DescribeCloudDriveGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudDriveGroups) {
      vector<boost::any> temp1;
      for(auto item1:*cloudDriveGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudDriveGroups"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudDriveGroups") != m.end() && !m["CloudDriveGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudDriveGroups"].type()) {
        vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudDriveGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDriveGroupsResponseBodyCloudDriveGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudDriveGroups = make_shared<vector<DescribeCloudDriveGroupsResponseBodyCloudDriveGroups>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCloudDriveGroupsResponseBody() = default;
};
class DescribeCloudDriveGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudDriveGroupsResponseBody> body{};

  DescribeCloudDriveGroupsResponse() {}

  explicit DescribeCloudDriveGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDriveGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDriveGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDriveGroupsResponse() = default;
};
class DescribeCloudDrivePermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> regionId{};

  DescribeCloudDrivePermissionsRequest() {}

  explicit DescribeCloudDrivePermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCloudDrivePermissionsRequest() = default;
};
class DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endUsers{};
  shared_ptr<string> permission{};

  DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels() {}

  explicit DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUsers) {
      res["EndUsers"] = boost::any(*endUsers);
    }
    if (permission) {
      res["Permission"] = boost::any(*permission);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUsers") != m.end() && !m["EndUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permission = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
  }


  virtual ~DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels() = default;
};
class DescribeCloudDrivePermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels>> cloudDrivePermissionModels{};
  shared_ptr<string> requestId{};

  DescribeCloudDrivePermissionsResponseBody() {}

  explicit DescribeCloudDrivePermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudDrivePermissionModels) {
      vector<boost::any> temp1;
      for(auto item1:*cloudDrivePermissionModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudDrivePermissionModels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudDrivePermissionModels") != m.end() && !m["CloudDrivePermissionModels"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudDrivePermissionModels"].type()) {
        vector<DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudDrivePermissionModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudDrivePermissionModels = make_shared<vector<DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudDrivePermissionsResponseBody() = default;
};
class DescribeCloudDrivePermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudDrivePermissionsResponseBody> body{};

  DescribeCloudDrivePermissionsResponse() {}

  explicit DescribeCloudDrivePermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDrivePermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDrivePermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDrivePermissionsResponse() = default;
};
class DescribeCloudDriveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeCloudDriveUsersRequest() {}

  explicit DescribeCloudDriveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCloudDriveUsersRequest() = default;
};
class DescribeCloudDriveUsersResponseBodyCloudDriveUsers : public Darabonba::Model {
public:
  shared_ptr<string> driveId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> status{};
  shared_ptr<long> totalSize{};
  shared_ptr<long> usedSize{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  DescribeCloudDriveUsersResponseBodyCloudDriveUsers() {}

  explicit DescribeCloudDriveUsersResponseBodyCloudDriveUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driveId) {
      res["DriveId"] = boost::any(*driveId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    if (usedSize) {
      res["UsedSize"] = boost::any(*usedSize);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriveId") != m.end() && !m["DriveId"].empty()) {
      driveId = make_shared<string>(boost::any_cast<string>(m["DriveId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
    if (m.find("UsedSize") != m.end() && !m["UsedSize"].empty()) {
      usedSize = make_shared<long>(boost::any_cast<long>(m["UsedSize"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeCloudDriveUsersResponseBodyCloudDriveUsers() = default;
};
class DescribeCloudDriveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDriveUsersResponseBodyCloudDriveUsers>> cloudDriveUsers{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeCloudDriveUsersResponseBody() {}

  explicit DescribeCloudDriveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudDriveUsers) {
      vector<boost::any> temp1;
      for(auto item1:*cloudDriveUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudDriveUsers"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudDriveUsers") != m.end() && !m["CloudDriveUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudDriveUsers"].type()) {
        vector<DescribeCloudDriveUsersResponseBodyCloudDriveUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudDriveUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDriveUsersResponseBodyCloudDriveUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudDriveUsers = make_shared<vector<DescribeCloudDriveUsersResponseBodyCloudDriveUsers>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudDriveUsersResponseBody() = default;
};
class DescribeCloudDriveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudDriveUsersResponseBody> body{};

  DescribeCloudDriveUsersResponse() {}

  explicit DescribeCloudDriveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDriveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDriveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDriveUsersResponse() = default;
};
class DescribeConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> statuses{};
  shared_ptr<string> type{};

  DescribeConfigGroupRequest() {}

  explicit DescribeConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeConfigGroupRequest() = default;
};
class DescribeConfigGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> bindCount{};
  shared_ptr<map<string, long>> bindCountMap{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> productType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeConfigGroupResponseBodyData() {}

  explicit DescribeConfigGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (bindCountMap) {
      res["BindCountMap"] = boost::any(*bindCountMap);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("BindCountMap") != m.end() && !m["BindCountMap"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["BindCountMap"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bindCountMap = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeConfigGroupResponseBodyData() = default;
};
class DescribeConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeConfigGroupResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeConfigGroupResponseBody() {}

  explicit DescribeConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeConfigGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeConfigGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeConfigGroupResponseBody() = default;
};
class DescribeConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConfigGroupResponseBody> body{};

  DescribeConfigGroupResponse() {}

  explicit DescribeConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConfigGroupResponse() = default;
};
class DescribeCustomizedListHeadersRequest : public Darabonba::Model {
public:
  shared_ptr<string> langType{};
  shared_ptr<string> listType{};
  shared_ptr<string> regionId{};

  DescribeCustomizedListHeadersRequest() {}

  explicit DescribeCustomizedListHeadersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (langType) {
      res["LangType"] = boost::any(*langType);
    }
    if (listType) {
      res["ListType"] = boost::any(*listType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LangType") != m.end() && !m["LangType"].empty()) {
      langType = make_shared<string>(boost::any_cast<string>(m["LangType"]));
    }
    if (m.find("ListType") != m.end() && !m["ListType"].empty()) {
      listType = make_shared<string>(boost::any_cast<string>(m["ListType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomizedListHeadersRequest() = default;
};
class DescribeCustomizedListHeadersResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<string> displayType{};
  shared_ptr<string> headerKey{};
  shared_ptr<string> headerName{};

  DescribeCustomizedListHeadersResponseBodyHeaders() {}

  explicit DescribeCustomizedListHeadersResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayType) {
      res["DisplayType"] = boost::any(*displayType);
    }
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayType") != m.end() && !m["DisplayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["DisplayType"]));
    }
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
  }


  virtual ~DescribeCustomizedListHeadersResponseBodyHeaders() = default;
};
class DescribeCustomizedListHeadersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomizedListHeadersResponseBodyHeaders>> headers{};
  shared_ptr<string> requestId{};

  DescribeCustomizedListHeadersResponseBody() {}

  explicit DescribeCustomizedListHeadersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<DescribeCustomizedListHeadersResponseBodyHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomizedListHeadersResponseBodyHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<DescribeCustomizedListHeadersResponseBodyHeaders>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCustomizedListHeadersResponseBody() = default;
};
class DescribeCustomizedListHeadersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomizedListHeadersResponseBody> body{};

  DescribeCustomizedListHeadersResponse() {}

  explicit DescribeCustomizedListHeadersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomizedListHeadersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomizedListHeadersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomizedListHeadersResponse() = default;
};
class DescribeDesktopGroupSessionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sessionStatus{};
  shared_ptr<string> startTime{};

  DescribeDesktopGroupSessionsRequest() {}

  explicit DescribeDesktopGroupSessionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sessionStatus) {
      res["SessionStatus"] = boost::any(*sessionStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SessionStatus") != m.end() && !m["SessionStatus"].empty()) {
      sessionStatus = make_shared<string>(boost::any_cast<string>(m["SessionStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDesktopGroupSessionsRequest() = default;
};
class DescribeDesktopGroupSessionsResponseBodySessions : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientOS{};
  shared_ptr<string> clientVersion{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<string> desktopId{};
  shared_ptr<long> endUserApplyCoordinateTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> lastSessionEndTime{};
  shared_ptr<string> lastSessionStartTime{};
  shared_ptr<long> latestConnectionTime{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> osType{};
  shared_ptr<long> ownType{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> sessionIdleTime{};
  shared_ptr<string> sessionStatus{};
  shared_ptr<long> totalConnectionDuration{};

  DescribeDesktopGroupSessionsResponseBodySessions() {}

  explicit DescribeDesktopGroupSessionsResponseBodySessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientOS) {
      res["ClientOS"] = boost::any(*clientOS);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserApplyCoordinateTime) {
      res["EndUserApplyCoordinateTime"] = boost::any(*endUserApplyCoordinateTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (lastSessionEndTime) {
      res["LastSessionEndTime"] = boost::any(*lastSessionEndTime);
    }
    if (lastSessionStartTime) {
      res["LastSessionStartTime"] = boost::any(*lastSessionStartTime);
    }
    if (latestConnectionTime) {
      res["LatestConnectionTime"] = boost::any(*latestConnectionTime);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (sessionIdleTime) {
      res["SessionIdleTime"] = boost::any(*sessionIdleTime);
    }
    if (sessionStatus) {
      res["SessionStatus"] = boost::any(*sessionStatus);
    }
    if (totalConnectionDuration) {
      res["TotalConnectionDuration"] = boost::any(*totalConnectionDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientOS") != m.end() && !m["ClientOS"].empty()) {
      clientOS = make_shared<string>(boost::any_cast<string>(m["ClientOS"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserApplyCoordinateTime") != m.end() && !m["EndUserApplyCoordinateTime"].empty()) {
      endUserApplyCoordinateTime = make_shared<long>(boost::any_cast<long>(m["EndUserApplyCoordinateTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("LastSessionEndTime") != m.end() && !m["LastSessionEndTime"].empty()) {
      lastSessionEndTime = make_shared<string>(boost::any_cast<string>(m["LastSessionEndTime"]));
    }
    if (m.find("LastSessionStartTime") != m.end() && !m["LastSessionStartTime"].empty()) {
      lastSessionStartTime = make_shared<string>(boost::any_cast<string>(m["LastSessionStartTime"]));
    }
    if (m.find("LatestConnectionTime") != m.end() && !m["LatestConnectionTime"].empty()) {
      latestConnectionTime = make_shared<long>(boost::any_cast<long>(m["LatestConnectionTime"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("SessionIdleTime") != m.end() && !m["SessionIdleTime"].empty()) {
      sessionIdleTime = make_shared<long>(boost::any_cast<long>(m["SessionIdleTime"]));
    }
    if (m.find("SessionStatus") != m.end() && !m["SessionStatus"].empty()) {
      sessionStatus = make_shared<string>(boost::any_cast<string>(m["SessionStatus"]));
    }
    if (m.find("TotalConnectionDuration") != m.end() && !m["TotalConnectionDuration"].empty()) {
      totalConnectionDuration = make_shared<long>(boost::any_cast<long>(m["TotalConnectionDuration"]));
    }
  }


  virtual ~DescribeDesktopGroupSessionsResponseBodySessions() = default;
};
class DescribeDesktopGroupSessionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDesktopGroupSessionsResponseBodySessions>> sessions{};
  shared_ptr<long> totalCount{};

  DescribeDesktopGroupSessionsResponseBody() {}

  explicit DescribeDesktopGroupSessionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<DescribeDesktopGroupSessionsResponseBodySessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopGroupSessionsResponseBodySessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<DescribeDesktopGroupSessionsResponseBodySessions>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDesktopGroupSessionsResponseBody() = default;
};
class DescribeDesktopGroupSessionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopGroupSessionsResponseBody> body{};

  DescribeDesktopGroupSessionsResponse() {}

  explicit DescribeDesktopGroupSessionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopGroupSessionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopGroupSessionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopGroupSessionsResponse() = default;
};
class DescribeDesktopGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDesktopGroupsRequestTag() {}

  explicit DescribeDesktopGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDesktopGroupsRequestTag() = default;
};
class DescribeDesktopGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bundleId{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopGroupIds{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<vector<string>> excludedEndUserIds{};
  shared_ptr<vector<string>> imageId{};
  shared_ptr<long> maxResults{};
  shared_ptr<bool> multiResource{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> ownType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<vector<DescribeDesktopGroupsRequestTag>> tag{};

  DescribeDesktopGroupsRequest() {}

  explicit DescribeDesktopGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupIds) {
      res["DesktopGroupIds"] = boost::any(*desktopGroupIds);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (excludedEndUserIds) {
      res["ExcludedEndUserIds"] = boost::any(*excludedEndUserIds);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (multiResource) {
      res["MultiResource"] = boost::any(*multiResource);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BundleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BundleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bundleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupIds") != m.end() && !m["DesktopGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedEndUserIds") != m.end() && !m["ExcludedEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MultiResource") != m.end() && !m["MultiResource"].empty()) {
      multiResource = make_shared<bool>(boost::any_cast<bool>(m["MultiResource"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDesktopGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDesktopGroupsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDesktopGroupsRequest() = default;
};
class DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> status{};

  DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus() {}

  explicit DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus() = default;
};
class DescribeDesktopGroupsResponseBodyDesktopGroupsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDesktopGroupsResponseBodyDesktopGroupsTags() {}

  explicit DescribeDesktopGroupsResponseBodyDesktopGroupsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDesktopGroupsResponseBodyDesktopGroupsTags() = default;
};
class DescribeDesktopGroupsResponseBodyDesktopGroups : public Darabonba::Model {
public:
  shared_ptr<long> bindAmount{};
  shared_ptr<long> buyDesktopsCount{};
  shared_ptr<string> comments{};
  shared_ptr<long> connectDuration{};
  shared_ptr<vector<DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus>> countPerStatus{};
  shared_ptr<long> cpu{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> dataDiskSize{};
  shared_ptr<long> desktopCount{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<string> desktopType{};
  shared_ptr<long> endUserCount{};
  shared_ptr<string> expiredTime{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<bool> isLdap{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxDesktopsCount{};
  shared_ptr<long> memory{};
  shared_ptr<long> minDesktopsCount{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> osType{};
  shared_ptr<string> ownBundleId{};
  shared_ptr<string> ownBundleName{};
  shared_ptr<long> ownType{};
  shared_ptr<string> payType{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> policyGroupName{};
  shared_ptr<string> protocolType{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<long> resetType{};
  shared_ptr<long> status{};
  shared_ptr<long> stopDuration{};
  shared_ptr<string> subnetId{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<DescribeDesktopGroupsResponseBodyDesktopGroupsTags>> tags{};
  shared_ptr<string> userOuPath{};
  shared_ptr<long> version{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  DescribeDesktopGroupsResponseBodyDesktopGroups() {}

  explicit DescribeDesktopGroupsResponseBodyDesktopGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindAmount) {
      res["BindAmount"] = boost::any(*bindAmount);
    }
    if (buyDesktopsCount) {
      res["BuyDesktopsCount"] = boost::any(*buyDesktopsCount);
    }
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (connectDuration) {
      res["ConnectDuration"] = boost::any(*connectDuration);
    }
    if (countPerStatus) {
      vector<boost::any> temp1;
      for(auto item1:*countPerStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CountPerStatus"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (desktopCount) {
      res["DesktopCount"] = boost::any(*desktopCount);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (endUserCount) {
      res["EndUserCount"] = boost::any(*endUserCount);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (isLdap) {
      res["IsLdap"] = boost::any(*isLdap);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxDesktopsCount) {
      res["MaxDesktopsCount"] = boost::any(*maxDesktopsCount);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minDesktopsCount) {
      res["MinDesktopsCount"] = boost::any(*minDesktopsCount);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (ownBundleId) {
      res["OwnBundleId"] = boost::any(*ownBundleId);
    }
    if (ownBundleName) {
      res["OwnBundleName"] = boost::any(*ownBundleName);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupName) {
      res["PolicyGroupName"] = boost::any(*policyGroupName);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    if (subnetId) {
      res["SubnetId"] = boost::any(*subnetId);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userOuPath) {
      res["UserOuPath"] = boost::any(*userOuPath);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindAmount") != m.end() && !m["BindAmount"].empty()) {
      bindAmount = make_shared<long>(boost::any_cast<long>(m["BindAmount"]));
    }
    if (m.find("BuyDesktopsCount") != m.end() && !m["BuyDesktopsCount"].empty()) {
      buyDesktopsCount = make_shared<long>(boost::any_cast<long>(m["BuyDesktopsCount"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("ConnectDuration") != m.end() && !m["ConnectDuration"].empty()) {
      connectDuration = make_shared<long>(boost::any_cast<long>(m["ConnectDuration"]));
    }
    if (m.find("CountPerStatus") != m.end() && !m["CountPerStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["CountPerStatus"].type()) {
        vector<DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CountPerStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        countPerStatus = make_shared<vector<DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("DesktopCount") != m.end() && !m["DesktopCount"].empty()) {
      desktopCount = make_shared<long>(boost::any_cast<long>(m["DesktopCount"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("EndUserCount") != m.end() && !m["EndUserCount"].empty()) {
      endUserCount = make_shared<long>(boost::any_cast<long>(m["EndUserCount"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("IsLdap") != m.end() && !m["IsLdap"].empty()) {
      isLdap = make_shared<bool>(boost::any_cast<bool>(m["IsLdap"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxDesktopsCount") != m.end() && !m["MaxDesktopsCount"].empty()) {
      maxDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MaxDesktopsCount"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MinDesktopsCount") != m.end() && !m["MinDesktopsCount"].empty()) {
      minDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MinDesktopsCount"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OwnBundleId") != m.end() && !m["OwnBundleId"].empty()) {
      ownBundleId = make_shared<string>(boost::any_cast<string>(m["OwnBundleId"]));
    }
    if (m.find("OwnBundleName") != m.end() && !m["OwnBundleName"].empty()) {
      ownBundleName = make_shared<string>(boost::any_cast<string>(m["OwnBundleName"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupName") != m.end() && !m["PolicyGroupName"].empty()) {
      policyGroupName = make_shared<string>(boost::any_cast<string>(m["PolicyGroupName"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<long>(boost::any_cast<long>(m["ResetType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
    if (m.find("SubnetId") != m.end() && !m["SubnetId"].empty()) {
      subnetId = make_shared<string>(boost::any_cast<string>(m["SubnetId"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDesktopGroupsResponseBodyDesktopGroupsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopGroupsResponseBodyDesktopGroupsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDesktopGroupsResponseBodyDesktopGroupsTags>>(expect1);
      }
    }
    if (m.find("UserOuPath") != m.end() && !m["UserOuPath"].empty()) {
      userOuPath = make_shared<string>(boost::any_cast<string>(m["UserOuPath"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~DescribeDesktopGroupsResponseBodyDesktopGroups() = default;
};
class DescribeDesktopGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDesktopGroupsResponseBodyDesktopGroups>> desktopGroups{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDesktopGroupsResponseBody() {}

  explicit DescribeDesktopGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroups) {
      vector<boost::any> temp1;
      for(auto item1:*desktopGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopGroups"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroups") != m.end() && !m["DesktopGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopGroups"].type()) {
        vector<DescribeDesktopGroupsResponseBodyDesktopGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopGroupsResponseBodyDesktopGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopGroups = make_shared<vector<DescribeDesktopGroupsResponseBodyDesktopGroups>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopGroupsResponseBody() = default;
};
class DescribeDesktopGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopGroupsResponseBody> body{};

  DescribeDesktopGroupsResponse() {}

  explicit DescribeDesktopGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopGroupsResponse() = default;
};
class DescribeDesktopInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};

  DescribeDesktopInfoRequest() {}

  explicit DescribeDesktopInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDesktopInfoRequest() = default;
};
class DescribeDesktopInfoResponseBodyDesktops : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<string> currentAppVersion{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<vector<string>> managementFlag{};
  shared_ptr<long> newAppSize{};
  shared_ptr<string> newAppVersion{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> startTime{};

  DescribeDesktopInfoResponseBodyDesktops() {}

  explicit DescribeDesktopInfoResponseBodyDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (currentAppVersion) {
      res["CurrentAppVersion"] = boost::any(*currentAppVersion);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (managementFlag) {
      res["ManagementFlag"] = boost::any(*managementFlag);
    }
    if (newAppSize) {
      res["NewAppSize"] = boost::any(*newAppSize);
    }
    if (newAppVersion) {
      res["NewAppVersion"] = boost::any(*newAppVersion);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("CurrentAppVersion") != m.end() && !m["CurrentAppVersion"].empty()) {
      currentAppVersion = make_shared<string>(boost::any_cast<string>(m["CurrentAppVersion"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("ManagementFlag") != m.end() && !m["ManagementFlag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ManagementFlag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ManagementFlag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managementFlag = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NewAppSize") != m.end() && !m["NewAppSize"].empty()) {
      newAppSize = make_shared<long>(boost::any_cast<long>(m["NewAppSize"]));
    }
    if (m.find("NewAppVersion") != m.end() && !m["NewAppVersion"].empty()) {
      newAppVersion = make_shared<string>(boost::any_cast<string>(m["NewAppVersion"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDesktopInfoResponseBodyDesktops() = default;
};
class DescribeDesktopInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDesktopInfoResponseBodyDesktops>> desktops{};
  shared_ptr<string> requestId{};

  DescribeDesktopInfoResponseBody() {}

  explicit DescribeDesktopInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktops) {
      vector<boost::any> temp1;
      for(auto item1:*desktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Desktops"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desktops") != m.end() && !m["Desktops"].empty()) {
      if (typeid(vector<boost::any>) == m["Desktops"].type()) {
        vector<DescribeDesktopInfoResponseBodyDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Desktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopInfoResponseBodyDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktops = make_shared<vector<DescribeDesktopInfoResponseBodyDesktops>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopInfoResponseBody() = default;
};
class DescribeDesktopInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopInfoResponseBody> body{};

  DescribeDesktopInfoResponse() {}

  explicit DescribeDesktopInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopInfoResponse() = default;
};
class DescribeDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> oversoldGroupIds{};

  DescribeDesktopOversoldGroupRequest() {}

  explicit DescribeDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (oversoldGroupIds) {
      res["OversoldGroupIds"] = boost::any(*oversoldGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OversoldGroupIds") != m.end() && !m["OversoldGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OversoldGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OversoldGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      oversoldGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDesktopOversoldGroupRequest() = default;
};
class DescribeDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<long> curConcurrenceCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<string> keepDuration{};
  shared_ptr<string> name{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> oversoldUserCount{};
  shared_ptr<long> oversoldWarn{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> saleStatus{};
  shared_ptr<string> status{};
  shared_ptr<long> stopDuration{};
  shared_ptr<long> systemDiskSize{};

  DescribeDesktopOversoldGroupResponseBodyData() {}

  explicit DescribeDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (curConcurrenceCount) {
      res["CurConcurrenceCount"] = boost::any(*curConcurrenceCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    if (oversoldWarn) {
      res["OversoldWarn"] = boost::any(*oversoldWarn);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (saleStatus) {
      res["SaleStatus"] = boost::any(*saleStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("CurConcurrenceCount") != m.end() && !m["CurConcurrenceCount"].empty()) {
      curConcurrenceCount = make_shared<long>(boost::any_cast<long>(m["CurConcurrenceCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<string>(boost::any_cast<string>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<string>(boost::any_cast<string>(m["KeepDuration"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
    if (m.find("OversoldWarn") != m.end() && !m["OversoldWarn"].empty()) {
      oversoldWarn = make_shared<long>(boost::any_cast<long>(m["OversoldWarn"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("SaleStatus") != m.end() && !m["SaleStatus"].empty()) {
      saleStatus = make_shared<string>(boost::any_cast<string>(m["SaleStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeDesktopOversoldGroupResponseBodyData() = default;
};
class DescribeDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeDesktopOversoldGroupResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDesktopOversoldGroupResponseBody() {}

  explicit DescribeDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDesktopOversoldGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopOversoldGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDesktopOversoldGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopOversoldGroupResponseBody() = default;
};
class DescribeDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopOversoldGroupResponseBody> body{};

  DescribeDesktopOversoldGroupResponse() {}

  explicit DescribeDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopOversoldGroupResponse() = default;
};
class DescribeDesktopOversoldUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<vector<string>> userDesktopIds{};
  shared_ptr<string> userGroupId{};

  DescribeDesktopOversoldUserRequest() {}

  explicit DescribeDesktopOversoldUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (userDesktopIds) {
      res["UserDesktopIds"] = boost::any(*userDesktopIds);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("UserDesktopIds") != m.end() && !m["UserDesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserDesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserDesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userDesktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DescribeDesktopOversoldUserRequest() = default;
};
class DescribeDesktopOversoldUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endUserId{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> userDesktopId{};
  shared_ptr<string> userGroupId{};

  DescribeDesktopOversoldUserResponseBodyData() {}

  explicit DescribeDesktopOversoldUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (userDesktopId) {
      res["UserDesktopId"] = boost::any(*userDesktopId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("UserDesktopId") != m.end() && !m["UserDesktopId"].empty()) {
      userDesktopId = make_shared<string>(boost::any_cast<string>(m["UserDesktopId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DescribeDesktopOversoldUserResponseBodyData() = default;
};
class DescribeDesktopOversoldUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeDesktopOversoldUserResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDesktopOversoldUserResponseBody() {}

  explicit DescribeDesktopOversoldUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDesktopOversoldUserResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopOversoldUserResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDesktopOversoldUserResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopOversoldUserResponseBody() = default;
};
class DescribeDesktopOversoldUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopOversoldUserResponseBody> body{};

  DescribeDesktopOversoldUserResponse() {}

  explicit DescribeDesktopOversoldUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopOversoldUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopOversoldUserResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopOversoldUserResponse() = default;
};
class DescribeDesktopOversoldUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<vector<string>> userGroupIds{};

  DescribeDesktopOversoldUserGroupRequest() {}

  explicit DescribeDesktopOversoldUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (userGroupIds) {
      res["UserGroupIds"] = boost::any(*userGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("UserGroupIds") != m.end() && !m["UserGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDesktopOversoldUserGroupRequest() = default;
};
class DescribeDesktopOversoldUserGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> name{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> userGroupId{};

  DescribeDesktopOversoldUserGroupResponseBodyData() {}

  explicit DescribeDesktopOversoldUserGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DescribeDesktopOversoldUserGroupResponseBodyData() = default;
};
class DescribeDesktopOversoldUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeDesktopOversoldUserGroupResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDesktopOversoldUserGroupResponseBody() {}

  explicit DescribeDesktopOversoldUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDesktopOversoldUserGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopOversoldUserGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDesktopOversoldUserGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopOversoldUserGroupResponseBody() = default;
};
class DescribeDesktopOversoldUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopOversoldUserGroupResponseBody> body{};

  DescribeDesktopOversoldUserGroupResponse() {}

  explicit DescribeDesktopOversoldUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopOversoldUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopOversoldUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopOversoldUserGroupResponse() = default;
};
class DescribeDesktopSessionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> checkOsSession{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> endUserIdFilter{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sessionStatus{};
  shared_ptr<string> startTime{};
  shared_ptr<string> subPayType{};

  DescribeDesktopSessionsRequest() {}

  explicit DescribeDesktopSessionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkOsSession) {
      res["CheckOsSession"] = boost::any(*checkOsSession);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserIdFilter) {
      res["EndUserIdFilter"] = boost::any(*endUserIdFilter);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sessionStatus) {
      res["SessionStatus"] = boost::any(*sessionStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (subPayType) {
      res["SubPayType"] = boost::any(*subPayType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckOsSession") != m.end() && !m["CheckOsSession"].empty()) {
      checkOsSession = make_shared<bool>(boost::any_cast<bool>(m["CheckOsSession"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserIdFilter") != m.end() && !m["EndUserIdFilter"].empty()) {
      endUserIdFilter = make_shared<string>(boost::any_cast<string>(m["EndUserIdFilter"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SessionStatus") != m.end() && !m["SessionStatus"].empty()) {
      sessionStatus = make_shared<string>(boost::any_cast<string>(m["SessionStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SubPayType") != m.end() && !m["SubPayType"].empty()) {
      subPayType = make_shared<string>(boost::any_cast<string>(m["SubPayType"]));
    }
  }


  virtual ~DescribeDesktopSessionsRequest() = default;
};
class DescribeDesktopSessionsResponseBodySessions : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientOS{};
  shared_ptr<string> clientVersion{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<long> endUserApplyCoordinateTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> latestConnectionTime{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> osSessionStatus{};
  shared_ptr<string> osType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> sessionEndTime{};
  shared_ptr<long> sessionIdleTime{};
  shared_ptr<string> sessionStartTime{};
  shared_ptr<string> sessionStatus{};
  shared_ptr<string> subPayType{};
  shared_ptr<long> totalConnectionTime{};

  DescribeDesktopSessionsResponseBodySessions() {}

  explicit DescribeDesktopSessionsResponseBodySessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientOS) {
      res["ClientOS"] = boost::any(*clientOS);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endUserApplyCoordinateTime) {
      res["EndUserApplyCoordinateTime"] = boost::any(*endUserApplyCoordinateTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (latestConnectionTime) {
      res["LatestConnectionTime"] = boost::any(*latestConnectionTime);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (osSessionStatus) {
      res["OsSessionStatus"] = boost::any(*osSessionStatus);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (sessionEndTime) {
      res["SessionEndTime"] = boost::any(*sessionEndTime);
    }
    if (sessionIdleTime) {
      res["SessionIdleTime"] = boost::any(*sessionIdleTime);
    }
    if (sessionStartTime) {
      res["SessionStartTime"] = boost::any(*sessionStartTime);
    }
    if (sessionStatus) {
      res["SessionStatus"] = boost::any(*sessionStatus);
    }
    if (subPayType) {
      res["SubPayType"] = boost::any(*subPayType);
    }
    if (totalConnectionTime) {
      res["TotalConnectionTime"] = boost::any(*totalConnectionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientOS") != m.end() && !m["ClientOS"].empty()) {
      clientOS = make_shared<string>(boost::any_cast<string>(m["ClientOS"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndUserApplyCoordinateTime") != m.end() && !m["EndUserApplyCoordinateTime"].empty()) {
      endUserApplyCoordinateTime = make_shared<long>(boost::any_cast<long>(m["EndUserApplyCoordinateTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("LatestConnectionTime") != m.end() && !m["LatestConnectionTime"].empty()) {
      latestConnectionTime = make_shared<long>(boost::any_cast<long>(m["LatestConnectionTime"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OsSessionStatus") != m.end() && !m["OsSessionStatus"].empty()) {
      osSessionStatus = make_shared<string>(boost::any_cast<string>(m["OsSessionStatus"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("SessionEndTime") != m.end() && !m["SessionEndTime"].empty()) {
      sessionEndTime = make_shared<string>(boost::any_cast<string>(m["SessionEndTime"]));
    }
    if (m.find("SessionIdleTime") != m.end() && !m["SessionIdleTime"].empty()) {
      sessionIdleTime = make_shared<long>(boost::any_cast<long>(m["SessionIdleTime"]));
    }
    if (m.find("SessionStartTime") != m.end() && !m["SessionStartTime"].empty()) {
      sessionStartTime = make_shared<string>(boost::any_cast<string>(m["SessionStartTime"]));
    }
    if (m.find("SessionStatus") != m.end() && !m["SessionStatus"].empty()) {
      sessionStatus = make_shared<string>(boost::any_cast<string>(m["SessionStatus"]));
    }
    if (m.find("SubPayType") != m.end() && !m["SubPayType"].empty()) {
      subPayType = make_shared<string>(boost::any_cast<string>(m["SubPayType"]));
    }
    if (m.find("TotalConnectionTime") != m.end() && !m["TotalConnectionTime"].empty()) {
      totalConnectionTime = make_shared<long>(boost::any_cast<long>(m["TotalConnectionTime"]));
    }
  }


  virtual ~DescribeDesktopSessionsResponseBodySessions() = default;
};
class DescribeDesktopSessionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDesktopSessionsResponseBodySessions>> sessions{};
  shared_ptr<long> totalCount{};

  DescribeDesktopSessionsResponseBody() {}

  explicit DescribeDesktopSessionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<DescribeDesktopSessionsResponseBodySessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopSessionsResponseBodySessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<DescribeDesktopSessionsResponseBodySessions>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDesktopSessionsResponseBody() = default;
};
class DescribeDesktopSessionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopSessionsResponseBody> body{};

  DescribeDesktopSessionsResponse() {}

  explicit DescribeDesktopSessionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopSessionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopSessionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopSessionsResponse() = default;
};
class DescribeDesktopTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appliedScope{};
  shared_ptr<long> cpuCount{};
  shared_ptr<string> desktopGroupIdForModify{};
  shared_ptr<string> desktopIdForModify{};
  shared_ptr<string> desktopTypeId{};
  shared_ptr<vector<string>> desktopTypeIdList{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuDriverType{};
  shared_ptr<long> gpuMemory{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scope{};
  shared_ptr<string> sortType{};
  shared_ptr<long> supportMinSessionCount{};
  shared_ptr<string> zoneId{};

  DescribeDesktopTypesRequest() {}

  explicit DescribeDesktopTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedScope) {
      res["AppliedScope"] = boost::any(*appliedScope);
    }
    if (cpuCount) {
      res["CpuCount"] = boost::any(*cpuCount);
    }
    if (desktopGroupIdForModify) {
      res["DesktopGroupIdForModify"] = boost::any(*desktopGroupIdForModify);
    }
    if (desktopIdForModify) {
      res["DesktopIdForModify"] = boost::any(*desktopIdForModify);
    }
    if (desktopTypeId) {
      res["DesktopTypeId"] = boost::any(*desktopTypeId);
    }
    if (desktopTypeIdList) {
      res["DesktopTypeIdList"] = boost::any(*desktopTypeIdList);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuDriverType) {
      res["GpuDriverType"] = boost::any(*gpuDriverType);
    }
    if (gpuMemory) {
      res["GpuMemory"] = boost::any(*gpuMemory);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (supportMinSessionCount) {
      res["SupportMinSessionCount"] = boost::any(*supportMinSessionCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedScope") != m.end() && !m["AppliedScope"].empty()) {
      appliedScope = make_shared<string>(boost::any_cast<string>(m["AppliedScope"]));
    }
    if (m.find("CpuCount") != m.end() && !m["CpuCount"].empty()) {
      cpuCount = make_shared<long>(boost::any_cast<long>(m["CpuCount"]));
    }
    if (m.find("DesktopGroupIdForModify") != m.end() && !m["DesktopGroupIdForModify"].empty()) {
      desktopGroupIdForModify = make_shared<string>(boost::any_cast<string>(m["DesktopGroupIdForModify"]));
    }
    if (m.find("DesktopIdForModify") != m.end() && !m["DesktopIdForModify"].empty()) {
      desktopIdForModify = make_shared<string>(boost::any_cast<string>(m["DesktopIdForModify"]));
    }
    if (m.find("DesktopTypeId") != m.end() && !m["DesktopTypeId"].empty()) {
      desktopTypeId = make_shared<string>(boost::any_cast<string>(m["DesktopTypeId"]));
    }
    if (m.find("DesktopTypeIdList") != m.end() && !m["DesktopTypeIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopTypeIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopTypeIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopTypeIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuDriverType") != m.end() && !m["GpuDriverType"].empty()) {
      gpuDriverType = make_shared<string>(boost::any_cast<string>(m["GpuDriverType"]));
    }
    if (m.find("GpuMemory") != m.end() && !m["GpuMemory"].empty()) {
      gpuMemory = make_shared<long>(boost::any_cast<long>(m["GpuMemory"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
    if (m.find("SupportMinSessionCount") != m.end() && !m["SupportMinSessionCount"].empty()) {
      supportMinSessionCount = make_shared<long>(boost::any_cast<long>(m["SupportMinSessionCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDesktopTypesRequest() = default;
};
class DescribeDesktopTypesResponseBodyDesktopTypes : public Darabonba::Model {
public:
  shared_ptr<string> cpuCount{};
  shared_ptr<string> dataDiskSize{};
  shared_ptr<string> desktopTypeId{};
  shared_ptr<string> desktopTypeStatus{};
  shared_ptr<double> gpuCount{};
  shared_ptr<long> gpuMemory{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> maxSessionCount{};
  shared_ptr<string> memorySize{};
  shared_ptr<vector<string>> scopes{};
  shared_ptr<string> stockState{};
  shared_ptr<string> systemDiskSize{};

  DescribeDesktopTypesResponseBodyDesktopTypes() {}

  explicit DescribeDesktopTypesResponseBodyDesktopTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuCount) {
      res["CpuCount"] = boost::any(*cpuCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (desktopTypeId) {
      res["DesktopTypeId"] = boost::any(*desktopTypeId);
    }
    if (desktopTypeStatus) {
      res["DesktopTypeStatus"] = boost::any(*desktopTypeStatus);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuMemory) {
      res["GpuMemory"] = boost::any(*gpuMemory);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (maxSessionCount) {
      res["MaxSessionCount"] = boost::any(*maxSessionCount);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (scopes) {
      res["Scopes"] = boost::any(*scopes);
    }
    if (stockState) {
      res["StockState"] = boost::any(*stockState);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuCount") != m.end() && !m["CpuCount"].empty()) {
      cpuCount = make_shared<string>(boost::any_cast<string>(m["CpuCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("DesktopTypeId") != m.end() && !m["DesktopTypeId"].empty()) {
      desktopTypeId = make_shared<string>(boost::any_cast<string>(m["DesktopTypeId"]));
    }
    if (m.find("DesktopTypeStatus") != m.end() && !m["DesktopTypeStatus"].empty()) {
      desktopTypeStatus = make_shared<string>(boost::any_cast<string>(m["DesktopTypeStatus"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuMemory") != m.end() && !m["GpuMemory"].empty()) {
      gpuMemory = make_shared<long>(boost::any_cast<long>(m["GpuMemory"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("MaxSessionCount") != m.end() && !m["MaxSessionCount"].empty()) {
      maxSessionCount = make_shared<long>(boost::any_cast<long>(m["MaxSessionCount"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<string>(boost::any_cast<string>(m["MemorySize"]));
    }
    if (m.find("Scopes") != m.end() && !m["Scopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StockState") != m.end() && !m["StockState"].empty()) {
      stockState = make_shared<string>(boost::any_cast<string>(m["StockState"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<string>(boost::any_cast<string>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeDesktopTypesResponseBodyDesktopTypes() = default;
};
class DescribeDesktopTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDesktopTypesResponseBodyDesktopTypes>> desktopTypes{};
  shared_ptr<string> requestId{};

  DescribeDesktopTypesResponseBody() {}

  explicit DescribeDesktopTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopTypes) {
      vector<boost::any> temp1;
      for(auto item1:*desktopTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopTypes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopTypes") != m.end() && !m["DesktopTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopTypes"].type()) {
        vector<DescribeDesktopTypesResponseBodyDesktopTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopTypesResponseBodyDesktopTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopTypes = make_shared<vector<DescribeDesktopTypesResponseBodyDesktopTypes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDesktopTypesResponseBody() = default;
};
class DescribeDesktopTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopTypesResponseBody> body{};

  DescribeDesktopTypesResponse() {}

  explicit DescribeDesktopTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopTypesResponse() = default;
};
class DescribeDesktopsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDesktopsRequestTag() {}

  explicit DescribeDesktopsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDesktopsRequestTag() = default;
};
class DescribeDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<vector<string>> desktopStatusList{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> directoryId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<vector<string>> excludedEndUserId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<bool> fillResourceGroup{};
  shared_ptr<bool> filterDesktopGroup{};
  shared_ptr<string> gpuInstanceGroupId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> imageId{};
  shared_ptr<string> managementFlag{};
  shared_ptr<long> maxResults{};
  shared_ptr<bool> multiResource{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<bool> onlyDesktopGroup{};
  shared_ptr<vector<string>> osTypes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> qosRuleId{};
  shared_ptr<bool> queryFotaUpdate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> snapshotPolicyId{};
  shared_ptr<string> subPayType{};
  shared_ptr<vector<DescribeDesktopsRequestTag>> tag{};
  shared_ptr<string> userName{};

  DescribeDesktopsRequest() {}

  explicit DescribeDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (desktopStatusList) {
      res["DesktopStatusList"] = boost::any(*desktopStatusList);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (excludedEndUserId) {
      res["ExcludedEndUserId"] = boost::any(*excludedEndUserId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (fillResourceGroup) {
      res["FillResourceGroup"] = boost::any(*fillResourceGroup);
    }
    if (filterDesktopGroup) {
      res["FilterDesktopGroup"] = boost::any(*filterDesktopGroup);
    }
    if (gpuInstanceGroupId) {
      res["GpuInstanceGroupId"] = boost::any(*gpuInstanceGroupId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (managementFlag) {
      res["ManagementFlag"] = boost::any(*managementFlag);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (multiResource) {
      res["MultiResource"] = boost::any(*multiResource);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (onlyDesktopGroup) {
      res["OnlyDesktopGroup"] = boost::any(*onlyDesktopGroup);
    }
    if (osTypes) {
      res["OsTypes"] = boost::any(*osTypes);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (qosRuleId) {
      res["QosRuleId"] = boost::any(*qosRuleId);
    }
    if (queryFotaUpdate) {
      res["QueryFotaUpdate"] = boost::any(*queryFotaUpdate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (snapshotPolicyId) {
      res["SnapshotPolicyId"] = boost::any(*snapshotPolicyId);
    }
    if (subPayType) {
      res["SubPayType"] = boost::any(*subPayType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("DesktopStatusList") != m.end() && !m["DesktopStatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopStatusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludedEndUserId") != m.end() && !m["ExcludedEndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludedEndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludedEndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedEndUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("FillResourceGroup") != m.end() && !m["FillResourceGroup"].empty()) {
      fillResourceGroup = make_shared<bool>(boost::any_cast<bool>(m["FillResourceGroup"]));
    }
    if (m.find("FilterDesktopGroup") != m.end() && !m["FilterDesktopGroup"].empty()) {
      filterDesktopGroup = make_shared<bool>(boost::any_cast<bool>(m["FilterDesktopGroup"]));
    }
    if (m.find("GpuInstanceGroupId") != m.end() && !m["GpuInstanceGroupId"].empty()) {
      gpuInstanceGroupId = make_shared<string>(boost::any_cast<string>(m["GpuInstanceGroupId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ManagementFlag") != m.end() && !m["ManagementFlag"].empty()) {
      managementFlag = make_shared<string>(boost::any_cast<string>(m["ManagementFlag"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MultiResource") != m.end() && !m["MultiResource"].empty()) {
      multiResource = make_shared<bool>(boost::any_cast<bool>(m["MultiResource"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OnlyDesktopGroup") != m.end() && !m["OnlyDesktopGroup"].empty()) {
      onlyDesktopGroup = make_shared<bool>(boost::any_cast<bool>(m["OnlyDesktopGroup"]));
    }
    if (m.find("OsTypes") != m.end() && !m["OsTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OsTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OsTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      osTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("QosRuleId") != m.end() && !m["QosRuleId"].empty()) {
      qosRuleId = make_shared<string>(boost::any_cast<string>(m["QosRuleId"]));
    }
    if (m.find("QueryFotaUpdate") != m.end() && !m["QueryFotaUpdate"].empty()) {
      queryFotaUpdate = make_shared<bool>(boost::any_cast<bool>(m["QueryFotaUpdate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SnapshotPolicyId") != m.end() && !m["SnapshotPolicyId"].empty()) {
      snapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyId"]));
    }
    if (m.find("SubPayType") != m.end() && !m["SubPayType"].empty()) {
      subPayType = make_shared<string>(boost::any_cast<string>(m["SubPayType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDesktopsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDesktopsRequestTag>>(expect1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDesktopsRequest() = default;
};
class DescribeDesktopsResponseBodyDesktopsDesktopDurationList : public Darabonba::Model {
public:
  shared_ptr<string> orderInstanceId{};
  shared_ptr<string> packageCreationTime{};
  shared_ptr<string> packageExpiredTime{};
  shared_ptr<string> packageId{};
  shared_ptr<string> packageStatus{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUsedUpStrategy{};
  shared_ptr<string> periodEndTime{};
  shared_ptr<string> periodStartTime{};
  shared_ptr<double> postPaidLimitFee{};
  shared_ptr<long> totalDuration{};
  shared_ptr<long> usedDuration{};

  DescribeDesktopsResponseBodyDesktopsDesktopDurationList() {}

  explicit DescribeDesktopsResponseBodyDesktopsDesktopDurationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (packageCreationTime) {
      res["PackageCreationTime"] = boost::any(*packageCreationTime);
    }
    if (packageExpiredTime) {
      res["PackageExpiredTime"] = boost::any(*packageExpiredTime);
    }
    if (packageId) {
      res["PackageId"] = boost::any(*packageId);
    }
    if (packageStatus) {
      res["PackageStatus"] = boost::any(*packageStatus);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUsedUpStrategy) {
      res["PackageUsedUpStrategy"] = boost::any(*packageUsedUpStrategy);
    }
    if (periodEndTime) {
      res["PeriodEndTime"] = boost::any(*periodEndTime);
    }
    if (periodStartTime) {
      res["PeriodStartTime"] = boost::any(*periodStartTime);
    }
    if (postPaidLimitFee) {
      res["PostPaidLimitFee"] = boost::any(*postPaidLimitFee);
    }
    if (totalDuration) {
      res["TotalDuration"] = boost::any(*totalDuration);
    }
    if (usedDuration) {
      res["UsedDuration"] = boost::any(*usedDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PackageCreationTime") != m.end() && !m["PackageCreationTime"].empty()) {
      packageCreationTime = make_shared<string>(boost::any_cast<string>(m["PackageCreationTime"]));
    }
    if (m.find("PackageExpiredTime") != m.end() && !m["PackageExpiredTime"].empty()) {
      packageExpiredTime = make_shared<string>(boost::any_cast<string>(m["PackageExpiredTime"]));
    }
    if (m.find("PackageId") != m.end() && !m["PackageId"].empty()) {
      packageId = make_shared<string>(boost::any_cast<string>(m["PackageId"]));
    }
    if (m.find("PackageStatus") != m.end() && !m["PackageStatus"].empty()) {
      packageStatus = make_shared<string>(boost::any_cast<string>(m["PackageStatus"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUsedUpStrategy") != m.end() && !m["PackageUsedUpStrategy"].empty()) {
      packageUsedUpStrategy = make_shared<string>(boost::any_cast<string>(m["PackageUsedUpStrategy"]));
    }
    if (m.find("PeriodEndTime") != m.end() && !m["PeriodEndTime"].empty()) {
      periodEndTime = make_shared<string>(boost::any_cast<string>(m["PeriodEndTime"]));
    }
    if (m.find("PeriodStartTime") != m.end() && !m["PeriodStartTime"].empty()) {
      periodStartTime = make_shared<string>(boost::any_cast<string>(m["PeriodStartTime"]));
    }
    if (m.find("PostPaidLimitFee") != m.end() && !m["PostPaidLimitFee"].empty()) {
      postPaidLimitFee = make_shared<double>(boost::any_cast<double>(m["PostPaidLimitFee"]));
    }
    if (m.find("TotalDuration") != m.end() && !m["TotalDuration"].empty()) {
      totalDuration = make_shared<long>(boost::any_cast<long>(m["TotalDuration"]));
    }
    if (m.find("UsedDuration") != m.end() && !m["UsedDuration"].empty()) {
      usedDuration = make_shared<long>(boost::any_cast<long>(m["UsedDuration"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsDesktopDurationList() = default;
};
class DescribeDesktopsResponseBodyDesktopsDisks : public Darabonba::Model {
public:
  shared_ptr<string> diskCategory{};
  shared_ptr<string> diskId{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> diskType{};
  shared_ptr<string> performanceLevel{};

  DescribeDesktopsResponseBodyDesktopsDisks() {}

  explicit DescribeDesktopsResponseBodyDesktopsDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsDisks() = default;
};
class DescribeDesktopsResponseBodyDesktopsFotaUpdate : public Darabonba::Model {
public:
  shared_ptr<string> currentAppVersion{};
  shared_ptr<string> newAppVersion{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> releaseNoteEn{};
  shared_ptr<string> releaseNoteJp{};
  shared_ptr<long> size{};

  DescribeDesktopsResponseBodyDesktopsFotaUpdate() {}

  explicit DescribeDesktopsResponseBodyDesktopsFotaUpdate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentAppVersion) {
      res["CurrentAppVersion"] = boost::any(*currentAppVersion);
    }
    if (newAppVersion) {
      res["NewAppVersion"] = boost::any(*newAppVersion);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (releaseNoteEn) {
      res["ReleaseNoteEn"] = boost::any(*releaseNoteEn);
    }
    if (releaseNoteJp) {
      res["ReleaseNoteJp"] = boost::any(*releaseNoteJp);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentAppVersion") != m.end() && !m["CurrentAppVersion"].empty()) {
      currentAppVersion = make_shared<string>(boost::any_cast<string>(m["CurrentAppVersion"]));
    }
    if (m.find("NewAppVersion") != m.end() && !m["NewAppVersion"].empty()) {
      newAppVersion = make_shared<string>(boost::any_cast<string>(m["NewAppVersion"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("ReleaseNoteEn") != m.end() && !m["ReleaseNoteEn"].empty()) {
      releaseNoteEn = make_shared<string>(boost::any_cast<string>(m["ReleaseNoteEn"]));
    }
    if (m.find("ReleaseNoteJp") != m.end() && !m["ReleaseNoteJp"].empty()) {
      releaseNoteJp = make_shared<string>(boost::any_cast<string>(m["ReleaseNoteJp"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsFotaUpdate() = default;
};
class DescribeDesktopsResponseBodyDesktopsOsUpdatePackages : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> kb{};
  shared_ptr<string> title{};

  DescribeDesktopsResponseBodyDesktopsOsUpdatePackages() {}

  explicit DescribeDesktopsResponseBodyDesktopsOsUpdatePackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (kb) {
      res["Kb"] = boost::any(*kb);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Kb") != m.end() && !m["Kb"].empty()) {
      kb = make_shared<string>(boost::any_cast<string>(m["Kb"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsOsUpdatePackages() = default;
};
class DescribeDesktopsResponseBodyDesktopsOsUpdate : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<long> packageCount{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsOsUpdatePackages>> packages{};

  DescribeDesktopsResponseBodyDesktopsOsUpdate() {}

  explicit DescribeDesktopsResponseBodyDesktopsOsUpdate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (packageCount) {
      res["PackageCount"] = boost::any(*packageCount);
    }
    if (packages) {
      vector<boost::any> temp1;
      for(auto item1:*packages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Packages"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["CheckId"]));
    }
    if (m.find("PackageCount") != m.end() && !m["PackageCount"].empty()) {
      packageCount = make_shared<long>(boost::any_cast<long>(m["PackageCount"]));
    }
    if (m.find("Packages") != m.end() && !m["Packages"].empty()) {
      if (typeid(vector<boost::any>) == m["Packages"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsOsUpdatePackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Packages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsOsUpdatePackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packages = make_shared<vector<DescribeDesktopsResponseBodyDesktopsOsUpdatePackages>>(expect1);
      }
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsOsUpdate() = default;
};
class DescribeDesktopsResponseBodyDesktopsResourceGroups : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribeDesktopsResponseBodyDesktopsResourceGroups() {}

  explicit DescribeDesktopsResponseBodyDesktopsResourceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsResourceGroups() = default;
};
class DescribeDesktopsResponseBodyDesktopsSessions : public Darabonba::Model {
public:
  shared_ptr<string> endUserId{};
  shared_ptr<string> establishmentTime{};
  shared_ptr<string> externalUserName{};

  DescribeDesktopsResponseBodyDesktopsSessions() {}

  explicit DescribeDesktopsResponseBodyDesktopsSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (establishmentTime) {
      res["EstablishmentTime"] = boost::any(*establishmentTime);
    }
    if (externalUserName) {
      res["ExternalUserName"] = boost::any(*externalUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EstablishmentTime") != m.end() && !m["EstablishmentTime"].empty()) {
      establishmentTime = make_shared<string>(boost::any_cast<string>(m["EstablishmentTime"]));
    }
    if (m.find("ExternalUserName") != m.end() && !m["ExternalUserName"].empty()) {
      externalUserName = make_shared<string>(boost::any_cast<string>(m["ExternalUserName"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsSessions() = default;
};
class DescribeDesktopsResponseBodyDesktopsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDesktopsResponseBodyDesktopsTags() {}

  explicit DescribeDesktopsResponseBodyDesktopsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktopsTags() = default;
};
class DescribeDesktopsResponseBodyDesktops : public Darabonba::Model {
public:
  shared_ptr<long> bindAmount{};
  shared_ptr<string> bundleId{};
  shared_ptr<string> bundleName{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> connectionStatus{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> dataDiskSize{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsDesktopDurationList>> desktopDurationList{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryType{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsDisks>> disks{};
  shared_ptr<long> downgradeQuota{};
  shared_ptr<long> downgradedTimes{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> expiredTime{};
  shared_ptr<DescribeDesktopsResponseBodyDesktopsFotaUpdate> fotaUpdate{};
  shared_ptr<long> gpuCategory{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<bool> hibernationBeta{};
  shared_ptr<bool> hibernationOptionsConfigured{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<bool> isLdap{};
  shared_ptr<string> managementFlag{};
  shared_ptr<vector<string>> managementFlags{};
  shared_ptr<long> memory{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> networkInterfaceIp{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> officeSiteVpcType{};
  shared_ptr<string> osType{};
  shared_ptr<DescribeDesktopsResponseBodyDesktopsOsUpdate> osUpdate{};
  shared_ptr<string> platform{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<vector<string>> policyGroupIdList{};
  shared_ptr<string> policyGroupName{};
  shared_ptr<vector<string>> policyGroupNameList{};
  shared_ptr<string> progress{};
  shared_ptr<string> protocolType{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsResourceGroups>> resourceGroups{};
  shared_ptr<string> sessionType{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsSessions>> sessions{};
  shared_ptr<string> snapshotPolicyId{};
  shared_ptr<string> snapshotPolicyName{};
  shared_ptr<string> standardStartTime{};
  shared_ptr<string> startTime{};
  shared_ptr<bool> supportHibernation{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktopsTags>> tags{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};
  shared_ptr<string> zoneType{};

  DescribeDesktopsResponseBodyDesktops() {}

  explicit DescribeDesktopsResponseBodyDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindAmount) {
      res["BindAmount"] = boost::any(*bindAmount);
    }
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleName) {
      res["BundleName"] = boost::any(*bundleName);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (desktopDurationList) {
      vector<boost::any> temp1;
      for(auto item1:*desktopDurationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopDurationList"] = boost::any(temp1);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryType) {
      res["DirectoryType"] = boost::any(*directoryType);
    }
    if (disks) {
      vector<boost::any> temp1;
      for(auto item1:*disks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disks"] = boost::any(temp1);
    }
    if (downgradeQuota) {
      res["DowngradeQuota"] = boost::any(*downgradeQuota);
    }
    if (downgradedTimes) {
      res["DowngradedTimes"] = boost::any(*downgradedTimes);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (fotaUpdate) {
      res["FotaUpdate"] = fotaUpdate ? boost::any(fotaUpdate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gpuCategory) {
      res["GpuCategory"] = boost::any(*gpuCategory);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (hibernationBeta) {
      res["HibernationBeta"] = boost::any(*hibernationBeta);
    }
    if (hibernationOptionsConfigured) {
      res["HibernationOptionsConfigured"] = boost::any(*hibernationOptionsConfigured);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (isLdap) {
      res["IsLdap"] = boost::any(*isLdap);
    }
    if (managementFlag) {
      res["ManagementFlag"] = boost::any(*managementFlag);
    }
    if (managementFlags) {
      res["ManagementFlags"] = boost::any(*managementFlags);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceIp) {
      res["NetworkInterfaceIp"] = boost::any(*networkInterfaceIp);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (officeSiteVpcType) {
      res["OfficeSiteVpcType"] = boost::any(*officeSiteVpcType);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (osUpdate) {
      res["OsUpdate"] = osUpdate ? boost::any(osUpdate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupIdList) {
      res["PolicyGroupIdList"] = boost::any(*policyGroupIdList);
    }
    if (policyGroupName) {
      res["PolicyGroupName"] = boost::any(*policyGroupName);
    }
    if (policyGroupNameList) {
      res["PolicyGroupNameList"] = boost::any(*policyGroupNameList);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (resourceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*resourceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceGroups"] = boost::any(temp1);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    if (snapshotPolicyId) {
      res["SnapshotPolicyId"] = boost::any(*snapshotPolicyId);
    }
    if (snapshotPolicyName) {
      res["SnapshotPolicyName"] = boost::any(*snapshotPolicyName);
    }
    if (standardStartTime) {
      res["StandardStartTime"] = boost::any(*standardStartTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (supportHibernation) {
      res["SupportHibernation"] = boost::any(*supportHibernation);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    if (zoneType) {
      res["ZoneType"] = boost::any(*zoneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindAmount") != m.end() && !m["BindAmount"].empty()) {
      bindAmount = make_shared<long>(boost::any_cast<long>(m["BindAmount"]));
    }
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BundleName") != m.end() && !m["BundleName"].empty()) {
      bundleName = make_shared<string>(boost::any_cast<string>(m["BundleName"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("DesktopDurationList") != m.end() && !m["DesktopDurationList"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopDurationList"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsDesktopDurationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopDurationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsDesktopDurationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopDurationList = make_shared<vector<DescribeDesktopsResponseBodyDesktopsDesktopDurationList>>(expect1);
      }
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryType") != m.end() && !m["DirectoryType"].empty()) {
      directoryType = make_shared<string>(boost::any_cast<string>(m["DirectoryType"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(vector<boost::any>) == m["Disks"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disks = make_shared<vector<DescribeDesktopsResponseBodyDesktopsDisks>>(expect1);
      }
    }
    if (m.find("DowngradeQuota") != m.end() && !m["DowngradeQuota"].empty()) {
      downgradeQuota = make_shared<long>(boost::any_cast<long>(m["DowngradeQuota"]));
    }
    if (m.find("DowngradedTimes") != m.end() && !m["DowngradedTimes"].empty()) {
      downgradedTimes = make_shared<long>(boost::any_cast<long>(m["DowngradedTimes"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("FotaUpdate") != m.end() && !m["FotaUpdate"].empty()) {
      if (typeid(map<string, boost::any>) == m["FotaUpdate"].type()) {
        DescribeDesktopsResponseBodyDesktopsFotaUpdate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FotaUpdate"]));
        fotaUpdate = make_shared<DescribeDesktopsResponseBodyDesktopsFotaUpdate>(model1);
      }
    }
    if (m.find("GpuCategory") != m.end() && !m["GpuCategory"].empty()) {
      gpuCategory = make_shared<long>(boost::any_cast<long>(m["GpuCategory"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("HibernationBeta") != m.end() && !m["HibernationBeta"].empty()) {
      hibernationBeta = make_shared<bool>(boost::any_cast<bool>(m["HibernationBeta"]));
    }
    if (m.find("HibernationOptionsConfigured") != m.end() && !m["HibernationOptionsConfigured"].empty()) {
      hibernationOptionsConfigured = make_shared<bool>(boost::any_cast<bool>(m["HibernationOptionsConfigured"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("IsLdap") != m.end() && !m["IsLdap"].empty()) {
      isLdap = make_shared<bool>(boost::any_cast<bool>(m["IsLdap"]));
    }
    if (m.find("ManagementFlag") != m.end() && !m["ManagementFlag"].empty()) {
      managementFlag = make_shared<string>(boost::any_cast<string>(m["ManagementFlag"]));
    }
    if (m.find("ManagementFlags") != m.end() && !m["ManagementFlags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ManagementFlags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ManagementFlags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managementFlags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceIp") != m.end() && !m["NetworkInterfaceIp"].empty()) {
      networkInterfaceIp = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceIp"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("OfficeSiteVpcType") != m.end() && !m["OfficeSiteVpcType"].empty()) {
      officeSiteVpcType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteVpcType"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OsUpdate") != m.end() && !m["OsUpdate"].empty()) {
      if (typeid(map<string, boost::any>) == m["OsUpdate"].type()) {
        DescribeDesktopsResponseBodyDesktopsOsUpdate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OsUpdate"]));
        osUpdate = make_shared<DescribeDesktopsResponseBodyDesktopsOsUpdate>(model1);
      }
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupIdList") != m.end() && !m["PolicyGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyGroupName") != m.end() && !m["PolicyGroupName"].empty()) {
      policyGroupName = make_shared<string>(boost::any_cast<string>(m["PolicyGroupName"]));
    }
    if (m.find("PolicyGroupNameList") != m.end() && !m["PolicyGroupNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ResourceGroups") != m.end() && !m["ResourceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceGroups"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsResourceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsResourceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceGroups = make_shared<vector<DescribeDesktopsResponseBodyDesktopsResourceGroups>>(expect1);
      }
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<DescribeDesktopsResponseBodyDesktopsSessions>>(expect1);
      }
    }
    if (m.find("SnapshotPolicyId") != m.end() && !m["SnapshotPolicyId"].empty()) {
      snapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyId"]));
    }
    if (m.find("SnapshotPolicyName") != m.end() && !m["SnapshotPolicyName"].empty()) {
      snapshotPolicyName = make_shared<string>(boost::any_cast<string>(m["SnapshotPolicyName"]));
    }
    if (m.find("StandardStartTime") != m.end() && !m["StandardStartTime"].empty()) {
      standardStartTime = make_shared<string>(boost::any_cast<string>(m["StandardStartTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SupportHibernation") != m.end() && !m["SupportHibernation"].empty()) {
      supportHibernation = make_shared<bool>(boost::any_cast<bool>(m["SupportHibernation"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDesktopsResponseBodyDesktopsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktopsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDesktopsResponseBodyDesktopsTags>>(expect1);
      }
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
    if (m.find("ZoneType") != m.end() && !m["ZoneType"].empty()) {
      zoneType = make_shared<string>(boost::any_cast<string>(m["ZoneType"]));
    }
  }


  virtual ~DescribeDesktopsResponseBodyDesktops() = default;
};
class DescribeDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDesktopsResponseBodyDesktops>> desktops{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDesktopsResponseBody() {}

  explicit DescribeDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktops) {
      vector<boost::any> temp1;
      for(auto item1:*desktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Desktops"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desktops") != m.end() && !m["Desktops"].empty()) {
      if (typeid(vector<boost::any>) == m["Desktops"].type()) {
        vector<DescribeDesktopsResponseBodyDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Desktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsResponseBodyDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktops = make_shared<vector<DescribeDesktopsResponseBodyDesktops>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDesktopsResponseBody() = default;
};
class DescribeDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopsResponseBody> body{};

  DescribeDesktopsResponse() {}

  explicit DescribeDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopsResponse() = default;
};
class DescribeDesktopsInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> customEndTimePeriod{};
  shared_ptr<long> customStartTimePeriod{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<bool> ignoreDeleted{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};

  DescribeDesktopsInGroupRequest() {}

  explicit DescribeDesktopsInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEndTimePeriod) {
      res["CustomEndTimePeriod"] = boost::any(*customEndTimePeriod);
    }
    if (customStartTimePeriod) {
      res["CustomStartTimePeriod"] = boost::any(*customStartTimePeriod);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (ignoreDeleted) {
      res["IgnoreDeleted"] = boost::any(*ignoreDeleted);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEndTimePeriod") != m.end() && !m["CustomEndTimePeriod"].empty()) {
      customEndTimePeriod = make_shared<long>(boost::any_cast<long>(m["CustomEndTimePeriod"]));
    }
    if (m.find("CustomStartTimePeriod") != m.end() && !m["CustomStartTimePeriod"].empty()) {
      customStartTimePeriod = make_shared<long>(boost::any_cast<long>(m["CustomStartTimePeriod"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("IgnoreDeleted") != m.end() && !m["IgnoreDeleted"].empty()) {
      ignoreDeleted = make_shared<bool>(boost::any_cast<bool>(m["IgnoreDeleted"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDesktopsInGroupRequest() = default;
};
class DescribeDesktopsInGroupResponseBodyPaidDesktops : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<string> diskType{};
  shared_ptr<string> endUserId{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> endUserName{};
  shared_ptr<vector<string>> endUserNames{};
  shared_ptr<string> fotaVersion{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> managementFlag{};
  shared_ptr<vector<string>> managementFlags{};
  shared_ptr<string> memberEniIp{};
  shared_ptr<string> osType{};
  shared_ptr<string> primaryEniIp{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> resetTime{};
  shared_ptr<long> systemDiskSize{};

  DescribeDesktopsInGroupResponseBodyPaidDesktops() {}

  explicit DescribeDesktopsInGroupResponseBodyPaidDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (endUserName) {
      res["EndUserName"] = boost::any(*endUserName);
    }
    if (endUserNames) {
      res["EndUserNames"] = boost::any(*endUserNames);
    }
    if (fotaVersion) {
      res["FotaVersion"] = boost::any(*fotaVersion);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (managementFlag) {
      res["ManagementFlag"] = boost::any(*managementFlag);
    }
    if (managementFlags) {
      res["ManagementFlags"] = boost::any(*managementFlags);
    }
    if (memberEniIp) {
      res["MemberEniIp"] = boost::any(*memberEniIp);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (primaryEniIp) {
      res["PrimaryEniIp"] = boost::any(*primaryEniIp);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (resetTime) {
      res["ResetTime"] = boost::any(*resetTime);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserName") != m.end() && !m["EndUserName"].empty()) {
      endUserName = make_shared<string>(boost::any_cast<string>(m["EndUserName"]));
    }
    if (m.find("EndUserNames") != m.end() && !m["EndUserNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FotaVersion") != m.end() && !m["FotaVersion"].empty()) {
      fotaVersion = make_shared<string>(boost::any_cast<string>(m["FotaVersion"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ManagementFlag") != m.end() && !m["ManagementFlag"].empty()) {
      managementFlag = make_shared<string>(boost::any_cast<string>(m["ManagementFlag"]));
    }
    if (m.find("ManagementFlags") != m.end() && !m["ManagementFlags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ManagementFlags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ManagementFlags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managementFlags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemberEniIp") != m.end() && !m["MemberEniIp"].empty()) {
      memberEniIp = make_shared<string>(boost::any_cast<string>(m["MemberEniIp"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("PrimaryEniIp") != m.end() && !m["PrimaryEniIp"].empty()) {
      primaryEniIp = make_shared<string>(boost::any_cast<string>(m["PrimaryEniIp"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ResetTime") != m.end() && !m["ResetTime"].empty()) {
      resetTime = make_shared<string>(boost::any_cast<string>(m["ResetTime"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeDesktopsInGroupResponseBodyPaidDesktops() = default;
};
class DescribeDesktopsInGroupResponseBodyPostPaidDesktops : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<string> createDuration{};
  shared_ptr<string> createTime{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<string> diskType{};
  shared_ptr<string> endUserId{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> endUserName{};
  shared_ptr<vector<string>> endUserNames{};
  shared_ptr<string> fotaVersion{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> managementFlag{};
  shared_ptr<vector<string>> managementFlags{};
  shared_ptr<string> memberEniIp{};
  shared_ptr<string> osType{};
  shared_ptr<string> primaryEniIp{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> releaseTime{};
  shared_ptr<string> resetTime{};
  shared_ptr<long> systemDiskSize{};

  DescribeDesktopsInGroupResponseBodyPostPaidDesktops() {}

  explicit DescribeDesktopsInGroupResponseBodyPostPaidDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (createDuration) {
      res["CreateDuration"] = boost::any(*createDuration);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (endUserName) {
      res["EndUserName"] = boost::any(*endUserName);
    }
    if (endUserNames) {
      res["EndUserNames"] = boost::any(*endUserNames);
    }
    if (fotaVersion) {
      res["FotaVersion"] = boost::any(*fotaVersion);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (managementFlag) {
      res["ManagementFlag"] = boost::any(*managementFlag);
    }
    if (managementFlags) {
      res["ManagementFlags"] = boost::any(*managementFlags);
    }
    if (memberEniIp) {
      res["MemberEniIp"] = boost::any(*memberEniIp);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (primaryEniIp) {
      res["PrimaryEniIp"] = boost::any(*primaryEniIp);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (resetTime) {
      res["ResetTime"] = boost::any(*resetTime);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("CreateDuration") != m.end() && !m["CreateDuration"].empty()) {
      createDuration = make_shared<string>(boost::any_cast<string>(m["CreateDuration"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserName") != m.end() && !m["EndUserName"].empty()) {
      endUserName = make_shared<string>(boost::any_cast<string>(m["EndUserName"]));
    }
    if (m.find("EndUserNames") != m.end() && !m["EndUserNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FotaVersion") != m.end() && !m["FotaVersion"].empty()) {
      fotaVersion = make_shared<string>(boost::any_cast<string>(m["FotaVersion"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ManagementFlag") != m.end() && !m["ManagementFlag"].empty()) {
      managementFlag = make_shared<string>(boost::any_cast<string>(m["ManagementFlag"]));
    }
    if (m.find("ManagementFlags") != m.end() && !m["ManagementFlags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ManagementFlags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ManagementFlags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managementFlags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemberEniIp") != m.end() && !m["MemberEniIp"].empty()) {
      memberEniIp = make_shared<string>(boost::any_cast<string>(m["MemberEniIp"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("PrimaryEniIp") != m.end() && !m["PrimaryEniIp"].empty()) {
      primaryEniIp = make_shared<string>(boost::any_cast<string>(m["PrimaryEniIp"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<string>(boost::any_cast<string>(m["ReleaseTime"]));
    }
    if (m.find("ResetTime") != m.end() && !m["ResetTime"].empty()) {
      resetTime = make_shared<string>(boost::any_cast<string>(m["ResetTime"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeDesktopsInGroupResponseBodyPostPaidDesktops() = default;
};
class DescribeDesktopsInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> onlinePrePaidDesktopsCount{};
  shared_ptr<vector<DescribeDesktopsInGroupResponseBodyPaidDesktops>> paidDesktops{};
  shared_ptr<long> paidDesktopsCount{};
  shared_ptr<vector<DescribeDesktopsInGroupResponseBodyPostPaidDesktops>> postPaidDesktops{};
  shared_ptr<long> postPaidDesktopsCount{};
  shared_ptr<long> postPaidDesktopsTotalAmount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> runningPrePaidDesktopsCount{};
  shared_ptr<long> stopedPrePaidDesktopsCount{};
  shared_ptr<long> stoppedPrePaidDesktopsCount{};

  DescribeDesktopsInGroupResponseBody() {}

  explicit DescribeDesktopsInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (onlinePrePaidDesktopsCount) {
      res["OnlinePrePaidDesktopsCount"] = boost::any(*onlinePrePaidDesktopsCount);
    }
    if (paidDesktops) {
      vector<boost::any> temp1;
      for(auto item1:*paidDesktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PaidDesktops"] = boost::any(temp1);
    }
    if (paidDesktopsCount) {
      res["PaidDesktopsCount"] = boost::any(*paidDesktopsCount);
    }
    if (postPaidDesktops) {
      vector<boost::any> temp1;
      for(auto item1:*postPaidDesktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PostPaidDesktops"] = boost::any(temp1);
    }
    if (postPaidDesktopsCount) {
      res["PostPaidDesktopsCount"] = boost::any(*postPaidDesktopsCount);
    }
    if (postPaidDesktopsTotalAmount) {
      res["PostPaidDesktopsTotalAmount"] = boost::any(*postPaidDesktopsTotalAmount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (runningPrePaidDesktopsCount) {
      res["RunningPrePaidDesktopsCount"] = boost::any(*runningPrePaidDesktopsCount);
    }
    if (stopedPrePaidDesktopsCount) {
      res["StopedPrePaidDesktopsCount"] = boost::any(*stopedPrePaidDesktopsCount);
    }
    if (stoppedPrePaidDesktopsCount) {
      res["StoppedPrePaidDesktopsCount"] = boost::any(*stoppedPrePaidDesktopsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OnlinePrePaidDesktopsCount") != m.end() && !m["OnlinePrePaidDesktopsCount"].empty()) {
      onlinePrePaidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["OnlinePrePaidDesktopsCount"]));
    }
    if (m.find("PaidDesktops") != m.end() && !m["PaidDesktops"].empty()) {
      if (typeid(vector<boost::any>) == m["PaidDesktops"].type()) {
        vector<DescribeDesktopsInGroupResponseBodyPaidDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PaidDesktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsInGroupResponseBodyPaidDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paidDesktops = make_shared<vector<DescribeDesktopsInGroupResponseBodyPaidDesktops>>(expect1);
      }
    }
    if (m.find("PaidDesktopsCount") != m.end() && !m["PaidDesktopsCount"].empty()) {
      paidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["PaidDesktopsCount"]));
    }
    if (m.find("PostPaidDesktops") != m.end() && !m["PostPaidDesktops"].empty()) {
      if (typeid(vector<boost::any>) == m["PostPaidDesktops"].type()) {
        vector<DescribeDesktopsInGroupResponseBodyPostPaidDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PostPaidDesktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDesktopsInGroupResponseBodyPostPaidDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        postPaidDesktops = make_shared<vector<DescribeDesktopsInGroupResponseBodyPostPaidDesktops>>(expect1);
      }
    }
    if (m.find("PostPaidDesktopsCount") != m.end() && !m["PostPaidDesktopsCount"].empty()) {
      postPaidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["PostPaidDesktopsCount"]));
    }
    if (m.find("PostPaidDesktopsTotalAmount") != m.end() && !m["PostPaidDesktopsTotalAmount"].empty()) {
      postPaidDesktopsTotalAmount = make_shared<long>(boost::any_cast<long>(m["PostPaidDesktopsTotalAmount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RunningPrePaidDesktopsCount") != m.end() && !m["RunningPrePaidDesktopsCount"].empty()) {
      runningPrePaidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["RunningPrePaidDesktopsCount"]));
    }
    if (m.find("StopedPrePaidDesktopsCount") != m.end() && !m["StopedPrePaidDesktopsCount"].empty()) {
      stopedPrePaidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["StopedPrePaidDesktopsCount"]));
    }
    if (m.find("StoppedPrePaidDesktopsCount") != m.end() && !m["StoppedPrePaidDesktopsCount"].empty()) {
      stoppedPrePaidDesktopsCount = make_shared<long>(boost::any_cast<long>(m["StoppedPrePaidDesktopsCount"]));
    }
  }


  virtual ~DescribeDesktopsInGroupResponseBody() = default;
};
class DescribeDesktopsInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDesktopsInGroupResponseBody> body{};

  DescribeDesktopsInGroupResponse() {}

  explicit DescribeDesktopsInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDesktopsInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDesktopsInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDesktopsInGroupResponse() = default;
};
class DescribeDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> adDomain{};
  shared_ptr<string> clientType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> userType{};

  DescribeDevicesRequest() {}

  explicit DescribeDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adDomain) {
      res["AdDomain"] = boost::any(*adDomain);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdDomain") != m.end() && !m["AdDomain"].empty()) {
      adDomain = make_shared<string>(boost::any_cast<string>(m["AdDomain"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~DescribeDevicesRequest() = default;
};
class DescribeDevicesResponseBodyDevicesEndUserList : public Darabonba::Model {
public:
  shared_ptr<string> adDomain{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> userType{};

  DescribeDevicesResponseBodyDevicesEndUserList() {}

  explicit DescribeDevicesResponseBodyDevicesEndUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adDomain) {
      res["AdDomain"] = boost::any(*adDomain);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdDomain") != m.end() && !m["AdDomain"].empty()) {
      adDomain = make_shared<string>(boost::any_cast<string>(m["AdDomain"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~DescribeDevicesResponseBodyDevicesEndUserList() = default;
};
class DescribeDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<vector<DescribeDevicesResponseBodyDevicesEndUserList>> endUserList{};

  DescribeDevicesResponseBodyDevices() {}

  explicit DescribeDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (endUserList) {
      vector<boost::any> temp1;
      for(auto item1:*endUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndUserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("EndUserList") != m.end() && !m["EndUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["EndUserList"].type()) {
        vector<DescribeDevicesResponseBodyDevicesEndUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDevicesResponseBodyDevicesEndUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endUserList = make_shared<vector<DescribeDevicesResponseBodyDevicesEndUserList>>(expect1);
      }
    }
  }


  virtual ~DescribeDevicesResponseBodyDevices() = default;
};
class DescribeDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDevicesResponseBodyDevices>> devices{};
  shared_ptr<string> requestId{};

  DescribeDevicesResponseBody() {}

  explicit DescribeDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<DescribeDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<DescribeDevicesResponseBodyDevices>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDevicesResponseBody() = default;
};
class DescribeDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDevicesResponseBody> body{};

  DescribeDevicesResponse() {}

  explicit DescribeDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDevicesResponse() = default;
};
class DescribeDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> directoryId{};
  shared_ptr<string> directoryStatus{};
  shared_ptr<string> directoryType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribeDirectoriesRequest() {}

  explicit DescribeDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryStatus) {
      res["DirectoryStatus"] = boost::any(*directoryStatus);
    }
    if (directoryType) {
      res["DirectoryType"] = boost::any(*directoryType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DirectoryId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DirectoryId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      directoryId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DirectoryStatus") != m.end() && !m["DirectoryStatus"].empty()) {
      directoryStatus = make_shared<string>(boost::any_cast<string>(m["DirectoryStatus"]));
    }
    if (m.find("DirectoryType") != m.end() && !m["DirectoryType"].empty()) {
      directoryType = make_shared<string>(boost::any_cast<string>(m["DirectoryType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDirectoriesRequest() = default;
};
class DescribeDirectoriesResponseBodyDirectoriesADConnectors : public Darabonba::Model {
public:
  shared_ptr<string> ADConnectorAddress{};
  shared_ptr<string> connectorStatus{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> specification{};
  shared_ptr<string> trustKey{};
  shared_ptr<string> vSwitchId{};

  DescribeDirectoriesResponseBodyDirectoriesADConnectors() {}

  explicit DescribeDirectoriesResponseBodyDirectoriesADConnectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ADConnectorAddress) {
      res["ADConnectorAddress"] = boost::any(*ADConnectorAddress);
    }
    if (connectorStatus) {
      res["ConnectorStatus"] = boost::any(*connectorStatus);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (trustKey) {
      res["TrustKey"] = boost::any(*trustKey);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ADConnectorAddress") != m.end() && !m["ADConnectorAddress"].empty()) {
      ADConnectorAddress = make_shared<string>(boost::any_cast<string>(m["ADConnectorAddress"]));
    }
    if (m.find("ConnectorStatus") != m.end() && !m["ConnectorStatus"].empty()) {
      connectorStatus = make_shared<string>(boost::any_cast<string>(m["ConnectorStatus"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("TrustKey") != m.end() && !m["TrustKey"].empty()) {
      trustKey = make_shared<string>(boost::any_cast<string>(m["TrustKey"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBodyDirectoriesADConnectors() = default;
};
class DescribeDirectoriesResponseBodyDirectoriesLogs : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> step{};
  shared_ptr<string> timeStamp{};

  DescribeDirectoriesResponseBodyDirectoriesLogs() {}

  explicit DescribeDirectoriesResponseBodyDirectoriesLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<string>(boost::any_cast<string>(m["Step"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBodyDirectoriesLogs() = default;
};
class DescribeDirectoriesResponseBodyDirectories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDirectoriesResponseBodyDirectoriesADConnectors>> ADConnectors{};
  shared_ptr<string> adHostname{};
  shared_ptr<string> backupDCHostname{};
  shared_ptr<string> backupDns{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> customSecurityGroupId{};
  shared_ptr<string> desktopAccessType{};
  shared_ptr<string> desktopVpcEndpoint{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryType{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> dnsUserName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> enableCrossDesktopAccess{};
  shared_ptr<bool> enableInternetAccess{};
  shared_ptr<vector<string>> fileSystemIds{};
  shared_ptr<vector<DescribeDirectoriesResponseBodyDirectoriesLogs>> logs{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> name{};
  shared_ptr<bool> needVerifyLoginRisk{};
  shared_ptr<string> ouName{};
  shared_ptr<bool> ssoEnabled{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> subDnsAddress{};
  shared_ptr<string> subDomainName{};
  shared_ptr<string> trustPassword{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  DescribeDirectoriesResponseBodyDirectories() {}

  explicit DescribeDirectoriesResponseBodyDirectories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ADConnectors) {
      vector<boost::any> temp1;
      for(auto item1:*ADConnectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ADConnectors"] = boost::any(temp1);
    }
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (backupDCHostname) {
      res["BackupDCHostname"] = boost::any(*backupDCHostname);
    }
    if (backupDns) {
      res["BackupDns"] = boost::any(*backupDns);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (customSecurityGroupId) {
      res["CustomSecurityGroupId"] = boost::any(*customSecurityGroupId);
    }
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (desktopVpcEndpoint) {
      res["DesktopVpcEndpoint"] = boost::any(*desktopVpcEndpoint);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryType) {
      res["DirectoryType"] = boost::any(*directoryType);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (dnsUserName) {
      res["DnsUserName"] = boost::any(*dnsUserName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (enableCrossDesktopAccess) {
      res["EnableCrossDesktopAccess"] = boost::any(*enableCrossDesktopAccess);
    }
    if (enableInternetAccess) {
      res["EnableInternetAccess"] = boost::any(*enableInternetAccess);
    }
    if (fileSystemIds) {
      res["FileSystemIds"] = boost::any(*fileSystemIds);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needVerifyLoginRisk) {
      res["NeedVerifyLoginRisk"] = boost::any(*needVerifyLoginRisk);
    }
    if (ouName) {
      res["OuName"] = boost::any(*ouName);
    }
    if (ssoEnabled) {
      res["SsoEnabled"] = boost::any(*ssoEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDnsAddress) {
      res["SubDnsAddress"] = boost::any(*subDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    if (trustPassword) {
      res["TrustPassword"] = boost::any(*trustPassword);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ADConnectors") != m.end() && !m["ADConnectors"].empty()) {
      if (typeid(vector<boost::any>) == m["ADConnectors"].type()) {
        vector<DescribeDirectoriesResponseBodyDirectoriesADConnectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ADConnectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDirectoriesResponseBodyDirectoriesADConnectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ADConnectors = make_shared<vector<DescribeDirectoriesResponseBodyDirectoriesADConnectors>>(expect1);
      }
    }
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("BackupDCHostname") != m.end() && !m["BackupDCHostname"].empty()) {
      backupDCHostname = make_shared<string>(boost::any_cast<string>(m["BackupDCHostname"]));
    }
    if (m.find("BackupDns") != m.end() && !m["BackupDns"].empty()) {
      backupDns = make_shared<string>(boost::any_cast<string>(m["BackupDns"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CustomSecurityGroupId") != m.end() && !m["CustomSecurityGroupId"].empty()) {
      customSecurityGroupId = make_shared<string>(boost::any_cast<string>(m["CustomSecurityGroupId"]));
    }
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("DesktopVpcEndpoint") != m.end() && !m["DesktopVpcEndpoint"].empty()) {
      desktopVpcEndpoint = make_shared<string>(boost::any_cast<string>(m["DesktopVpcEndpoint"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryType") != m.end() && !m["DirectoryType"].empty()) {
      directoryType = make_shared<string>(boost::any_cast<string>(m["DirectoryType"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsUserName") != m.end() && !m["DnsUserName"].empty()) {
      dnsUserName = make_shared<string>(boost::any_cast<string>(m["DnsUserName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("EnableCrossDesktopAccess") != m.end() && !m["EnableCrossDesktopAccess"].empty()) {
      enableCrossDesktopAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossDesktopAccess"]));
    }
    if (m.find("EnableInternetAccess") != m.end() && !m["EnableInternetAccess"].empty()) {
      enableInternetAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAccess"]));
    }
    if (m.find("FileSystemIds") != m.end() && !m["FileSystemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileSystemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileSystemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileSystemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribeDirectoriesResponseBodyDirectoriesLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDirectoriesResponseBodyDirectoriesLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribeDirectoriesResponseBodyDirectoriesLogs>>(expect1);
      }
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedVerifyLoginRisk") != m.end() && !m["NeedVerifyLoginRisk"].empty()) {
      needVerifyLoginRisk = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyLoginRisk"]));
    }
    if (m.find("OuName") != m.end() && !m["OuName"].empty()) {
      ouName = make_shared<string>(boost::any_cast<string>(m["OuName"]));
    }
    if (m.find("SsoEnabled") != m.end() && !m["SsoEnabled"].empty()) {
      ssoEnabled = make_shared<bool>(boost::any_cast<bool>(m["SsoEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDnsAddress") != m.end() && !m["SubDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
    if (m.find("TrustPassword") != m.end() && !m["TrustPassword"].empty()) {
      trustPassword = make_shared<string>(boost::any_cast<string>(m["TrustPassword"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBodyDirectories() = default;
};
class DescribeDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> adHostname{};
  shared_ptr<vector<DescribeDirectoriesResponseBodyDirectories>> directories{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDirectoriesResponseBody() {}

  explicit DescribeDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (directories) {
      vector<boost::any> temp1;
      for(auto item1:*directories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Directories"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("Directories") != m.end() && !m["Directories"].empty()) {
      if (typeid(vector<boost::any>) == m["Directories"].type()) {
        vector<DescribeDirectoriesResponseBodyDirectories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Directories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDirectoriesResponseBodyDirectories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        directories = make_shared<vector<DescribeDirectoriesResponseBodyDirectories>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBody() = default;
};
class DescribeDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDirectoriesResponseBody> body{};

  DescribeDirectoriesResponse() {}

  explicit DescribeDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDirectoriesResponse() = default;
};
class DescribeFlowMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> metricType{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeFlowMetricRequest() {}

  explicit DescribeFlowMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeFlowMetricRequest() = default;
};
class DescribeFlowMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeFlowMetricResponseBody() {}

  explicit DescribeFlowMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowMetricResponseBody() = default;
};
class DescribeFlowMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowMetricResponseBody> body{};

  DescribeFlowMetricResponse() {}

  explicit DescribeFlowMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowMetricResponse() = default;
};
class DescribeFlowStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};

  DescribeFlowStatisticRequest() {}

  explicit DescribeFlowStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowStatisticRequest() = default;
};
class DescribeFlowStatisticResponseBodyDesktopFlowStatistic : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> flowIn{};
  shared_ptr<long> flowRank{};

  DescribeFlowStatisticResponseBodyDesktopFlowStatistic() {}

  explicit DescribeFlowStatisticResponseBodyDesktopFlowStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (flowIn) {
      res["FlowIn"] = boost::any(*flowIn);
    }
    if (flowRank) {
      res["FlowRank"] = boost::any(*flowRank);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("FlowIn") != m.end() && !m["FlowIn"].empty()) {
      flowIn = make_shared<string>(boost::any_cast<string>(m["FlowIn"]));
    }
    if (m.find("FlowRank") != m.end() && !m["FlowRank"].empty()) {
      flowRank = make_shared<long>(boost::any_cast<long>(m["FlowRank"]));
    }
  }


  virtual ~DescribeFlowStatisticResponseBodyDesktopFlowStatistic() = default;
};
class DescribeFlowStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> desktopCount{};
  shared_ptr<vector<DescribeFlowStatisticResponseBodyDesktopFlowStatistic>> desktopFlowStatistic{};
  shared_ptr<string> requestId{};

  DescribeFlowStatisticResponseBody() {}

  explicit DescribeFlowStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopCount) {
      res["DesktopCount"] = boost::any(*desktopCount);
    }
    if (desktopFlowStatistic) {
      vector<boost::any> temp1;
      for(auto item1:*desktopFlowStatistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopFlowStatistic"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopCount") != m.end() && !m["DesktopCount"].empty()) {
      desktopCount = make_shared<long>(boost::any_cast<long>(m["DesktopCount"]));
    }
    if (m.find("DesktopFlowStatistic") != m.end() && !m["DesktopFlowStatistic"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopFlowStatistic"].type()) {
        vector<DescribeFlowStatisticResponseBodyDesktopFlowStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopFlowStatistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowStatisticResponseBodyDesktopFlowStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopFlowStatistic = make_shared<vector<DescribeFlowStatisticResponseBodyDesktopFlowStatistic>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowStatisticResponseBody() = default;
};
class DescribeFlowStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowStatisticResponseBody> body{};

  DescribeFlowStatisticResponse() {}

  explicit DescribeFlowStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowStatisticResponse() = default;
};
class DescribeFotaPendingDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskUid{};

  DescribeFotaPendingDesktopsRequest() {}

  explicit DescribeFotaPendingDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskUid) {
      res["TaskUid"] = boost::any(*taskUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskUid") != m.end() && !m["TaskUid"].empty()) {
      taskUid = make_shared<string>(boost::any_cast<string>(m["TaskUid"]));
    }
  }


  virtual ~DescribeFotaPendingDesktopsRequest() = default;
};
class DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions : public Darabonba::Model {
public:
  shared_ptr<string> endUserId{};

  DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions() {}

  explicit DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
  }


  virtual ~DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions() = default;
};
class DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops : public Darabonba::Model {
public:
  shared_ptr<string> currentAppVersion{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> fotaProject{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions>> sessions{};
  shared_ptr<long> status{};

  DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops() {}

  explicit DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentAppVersion) {
      res["CurrentAppVersion"] = boost::any(*currentAppVersion);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (fotaProject) {
      res["FotaProject"] = boost::any(*fotaProject);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentAppVersion") != m.end() && !m["CurrentAppVersion"].empty()) {
      currentAppVersion = make_shared<string>(boost::any_cast<string>(m["CurrentAppVersion"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("FotaProject") != m.end() && !m["FotaProject"].empty()) {
      fotaProject = make_shared<string>(boost::any_cast<string>(m["FotaProject"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops() = default;
};
class DescribeFotaPendingDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops>> fotaPendingDesktops{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeFotaPendingDesktopsResponseBody() {}

  explicit DescribeFotaPendingDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fotaPendingDesktops) {
      vector<boost::any> temp1;
      for(auto item1:*fotaPendingDesktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FotaPendingDesktops"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FotaPendingDesktops") != m.end() && !m["FotaPendingDesktops"].empty()) {
      if (typeid(vector<boost::any>) == m["FotaPendingDesktops"].type()) {
        vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FotaPendingDesktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fotaPendingDesktops = make_shared<vector<DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFotaPendingDesktopsResponseBody() = default;
};
class DescribeFotaPendingDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFotaPendingDesktopsResponseBody> body{};

  DescribeFotaPendingDesktopsResponse() {}

  explicit DescribeFotaPendingDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFotaPendingDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFotaPendingDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFotaPendingDesktopsResponse() = default;
};
class DescribeFotaTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> fotaStatus{};
  shared_ptr<string> lang{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> taskUid{};
  shared_ptr<string> userStatus{};

  DescribeFotaTasksRequest() {}

  explicit DescribeFotaTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fotaStatus) {
      res["FotaStatus"] = boost::any(*fotaStatus);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskUid) {
      res["TaskUid"] = boost::any(*taskUid);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FotaStatus") != m.end() && !m["FotaStatus"].empty()) {
      fotaStatus = make_shared<string>(boost::any_cast<string>(m["FotaStatus"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskUid") != m.end() && !m["TaskUid"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskUid"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskUid"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskUid = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~DescribeFotaTasksRequest() = default;
};
class DescribeFotaTasksResponseBodyFotaTasks : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> fotaProject{};
  shared_ptr<long> pendingCustomImageCount{};
  shared_ptr<long> pendingDesktopCount{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> releaseNote{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> taskUid{};

  DescribeFotaTasksResponseBodyFotaTasks() {}

  explicit DescribeFotaTasksResponseBodyFotaTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (fotaProject) {
      res["FotaProject"] = boost::any(*fotaProject);
    }
    if (pendingCustomImageCount) {
      res["PendingCustomImageCount"] = boost::any(*pendingCustomImageCount);
    }
    if (pendingDesktopCount) {
      res["PendingDesktopCount"] = boost::any(*pendingDesktopCount);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskUid) {
      res["TaskUid"] = boost::any(*taskUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("FotaProject") != m.end() && !m["FotaProject"].empty()) {
      fotaProject = make_shared<string>(boost::any_cast<string>(m["FotaProject"]));
    }
    if (m.find("PendingCustomImageCount") != m.end() && !m["PendingCustomImageCount"].empty()) {
      pendingCustomImageCount = make_shared<long>(boost::any_cast<long>(m["PendingCustomImageCount"]));
    }
    if (m.find("PendingDesktopCount") != m.end() && !m["PendingDesktopCount"].empty()) {
      pendingDesktopCount = make_shared<long>(boost::any_cast<long>(m["PendingDesktopCount"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskUid") != m.end() && !m["TaskUid"].empty()) {
      taskUid = make_shared<string>(boost::any_cast<string>(m["TaskUid"]));
    }
  }


  virtual ~DescribeFotaTasksResponseBodyFotaTasks() = default;
};
class DescribeFotaTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeFotaTasksResponseBodyFotaTasks>> fotaTasks{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeFotaTasksResponseBody() {}

  explicit DescribeFotaTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fotaTasks) {
      vector<boost::any> temp1;
      for(auto item1:*fotaTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FotaTasks"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FotaTasks") != m.end() && !m["FotaTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["FotaTasks"].type()) {
        vector<DescribeFotaTasksResponseBodyFotaTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FotaTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFotaTasksResponseBodyFotaTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fotaTasks = make_shared<vector<DescribeFotaTasksResponseBodyFotaTasks>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFotaTasksResponseBody() = default;
};
class DescribeFotaTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFotaTasksResponseBody> body{};

  DescribeFotaTasksResponse() {}

  explicit DescribeFotaTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFotaTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFotaTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFotaTasksResponse() = default;
};
class DescribeGuestApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};

  DescribeGuestApplicationsRequest() {}

  explicit DescribeGuestApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeGuestApplicationsRequest() = default;
};
class DescribeGuestApplicationsResponseBodyApplicationsProcessData : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationVersion{};
  shared_ptr<double> cpuPercent{};
  shared_ptr<double> gpuPercent{};
  shared_ptr<double> iospeed{};
  shared_ptr<double> memPercent{};
  shared_ptr<long> pid{};
  shared_ptr<string> processPath{};

  DescribeGuestApplicationsResponseBodyApplicationsProcessData() {}

  explicit DescribeGuestApplicationsResponseBodyApplicationsProcessData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    if (cpuPercent) {
      res["CpuPercent"] = boost::any(*cpuPercent);
    }
    if (gpuPercent) {
      res["GpuPercent"] = boost::any(*gpuPercent);
    }
    if (iospeed) {
      res["Iospeed"] = boost::any(*iospeed);
    }
    if (memPercent) {
      res["MemPercent"] = boost::any(*memPercent);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (processPath) {
      res["ProcessPath"] = boost::any(*processPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
    if (m.find("CpuPercent") != m.end() && !m["CpuPercent"].empty()) {
      cpuPercent = make_shared<double>(boost::any_cast<double>(m["CpuPercent"]));
    }
    if (m.find("GpuPercent") != m.end() && !m["GpuPercent"].empty()) {
      gpuPercent = make_shared<double>(boost::any_cast<double>(m["GpuPercent"]));
    }
    if (m.find("Iospeed") != m.end() && !m["Iospeed"].empty()) {
      iospeed = make_shared<double>(boost::any_cast<double>(m["Iospeed"]));
    }
    if (m.find("MemPercent") != m.end() && !m["MemPercent"].empty()) {
      memPercent = make_shared<double>(boost::any_cast<double>(m["MemPercent"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
    if (m.find("ProcessPath") != m.end() && !m["ProcessPath"].empty()) {
      processPath = make_shared<string>(boost::any_cast<string>(m["ProcessPath"]));
    }
  }


  virtual ~DescribeGuestApplicationsResponseBodyApplicationsProcessData() = default;
};
class DescribeGuestApplicationsResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationVersion{};
  shared_ptr<double> cpuPercent{};
  shared_ptr<double> gpuPercent{};
  shared_ptr<string> iconUrl{};
  shared_ptr<double> ioSpeed{};
  shared_ptr<double> memPercent{};
  shared_ptr<long> pid{};
  shared_ptr<vector<DescribeGuestApplicationsResponseBodyApplicationsProcessData>> processData{};
  shared_ptr<string> processPath{};
  shared_ptr<string> status{};

  DescribeGuestApplicationsResponseBodyApplications() {}

  explicit DescribeGuestApplicationsResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    if (cpuPercent) {
      res["CpuPercent"] = boost::any(*cpuPercent);
    }
    if (gpuPercent) {
      res["GpuPercent"] = boost::any(*gpuPercent);
    }
    if (iconUrl) {
      res["IconUrl"] = boost::any(*iconUrl);
    }
    if (ioSpeed) {
      res["IoSpeed"] = boost::any(*ioSpeed);
    }
    if (memPercent) {
      res["MemPercent"] = boost::any(*memPercent);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (processData) {
      vector<boost::any> temp1;
      for(auto item1:*processData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProcessData"] = boost::any(temp1);
    }
    if (processPath) {
      res["ProcessPath"] = boost::any(*processPath);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
    if (m.find("CpuPercent") != m.end() && !m["CpuPercent"].empty()) {
      cpuPercent = make_shared<double>(boost::any_cast<double>(m["CpuPercent"]));
    }
    if (m.find("GpuPercent") != m.end() && !m["GpuPercent"].empty()) {
      gpuPercent = make_shared<double>(boost::any_cast<double>(m["GpuPercent"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      iconUrl = make_shared<string>(boost::any_cast<string>(m["IconUrl"]));
    }
    if (m.find("IoSpeed") != m.end() && !m["IoSpeed"].empty()) {
      ioSpeed = make_shared<double>(boost::any_cast<double>(m["IoSpeed"]));
    }
    if (m.find("MemPercent") != m.end() && !m["MemPercent"].empty()) {
      memPercent = make_shared<double>(boost::any_cast<double>(m["MemPercent"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
    if (m.find("ProcessData") != m.end() && !m["ProcessData"].empty()) {
      if (typeid(vector<boost::any>) == m["ProcessData"].type()) {
        vector<DescribeGuestApplicationsResponseBodyApplicationsProcessData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProcessData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGuestApplicationsResponseBodyApplicationsProcessData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        processData = make_shared<vector<DescribeGuestApplicationsResponseBodyApplicationsProcessData>>(expect1);
      }
    }
    if (m.find("ProcessPath") != m.end() && !m["ProcessPath"].empty()) {
      processPath = make_shared<string>(boost::any_cast<string>(m["ProcessPath"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGuestApplicationsResponseBodyApplications() = default;
};
class DescribeGuestApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGuestApplicationsResponseBodyApplications>> applications{};
  shared_ptr<string> requestId{};

  DescribeGuestApplicationsResponseBody() {}

  explicit DescribeGuestApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<DescribeGuestApplicationsResponseBodyApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGuestApplicationsResponseBodyApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<DescribeGuestApplicationsResponseBodyApplications>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGuestApplicationsResponseBody() = default;
};
class DescribeGuestApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGuestApplicationsResponseBody> body{};

  DescribeGuestApplicationsResponse() {}

  explicit DescribeGuestApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGuestApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGuestApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGuestApplicationsResponse() = default;
};
class DescribeImageModifiedRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeImageModifiedRecordsRequest() {}

  explicit DescribeImageModifiedRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeImageModifiedRecordsRequest() = default;
};
class DescribeImageModifiedRecordsResponseBodyImageModifiedRecords : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> newImageId{};
  shared_ptr<string> newImageName{};
  shared_ptr<string> reason{};
  shared_ptr<long> status{};
  shared_ptr<string> updateTime{};

  DescribeImageModifiedRecordsResponseBodyImageModifiedRecords() {}

  explicit DescribeImageModifiedRecordsResponseBodyImageModifiedRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (newImageId) {
      res["NewImageId"] = boost::any(*newImageId);
    }
    if (newImageName) {
      res["NewImageName"] = boost::any(*newImageName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("NewImageId") != m.end() && !m["NewImageId"].empty()) {
      newImageId = make_shared<string>(boost::any_cast<string>(m["NewImageId"]));
    }
    if (m.find("NewImageName") != m.end() && !m["NewImageName"].empty()) {
      newImageName = make_shared<string>(boost::any_cast<string>(m["NewImageName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeImageModifiedRecordsResponseBodyImageModifiedRecords() = default;
};
class DescribeImageModifiedRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageModifiedRecordsResponseBodyImageModifiedRecords>> imageModifiedRecords{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageModifiedRecordsResponseBody() {}

  explicit DescribeImageModifiedRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageModifiedRecords) {
      vector<boost::any> temp1;
      for(auto item1:*imageModifiedRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageModifiedRecords"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageModifiedRecords") != m.end() && !m["ImageModifiedRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageModifiedRecords"].type()) {
        vector<DescribeImageModifiedRecordsResponseBodyImageModifiedRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageModifiedRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageModifiedRecordsResponseBodyImageModifiedRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageModifiedRecords = make_shared<vector<DescribeImageModifiedRecordsResponseBodyImageModifiedRecords>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageModifiedRecordsResponseBody() = default;
};
class DescribeImageModifiedRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageModifiedRecordsResponseBody> body{};

  DescribeImageModifiedRecordsResponse() {}

  explicit DescribeImageModifiedRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageModifiedRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageModifiedRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageModifiedRecordsResponse() = default;
};
class DescribeImagePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};

  DescribeImagePermissionRequest() {}

  explicit DescribeImagePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeImagePermissionRequest() = default;
};
class DescribeImagePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aliUids{};
  shared_ptr<string> requestId{};

  DescribeImagePermissionResponseBody() {}

  explicit DescribeImagePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUids) {
      res["AliUids"] = boost::any(*aliUids);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUids") != m.end() && !m["AliUids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AliUids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AliUids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aliUids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImagePermissionResponseBody() = default;
};
class DescribeImagePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImagePermissionResponseBody> body{};

  DescribeImagePermissionResponse() {}

  explicit DescribeImagePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagePermissionResponse() = default;
};
class DescribeImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopInstanceType{};
  shared_ptr<string> fotaVersion{};
  shared_ptr<bool> gpuCategory{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<vector<string>> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageStatus{};
  shared_ptr<string> imageType{};
  shared_ptr<string> languageType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> osType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sessionType{};

  DescribeImagesRequest() {}

  explicit DescribeImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopInstanceType) {
      res["DesktopInstanceType"] = boost::any(*desktopInstanceType);
    }
    if (fotaVersion) {
      res["FotaVersion"] = boost::any(*fotaVersion);
    }
    if (gpuCategory) {
      res["GpuCategory"] = boost::any(*gpuCategory);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageStatus) {
      res["ImageStatus"] = boost::any(*imageStatus);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (languageType) {
      res["LanguageType"] = boost::any(*languageType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopInstanceType") != m.end() && !m["DesktopInstanceType"].empty()) {
      desktopInstanceType = make_shared<string>(boost::any_cast<string>(m["DesktopInstanceType"]));
    }
    if (m.find("FotaVersion") != m.end() && !m["FotaVersion"].empty()) {
      fotaVersion = make_shared<string>(boost::any_cast<string>(m["FotaVersion"]));
    }
    if (m.find("GpuCategory") != m.end() && !m["GpuCategory"].empty()) {
      gpuCategory = make_shared<bool>(boost::any_cast<bool>(m["GpuCategory"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageStatus") != m.end() && !m["ImageStatus"].empty()) {
      imageStatus = make_shared<string>(boost::any_cast<string>(m["ImageStatus"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("LanguageType") != m.end() && !m["LanguageType"].empty()) {
      languageType = make_shared<string>(boost::any_cast<string>(m["LanguageType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
  }


  virtual ~DescribeImagesRequest() = default;
};
class DescribeImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> creationTime{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> description{};
  shared_ptr<bool> gpuCategory{};
  shared_ptr<string> gpuDriverVersion{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> name{};
  shared_ptr<string> osType{};
  shared_ptr<string> platform{};
  shared_ptr<string> progress{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> sessionType{};
  shared_ptr<long> sharedCount{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> supportedLanguages{};
  shared_ptr<string> updateTime{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  DescribeImagesResponseBodyImages() {}

  explicit DescribeImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gpuCategory) {
      res["GpuCategory"] = boost::any(*gpuCategory);
    }
    if (gpuDriverVersion) {
      res["GpuDriverVersion"] = boost::any(*gpuDriverVersion);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (sessionType) {
      res["SessionType"] = boost::any(*sessionType);
    }
    if (sharedCount) {
      res["SharedCount"] = boost::any(*sharedCount);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportedLanguages) {
      res["SupportedLanguages"] = boost::any(*supportedLanguages);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GpuCategory") != m.end() && !m["GpuCategory"].empty()) {
      gpuCategory = make_shared<bool>(boost::any_cast<bool>(m["GpuCategory"]));
    }
    if (m.find("GpuDriverVersion") != m.end() && !m["GpuDriverVersion"].empty()) {
      gpuDriverVersion = make_shared<string>(boost::any_cast<string>(m["GpuDriverVersion"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("SessionType") != m.end() && !m["SessionType"].empty()) {
      sessionType = make_shared<string>(boost::any_cast<string>(m["SessionType"]));
    }
    if (m.find("SharedCount") != m.end() && !m["SharedCount"].empty()) {
      sharedCount = make_shared<long>(boost::any_cast<long>(m["SharedCount"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportedLanguages") != m.end() && !m["SupportedLanguages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedLanguages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedLanguages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedLanguages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImages() = default;
};
class DescribeImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImages>> images{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeImagesResponseBody() {}

  explicit DescribeImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Images"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<DescribeImagesResponseBodyImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<DescribeImagesResponseBodyImages>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImagesResponseBody() = default;
};
class DescribeImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImagesResponseBody> body{};

  DescribeImagesResponse() {}

  explicit DescribeImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagesResponse() = default;
};
class DescribeInvocationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandType{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> desktopId{};
  shared_ptr<vector<string>> desktopIds{};
  shared_ptr<string> endUserId{};
  shared_ptr<bool> includeInvokeDesktops{};
  shared_ptr<bool> includeOutput{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> invokeStatus{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeInvocationsRequest() {}

  explicit DescribeInvocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandType) {
      res["CommandType"] = boost::any(*commandType);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopIds) {
      res["DesktopIds"] = boost::any(*desktopIds);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (includeInvokeDesktops) {
      res["IncludeInvokeDesktops"] = boost::any(*includeInvokeDesktops);
    }
    if (includeOutput) {
      res["IncludeOutput"] = boost::any(*includeOutput);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (invokeStatus) {
      res["InvokeStatus"] = boost::any(*invokeStatus);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandType") != m.end() && !m["CommandType"].empty()) {
      commandType = make_shared<string>(boost::any_cast<string>(m["CommandType"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopIds") != m.end() && !m["DesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("IncludeInvokeDesktops") != m.end() && !m["IncludeInvokeDesktops"].empty()) {
      includeInvokeDesktops = make_shared<bool>(boost::any_cast<bool>(m["IncludeInvokeDesktops"]));
    }
    if (m.find("IncludeOutput") != m.end() && !m["IncludeOutput"].empty()) {
      includeOutput = make_shared<bool>(boost::any_cast<bool>(m["IncludeOutput"]));
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("InvokeStatus") != m.end() && !m["InvokeStatus"].empty()) {
      invokeStatus = make_shared<string>(boost::any_cast<string>(m["InvokeStatus"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeInvocationsRequest() = default;
};
class DescribeInvocationsResponseBodyInvocationsInvokeDesktops : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<long> dropped{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorInfo{};
  shared_ptr<long> exitCode{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<string> output{};
  shared_ptr<long> repeats{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stopTime{};
  shared_ptr<string> updateTime{};

  DescribeInvocationsResponseBodyInvocationsInvokeDesktops() {}

  explicit DescribeInvocationsResponseBodyInvocationsInvokeDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (dropped) {
      res["Dropped"] = boost::any(*dropped);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (repeats) {
      res["Repeats"] = boost::any(*repeats);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("Dropped") != m.end() && !m["Dropped"].empty()) {
      dropped = make_shared<long>(boost::any_cast<long>(m["Dropped"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<long>(boost::any_cast<long>(m["ExitCode"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Repeats") != m.end() && !m["Repeats"].empty()) {
      repeats = make_shared<long>(boost::any_cast<long>(m["Repeats"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocationsInvokeDesktops() = default;
};
class DescribeInvocationsResponseBodyInvocations : public Darabonba::Model {
public:
  shared_ptr<string> commandContent{};
  shared_ptr<string> commandType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> invocationStatus{};
  shared_ptr<long> invokeDesktopCount{};
  shared_ptr<long> invokeDesktopSucceedCount{};
  shared_ptr<vector<DescribeInvocationsResponseBodyInvocationsInvokeDesktops>> invokeDesktops{};
  shared_ptr<string> invokeId{};

  DescribeInvocationsResponseBodyInvocations() {}

  explicit DescribeInvocationsResponseBodyInvocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (commandType) {
      res["CommandType"] = boost::any(*commandType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (invocationStatus) {
      res["InvocationStatus"] = boost::any(*invocationStatus);
    }
    if (invokeDesktopCount) {
      res["InvokeDesktopCount"] = boost::any(*invokeDesktopCount);
    }
    if (invokeDesktopSucceedCount) {
      res["InvokeDesktopSucceedCount"] = boost::any(*invokeDesktopSucceedCount);
    }
    if (invokeDesktops) {
      vector<boost::any> temp1;
      for(auto item1:*invokeDesktops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvokeDesktops"] = boost::any(temp1);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("CommandType") != m.end() && !m["CommandType"].empty()) {
      commandType = make_shared<string>(boost::any_cast<string>(m["CommandType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("InvocationStatus") != m.end() && !m["InvocationStatus"].empty()) {
      invocationStatus = make_shared<string>(boost::any_cast<string>(m["InvocationStatus"]));
    }
    if (m.find("InvokeDesktopCount") != m.end() && !m["InvokeDesktopCount"].empty()) {
      invokeDesktopCount = make_shared<long>(boost::any_cast<long>(m["InvokeDesktopCount"]));
    }
    if (m.find("InvokeDesktopSucceedCount") != m.end() && !m["InvokeDesktopSucceedCount"].empty()) {
      invokeDesktopSucceedCount = make_shared<long>(boost::any_cast<long>(m["InvokeDesktopSucceedCount"]));
    }
    if (m.find("InvokeDesktops") != m.end() && !m["InvokeDesktops"].empty()) {
      if (typeid(vector<boost::any>) == m["InvokeDesktops"].type()) {
        vector<DescribeInvocationsResponseBodyInvocationsInvokeDesktops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvokeDesktops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvocationsResponseBodyInvocationsInvokeDesktops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invokeDesktops = make_shared<vector<DescribeInvocationsResponseBodyInvocationsInvokeDesktops>>(expect1);
      }
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
  }


  virtual ~DescribeInvocationsResponseBodyInvocations() = default;
};
class DescribeInvocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInvocationsResponseBodyInvocations>> invocations{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeInvocationsResponseBody() {}

  explicit DescribeInvocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invocations) {
      vector<boost::any> temp1;
      for(auto item1:*invocations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Invocations"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Invocations") != m.end() && !m["Invocations"].empty()) {
      if (typeid(vector<boost::any>) == m["Invocations"].type()) {
        vector<DescribeInvocationsResponseBodyInvocations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Invocations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvocationsResponseBodyInvocations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invocations = make_shared<vector<DescribeInvocationsResponseBodyInvocations>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInvocationsResponseBody() = default;
};
class DescribeInvocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInvocationsResponseBody> body{};

  DescribeInvocationsResponse() {}

  explicit DescribeInvocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInvocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInvocationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInvocationsResponse() = default;
};
class DescribeKmsKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeKmsKeysRequest() {}

  explicit DescribeKmsKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeKmsKeysRequest() = default;
};
class DescribeKmsKeysResponseBodyKeys : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> arn{};
  shared_ptr<string> keyId{};
  shared_ptr<string> type{};

  DescribeKmsKeysResponseBodyKeys() {}

  explicit DescribeKmsKeysResponseBodyKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeKmsKeysResponseBodyKeys() = default;
};
class DescribeKmsKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authorizeStatus{};
  shared_ptr<vector<DescribeKmsKeysResponseBodyKeys>> keys{};
  shared_ptr<string> kmsServiceStatus{};
  shared_ptr<string> requestId{};

  DescribeKmsKeysResponseBody() {}

  explicit DescribeKmsKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeStatus) {
      res["AuthorizeStatus"] = boost::any(*authorizeStatus);
    }
    if (keys) {
      vector<boost::any> temp1;
      for(auto item1:*keys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keys"] = boost::any(temp1);
    }
    if (kmsServiceStatus) {
      res["KmsServiceStatus"] = boost::any(*kmsServiceStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeStatus") != m.end() && !m["AuthorizeStatus"].empty()) {
      authorizeStatus = make_shared<string>(boost::any_cast<string>(m["AuthorizeStatus"]));
    }
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<DescribeKmsKeysResponseBodyKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKmsKeysResponseBodyKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keys = make_shared<vector<DescribeKmsKeysResponseBodyKeys>>(expect1);
      }
    }
    if (m.find("KmsServiceStatus") != m.end() && !m["KmsServiceStatus"].empty()) {
      kmsServiceStatus = make_shared<string>(boost::any_cast<string>(m["KmsServiceStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeKmsKeysResponseBody() = default;
};
class DescribeKmsKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKmsKeysResponseBody> body{};

  DescribeKmsKeysResponse() {}

  explicit DescribeKmsKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKmsKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKmsKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKmsKeysResponse() = default;
};
class DescribeModificationPriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> rootDiskSizeGib{};
  shared_ptr<long> userDiskSizeGib{};

  DescribeModificationPriceRequest() {}

  explicit DescribeModificationPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (rootDiskSizeGib) {
      res["RootDiskSizeGib"] = boost::any(*rootDiskSizeGib);
    }
    if (userDiskSizeGib) {
      res["UserDiskSizeGib"] = boost::any(*userDiskSizeGib);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RootDiskSizeGib") != m.end() && !m["RootDiskSizeGib"].empty()) {
      rootDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["RootDiskSizeGib"]));
    }
    if (m.find("UserDiskSizeGib") != m.end() && !m["UserDiskSizeGib"].empty()) {
      userDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["UserDiskSizeGib"]));
    }
  }


  virtual ~DescribeModificationPriceRequest() = default;
};
class DescribeModificationPriceResponseBodyPriceInfoPricePromotions : public Darabonba::Model {
public:
  shared_ptr<string> optionCode{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<bool> selected{};

  DescribeModificationPriceResponseBodyPriceInfoPricePromotions() {}

  explicit DescribeModificationPriceResponseBodyPriceInfoPricePromotions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionCode) {
      res["OptionCode"] = boost::any(*optionCode);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OptionCode") != m.end() && !m["OptionCode"].empty()) {
      optionCode = make_shared<string>(boost::any_cast<string>(m["OptionCode"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
  }


  virtual ~DescribeModificationPriceResponseBodyPriceInfoPricePromotions() = default;
};
class DescribeModificationPriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<map<string, string>> orderLines{};
  shared_ptr<double> originalPrice{};
  shared_ptr<vector<DescribeModificationPriceResponseBodyPriceInfoPricePromotions>> promotions{};
  shared_ptr<double> tradePrice{};

  DescribeModificationPriceResponseBodyPriceInfoPrice() {}

  explicit DescribeModificationPriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (orderLines) {
      res["OrderLines"] = boost::any(*orderLines);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (promotions) {
      vector<boost::any> temp1;
      for(auto item1:*promotions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Promotions"] = boost::any(temp1);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OrderLines") != m.end() && !m["OrderLines"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["OrderLines"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderLines = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Promotions") != m.end() && !m["Promotions"].empty()) {
      if (typeid(vector<boost::any>) == m["Promotions"].type()) {
        vector<DescribeModificationPriceResponseBodyPriceInfoPricePromotions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Promotions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModificationPriceResponseBodyPriceInfoPricePromotions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotions = make_shared<vector<DescribeModificationPriceResponseBodyPriceInfoPricePromotions>>(expect1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeModificationPriceResponseBodyPriceInfoPrice() = default;
};
class DescribeModificationPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeModificationPriceResponseBodyPriceInfoRules() {}

  explicit DescribeModificationPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeModificationPriceResponseBodyPriceInfoRules() = default;
};
class DescribeModificationPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeModificationPriceResponseBodyPriceInfoPrice> price{};
  shared_ptr<vector<DescribeModificationPriceResponseBodyPriceInfoRules>> rules{};

  DescribeModificationPriceResponseBodyPriceInfo() {}

  explicit DescribeModificationPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribeModificationPriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribeModificationPriceResponseBodyPriceInfoPrice>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeModificationPriceResponseBodyPriceInfoRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModificationPriceResponseBodyPriceInfoRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeModificationPriceResponseBodyPriceInfoRules>>(expect1);
      }
    }
  }


  virtual ~DescribeModificationPriceResponseBodyPriceInfo() = default;
};
class DescribeModificationPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeModificationPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeModificationPriceResponseBody() {}

  explicit DescribeModificationPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeModificationPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeModificationPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeModificationPriceResponseBody() = default;
};
class DescribeModificationPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeModificationPriceResponseBody> body{};

  DescribeModificationPriceResponse() {}

  explicit DescribeModificationPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModificationPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModificationPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModificationPriceResponse() = default;
};
class DescribeNASFileSystemsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileSystemId{};
  shared_ptr<bool> matchCompatibleProfile{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  DescribeNASFileSystemsRequest() {}

  explicit DescribeNASFileSystemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (matchCompatibleProfile) {
      res["MatchCompatibleProfile"] = boost::any(*matchCompatibleProfile);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileSystemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileSystemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileSystemId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MatchCompatibleProfile") != m.end() && !m["MatchCompatibleProfile"].empty()) {
      matchCompatibleProfile = make_shared<bool>(boost::any_cast<bool>(m["MatchCompatibleProfile"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeNASFileSystemsRequest() = default;
};
class DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups : public Darabonba::Model {
public:
  shared_ptr<string> appInstanceGroupId{};
  shared_ptr<string> appInstanceGroupName{};

  DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups() {}

  explicit DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInstanceGroupId) {
      res["AppInstanceGroupId"] = boost::any(*appInstanceGroupId);
    }
    if (appInstanceGroupName) {
      res["AppInstanceGroupName"] = boost::any(*appInstanceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInstanceGroupId") != m.end() && !m["AppInstanceGroupId"].empty()) {
      appInstanceGroupId = make_shared<string>(boost::any_cast<string>(m["AppInstanceGroupId"]));
    }
    if (m.find("AppInstanceGroupName") != m.end() && !m["AppInstanceGroupName"].empty()) {
      appInstanceGroupName = make_shared<string>(boost::any_cast<string>(m["AppInstanceGroupName"]));
    }
  }


  virtual ~DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups() = default;
};
class DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};

  DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups() {}

  explicit DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
  }


  virtual ~DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups() = default;
};
class DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};

  DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites() {}

  explicit DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
  }


  virtual ~DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites() = default;
};
class DescribeNASFileSystemsResponseBodyFileSystems : public Darabonba::Model {
public:
  shared_ptr<bool> allowOperateUserDrive{};
  shared_ptr<vector<DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups>> appInstanceGroups{};
  shared_ptr<long> capacity{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups>> desktopGroups{};
  shared_ptr<bool> encryptionEnabled{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<string> fileSystemStatus{};
  shared_ptr<string> fileSystemType{};
  shared_ptr<long> meteredSize{};
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> mountTargetStatus{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<vector<DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites>> officeSites{};
  shared_ptr<bool> profileCompatible{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scene{};
  shared_ptr<string> storageType{};
  shared_ptr<bool> supportAcl{};
  shared_ptr<string> zoneId{};

  DescribeNASFileSystemsResponseBodyFileSystems() {}

  explicit DescribeNASFileSystemsResponseBodyFileSystems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowOperateUserDrive) {
      res["AllowOperateUserDrive"] = boost::any(*allowOperateUserDrive);
    }
    if (appInstanceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*appInstanceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppInstanceGroups"] = boost::any(temp1);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopGroups) {
      vector<boost::any> temp1;
      for(auto item1:*desktopGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopGroups"] = boost::any(temp1);
    }
    if (encryptionEnabled) {
      res["EncryptionEnabled"] = boost::any(*encryptionEnabled);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (fileSystemStatus) {
      res["FileSystemStatus"] = boost::any(*fileSystemStatus);
    }
    if (fileSystemType) {
      res["FileSystemType"] = boost::any(*fileSystemType);
    }
    if (meteredSize) {
      res["MeteredSize"] = boost::any(*meteredSize);
    }
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (mountTargetStatus) {
      res["MountTargetStatus"] = boost::any(*mountTargetStatus);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSites) {
      vector<boost::any> temp1;
      for(auto item1:*officeSites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OfficeSites"] = boost::any(temp1);
    }
    if (profileCompatible) {
      res["ProfileCompatible"] = boost::any(*profileCompatible);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (supportAcl) {
      res["SupportAcl"] = boost::any(*supportAcl);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowOperateUserDrive") != m.end() && !m["AllowOperateUserDrive"].empty()) {
      allowOperateUserDrive = make_shared<bool>(boost::any_cast<bool>(m["AllowOperateUserDrive"]));
    }
    if (m.find("AppInstanceGroups") != m.end() && !m["AppInstanceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AppInstanceGroups"].type()) {
        vector<DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppInstanceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appInstanceGroups = make_shared<vector<DescribeNASFileSystemsResponseBodyFileSystemsAppInstanceGroups>>(expect1);
      }
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopGroups") != m.end() && !m["DesktopGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopGroups"].type()) {
        vector<DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopGroups = make_shared<vector<DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups>>(expect1);
      }
    }
    if (m.find("EncryptionEnabled") != m.end() && !m["EncryptionEnabled"].empty()) {
      encryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["EncryptionEnabled"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("FileSystemStatus") != m.end() && !m["FileSystemStatus"].empty()) {
      fileSystemStatus = make_shared<string>(boost::any_cast<string>(m["FileSystemStatus"]));
    }
    if (m.find("FileSystemType") != m.end() && !m["FileSystemType"].empty()) {
      fileSystemType = make_shared<string>(boost::any_cast<string>(m["FileSystemType"]));
    }
    if (m.find("MeteredSize") != m.end() && !m["MeteredSize"].empty()) {
      meteredSize = make_shared<long>(boost::any_cast<long>(m["MeteredSize"]));
    }
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("MountTargetStatus") != m.end() && !m["MountTargetStatus"].empty()) {
      mountTargetStatus = make_shared<string>(boost::any_cast<string>(m["MountTargetStatus"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSites") != m.end() && !m["OfficeSites"].empty()) {
      if (typeid(vector<boost::any>) == m["OfficeSites"].type()) {
        vector<DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OfficeSites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        officeSites = make_shared<vector<DescribeNASFileSystemsResponseBodyFileSystemsOfficeSites>>(expect1);
      }
    }
    if (m.find("ProfileCompatible") != m.end() && !m["ProfileCompatible"].empty()) {
      profileCompatible = make_shared<bool>(boost::any_cast<bool>(m["ProfileCompatible"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("SupportAcl") != m.end() && !m["SupportAcl"].empty()) {
      supportAcl = make_shared<bool>(boost::any_cast<bool>(m["SupportAcl"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeNASFileSystemsResponseBodyFileSystems() = default;
};
class DescribeNASFileSystemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNASFileSystemsResponseBodyFileSystems>> fileSystems{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeNASFileSystemsResponseBody() {}

  explicit DescribeNASFileSystemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystems) {
      vector<boost::any> temp1;
      for(auto item1:*fileSystems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileSystems"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystems") != m.end() && !m["FileSystems"].empty()) {
      if (typeid(vector<boost::any>) == m["FileSystems"].type()) {
        vector<DescribeNASFileSystemsResponseBodyFileSystems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileSystems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNASFileSystemsResponseBodyFileSystems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileSystems = make_shared<vector<DescribeNASFileSystemsResponseBodyFileSystems>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNASFileSystemsResponseBody() = default;
};
class DescribeNASFileSystemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNASFileSystemsResponseBody> body{};

  DescribeNASFileSystemsResponse() {}

  explicit DescribeNASFileSystemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNASFileSystemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNASFileSystemsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNASFileSystemsResponse() = default;
};
class DescribeNetworkPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> networkPackageId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeNetworkPackagesRequest() {}

  explicit DescribeNetworkPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkPackageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkPackageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkPackageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeNetworkPackagesRequest() = default;
};
class DescribeNetworkPackagesResponseBodyNetworkPackages : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<string>> eipAddresses{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> networkPackageStatus{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteVpcType{};
  shared_ptr<string> payType{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<long> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};

  DescribeNetworkPackagesResponseBodyNetworkPackages() {}

  explicit DescribeNetworkPackagesResponseBodyNetworkPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (eipAddresses) {
      res["EipAddresses"] = boost::any(*eipAddresses);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (networkPackageStatus) {
      res["NetworkPackageStatus"] = boost::any(*networkPackageStatus);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteVpcType) {
      res["OfficeSiteVpcType"] = boost::any(*officeSiteVpcType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EipAddresses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EipAddresses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eipAddresses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("NetworkPackageStatus") != m.end() && !m["NetworkPackageStatus"].empty()) {
      networkPackageStatus = make_shared<string>(boost::any_cast<string>(m["NetworkPackageStatus"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteVpcType") != m.end() && !m["OfficeSiteVpcType"].empty()) {
      officeSiteVpcType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteVpcType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<long>(boost::any_cast<long>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
  }


  virtual ~DescribeNetworkPackagesResponseBodyNetworkPackages() = default;
};
class DescribeNetworkPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkPackagesResponseBodyNetworkPackages>> networkPackages{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeNetworkPackagesResponseBody() {}

  explicit DescribeNetworkPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkPackages) {
      vector<boost::any> temp1;
      for(auto item1:*networkPackages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkPackages"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkPackages") != m.end() && !m["NetworkPackages"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkPackages"].type()) {
        vector<DescribeNetworkPackagesResponseBodyNetworkPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkPackages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkPackagesResponseBodyNetworkPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkPackages = make_shared<vector<DescribeNetworkPackagesResponseBodyNetworkPackages>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkPackagesResponseBody() = default;
};
class DescribeNetworkPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkPackagesResponseBody> body{};

  DescribeNetworkPackagesResponse() {}

  explicit DescribeNetworkPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkPackagesResponse() = default;
};
class DescribeOfficeSitesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> officeSiteId{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityProtection{};
  shared_ptr<string> status{};

  DescribeOfficeSitesRequest() {}

  explicit DescribeOfficeSitesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityProtection) {
      res["SecurityProtection"] = boost::any(*securityProtection);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OfficeSiteId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OfficeSiteId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      officeSiteId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityProtection") != m.end() && !m["SecurityProtection"].empty()) {
      securityProtection = make_shared<string>(boost::any_cast<string>(m["SecurityProtection"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeOfficeSitesRequest() = default;
};
class DescribeOfficeSitesResponseBodyOfficeSitesADConnectors : public Darabonba::Model {
public:
  shared_ptr<string> ADConnectorAddress{};
  shared_ptr<string> connectorStatus{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> specification{};
  shared_ptr<string> trustKey{};
  shared_ptr<string> vSwitchId{};

  DescribeOfficeSitesResponseBodyOfficeSitesADConnectors() {}

  explicit DescribeOfficeSitesResponseBodyOfficeSitesADConnectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ADConnectorAddress) {
      res["ADConnectorAddress"] = boost::any(*ADConnectorAddress);
    }
    if (connectorStatus) {
      res["ConnectorStatus"] = boost::any(*connectorStatus);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (trustKey) {
      res["TrustKey"] = boost::any(*trustKey);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ADConnectorAddress") != m.end() && !m["ADConnectorAddress"].empty()) {
      ADConnectorAddress = make_shared<string>(boost::any_cast<string>(m["ADConnectorAddress"]));
    }
    if (m.find("ConnectorStatus") != m.end() && !m["ConnectorStatus"].empty()) {
      connectorStatus = make_shared<string>(boost::any_cast<string>(m["ConnectorStatus"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("TrustKey") != m.end() && !m["TrustKey"].empty()) {
      trustKey = make_shared<string>(boost::any_cast<string>(m["TrustKey"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeOfficeSitesResponseBodyOfficeSitesADConnectors() = default;
};
class DescribeOfficeSitesResponseBodyOfficeSitesLogs : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> step{};
  shared_ptr<string> timeStamp{};

  DescribeOfficeSitesResponseBodyOfficeSitesLogs() {}

  explicit DescribeOfficeSitesResponseBodyOfficeSitesLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<string>(boost::any_cast<string>(m["Step"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeOfficeSitesResponseBodyOfficeSitesLogs() = default;
};
class DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> resourceType{};

  DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts() {}

  explicit DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
  }


  virtual ~DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts() = default;
};
class DescribeOfficeSitesResponseBodyOfficeSites : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOfficeSitesResponseBodyOfficeSitesADConnectors>> ADConnectors{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> adHostname{};
  shared_ptr<string> backupDCHostname{};
  shared_ptr<string> backupDns{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> cenAttachStatus{};
  shared_ptr<string> cenId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<bool> cloudBoxOfficeSite{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> customAccessPoint{};
  shared_ptr<vector<string>> customDnsAddress{};
  shared_ptr<string> customSecurityGroupId{};
  shared_ptr<string> desktopAccessType{};
  shared_ptr<long> desktopCount{};
  shared_ptr<string> desktopVpcEndpoint{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> dnsUserName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> enableCrossDesktopAccess{};
  shared_ptr<bool> enableInternetAccess{};
  shared_ptr<bool> enableServiceRoute{};
  shared_ptr<vector<string>> fileSystemIds{};
  shared_ptr<bool> isLdap{};
  shared_ptr<string> ldapUrl{};
  shared_ptr<vector<DescribeOfficeSitesResponseBodyOfficeSitesLogs>> logs{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> name{};
  shared_ptr<bool> needVerifyLoginRisk{};
  shared_ptr<bool> needVerifyZeroDevice{};
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> nmVersion{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> ouName{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> rdsLicenseAddress{};
  shared_ptr<string> rdsLicenseDomainName{};
  shared_ptr<string> rdsLicenseStatus{};
  shared_ptr<vector<DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts>> resourceAmounts{};
  shared_ptr<string> securityProtection{};
  shared_ptr<bool> ssoEnabled{};
  shared_ptr<string> ssoType{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> subDnsAddress{};
  shared_ptr<string> subDomainName{};
  shared_ptr<string> subnetMode{};
  shared_ptr<long> totalEdsCount{};
  shared_ptr<long> totalEdsCountForGroup{};
  shared_ptr<long> totalResourceAmount{};
  shared_ptr<string> trustPassword{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcType{};

  DescribeOfficeSitesResponseBodyOfficeSites() {}

  explicit DescribeOfficeSitesResponseBodyOfficeSites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ADConnectors) {
      vector<boost::any> temp1;
      for(auto item1:*ADConnectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ADConnectors"] = boost::any(temp1);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (backupDCHostname) {
      res["BackupDCHostname"] = boost::any(*backupDCHostname);
    }
    if (backupDns) {
      res["BackupDns"] = boost::any(*backupDns);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cenAttachStatus) {
      res["CenAttachStatus"] = boost::any(*cenAttachStatus);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (cloudBoxOfficeSite) {
      res["CloudBoxOfficeSite"] = boost::any(*cloudBoxOfficeSite);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (customAccessPoint) {
      res["CustomAccessPoint"] = boost::any(*customAccessPoint);
    }
    if (customDnsAddress) {
      res["CustomDnsAddress"] = boost::any(*customDnsAddress);
    }
    if (customSecurityGroupId) {
      res["CustomSecurityGroupId"] = boost::any(*customSecurityGroupId);
    }
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (desktopCount) {
      res["DesktopCount"] = boost::any(*desktopCount);
    }
    if (desktopVpcEndpoint) {
      res["DesktopVpcEndpoint"] = boost::any(*desktopVpcEndpoint);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (dnsUserName) {
      res["DnsUserName"] = boost::any(*dnsUserName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (enableCrossDesktopAccess) {
      res["EnableCrossDesktopAccess"] = boost::any(*enableCrossDesktopAccess);
    }
    if (enableInternetAccess) {
      res["EnableInternetAccess"] = boost::any(*enableInternetAccess);
    }
    if (enableServiceRoute) {
      res["EnableServiceRoute"] = boost::any(*enableServiceRoute);
    }
    if (fileSystemIds) {
      res["FileSystemIds"] = boost::any(*fileSystemIds);
    }
    if (isLdap) {
      res["IsLdap"] = boost::any(*isLdap);
    }
    if (ldapUrl) {
      res["LdapUrl"] = boost::any(*ldapUrl);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needVerifyLoginRisk) {
      res["NeedVerifyLoginRisk"] = boost::any(*needVerifyLoginRisk);
    }
    if (needVerifyZeroDevice) {
      res["NeedVerifyZeroDevice"] = boost::any(*needVerifyZeroDevice);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (nmVersion) {
      res["NmVersion"] = boost::any(*nmVersion);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (ouName) {
      res["OuName"] = boost::any(*ouName);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (rdsLicenseAddress) {
      res["RdsLicenseAddress"] = boost::any(*rdsLicenseAddress);
    }
    if (rdsLicenseDomainName) {
      res["RdsLicenseDomainName"] = boost::any(*rdsLicenseDomainName);
    }
    if (rdsLicenseStatus) {
      res["RdsLicenseStatus"] = boost::any(*rdsLicenseStatus);
    }
    if (resourceAmounts) {
      vector<boost::any> temp1;
      for(auto item1:*resourceAmounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceAmounts"] = boost::any(temp1);
    }
    if (securityProtection) {
      res["SecurityProtection"] = boost::any(*securityProtection);
    }
    if (ssoEnabled) {
      res["SsoEnabled"] = boost::any(*ssoEnabled);
    }
    if (ssoType) {
      res["SsoType"] = boost::any(*ssoType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDnsAddress) {
      res["SubDnsAddress"] = boost::any(*subDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    if (subnetMode) {
      res["SubnetMode"] = boost::any(*subnetMode);
    }
    if (totalEdsCount) {
      res["TotalEdsCount"] = boost::any(*totalEdsCount);
    }
    if (totalEdsCountForGroup) {
      res["TotalEdsCountForGroup"] = boost::any(*totalEdsCountForGroup);
    }
    if (totalResourceAmount) {
      res["TotalResourceAmount"] = boost::any(*totalResourceAmount);
    }
    if (trustPassword) {
      res["TrustPassword"] = boost::any(*trustPassword);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcType) {
      res["VpcType"] = boost::any(*vpcType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ADConnectors") != m.end() && !m["ADConnectors"].empty()) {
      if (typeid(vector<boost::any>) == m["ADConnectors"].type()) {
        vector<DescribeOfficeSitesResponseBodyOfficeSitesADConnectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ADConnectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOfficeSitesResponseBodyOfficeSitesADConnectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ADConnectors = make_shared<vector<DescribeOfficeSitesResponseBodyOfficeSitesADConnectors>>(expect1);
      }
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("BackupDCHostname") != m.end() && !m["BackupDCHostname"].empty()) {
      backupDCHostname = make_shared<string>(boost::any_cast<string>(m["BackupDCHostname"]));
    }
    if (m.find("BackupDns") != m.end() && !m["BackupDns"].empty()) {
      backupDns = make_shared<string>(boost::any_cast<string>(m["BackupDns"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CenAttachStatus") != m.end() && !m["CenAttachStatus"].empty()) {
      cenAttachStatus = make_shared<string>(boost::any_cast<string>(m["CenAttachStatus"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CloudBoxOfficeSite") != m.end() && !m["CloudBoxOfficeSite"].empty()) {
      cloudBoxOfficeSite = make_shared<bool>(boost::any_cast<bool>(m["CloudBoxOfficeSite"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CustomAccessPoint") != m.end() && !m["CustomAccessPoint"].empty()) {
      customAccessPoint = make_shared<string>(boost::any_cast<string>(m["CustomAccessPoint"]));
    }
    if (m.find("CustomDnsAddress") != m.end() && !m["CustomDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomSecurityGroupId") != m.end() && !m["CustomSecurityGroupId"].empty()) {
      customSecurityGroupId = make_shared<string>(boost::any_cast<string>(m["CustomSecurityGroupId"]));
    }
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("DesktopCount") != m.end() && !m["DesktopCount"].empty()) {
      desktopCount = make_shared<long>(boost::any_cast<long>(m["DesktopCount"]));
    }
    if (m.find("DesktopVpcEndpoint") != m.end() && !m["DesktopVpcEndpoint"].empty()) {
      desktopVpcEndpoint = make_shared<string>(boost::any_cast<string>(m["DesktopVpcEndpoint"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DnsUserName") != m.end() && !m["DnsUserName"].empty()) {
      dnsUserName = make_shared<string>(boost::any_cast<string>(m["DnsUserName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("EnableCrossDesktopAccess") != m.end() && !m["EnableCrossDesktopAccess"].empty()) {
      enableCrossDesktopAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossDesktopAccess"]));
    }
    if (m.find("EnableInternetAccess") != m.end() && !m["EnableInternetAccess"].empty()) {
      enableInternetAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAccess"]));
    }
    if (m.find("EnableServiceRoute") != m.end() && !m["EnableServiceRoute"].empty()) {
      enableServiceRoute = make_shared<bool>(boost::any_cast<bool>(m["EnableServiceRoute"]));
    }
    if (m.find("FileSystemIds") != m.end() && !m["FileSystemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileSystemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileSystemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileSystemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsLdap") != m.end() && !m["IsLdap"].empty()) {
      isLdap = make_shared<bool>(boost::any_cast<bool>(m["IsLdap"]));
    }
    if (m.find("LdapUrl") != m.end() && !m["LdapUrl"].empty()) {
      ldapUrl = make_shared<string>(boost::any_cast<string>(m["LdapUrl"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribeOfficeSitesResponseBodyOfficeSitesLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOfficeSitesResponseBodyOfficeSitesLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribeOfficeSitesResponseBodyOfficeSitesLogs>>(expect1);
      }
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedVerifyLoginRisk") != m.end() && !m["NeedVerifyLoginRisk"].empty()) {
      needVerifyLoginRisk = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyLoginRisk"]));
    }
    if (m.find("NeedVerifyZeroDevice") != m.end() && !m["NeedVerifyZeroDevice"].empty()) {
      needVerifyZeroDevice = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyZeroDevice"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("NmVersion") != m.end() && !m["NmVersion"].empty()) {
      nmVersion = make_shared<string>(boost::any_cast<string>(m["NmVersion"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("OuName") != m.end() && !m["OuName"].empty()) {
      ouName = make_shared<string>(boost::any_cast<string>(m["OuName"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RdsLicenseAddress") != m.end() && !m["RdsLicenseAddress"].empty()) {
      rdsLicenseAddress = make_shared<string>(boost::any_cast<string>(m["RdsLicenseAddress"]));
    }
    if (m.find("RdsLicenseDomainName") != m.end() && !m["RdsLicenseDomainName"].empty()) {
      rdsLicenseDomainName = make_shared<string>(boost::any_cast<string>(m["RdsLicenseDomainName"]));
    }
    if (m.find("RdsLicenseStatus") != m.end() && !m["RdsLicenseStatus"].empty()) {
      rdsLicenseStatus = make_shared<string>(boost::any_cast<string>(m["RdsLicenseStatus"]));
    }
    if (m.find("ResourceAmounts") != m.end() && !m["ResourceAmounts"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceAmounts"].type()) {
        vector<DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceAmounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceAmounts = make_shared<vector<DescribeOfficeSitesResponseBodyOfficeSitesResourceAmounts>>(expect1);
      }
    }
    if (m.find("SecurityProtection") != m.end() && !m["SecurityProtection"].empty()) {
      securityProtection = make_shared<string>(boost::any_cast<string>(m["SecurityProtection"]));
    }
    if (m.find("SsoEnabled") != m.end() && !m["SsoEnabled"].empty()) {
      ssoEnabled = make_shared<bool>(boost::any_cast<bool>(m["SsoEnabled"]));
    }
    if (m.find("SsoType") != m.end() && !m["SsoType"].empty()) {
      ssoType = make_shared<string>(boost::any_cast<string>(m["SsoType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDnsAddress") != m.end() && !m["SubDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
    if (m.find("SubnetMode") != m.end() && !m["SubnetMode"].empty()) {
      subnetMode = make_shared<string>(boost::any_cast<string>(m["SubnetMode"]));
    }
    if (m.find("TotalEdsCount") != m.end() && !m["TotalEdsCount"].empty()) {
      totalEdsCount = make_shared<long>(boost::any_cast<long>(m["TotalEdsCount"]));
    }
    if (m.find("TotalEdsCountForGroup") != m.end() && !m["TotalEdsCountForGroup"].empty()) {
      totalEdsCountForGroup = make_shared<long>(boost::any_cast<long>(m["TotalEdsCountForGroup"]));
    }
    if (m.find("TotalResourceAmount") != m.end() && !m["TotalResourceAmount"].empty()) {
      totalResourceAmount = make_shared<long>(boost::any_cast<long>(m["TotalResourceAmount"]));
    }
    if (m.find("TrustPassword") != m.end() && !m["TrustPassword"].empty()) {
      trustPassword = make_shared<string>(boost::any_cast<string>(m["TrustPassword"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcType") != m.end() && !m["VpcType"].empty()) {
      vpcType = make_shared<string>(boost::any_cast<string>(m["VpcType"]));
    }
  }


  virtual ~DescribeOfficeSitesResponseBodyOfficeSites() = default;
};
class DescribeOfficeSitesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<DescribeOfficeSitesResponseBodyOfficeSites>> officeSites{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeOfficeSitesResponseBody() {}

  explicit DescribeOfficeSitesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSites) {
      vector<boost::any> temp1;
      for(auto item1:*officeSites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OfficeSites"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSites") != m.end() && !m["OfficeSites"].empty()) {
      if (typeid(vector<boost::any>) == m["OfficeSites"].type()) {
        vector<DescribeOfficeSitesResponseBodyOfficeSites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OfficeSites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOfficeSitesResponseBodyOfficeSites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        officeSites = make_shared<vector<DescribeOfficeSitesResponseBodyOfficeSites>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOfficeSitesResponseBody() = default;
};
class DescribeOfficeSitesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOfficeSitesResponseBody> body{};

  DescribeOfficeSitesResponse() {}

  explicit DescribeOfficeSitesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOfficeSitesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOfficeSitesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOfficeSitesResponse() = default;
};
class DescribePolicyGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> externalPolicyGroupIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> policyGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scope{};

  DescribePolicyGroupsRequest() {}

  explicit DescribePolicyGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalPolicyGroupIds) {
      res["ExternalPolicyGroupIds"] = boost::any(*externalPolicyGroupIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalPolicyGroupIds") != m.end() && !m["ExternalPolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExternalPolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExternalPolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      externalPolicyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribePolicyGroupsRequest() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};
  shared_ptr<string> ruleType{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> deviceClass{};
  shared_ptr<string> deviceSubclass{};
  shared_ptr<string> productId{};
  shared_ptr<long> usbRedirectType{};
  shared_ptr<long> usbRuleType{};
  shared_ptr<string> vendorId{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceClass) {
      res["DeviceClass"] = boost::any(*deviceClass);
    }
    if (deviceSubclass) {
      res["DeviceSubclass"] = boost::any(*deviceSubclass);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceClass") != m.end() && !m["DeviceClass"].empty()) {
      deviceClass = make_shared<string>(boost::any_cast<string>(m["DeviceClass"]));
    }
    if (m.find("DeviceSubclass") != m.end() && !m["DeviceSubclass"].empty()) {
      deviceSubclass = make_shared<string>(boost::any_cast<string>(m["DeviceSubclass"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<long>(boost::any_cast<long>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<long>(boost::any_cast<long>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule() = default;
};
class DescribePolicyGroupsResponseBodyDescribePolicyGroups : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules>> authorizeAccessPolicyRules{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules>> authorizeSecurityPolicyRules{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes>> clientTypes{};
  shared_ptr<string> clipboard{};
  shared_ptr<string> colorEnhancement{};
  shared_ptr<long> cpuDownGradeDuration{};
  shared_ptr<vector<string>> cpuProcessors{};
  shared_ptr<string> cpuProtectedMode{};
  shared_ptr<long> cpuRateLimit{};
  shared_ptr<long> cpuSampleDuration{};
  shared_ptr<long> cpuSingleRateLimit{};
  shared_ptr<long> desktopCount{};
  shared_ptr<long> desktopGroupCount{};
  shared_ptr<string> deviceConnectHint{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules>> deviceRules{};
  shared_ptr<string> displayMode{};
  shared_ptr<string> domainList{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<long> edsCount{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> fileMigrate{};
  shared_ptr<string> fileTransfer{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5Access{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> internetPrinter{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<long> memoryDownGradeDuration{};
  shared_ptr<vector<string>> memoryProcessors{};
  shared_ptr<string> memoryProtectedMode{};
  shared_ptr<long> memoryRateLimit{};
  shared_ptr<long> memorySampleDuration{};
  shared_ptr<long> memorySingleRateLimit{};
  shared_ptr<string> mobileRestart{};
  shared_ptr<string> mobileShutdown{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule>> netRedirectRule{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> policyGroupType{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> preemptLogin{};
  shared_ptr<vector<string>> preemptLoginUsers{};
  shared_ptr<string> printerRedirection{};
  shared_ptr<string> qualityEnhancement{};
  shared_ptr<string> recordContent{};
  shared_ptr<long> recordContentExpires{};
  shared_ptr<long> recordEventDuration{};
  shared_ptr<vector<string>> recordEventFilePaths{};
  shared_ptr<vector<string>> recordEventRegisters{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<long> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<string> resetDesktop{};
  shared_ptr<long> resolutionHeight{};
  shared_ptr<string> resolutionModel{};
  shared_ptr<long> resolutionWidth{};
  shared_ptr<long> resourceGroupCount{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> safeMenu{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<string> smoothEnhancement{};
  shared_ptr<string> statusMonitor{};
  shared_ptr<string> streamingMode{};
  shared_ptr<long> targetFps{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<long> videoEncAvgKbps{};
  shared_ptr<long> videoEncMaxQP{};
  shared_ptr<long> videoEncMinQP{};
  shared_ptr<long> videoEncPeakKbps{};
  shared_ptr<string> videoEncPolicy{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<string> watermarkCustomText{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<string> watermarkTransparency{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wuyingKeeper{};
  shared_ptr<string> wyAssistant{};

  DescribePolicyGroupsResponseBodyDescribePolicyGroups() {}

  explicit DescribePolicyGroupsResponseBodyDescribePolicyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRules) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRules"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRules) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRules"] = boost::any(temp1);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientTypes) {
      vector<boost::any> temp1;
      for(auto item1:*clientTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientTypes"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (colorEnhancement) {
      res["ColorEnhancement"] = boost::any(*colorEnhancement);
    }
    if (cpuDownGradeDuration) {
      res["CpuDownGradeDuration"] = boost::any(*cpuDownGradeDuration);
    }
    if (cpuProcessors) {
      res["CpuProcessors"] = boost::any(*cpuProcessors);
    }
    if (cpuProtectedMode) {
      res["CpuProtectedMode"] = boost::any(*cpuProtectedMode);
    }
    if (cpuRateLimit) {
      res["CpuRateLimit"] = boost::any(*cpuRateLimit);
    }
    if (cpuSampleDuration) {
      res["CpuSampleDuration"] = boost::any(*cpuSampleDuration);
    }
    if (cpuSingleRateLimit) {
      res["CpuSingleRateLimit"] = boost::any(*cpuSingleRateLimit);
    }
    if (desktopCount) {
      res["DesktopCount"] = boost::any(*desktopCount);
    }
    if (desktopGroupCount) {
      res["DesktopGroupCount"] = boost::any(*desktopGroupCount);
    }
    if (deviceConnectHint) {
      res["DeviceConnectHint"] = boost::any(*deviceConnectHint);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (displayMode) {
      res["DisplayMode"] = boost::any(*displayMode);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (edsCount) {
      res["EdsCount"] = boost::any(*edsCount);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (fileMigrate) {
      res["FileMigrate"] = boost::any(*fileMigrate);
    }
    if (fileTransfer) {
      res["FileTransfer"] = boost::any(*fileTransfer);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5Access) {
      res["Html5Access"] = boost::any(*html5Access);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (internetPrinter) {
      res["InternetPrinter"] = boost::any(*internetPrinter);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (memoryDownGradeDuration) {
      res["MemoryDownGradeDuration"] = boost::any(*memoryDownGradeDuration);
    }
    if (memoryProcessors) {
      res["MemoryProcessors"] = boost::any(*memoryProcessors);
    }
    if (memoryProtectedMode) {
      res["MemoryProtectedMode"] = boost::any(*memoryProtectedMode);
    }
    if (memoryRateLimit) {
      res["MemoryRateLimit"] = boost::any(*memoryRateLimit);
    }
    if (memorySampleDuration) {
      res["MemorySampleDuration"] = boost::any(*memorySampleDuration);
    }
    if (memorySingleRateLimit) {
      res["MemorySingleRateLimit"] = boost::any(*memorySingleRateLimit);
    }
    if (mobileRestart) {
      res["MobileRestart"] = boost::any(*mobileRestart);
    }
    if (mobileShutdown) {
      res["MobileShutdown"] = boost::any(*mobileShutdown);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (netRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*netRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetRedirectRule"] = boost::any(temp1);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupType) {
      res["PolicyGroupType"] = boost::any(*policyGroupType);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (preemptLogin) {
      res["PreemptLogin"] = boost::any(*preemptLogin);
    }
    if (preemptLoginUsers) {
      res["PreemptLoginUsers"] = boost::any(*preemptLoginUsers);
    }
    if (printerRedirection) {
      res["PrinterRedirection"] = boost::any(*printerRedirection);
    }
    if (qualityEnhancement) {
      res["QualityEnhancement"] = boost::any(*qualityEnhancement);
    }
    if (recordContent) {
      res["RecordContent"] = boost::any(*recordContent);
    }
    if (recordContentExpires) {
      res["RecordContentExpires"] = boost::any(*recordContentExpires);
    }
    if (recordEventDuration) {
      res["RecordEventDuration"] = boost::any(*recordEventDuration);
    }
    if (recordEventFilePaths) {
      res["RecordEventFilePaths"] = boost::any(*recordEventFilePaths);
    }
    if (recordEventRegisters) {
      res["RecordEventRegisters"] = boost::any(*recordEventRegisters);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (resetDesktop) {
      res["ResetDesktop"] = boost::any(*resetDesktop);
    }
    if (resolutionHeight) {
      res["ResolutionHeight"] = boost::any(*resolutionHeight);
    }
    if (resolutionModel) {
      res["ResolutionModel"] = boost::any(*resolutionModel);
    }
    if (resolutionWidth) {
      res["ResolutionWidth"] = boost::any(*resolutionWidth);
    }
    if (resourceGroupCount) {
      res["ResourceGroupCount"] = boost::any(*resourceGroupCount);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (safeMenu) {
      res["SafeMenu"] = boost::any(*safeMenu);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (smoothEnhancement) {
      res["SmoothEnhancement"] = boost::any(*smoothEnhancement);
    }
    if (statusMonitor) {
      res["StatusMonitor"] = boost::any(*statusMonitor);
    }
    if (streamingMode) {
      res["StreamingMode"] = boost::any(*streamingMode);
    }
    if (targetFps) {
      res["TargetFps"] = boost::any(*targetFps);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoEncAvgKbps) {
      res["VideoEncAvgKbps"] = boost::any(*videoEncAvgKbps);
    }
    if (videoEncMaxQP) {
      res["VideoEncMaxQP"] = boost::any(*videoEncMaxQP);
    }
    if (videoEncMinQP) {
      res["VideoEncMinQP"] = boost::any(*videoEncMinQP);
    }
    if (videoEncPeakKbps) {
      res["VideoEncPeakKbps"] = boost::any(*videoEncPeakKbps);
    }
    if (videoEncPolicy) {
      res["VideoEncPolicy"] = boost::any(*videoEncPolicy);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkCustomText) {
      res["WatermarkCustomText"] = boost::any(*watermarkCustomText);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparency) {
      res["WatermarkTransparency"] = boost::any(*watermarkTransparency);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wuyingKeeper) {
      res["WuyingKeeper"] = boost::any(*wuyingKeeper);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRules") != m.end() && !m["AuthorizeAccessPolicyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRules"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRules = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRules") != m.end() && !m["AuthorizeSecurityPolicyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRules"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRules = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules>>(expect1);
      }
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientTypes") != m.end() && !m["ClientTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientTypes"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientTypes = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("ColorEnhancement") != m.end() && !m["ColorEnhancement"].empty()) {
      colorEnhancement = make_shared<string>(boost::any_cast<string>(m["ColorEnhancement"]));
    }
    if (m.find("CpuDownGradeDuration") != m.end() && !m["CpuDownGradeDuration"].empty()) {
      cpuDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["CpuDownGradeDuration"]));
    }
    if (m.find("CpuProcessors") != m.end() && !m["CpuProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CpuProtectedMode") != m.end() && !m["CpuProtectedMode"].empty()) {
      cpuProtectedMode = make_shared<string>(boost::any_cast<string>(m["CpuProtectedMode"]));
    }
    if (m.find("CpuRateLimit") != m.end() && !m["CpuRateLimit"].empty()) {
      cpuRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuRateLimit"]));
    }
    if (m.find("CpuSampleDuration") != m.end() && !m["CpuSampleDuration"].empty()) {
      cpuSampleDuration = make_shared<long>(boost::any_cast<long>(m["CpuSampleDuration"]));
    }
    if (m.find("CpuSingleRateLimit") != m.end() && !m["CpuSingleRateLimit"].empty()) {
      cpuSingleRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuSingleRateLimit"]));
    }
    if (m.find("DesktopCount") != m.end() && !m["DesktopCount"].empty()) {
      desktopCount = make_shared<long>(boost::any_cast<long>(m["DesktopCount"]));
    }
    if (m.find("DesktopGroupCount") != m.end() && !m["DesktopGroupCount"].empty()) {
      desktopGroupCount = make_shared<long>(boost::any_cast<long>(m["DesktopGroupCount"]));
    }
    if (m.find("DeviceConnectHint") != m.end() && !m["DeviceConnectHint"].empty()) {
      deviceConnectHint = make_shared<string>(boost::any_cast<string>(m["DeviceConnectHint"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDeviceRules>>(expect1);
      }
    }
    if (m.find("DisplayMode") != m.end() && !m["DisplayMode"].empty()) {
      displayMode = make_shared<string>(boost::any_cast<string>(m["DisplayMode"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EdsCount") != m.end() && !m["EdsCount"].empty()) {
      edsCount = make_shared<long>(boost::any_cast<long>(m["EdsCount"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("FileMigrate") != m.end() && !m["FileMigrate"].empty()) {
      fileMigrate = make_shared<string>(boost::any_cast<string>(m["FileMigrate"]));
    }
    if (m.find("FileTransfer") != m.end() && !m["FileTransfer"].empty()) {
      fileTransfer = make_shared<string>(boost::any_cast<string>(m["FileTransfer"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5Access") != m.end() && !m["Html5Access"].empty()) {
      html5Access = make_shared<string>(boost::any_cast<string>(m["Html5Access"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("InternetPrinter") != m.end() && !m["InternetPrinter"].empty()) {
      internetPrinter = make_shared<string>(boost::any_cast<string>(m["InternetPrinter"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("MemoryDownGradeDuration") != m.end() && !m["MemoryDownGradeDuration"].empty()) {
      memoryDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["MemoryDownGradeDuration"]));
    }
    if (m.find("MemoryProcessors") != m.end() && !m["MemoryProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemoryProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemoryProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memoryProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemoryProtectedMode") != m.end() && !m["MemoryProtectedMode"].empty()) {
      memoryProtectedMode = make_shared<string>(boost::any_cast<string>(m["MemoryProtectedMode"]));
    }
    if (m.find("MemoryRateLimit") != m.end() && !m["MemoryRateLimit"].empty()) {
      memoryRateLimit = make_shared<long>(boost::any_cast<long>(m["MemoryRateLimit"]));
    }
    if (m.find("MemorySampleDuration") != m.end() && !m["MemorySampleDuration"].empty()) {
      memorySampleDuration = make_shared<long>(boost::any_cast<long>(m["MemorySampleDuration"]));
    }
    if (m.find("MemorySingleRateLimit") != m.end() && !m["MemorySingleRateLimit"].empty()) {
      memorySingleRateLimit = make_shared<long>(boost::any_cast<long>(m["MemorySingleRateLimit"]));
    }
    if (m.find("MobileRestart") != m.end() && !m["MobileRestart"].empty()) {
      mobileRestart = make_shared<string>(boost::any_cast<string>(m["MobileRestart"]));
    }
    if (m.find("MobileShutdown") != m.end() && !m["MobileShutdown"].empty()) {
      mobileShutdown = make_shared<string>(boost::any_cast<string>(m["MobileShutdown"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("NetRedirectRule") != m.end() && !m["NetRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["NetRedirectRule"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        netRedirectRule = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule>>(expect1);
      }
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupType") != m.end() && !m["PolicyGroupType"].empty()) {
      policyGroupType = make_shared<string>(boost::any_cast<string>(m["PolicyGroupType"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("PreemptLogin") != m.end() && !m["PreemptLogin"].empty()) {
      preemptLogin = make_shared<string>(boost::any_cast<string>(m["PreemptLogin"]));
    }
    if (m.find("PreemptLoginUsers") != m.end() && !m["PreemptLoginUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PreemptLoginUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreemptLoginUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      preemptLoginUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrinterRedirection") != m.end() && !m["PrinterRedirection"].empty()) {
      printerRedirection = make_shared<string>(boost::any_cast<string>(m["PrinterRedirection"]));
    }
    if (m.find("QualityEnhancement") != m.end() && !m["QualityEnhancement"].empty()) {
      qualityEnhancement = make_shared<string>(boost::any_cast<string>(m["QualityEnhancement"]));
    }
    if (m.find("RecordContent") != m.end() && !m["RecordContent"].empty()) {
      recordContent = make_shared<string>(boost::any_cast<string>(m["RecordContent"]));
    }
    if (m.find("RecordContentExpires") != m.end() && !m["RecordContentExpires"].empty()) {
      recordContentExpires = make_shared<long>(boost::any_cast<long>(m["RecordContentExpires"]));
    }
    if (m.find("RecordEventDuration") != m.end() && !m["RecordEventDuration"].empty()) {
      recordEventDuration = make_shared<long>(boost::any_cast<long>(m["RecordEventDuration"]));
    }
    if (m.find("RecordEventFilePaths") != m.end() && !m["RecordEventFilePaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventFilePaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventFilePaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventFilePaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEventRegisters") != m.end() && !m["RecordEventRegisters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventRegisters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventRegisters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventRegisters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<long>(boost::any_cast<long>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("ResetDesktop") != m.end() && !m["ResetDesktop"].empty()) {
      resetDesktop = make_shared<string>(boost::any_cast<string>(m["ResetDesktop"]));
    }
    if (m.find("ResolutionHeight") != m.end() && !m["ResolutionHeight"].empty()) {
      resolutionHeight = make_shared<long>(boost::any_cast<long>(m["ResolutionHeight"]));
    }
    if (m.find("ResolutionModel") != m.end() && !m["ResolutionModel"].empty()) {
      resolutionModel = make_shared<string>(boost::any_cast<string>(m["ResolutionModel"]));
    }
    if (m.find("ResolutionWidth") != m.end() && !m["ResolutionWidth"].empty()) {
      resolutionWidth = make_shared<long>(boost::any_cast<long>(m["ResolutionWidth"]));
    }
    if (m.find("ResourceGroupCount") != m.end() && !m["ResourceGroupCount"].empty()) {
      resourceGroupCount = make_shared<long>(boost::any_cast<long>(m["ResourceGroupCount"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("SafeMenu") != m.end() && !m["SafeMenu"].empty()) {
      safeMenu = make_shared<string>(boost::any_cast<string>(m["SafeMenu"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SmoothEnhancement") != m.end() && !m["SmoothEnhancement"].empty()) {
      smoothEnhancement = make_shared<string>(boost::any_cast<string>(m["SmoothEnhancement"]));
    }
    if (m.find("StatusMonitor") != m.end() && !m["StatusMonitor"].empty()) {
      statusMonitor = make_shared<string>(boost::any_cast<string>(m["StatusMonitor"]));
    }
    if (m.find("StreamingMode") != m.end() && !m["StreamingMode"].empty()) {
      streamingMode = make_shared<string>(boost::any_cast<string>(m["StreamingMode"]));
    }
    if (m.find("TargetFps") != m.end() && !m["TargetFps"].empty()) {
      targetFps = make_shared<long>(boost::any_cast<long>(m["TargetFps"]));
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoEncAvgKbps") != m.end() && !m["VideoEncAvgKbps"].empty()) {
      videoEncAvgKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncAvgKbps"]));
    }
    if (m.find("VideoEncMaxQP") != m.end() && !m["VideoEncMaxQP"].empty()) {
      videoEncMaxQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMaxQP"]));
    }
    if (m.find("VideoEncMinQP") != m.end() && !m["VideoEncMinQP"].empty()) {
      videoEncMinQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMinQP"]));
    }
    if (m.find("VideoEncPeakKbps") != m.end() && !m["VideoEncPeakKbps"].empty()) {
      videoEncPeakKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncPeakKbps"]));
    }
    if (m.find("VideoEncPolicy") != m.end() && !m["VideoEncPolicy"].empty()) {
      videoEncPolicy = make_shared<string>(boost::any_cast<string>(m["VideoEncPolicy"]));
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkCustomText") != m.end() && !m["WatermarkCustomText"].empty()) {
      watermarkCustomText = make_shared<string>(boost::any_cast<string>(m["WatermarkCustomText"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparency") != m.end() && !m["WatermarkTransparency"].empty()) {
      watermarkTransparency = make_shared<string>(boost::any_cast<string>(m["WatermarkTransparency"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WuyingKeeper") != m.end() && !m["WuyingKeeper"].empty()) {
      wuyingKeeper = make_shared<string>(boost::any_cast<string>(m["WuyingKeeper"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBodyDescribePolicyGroups() = default;
};
class DescribePolicyGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroups>> describePolicyGroups{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  DescribePolicyGroupsResponseBody() {}

  explicit DescribePolicyGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (describePolicyGroups) {
      vector<boost::any> temp1;
      for(auto item1:*describePolicyGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribePolicyGroups"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DescribePolicyGroups") != m.end() && !m["DescribePolicyGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribePolicyGroups"].type()) {
        vector<DescribePolicyGroupsResponseBodyDescribePolicyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribePolicyGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGroupsResponseBodyDescribePolicyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describePolicyGroups = make_shared<vector<DescribePolicyGroupsResponseBodyDescribePolicyGroups>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePolicyGroupsResponseBody() = default;
};
class DescribePolicyGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePolicyGroupsResponseBody> body{};

  DescribePolicyGroupsResponse() {}

  explicit DescribePolicyGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePolicyGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePolicyGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePolicyGroupsResponse() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> bandwidth{};
  shared_ptr<long> duration{};
  shared_ptr<long> groupDesktopCount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> osType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> rootDiskCategory{};
  shared_ptr<long> rootDiskSizeGib{};
  shared_ptr<string> userDiskCategory{};
  shared_ptr<long> userDiskSizeGib{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (groupDesktopCount) {
      res["GroupDesktopCount"] = boost::any(*groupDesktopCount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (rootDiskCategory) {
      res["RootDiskCategory"] = boost::any(*rootDiskCategory);
    }
    if (rootDiskSizeGib) {
      res["RootDiskSizeGib"] = boost::any(*rootDiskSizeGib);
    }
    if (userDiskCategory) {
      res["UserDiskCategory"] = boost::any(*userDiskCategory);
    }
    if (userDiskSizeGib) {
      res["UserDiskSizeGib"] = boost::any(*userDiskSizeGib);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("GroupDesktopCount") != m.end() && !m["GroupDesktopCount"].empty()) {
      groupDesktopCount = make_shared<long>(boost::any_cast<long>(m["GroupDesktopCount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RootDiskCategory") != m.end() && !m["RootDiskCategory"].empty()) {
      rootDiskCategory = make_shared<string>(boost::any_cast<string>(m["RootDiskCategory"]));
    }
    if (m.find("RootDiskSizeGib") != m.end() && !m["RootDiskSizeGib"].empty()) {
      rootDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["RootDiskSizeGib"]));
    }
    if (m.find("UserDiskCategory") != m.end() && !m["UserDiskCategory"].empty()) {
      userDiskCategory = make_shared<string>(boost::any_cast<string>(m["UserDiskCategory"]));
    }
    if (m.find("UserDiskSizeGib") != m.end() && !m["UserDiskSizeGib"].empty()) {
      userDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["UserDiskSizeGib"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceResponseBodyPriceInfoPricePromotions : public Darabonba::Model {
public:
  shared_ptr<string> optionCode{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<bool> selected{};

  DescribePriceResponseBodyPriceInfoPricePromotions() {}

  explicit DescribePriceResponseBodyPriceInfoPricePromotions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionCode) {
      res["OptionCode"] = boost::any(*optionCode);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OptionCode") != m.end() && !m["OptionCode"].empty()) {
      optionCode = make_shared<string>(boost::any_cast<string>(m["OptionCode"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPricePromotions() = default;
};
class DescribePriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<map<string, string>> orderLines{};
  shared_ptr<double> originalPrice{};
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoPricePromotions>> promotions{};
  shared_ptr<long> spPrice{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoPrice() {}

  explicit DescribePriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (orderLines) {
      res["OrderLines"] = boost::any(*orderLines);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (promotions) {
      vector<boost::any> temp1;
      for(auto item1:*promotions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Promotions"] = boost::any(temp1);
    }
    if (spPrice) {
      res["SpPrice"] = boost::any(*spPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OrderLines") != m.end() && !m["OrderLines"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["OrderLines"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderLines = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Promotions") != m.end() && !m["Promotions"].empty()) {
      if (typeid(vector<boost::any>) == m["Promotions"].type()) {
        vector<DescribePriceResponseBodyPriceInfoPricePromotions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Promotions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoPricePromotions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotions = make_shared<vector<DescribePriceResponseBodyPriceInfoPricePromotions>>(expect1);
      }
    }
    if (m.find("SpPrice") != m.end() && !m["SpPrice"].empty()) {
      spPrice = make_shared<long>(boost::any_cast<long>(m["SpPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPrice() = default;
};
class DescribePriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribePriceResponseBodyPriceInfoRules() {}

  explicit DescribePriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRules() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<bool> freeCdsQuota{};
  shared_ptr<long> freeCdsSize{};
  shared_ptr<DescribePriceResponseBodyPriceInfoPrice> price{};
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoRules>> rules{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (freeCdsQuota) {
      res["FreeCdsQuota"] = boost::any(*freeCdsQuota);
    }
    if (freeCdsSize) {
      res["FreeCdsSize"] = boost::any(*freeCdsSize);
    }
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FreeCdsQuota") != m.end() && !m["FreeCdsQuota"].empty()) {
      freeCdsQuota = make_shared<bool>(boost::any_cast<bool>(m["FreeCdsQuota"]));
    }
    if (m.find("FreeCdsSize") != m.end() && !m["FreeCdsSize"].empty()) {
      freeCdsSize = make_shared<long>(boost::any_cast<long>(m["FreeCdsSize"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribePriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribePriceResponseBodyPriceInfoPrice>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribePriceResponseBodyPriceInfoRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribePriceResponseBodyPriceInfoRules>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribePriceForCreateDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> desktopType{};
  shared_ptr<long> oversoldUserCount{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> systemDiskSize{};

  DescribePriceForCreateDesktopOversoldGroupRequest() {}

  explicit DescribePriceForCreateDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribePriceForCreateDesktopOversoldGroupRequest() = default;
};
class DescribePriceForCreateDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> price{};

  DescribePriceForCreateDesktopOversoldGroupResponseBodyData() {}

  explicit DescribePriceForCreateDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = boost::any(*price);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["Price"]));
    }
  }


  virtual ~DescribePriceForCreateDesktopOversoldGroupResponseBodyData() = default;
};
class DescribePriceForCreateDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceForCreateDesktopOversoldGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribePriceForCreateDesktopOversoldGroupResponseBody() {}

  explicit DescribePriceForCreateDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribePriceForCreateDesktopOversoldGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribePriceForCreateDesktopOversoldGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceForCreateDesktopOversoldGroupResponseBody() = default;
};
class DescribePriceForCreateDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceForCreateDesktopOversoldGroupResponseBody> body{};

  DescribePriceForCreateDesktopOversoldGroupResponse() {}

  explicit DescribePriceForCreateDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceForCreateDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceForCreateDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceForCreateDesktopOversoldGroupResponse() = default;
};
class DescribePriceForModifyDesktopOversoldGroupSaleRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> oversoldUserCount{};

  DescribePriceForModifyDesktopOversoldGroupSaleRequest() {}

  explicit DescribePriceForModifyDesktopOversoldGroupSaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
  }


  virtual ~DescribePriceForModifyDesktopOversoldGroupSaleRequest() = default;
};
class DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> price{};

  DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData() {}

  explicit DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = boost::any(*price);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["Price"]));
    }
  }


  virtual ~DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData() = default;
};
class DescribePriceForModifyDesktopOversoldGroupSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribePriceForModifyDesktopOversoldGroupSaleResponseBody() {}

  explicit DescribePriceForModifyDesktopOversoldGroupSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceForModifyDesktopOversoldGroupSaleResponseBody() = default;
};
class DescribePriceForModifyDesktopOversoldGroupSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceForModifyDesktopOversoldGroupSaleResponseBody> body{};

  DescribePriceForModifyDesktopOversoldGroupSaleResponse() {}

  explicit DescribePriceForModifyDesktopOversoldGroupSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceForModifyDesktopOversoldGroupSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceForModifyDesktopOversoldGroupSaleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceForModifyDesktopOversoldGroupSaleResponse() = default;
};
class DescribePriceForRenewDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};

  DescribePriceForRenewDesktopOversoldGroupRequest() {}

  explicit DescribePriceForRenewDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~DescribePriceForRenewDesktopOversoldGroupRequest() = default;
};
class DescribePriceForRenewDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> price{};

  DescribePriceForRenewDesktopOversoldGroupResponseBodyData() {}

  explicit DescribePriceForRenewDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = boost::any(*price);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["Price"]));
    }
  }


  virtual ~DescribePriceForRenewDesktopOversoldGroupResponseBodyData() = default;
};
class DescribePriceForRenewDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceForRenewDesktopOversoldGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribePriceForRenewDesktopOversoldGroupResponseBody() {}

  explicit DescribePriceForRenewDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribePriceForRenewDesktopOversoldGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribePriceForRenewDesktopOversoldGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceForRenewDesktopOversoldGroupResponseBody() = default;
};
class DescribePriceForRenewDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceForRenewDesktopOversoldGroupResponseBody> body{};

  DescribePriceForRenewDesktopOversoldGroupResponse() {}

  explicit DescribePriceForRenewDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceForRenewDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceForRenewDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceForRenewDesktopOversoldGroupResponse() = default;
};
class DescribeRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<bool> needSignedUrl{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> signedUrlExpireMinutes{};
  shared_ptr<string> standardEndTime{};
  shared_ptr<string> standardStartTime{};
  shared_ptr<string> startTime{};

  DescribeRecordingsRequest() {}

  explicit DescribeRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (needSignedUrl) {
      res["NeedSignedUrl"] = boost::any(*needSignedUrl);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (signedUrlExpireMinutes) {
      res["SignedUrlExpireMinutes"] = boost::any(*signedUrlExpireMinutes);
    }
    if (standardEndTime) {
      res["StandardEndTime"] = boost::any(*standardEndTime);
    }
    if (standardStartTime) {
      res["StandardStartTime"] = boost::any(*standardStartTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NeedSignedUrl") != m.end() && !m["NeedSignedUrl"].empty()) {
      needSignedUrl = make_shared<bool>(boost::any_cast<bool>(m["NeedSignedUrl"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SignedUrlExpireMinutes") != m.end() && !m["SignedUrlExpireMinutes"].empty()) {
      signedUrlExpireMinutes = make_shared<long>(boost::any_cast<long>(m["SignedUrlExpireMinutes"]));
    }
    if (m.find("StandardEndTime") != m.end() && !m["StandardEndTime"].empty()) {
      standardEndTime = make_shared<string>(boost::any_cast<string>(m["StandardEndTime"]));
    }
    if (m.find("StandardStartTime") != m.end() && !m["StandardStartTime"].empty()) {
      standardStartTime = make_shared<string>(boost::any_cast<string>(m["StandardStartTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRecordingsRequest() = default;
};
class DescribeRecordingsResponseBodyRecordings : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> filePath{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<long> recordingSize{};
  shared_ptr<string> recordingType{};
  shared_ptr<string> signedUrl{};
  shared_ptr<string> startTime{};

  DescribeRecordingsResponseBodyRecordings() {}

  explicit DescribeRecordingsResponseBodyRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (recordingSize) {
      res["RecordingSize"] = boost::any(*recordingSize);
    }
    if (recordingType) {
      res["RecordingType"] = boost::any(*recordingType);
    }
    if (signedUrl) {
      res["SignedUrl"] = boost::any(*signedUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RecordingSize") != m.end() && !m["RecordingSize"].empty()) {
      recordingSize = make_shared<long>(boost::any_cast<long>(m["RecordingSize"]));
    }
    if (m.find("RecordingType") != m.end() && !m["RecordingType"].empty()) {
      recordingType = make_shared<string>(boost::any_cast<string>(m["RecordingType"]));
    }
    if (m.find("SignedUrl") != m.end() && !m["SignedUrl"].empty()) {
      signedUrl = make_shared<string>(boost::any_cast<string>(m["SignedUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRecordingsResponseBodyRecordings() = default;
};
class DescribeRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<DescribeRecordingsResponseBodyRecordings>> recordings{};
  shared_ptr<string> requestId{};

  DescribeRecordingsResponseBody() {}

  explicit DescribeRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (recordings) {
      vector<boost::any> temp1;
      for(auto item1:*recordings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recordings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(vector<boost::any>) == m["Recordings"].type()) {
        vector<DescribeRecordingsResponseBodyRecordings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recordings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordingsResponseBodyRecordings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordings = make_shared<vector<DescribeRecordingsResponseBodyRecordings>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRecordingsResponseBody() = default;
};
class DescribeRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordingsResponseBody> body{};

  DescribeRecordingsResponse() {}

  explicit DescribeRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordingsResponse() = default;
};
class DescribeRefundPriceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> refundType{};
  shared_ptr<string> regionId{};

  DescribeRefundPriceRequest() {}

  explicit DescribeRefundPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (refundType) {
      res["RefundType"] = boost::any(*refundType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RefundType") != m.end() && !m["RefundType"].empty()) {
      refundType = make_shared<string>(boost::any_cast<string>(m["RefundType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRefundPriceRequest() = default;
};
class DescribeRefundPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> refundFee{};

  DescribeRefundPriceResponseBodyPriceInfo() {}

  explicit DescribeRefundPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["RefundFee"]));
    }
  }


  virtual ~DescribeRefundPriceResponseBodyPriceInfo() = default;
};
class DescribeRefundPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRefundPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeRefundPriceResponseBody() {}

  explicit DescribeRefundPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeRefundPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeRefundPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRefundPriceResponseBody() = default;
};
class DescribeRefundPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRefundPriceResponseBody> body{};

  DescribeRefundPriceResponse() {}

  explicit DescribeRefundPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRefundPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRefundPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRefundPriceResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> regionId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRenewalPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  DescribeRenewalPriceRequest() {}

  explicit DescribeRenewalPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeRenewalPriceRequest() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPricePromotions : public Darabonba::Model {
public:
  shared_ptr<string> optionCode{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<bool> selected{};

  DescribeRenewalPriceResponseBodyPriceInfoPricePromotions() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPricePromotions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionCode) {
      res["OptionCode"] = boost::any(*optionCode);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OptionCode") != m.end() && !m["OptionCode"].empty()) {
      optionCode = make_shared<string>(boost::any_cast<string>(m["OptionCode"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPricePromotions() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<map<string, string>> orderLines{};
  shared_ptr<double> originalPrice{};
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoPricePromotions>> promotions{};
  shared_ptr<double> tradePrice{};

  DescribeRenewalPriceResponseBodyPriceInfoPrice() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (orderLines) {
      res["OrderLines"] = boost::any(*orderLines);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (promotions) {
      vector<boost::any> temp1;
      for(auto item1:*promotions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Promotions"] = boost::any(temp1);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OrderLines") != m.end() && !m["OrderLines"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["OrderLines"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderLines = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Promotions") != m.end() && !m["Promotions"].empty()) {
      if (typeid(vector<boost::any>) == m["Promotions"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoPricePromotions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Promotions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoPricePromotions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotions = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoPricePromotions>>(expect1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoPrice() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeRenewalPriceResponseBodyPriceInfoRules() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoRules() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoPrice> price{};
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoRules>> rules{};

  DescribeRenewalPriceResponseBodyPriceInfo() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribeRenewalPriceResponseBodyPriceInfoPrice>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoRules>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfo() = default;
};
class DescribeRenewalPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeRenewalPriceResponseBody() {}

  explicit DescribeRenewalPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeRenewalPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBody() = default;
};
class DescribeRenewalPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRenewalPriceResponseBody> body{};

  DescribeRenewalPriceResponse() {}

  explicit DescribeRenewalPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenewalPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenewalPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponse() = default;
};
class DescribeResourceByCenterPolicyIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> productType{};
  shared_ptr<string> resourceId{};

  DescribeResourceByCenterPolicyIdRequest() {}

  explicit DescribeResourceByCenterPolicyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~DescribeResourceByCenterPolicyIdRequest() = default;
};
class DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList() {}

  explicit DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList() = default;
};
class DescribeResourceByCenterPolicyIdResponseBodyResourceModelList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList>> appModelList{};
  shared_ptr<long> cpu{};
  shared_ptr<string> desktopType{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<long> memory{};
  shared_ptr<string> osType{};
  shared_ptr<string> payType{};
  shared_ptr<string> productType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceGroupName{};
  shared_ptr<long> resourceGroupRelCount{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};

  DescribeResourceByCenterPolicyIdResponseBodyResourceModelList() {}

  explicit DescribeResourceByCenterPolicyIdResponseBodyResourceModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appModelList) {
      vector<boost::any> temp1;
      for(auto item1:*appModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppModelList"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceGroupName) {
      res["ResourceGroupName"] = boost::any(*resourceGroupName);
    }
    if (resourceGroupRelCount) {
      res["ResourceGroupRelCount"] = boost::any(*resourceGroupRelCount);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppModelList") != m.end() && !m["AppModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppModelList"].type()) {
        vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appModelList = make_shared<vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelListAppModelList>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceGroupName") != m.end() && !m["ResourceGroupName"].empty()) {
      resourceGroupName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupName"]));
    }
    if (m.find("ResourceGroupRelCount") != m.end() && !m["ResourceGroupRelCount"].empty()) {
      resourceGroupRelCount = make_shared<long>(boost::any_cast<long>(m["ResourceGroupRelCount"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeResourceByCenterPolicyIdResponseBodyResourceModelList() = default;
};
class DescribeResourceByCenterPolicyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelList>> resourceModelList{};

  DescribeResourceByCenterPolicyIdResponseBody() {}

  explicit DescribeResourceByCenterPolicyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceModelList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceModelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceModelList") != m.end() && !m["ResourceModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceModelList"].type()) {
        vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceByCenterPolicyIdResponseBodyResourceModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceModelList = make_shared<vector<DescribeResourceByCenterPolicyIdResponseBodyResourceModelList>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceByCenterPolicyIdResponseBody() = default;
};
class DescribeResourceByCenterPolicyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceByCenterPolicyIdResponseBody> body{};

  DescribeResourceByCenterPolicyIdResponse() {}

  explicit DescribeResourceByCenterPolicyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceByCenterPolicyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceByCenterPolicyIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceByCenterPolicyIdResponse() = default;
};
class DescribeSessionStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchRegionId{};
  shared_ptr<string> startTime{};

  DescribeSessionStatisticRequest() {}

  explicit DescribeSessionStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchRegionId) {
      res["SearchRegionId"] = boost::any(*searchRegionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchRegionId") != m.end() && !m["SearchRegionId"].empty()) {
      searchRegionId = make_shared<string>(boost::any_cast<string>(m["SearchRegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeSessionStatisticRequest() = default;
};
class DescribeSessionStatisticResponseBodyStatistic : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> timePoint{};

  DescribeSessionStatisticResponseBodyStatistic() {}

  explicit DescribeSessionStatisticResponseBodyStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<long>(boost::any_cast<long>(m["TimePoint"]));
    }
  }


  virtual ~DescribeSessionStatisticResponseBodyStatistic() = default;
};
class DescribeSessionStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSessionStatisticResponseBodyStatistic>> statistic{};
  shared_ptr<string> totalCount{};

  DescribeSessionStatisticResponseBody() {}

  explicit DescribeSessionStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistic) {
      vector<boost::any> temp1;
      for(auto item1:*statistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistic"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistic"].type()) {
        vector<DescribeSessionStatisticResponseBodyStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSessionStatisticResponseBodyStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistic = make_shared<vector<DescribeSessionStatisticResponseBodyStatistic>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSessionStatisticResponseBody() = default;
};
class DescribeSessionStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSessionStatisticResponseBody> body{};

  DescribeSessionStatisticResponse() {}

  explicit DescribeSessionStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSessionStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSessionStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSessionStatisticResponse() = default;
};
class DescribeSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> osType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<string> startTime{};

  DescribeSnapshotsRequest() {}

  explicit DescribeSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeSnapshotsRequest() = default;
};
class DescribeSnapshotsResponseBodySnapshots : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> deletionTime{};
  shared_ptr<string> description{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<string> diskStatus{};
  shared_ptr<string> osType{};
  shared_ptr<string> progress{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> remainTime{};
  shared_ptr<string> restorePointId{};
  shared_ptr<string> restorePointName{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> sourceDiskSize{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<string> status{};
  shared_ptr<bool> volumeEncryptionEnabled{};
  shared_ptr<string> volumeEncryptionKey{};

  DescribeSnapshotsResponseBodySnapshots() {}

  explicit DescribeSnapshotsResponseBodySnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deletionTime) {
      res["DeletionTime"] = boost::any(*deletionTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (diskStatus) {
      res["DiskStatus"] = boost::any(*diskStatus);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (remainTime) {
      res["RemainTime"] = boost::any(*remainTime);
    }
    if (restorePointId) {
      res["RestorePointId"] = boost::any(*restorePointId);
    }
    if (restorePointName) {
      res["RestorePointName"] = boost::any(*restorePointName);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (sourceDiskSize) {
      res["SourceDiskSize"] = boost::any(*sourceDiskSize);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (volumeEncryptionEnabled) {
      res["VolumeEncryptionEnabled"] = boost::any(*volumeEncryptionEnabled);
    }
    if (volumeEncryptionKey) {
      res["VolumeEncryptionKey"] = boost::any(*volumeEncryptionKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeletionTime") != m.end() && !m["DeletionTime"].empty()) {
      deletionTime = make_shared<string>(boost::any_cast<string>(m["DeletionTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("DiskStatus") != m.end() && !m["DiskStatus"].empty()) {
      diskStatus = make_shared<string>(boost::any_cast<string>(m["DiskStatus"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RemainTime") != m.end() && !m["RemainTime"].empty()) {
      remainTime = make_shared<long>(boost::any_cast<long>(m["RemainTime"]));
    }
    if (m.find("RestorePointId") != m.end() && !m["RestorePointId"].empty()) {
      restorePointId = make_shared<string>(boost::any_cast<string>(m["RestorePointId"]));
    }
    if (m.find("RestorePointName") != m.end() && !m["RestorePointName"].empty()) {
      restorePointName = make_shared<string>(boost::any_cast<string>(m["RestorePointName"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("SourceDiskSize") != m.end() && !m["SourceDiskSize"].empty()) {
      sourceDiskSize = make_shared<string>(boost::any_cast<string>(m["SourceDiskSize"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VolumeEncryptionEnabled") != m.end() && !m["VolumeEncryptionEnabled"].empty()) {
      volumeEncryptionEnabled = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncryptionEnabled"]));
    }
    if (m.find("VolumeEncryptionKey") != m.end() && !m["VolumeEncryptionKey"].empty()) {
      volumeEncryptionKey = make_shared<string>(boost::any_cast<string>(m["VolumeEncryptionKey"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshots() = default;
};
class DescribeSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshots>> snapshots{};

  DescribeSnapshotsResponseBody() {}

  explicit DescribeSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshots) {
      vector<boost::any> temp1;
      for(auto item1:*snapshots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshots"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshots = make_shared<vector<DescribeSnapshotsResponseBodySnapshots>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBody() = default;
};
class DescribeSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnapshotsResponseBody> body{};

  DescribeSnapshotsResponse() {}

  explicit DescribeSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponse() = default;
};
class DescribeTimerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};

  DescribeTimerGroupRequest() {}

  explicit DescribeTimerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeTimerGroupRequest() = default;
};
class DescribeTimerGroupResponseBodyDataConfigTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<long> notificationTime{};
  shared_ptr<string> operationType{};
  shared_ptr<vector<string>> processWhitelist{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};
  shared_ptr<string> triggerType{};

  DescribeTimerGroupResponseBodyDataConfigTimers() {}

  explicit DescribeTimerGroupResponseBodyDataConfigTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (notificationTime) {
      res["NotificationTime"] = boost::any(*notificationTime);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (processWhitelist) {
      res["ProcessWhitelist"] = boost::any(*processWhitelist);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("NotificationTime") != m.end() && !m["NotificationTime"].empty()) {
      notificationTime = make_shared<long>(boost::any_cast<long>(m["NotificationTime"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ProcessWhitelist") != m.end() && !m["ProcessWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~DescribeTimerGroupResponseBodyDataConfigTimers() = default;
};
class DescribeTimerGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> bindCount{};
  shared_ptr<map<string, long>> bindCountMap{};
  shared_ptr<vector<DescribeTimerGroupResponseBodyDataConfigTimers>> configTimers{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> productType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeTimerGroupResponseBodyData() {}

  explicit DescribeTimerGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (bindCountMap) {
      res["BindCountMap"] = boost::any(*bindCountMap);
    }
    if (configTimers) {
      vector<boost::any> temp1;
      for(auto item1:*configTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTimers"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("BindCountMap") != m.end() && !m["BindCountMap"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["BindCountMap"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bindCountMap = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("ConfigTimers") != m.end() && !m["ConfigTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTimers"].type()) {
        vector<DescribeTimerGroupResponseBodyDataConfigTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTimerGroupResponseBodyDataConfigTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTimers = make_shared<vector<DescribeTimerGroupResponseBodyDataConfigTimers>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTimerGroupResponseBodyData() = default;
};
class DescribeTimerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeTimerGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeTimerGroupResponseBody() {}

  explicit DescribeTimerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeTimerGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeTimerGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTimerGroupResponseBody() = default;
};
class DescribeTimerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTimerGroupResponseBody> body{};

  DescribeTimerGroupResponse() {}

  explicit DescribeTimerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTimerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTimerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTimerGroupResponse() = default;
};
class DescribeUserConnectTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> userDesktopId{};
  shared_ptr<string> userGroupId{};

  DescribeUserConnectTimeRequest() {}

  explicit DescribeUserConnectTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userDesktopId) {
      res["UserDesktopId"] = boost::any(*userDesktopId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UserDesktopId") != m.end() && !m["UserDesktopId"].empty()) {
      userDesktopId = make_shared<string>(boost::any_cast<string>(m["UserDesktopId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DescribeUserConnectTimeRequest() = default;
};
class DescribeUserConnectTimeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endConnectTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> startConnectTime{};
  shared_ptr<string> userDesktopId{};
  shared_ptr<string> userGroupId{};

  DescribeUserConnectTimeResponseBodyData() {}

  explicit DescribeUserConnectTimeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endConnectTime) {
      res["EndConnectTime"] = boost::any(*endConnectTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (startConnectTime) {
      res["StartConnectTime"] = boost::any(*startConnectTime);
    }
    if (userDesktopId) {
      res["UserDesktopId"] = boost::any(*userDesktopId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndConnectTime") != m.end() && !m["EndConnectTime"].empty()) {
      endConnectTime = make_shared<string>(boost::any_cast<string>(m["EndConnectTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("StartConnectTime") != m.end() && !m["StartConnectTime"].empty()) {
      startConnectTime = make_shared<string>(boost::any_cast<string>(m["StartConnectTime"]));
    }
    if (m.find("UserDesktopId") != m.end() && !m["UserDesktopId"].empty()) {
      userDesktopId = make_shared<string>(boost::any_cast<string>(m["UserDesktopId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DescribeUserConnectTimeResponseBodyData() = default;
};
class DescribeUserConnectTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeUserConnectTimeResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeUserConnectTimeResponseBody() {}

  explicit DescribeUserConnectTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeUserConnectTimeResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserConnectTimeResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeUserConnectTimeResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserConnectTimeResponseBody() = default;
};
class DescribeUserConnectTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserConnectTimeResponseBody> body{};

  DescribeUserConnectTimeResponse() {}

  explicit DescribeUserConnectTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserConnectTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserConnectTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserConnectTimeResponse() = default;
};
class DescribeUserConnectionRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> connectDurationFrom{};
  shared_ptr<long> connectDurationTo{};
  shared_ptr<long> connectEndTimeFrom{};
  shared_ptr<long> connectEndTimeTo{};
  shared_ptr<long> connectStartTimeFrom{};
  shared_ptr<long> connectStartTimeTo{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> endUserType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeUserConnectionRecordsRequest() {}

  explicit DescribeUserConnectionRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectDurationFrom) {
      res["ConnectDurationFrom"] = boost::any(*connectDurationFrom);
    }
    if (connectDurationTo) {
      res["ConnectDurationTo"] = boost::any(*connectDurationTo);
    }
    if (connectEndTimeFrom) {
      res["ConnectEndTimeFrom"] = boost::any(*connectEndTimeFrom);
    }
    if (connectEndTimeTo) {
      res["ConnectEndTimeTo"] = boost::any(*connectEndTimeTo);
    }
    if (connectStartTimeFrom) {
      res["ConnectStartTimeFrom"] = boost::any(*connectStartTimeFrom);
    }
    if (connectStartTimeTo) {
      res["ConnectStartTimeTo"] = boost::any(*connectStartTimeTo);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserType) {
      res["EndUserType"] = boost::any(*endUserType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectDurationFrom") != m.end() && !m["ConnectDurationFrom"].empty()) {
      connectDurationFrom = make_shared<long>(boost::any_cast<long>(m["ConnectDurationFrom"]));
    }
    if (m.find("ConnectDurationTo") != m.end() && !m["ConnectDurationTo"].empty()) {
      connectDurationTo = make_shared<long>(boost::any_cast<long>(m["ConnectDurationTo"]));
    }
    if (m.find("ConnectEndTimeFrom") != m.end() && !m["ConnectEndTimeFrom"].empty()) {
      connectEndTimeFrom = make_shared<long>(boost::any_cast<long>(m["ConnectEndTimeFrom"]));
    }
    if (m.find("ConnectEndTimeTo") != m.end() && !m["ConnectEndTimeTo"].empty()) {
      connectEndTimeTo = make_shared<long>(boost::any_cast<long>(m["ConnectEndTimeTo"]));
    }
    if (m.find("ConnectStartTimeFrom") != m.end() && !m["ConnectStartTimeFrom"].empty()) {
      connectStartTimeFrom = make_shared<long>(boost::any_cast<long>(m["ConnectStartTimeFrom"]));
    }
    if (m.find("ConnectStartTimeTo") != m.end() && !m["ConnectStartTimeTo"].empty()) {
      connectStartTimeTo = make_shared<long>(boost::any_cast<long>(m["ConnectStartTimeTo"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserType") != m.end() && !m["EndUserType"].empty()) {
      endUserType = make_shared<string>(boost::any_cast<string>(m["EndUserType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUserConnectionRecordsRequest() = default;
};
class DescribeUserConnectionRecordsResponseBodyConnectionRecords : public Darabonba::Model {
public:
  shared_ptr<string> connectDuration{};
  shared_ptr<string> connectEndTime{};
  shared_ptr<string> connectStartTime{};
  shared_ptr<string> connectionRecordId{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};

  DescribeUserConnectionRecordsResponseBodyConnectionRecords() {}

  explicit DescribeUserConnectionRecordsResponseBodyConnectionRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectDuration) {
      res["ConnectDuration"] = boost::any(*connectDuration);
    }
    if (connectEndTime) {
      res["ConnectEndTime"] = boost::any(*connectEndTime);
    }
    if (connectStartTime) {
      res["ConnectStartTime"] = boost::any(*connectStartTime);
    }
    if (connectionRecordId) {
      res["ConnectionRecordId"] = boost::any(*connectionRecordId);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectDuration") != m.end() && !m["ConnectDuration"].empty()) {
      connectDuration = make_shared<string>(boost::any_cast<string>(m["ConnectDuration"]));
    }
    if (m.find("ConnectEndTime") != m.end() && !m["ConnectEndTime"].empty()) {
      connectEndTime = make_shared<string>(boost::any_cast<string>(m["ConnectEndTime"]));
    }
    if (m.find("ConnectStartTime") != m.end() && !m["ConnectStartTime"].empty()) {
      connectStartTime = make_shared<string>(boost::any_cast<string>(m["ConnectStartTime"]));
    }
    if (m.find("ConnectionRecordId") != m.end() && !m["ConnectionRecordId"].empty()) {
      connectionRecordId = make_shared<string>(boost::any_cast<string>(m["ConnectionRecordId"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
  }


  virtual ~DescribeUserConnectionRecordsResponseBodyConnectionRecords() = default;
};
class DescribeUserConnectionRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserConnectionRecordsResponseBodyConnectionRecords>> connectionRecords{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeUserConnectionRecordsResponseBody() {}

  explicit DescribeUserConnectionRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionRecords) {
      vector<boost::any> temp1;
      for(auto item1:*connectionRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConnectionRecords"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionRecords") != m.end() && !m["ConnectionRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["ConnectionRecords"].type()) {
        vector<DescribeUserConnectionRecordsResponseBodyConnectionRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConnectionRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserConnectionRecordsResponseBodyConnectionRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connectionRecords = make_shared<vector<DescribeUserConnectionRecordsResponseBodyConnectionRecords>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserConnectionRecordsResponseBody() = default;
};
class DescribeUserConnectionRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserConnectionRecordsResponseBody> body{};

  DescribeUserConnectionRecordsResponse() {}

  explicit DescribeUserConnectionRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserConnectionRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserConnectionRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserConnectionRecordsResponse() = default;
};
class DescribeUserProfilePathRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleType{};

  DescribeUserProfilePathRulesRequest() {}

  explicit DescribeUserProfilePathRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeUserProfilePathRulesRequest() = default;
};
class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath() {}

  explicit DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath() = default;
};
class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths() {}

  explicit DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths() = default;
};
class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules : public Darabonba::Model {
public:
  shared_ptr<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath> blackPath{};
  shared_ptr<vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths>> whitePaths{};

  DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules() {}

  explicit DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackPath) {
      res["BlackPath"] = blackPath ? boost::any(blackPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (whitePaths) {
      vector<boost::any> temp1;
      for(auto item1:*whitePaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WhitePaths"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackPath") != m.end() && !m["BlackPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlackPath"].type()) {
        DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlackPath"]));
        blackPath = make_shared<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath>(model1);
      }
    }
    if (m.find("WhitePaths") != m.end() && !m["WhitePaths"].empty()) {
      if (typeid(vector<boost::any>) == m["WhitePaths"].type()) {
        vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhitePaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whitePaths = make_shared<vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths>>(expect1);
      }
    }
  }


  virtual ~DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules() = default;
};
class DescribeUserProfilePathRulesResponseBodyUserProfilePathRule : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules>> rules{};
  shared_ptr<string> userProfileRuleType{};

  DescribeUserProfilePathRulesResponseBodyUserProfilePathRule() {}

  explicit DescribeUserProfilePathRulesResponseBodyUserProfilePathRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (userProfileRuleType) {
      res["UserProfileRuleType"] = boost::any(*userProfileRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules>>(expect1);
      }
    }
    if (m.find("UserProfileRuleType") != m.end() && !m["UserProfileRuleType"].empty()) {
      userProfileRuleType = make_shared<string>(boost::any_cast<string>(m["UserProfileRuleType"]));
    }
  }


  virtual ~DescribeUserProfilePathRulesResponseBodyUserProfilePathRule() = default;
};
class DescribeUserProfilePathRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserProfilePathRulesResponseBodyUserProfilePathRule> userProfilePathRule{};

  DescribeUserProfilePathRulesResponseBody() {}

  explicit DescribeUserProfilePathRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userProfilePathRule) {
      res["UserProfilePathRule"] = userProfilePathRule ? boost::any(userProfilePathRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserProfilePathRule") != m.end() && !m["UserProfilePathRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserProfilePathRule"].type()) {
        DescribeUserProfilePathRulesResponseBodyUserProfilePathRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserProfilePathRule"]));
        userProfilePathRule = make_shared<DescribeUserProfilePathRulesResponseBodyUserProfilePathRule>(model1);
      }
    }
  }


  virtual ~DescribeUserProfilePathRulesResponseBody() = default;
};
class DescribeUserProfilePathRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserProfilePathRulesResponseBody> body{};

  DescribeUserProfilePathRulesResponse() {}

  explicit DescribeUserProfilePathRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserProfilePathRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserProfilePathRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserProfilePathRulesResponse() = default;
};
class DescribeUsersInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> connectState{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> endUserId{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> filter{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orgId{};
  shared_ptr<bool> queryUserDetail{};
  shared_ptr<string> regionId{};

  DescribeUsersInGroupRequest() {}

  explicit DescribeUsersInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectState) {
      res["ConnectState"] = boost::any(*connectState);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orgId) {
      res["OrgId"] = boost::any(*orgId);
    }
    if (queryUserDetail) {
      res["QueryUserDetail"] = boost::any(*queryUserDetail);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectState") != m.end() && !m["ConnectState"].empty()) {
      connectState = make_shared<long>(boost::any_cast<long>(m["ConnectState"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrgId") != m.end() && !m["OrgId"].empty()) {
      orgId = make_shared<string>(boost::any_cast<string>(m["OrgId"]));
    }
    if (m.find("QueryUserDetail") != m.end() && !m["QueryUserDetail"].empty()) {
      queryUserDetail = make_shared<bool>(boost::any_cast<bool>(m["QueryUserDetail"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUsersInGroupRequest() = default;
};
class DescribeUsersInGroupResponseBodyEndUsersExternalInfo : public Darabonba::Model {
public:
  shared_ptr<string> externalName{};
  shared_ptr<string> jobNumber{};

  DescribeUsersInGroupResponseBodyEndUsersExternalInfo() {}

  explicit DescribeUsersInGroupResponseBodyEndUsersExternalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalName) {
      res["ExternalName"] = boost::any(*externalName);
    }
    if (jobNumber) {
      res["JobNumber"] = boost::any(*jobNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalName") != m.end() && !m["ExternalName"].empty()) {
      externalName = make_shared<string>(boost::any_cast<string>(m["ExternalName"]));
    }
    if (m.find("JobNumber") != m.end() && !m["JobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["JobNumber"]));
    }
  }


  virtual ~DescribeUsersInGroupResponseBodyEndUsersExternalInfo() = default;
};
class DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues : public Darabonba::Model {
public:
  shared_ptr<string> propertyValue{};
  shared_ptr<long> propertyValueId{};

  DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues() {}

  explicit DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyValue) {
      res["PropertyValue"] = boost::any(*propertyValue);
    }
    if (propertyValueId) {
      res["PropertyValueId"] = boost::any(*propertyValueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyValue") != m.end() && !m["PropertyValue"].empty()) {
      propertyValue = make_shared<string>(boost::any_cast<string>(m["PropertyValue"]));
    }
    if (m.find("PropertyValueId") != m.end() && !m["PropertyValueId"].empty()) {
      propertyValueId = make_shared<long>(boost::any_cast<long>(m["PropertyValueId"]));
    }
  }


  virtual ~DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues() = default;
};
class DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels : public Darabonba::Model {
public:
  shared_ptr<long> propertyId{};
  shared_ptr<string> propertyKey{};
  shared_ptr<long> propertyType{};
  shared_ptr<vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues>> propertyValues{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels() {}

  explicit DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyId) {
      res["PropertyId"] = boost::any(*propertyId);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    if (propertyValues) {
      vector<boost::any> temp1;
      for(auto item1:*propertyValues){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyValues"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyId") != m.end() && !m["PropertyId"].empty()) {
      propertyId = make_shared<long>(boost::any_cast<long>(m["PropertyId"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      propertyType = make_shared<long>(boost::any_cast<long>(m["PropertyType"]));
    }
    if (m.find("PropertyValues") != m.end() && !m["PropertyValues"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyValues"].type()) {
        vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyValues"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyValues = make_shared<vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels() = default;
};
class DescribeUsersInGroupResponseBodyEndUsers : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameNew{};
  shared_ptr<string> endUserEmail{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> endUserName{};
  shared_ptr<string> endUserPhone{};
  shared_ptr<string> endUserRemark{};
  shared_ptr<string> endUserType{};
  shared_ptr<DescribeUsersInGroupResponseBodyEndUsersExternalInfo> externalInfo{};
  shared_ptr<string> userDesktopId{};
  shared_ptr<string> userPrincipalName{};
  shared_ptr<vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels>> userSetPropertiesModels{};

  DescribeUsersInGroupResponseBodyEndUsers() {}

  explicit DescribeUsersInGroupResponseBodyEndUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameNew) {
      res["DisplayNameNew"] = boost::any(*displayNameNew);
    }
    if (endUserEmail) {
      res["EndUserEmail"] = boost::any(*endUserEmail);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (endUserName) {
      res["EndUserName"] = boost::any(*endUserName);
    }
    if (endUserPhone) {
      res["EndUserPhone"] = boost::any(*endUserPhone);
    }
    if (endUserRemark) {
      res["EndUserRemark"] = boost::any(*endUserRemark);
    }
    if (endUserType) {
      res["EndUserType"] = boost::any(*endUserType);
    }
    if (externalInfo) {
      res["ExternalInfo"] = externalInfo ? boost::any(externalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userDesktopId) {
      res["UserDesktopId"] = boost::any(*userDesktopId);
    }
    if (userPrincipalName) {
      res["UserPrincipalName"] = boost::any(*userPrincipalName);
    }
    if (userSetPropertiesModels) {
      vector<boost::any> temp1;
      for(auto item1:*userSetPropertiesModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserSetPropertiesModels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameNew") != m.end() && !m["DisplayNameNew"].empty()) {
      displayNameNew = make_shared<string>(boost::any_cast<string>(m["DisplayNameNew"]));
    }
    if (m.find("EndUserEmail") != m.end() && !m["EndUserEmail"].empty()) {
      endUserEmail = make_shared<string>(boost::any_cast<string>(m["EndUserEmail"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EndUserName") != m.end() && !m["EndUserName"].empty()) {
      endUserName = make_shared<string>(boost::any_cast<string>(m["EndUserName"]));
    }
    if (m.find("EndUserPhone") != m.end() && !m["EndUserPhone"].empty()) {
      endUserPhone = make_shared<string>(boost::any_cast<string>(m["EndUserPhone"]));
    }
    if (m.find("EndUserRemark") != m.end() && !m["EndUserRemark"].empty()) {
      endUserRemark = make_shared<string>(boost::any_cast<string>(m["EndUserRemark"]));
    }
    if (m.find("EndUserType") != m.end() && !m["EndUserType"].empty()) {
      endUserType = make_shared<string>(boost::any_cast<string>(m["EndUserType"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExternalInfo"].type()) {
        DescribeUsersInGroupResponseBodyEndUsersExternalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExternalInfo"]));
        externalInfo = make_shared<DescribeUsersInGroupResponseBodyEndUsersExternalInfo>(model1);
      }
    }
    if (m.find("UserDesktopId") != m.end() && !m["UserDesktopId"].empty()) {
      userDesktopId = make_shared<string>(boost::any_cast<string>(m["UserDesktopId"]));
    }
    if (m.find("UserPrincipalName") != m.end() && !m["UserPrincipalName"].empty()) {
      userPrincipalName = make_shared<string>(boost::any_cast<string>(m["UserPrincipalName"]));
    }
    if (m.find("UserSetPropertiesModels") != m.end() && !m["UserSetPropertiesModels"].empty()) {
      if (typeid(vector<boost::any>) == m["UserSetPropertiesModels"].type()) {
        vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserSetPropertiesModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userSetPropertiesModels = make_shared<vector<DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels>>(expect1);
      }
    }
  }


  virtual ~DescribeUsersInGroupResponseBodyEndUsers() = default;
};
class DescribeUsersInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUsersInGroupResponseBodyEndUsers>> endUsers{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> onlineUsersCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userOuPath{};
  shared_ptr<long> usersCount{};

  DescribeUsersInGroupResponseBody() {}

  explicit DescribeUsersInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUsers) {
      vector<boost::any> temp1;
      for(auto item1:*endUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndUsers"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (onlineUsersCount) {
      res["OnlineUsersCount"] = boost::any(*onlineUsersCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userOuPath) {
      res["UserOuPath"] = boost::any(*userOuPath);
    }
    if (usersCount) {
      res["UsersCount"] = boost::any(*usersCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUsers") != m.end() && !m["EndUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["EndUsers"].type()) {
        vector<DescribeUsersInGroupResponseBodyEndUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUsersInGroupResponseBodyEndUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endUsers = make_shared<vector<DescribeUsersInGroupResponseBodyEndUsers>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OnlineUsersCount") != m.end() && !m["OnlineUsersCount"].empty()) {
      onlineUsersCount = make_shared<long>(boost::any_cast<long>(m["OnlineUsersCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserOuPath") != m.end() && !m["UserOuPath"].empty()) {
      userOuPath = make_shared<string>(boost::any_cast<string>(m["UserOuPath"]));
    }
    if (m.find("UsersCount") != m.end() && !m["UsersCount"].empty()) {
      usersCount = make_shared<long>(boost::any_cast<long>(m["UsersCount"]));
    }
  }


  virtual ~DescribeUsersInGroupResponseBody() = default;
};
class DescribeUsersInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUsersInGroupResponseBody> body{};

  DescribeUsersInGroupResponse() {}

  explicit DescribeUsersInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUsersInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUsersInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUsersInGroupResponse() = default;
};
class DescribeUsersPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> regionId{};

  DescribeUsersPasswordRequest() {}

  explicit DescribeUsersPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUsersPasswordRequest() = default;
};
class DescribeUsersPasswordResponseBodyDesktopUsers : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> password{};

  DescribeUsersPasswordResponseBodyDesktopUsers() {}

  explicit DescribeUsersPasswordResponseBodyDesktopUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~DescribeUsersPasswordResponseBodyDesktopUsers() = default;
};
class DescribeUsersPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUsersPasswordResponseBodyDesktopUsers>> desktopUsers{};
  shared_ptr<string> requestId{};

  DescribeUsersPasswordResponseBody() {}

  explicit DescribeUsersPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopUsers) {
      vector<boost::any> temp1;
      for(auto item1:*desktopUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopUsers"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopUsers") != m.end() && !m["DesktopUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopUsers"].type()) {
        vector<DescribeUsersPasswordResponseBodyDesktopUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUsersPasswordResponseBodyDesktopUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopUsers = make_shared<vector<DescribeUsersPasswordResponseBodyDesktopUsers>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUsersPasswordResponseBody() = default;
};
class DescribeUsersPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUsersPasswordResponseBody> body{};

  DescribeUsersPasswordResponse() {}

  explicit DescribeUsersPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUsersPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUsersPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUsersPasswordResponse() = default;
};
class DescribeVirtualMFADevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  DescribeVirtualMFADevicesRequest() {}

  explicit DescribeVirtualMFADevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeVirtualMFADevicesRequest() = default;
};
class DescribeVirtualMFADevicesResponseBodyVirtualMFADevices : public Darabonba::Model {
public:
  shared_ptr<long> consecutiveFails{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> gmtEnabled{};
  shared_ptr<string> gmtUnlock{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};

  DescribeVirtualMFADevicesResponseBodyVirtualMFADevices() {}

  explicit DescribeVirtualMFADevicesResponseBodyVirtualMFADevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consecutiveFails) {
      res["ConsecutiveFails"] = boost::any(*consecutiveFails);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (gmtEnabled) {
      res["GmtEnabled"] = boost::any(*gmtEnabled);
    }
    if (gmtUnlock) {
      res["GmtUnlock"] = boost::any(*gmtUnlock);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsecutiveFails") != m.end() && !m["ConsecutiveFails"].empty()) {
      consecutiveFails = make_shared<long>(boost::any_cast<long>(m["ConsecutiveFails"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("GmtEnabled") != m.end() && !m["GmtEnabled"].empty()) {
      gmtEnabled = make_shared<string>(boost::any_cast<string>(m["GmtEnabled"]));
    }
    if (m.find("GmtUnlock") != m.end() && !m["GmtUnlock"].empty()) {
      gmtUnlock = make_shared<string>(boost::any_cast<string>(m["GmtUnlock"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeVirtualMFADevicesResponseBodyVirtualMFADevices() = default;
};
class DescribeVirtualMFADevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVirtualMFADevicesResponseBodyVirtualMFADevices>> virtualMFADevices{};

  DescribeVirtualMFADevicesResponseBody() {}

  explicit DescribeVirtualMFADevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (virtualMFADevices) {
      vector<boost::any> temp1;
      for(auto item1:*virtualMFADevices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualMFADevices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VirtualMFADevices") != m.end() && !m["VirtualMFADevices"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualMFADevices"].type()) {
        vector<DescribeVirtualMFADevicesResponseBodyVirtualMFADevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualMFADevices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualMFADevicesResponseBodyVirtualMFADevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualMFADevices = make_shared<vector<DescribeVirtualMFADevicesResponseBodyVirtualMFADevices>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualMFADevicesResponseBody() = default;
};
class DescribeVirtualMFADevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVirtualMFADevicesResponseBody> body{};

  DescribeVirtualMFADevicesResponse() {}

  explicit DescribeVirtualMFADevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVirtualMFADevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVirtualMFADevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVirtualMFADevicesResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneType{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneType) {
      res["ZoneType"] = boost::any(*zoneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneType") != m.end() && !m["ZoneType"].empty()) {
      zoneType = make_shared<string>(boost::any_cast<string>(m["ZoneType"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeZonesResponseBodyZones>> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      vector<boost::any> temp1;
      for(auto item1:*zones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<DescribeZonesResponseBodyZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zones = make_shared<vector<DescribeZonesResponseBodyZones>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class DetachCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  DetachCenRequest() {}

  explicit DetachCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DetachCenRequest() = default;
};
class DetachCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachCenResponseBody() {}

  explicit DetachCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachCenResponseBody() = default;
};
class DetachCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachCenResponseBody> body{};

  DetachCenResponse() {}

  explicit DetachCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachCenResponseBody>(model1);
      }
    }
  }


  virtual ~DetachCenResponse() = default;
};
class DetachEndUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> adDomain{};
  shared_ptr<string> clientType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> region{};

  DetachEndUserRequest() {}

  explicit DetachEndUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adDomain) {
      res["AdDomain"] = boost::any(*adDomain);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdDomain") != m.end() && !m["AdDomain"].empty()) {
      adDomain = make_shared<string>(boost::any_cast<string>(m["AdDomain"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DetachEndUserRequest() = default;
};
class DetachEndUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachEndUserResponseBody() {}

  explicit DetachEndUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachEndUserResponseBody() = default;
};
class DetachEndUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachEndUserResponseBody> body{};

  DetachEndUserResponse() {}

  explicit DetachEndUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachEndUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachEndUserResponseBody>(model1);
      }
    }
  }


  virtual ~DetachEndUserResponse() = default;
};
class DisableDesktopsInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopIds{};
  shared_ptr<string> regionId{};

  DisableDesktopsInGroupRequest() {}

  explicit DisableDesktopsInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopIds) {
      res["DesktopIds"] = boost::any(*desktopIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopIds") != m.end() && !m["DesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableDesktopsInGroupRequest() = default;
};
class DisableDesktopsInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableDesktopsInGroupResponseBody() {}

  explicit DisableDesktopsInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableDesktopsInGroupResponseBody() = default;
};
class DisableDesktopsInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableDesktopsInGroupResponseBody> body{};

  DisableDesktopsInGroupResponse() {}

  explicit DisableDesktopsInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDesktopsInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDesktopsInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDesktopsInGroupResponse() = default;
};
class DisconnectDesktopSessionsRequestSessions : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> endUserId{};

  DisconnectDesktopSessionsRequestSessions() {}

  explicit DisconnectDesktopSessionsRequestSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
  }


  virtual ~DisconnectDesktopSessionsRequestSessions() = default;
};
class DisconnectDesktopSessionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> preCheck{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<DisconnectDesktopSessionsRequestSessions>> sessions{};

  DisconnectDesktopSessionsRequest() {}

  explicit DisconnectDesktopSessionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preCheck) {
      res["PreCheck"] = boost::any(*preCheck);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sessions) {
      vector<boost::any> temp1;
      for(auto item1:*sessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sessions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreCheck") != m.end() && !m["PreCheck"].empty()) {
      preCheck = make_shared<bool>(boost::any_cast<bool>(m["PreCheck"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sessions") != m.end() && !m["Sessions"].empty()) {
      if (typeid(vector<boost::any>) == m["Sessions"].type()) {
        vector<DisconnectDesktopSessionsRequestSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisconnectDesktopSessionsRequestSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sessions = make_shared<vector<DisconnectDesktopSessionsRequestSessions>>(expect1);
      }
    }
  }


  virtual ~DisconnectDesktopSessionsRequest() = default;
};
class DisconnectDesktopSessionsResponseBodyInvalidSessions : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> endUserId{};

  DisconnectDesktopSessionsResponseBodyInvalidSessions() {}

  explicit DisconnectDesktopSessionsResponseBodyInvalidSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
  }


  virtual ~DisconnectDesktopSessionsResponseBodyInvalidSessions() = default;
};
class DisconnectDesktopSessionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DisconnectDesktopSessionsResponseBodyInvalidSessions>> invalidSessions{};
  shared_ptr<string> requestId{};

  DisconnectDesktopSessionsResponseBody() {}

  explicit DisconnectDesktopSessionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidSessions) {
      vector<boost::any> temp1;
      for(auto item1:*invalidSessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidSessions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidSessions") != m.end() && !m["InvalidSessions"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidSessions"].type()) {
        vector<DisconnectDesktopSessionsResponseBodyInvalidSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidSessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DisconnectDesktopSessionsResponseBodyInvalidSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidSessions = make_shared<vector<DisconnectDesktopSessionsResponseBodyInvalidSessions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisconnectDesktopSessionsResponseBody() = default;
};
class DisconnectDesktopSessionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisconnectDesktopSessionsResponseBody> body{};

  DisconnectDesktopSessionsResponse() {}

  explicit DisconnectDesktopSessionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisconnectDesktopSessionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisconnectDesktopSessionsResponseBody>(model1);
      }
    }
  }


  virtual ~DisconnectDesktopSessionsResponse() = default;
};
class DissociateNetworkPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> regionId{};

  DissociateNetworkPackageRequest() {}

  explicit DissociateNetworkPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DissociateNetworkPackageRequest() = default;
};
class DissociateNetworkPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DissociateNetworkPackageResponseBody() {}

  explicit DissociateNetworkPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateNetworkPackageResponseBody() = default;
};
class DissociateNetworkPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateNetworkPackageResponseBody> body{};

  DissociateNetworkPackageResponse() {}

  explicit DissociateNetworkPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateNetworkPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateNetworkPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateNetworkPackageResponse() = default;
};
class DownloadCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};

  DownloadCdsFileRequest() {}

  explicit DownloadCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DownloadCdsFileRequest() = default;
};
class DownloadCdsFileResponseBodyDownloadFileModel : public Darabonba::Model {
public:
  shared_ptr<string> downloadType{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> expirationSecond{};
  shared_ptr<string> expirationTime{};
  shared_ptr<string> fileId{};
  shared_ptr<long> size{};
  shared_ptr<string> streamUrl{};

  DownloadCdsFileResponseBodyDownloadFileModel() {}

  explicit DownloadCdsFileResponseBodyDownloadFileModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadType) {
      res["DownloadType"] = boost::any(*downloadType);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (expirationSecond) {
      res["ExpirationSecond"] = boost::any(*expirationSecond);
    }
    if (expirationTime) {
      res["ExpirationTime"] = boost::any(*expirationTime);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadType") != m.end() && !m["DownloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["DownloadType"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExpirationSecond") != m.end() && !m["ExpirationSecond"].empty()) {
      expirationSecond = make_shared<string>(boost::any_cast<string>(m["ExpirationSecond"]));
    }
    if (m.find("ExpirationTime") != m.end() && !m["ExpirationTime"].empty()) {
      expirationTime = make_shared<string>(boost::any_cast<string>(m["ExpirationTime"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DownloadCdsFileResponseBodyDownloadFileModel() = default;
};
class DownloadCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<DownloadCdsFileResponseBodyDownloadFileModel> downloadFileModel{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DownloadCdsFileResponseBody() {}

  explicit DownloadCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadFileModel) {
      res["DownloadFileModel"] = downloadFileModel ? boost::any(downloadFileModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadFileModel") != m.end() && !m["DownloadFileModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadFileModel"].type()) {
        DownloadCdsFileResponseBodyDownloadFileModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadFileModel"]));
        downloadFileModel = make_shared<DownloadCdsFileResponseBodyDownloadFileModel>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadCdsFileResponseBody() = default;
};
class DownloadCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadCdsFileResponseBody> body{};

  DownloadCdsFileResponse() {}

  explicit DownloadCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadCdsFileResponse() = default;
};
class ExportClientEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> eventType{};
  shared_ptr<vector<string>> eventTypes{};
  shared_ptr<string> langType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  ExportClientEventsRequest() {}

  explicit ExportClientEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (eventTypes) {
      res["EventTypes"] = boost::any(*eventTypes);
    }
    if (langType) {
      res["LangType"] = boost::any(*langType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("EventTypes") != m.end() && !m["EventTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LangType") != m.end() && !m["LangType"].empty()) {
      langType = make_shared<string>(boost::any_cast<string>(m["LangType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ExportClientEventsRequest() = default;
};
class ExportClientEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  ExportClientEventsResponseBody() {}

  explicit ExportClientEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ExportClientEventsResponseBody() = default;
};
class ExportClientEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportClientEventsResponseBody> body{};

  ExportClientEventsResponse() {}

  explicit ExportClientEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportClientEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportClientEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ExportClientEventsResponse() = default;
};
class ExportDesktopGroupInfoRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ExportDesktopGroupInfoRequestTag() {}

  explicit ExportDesktopGroupInfoRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExportDesktopGroupInfoRequestTag() = default;
};
class ExportDesktopGroupInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<vector<string>> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> langType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ExportDesktopGroupInfoRequestTag>> tag{};

  ExportDesktopGroupInfoRequest() {}

  explicit ExportDesktopGroupInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (langType) {
      res["LangType"] = boost::any(*langType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("LangType") != m.end() && !m["LangType"].empty()) {
      langType = make_shared<string>(boost::any_cast<string>(m["LangType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ExportDesktopGroupInfoRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportDesktopGroupInfoRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ExportDesktopGroupInfoRequestTag>>(expect1);
      }
    }
  }


  virtual ~ExportDesktopGroupInfoRequest() = default;
};
class ExportDesktopGroupInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  ExportDesktopGroupInfoResponseBody() {}

  explicit ExportDesktopGroupInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ExportDesktopGroupInfoResponseBody() = default;
};
class ExportDesktopGroupInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportDesktopGroupInfoResponseBody> body{};

  ExportDesktopGroupInfoResponse() {}

  explicit ExportDesktopGroupInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportDesktopGroupInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportDesktopGroupInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ExportDesktopGroupInfoResponse() = default;
};
class ExportDesktopListInfoRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ExportDesktopListInfoRequestTag() {}

  explicit ExportDesktopListInfoRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExportDesktopListInfoRequestTag() = default;
};
class ExportDesktopListInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> desktopName{};
  shared_ptr<string> desktopStatus{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> langType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ExportDesktopListInfoRequestTag>> tag{};
  shared_ptr<string> userName{};

  ExportDesktopListInfoRequest() {}

  explicit ExportDesktopListInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopName) {
      res["DesktopName"] = boost::any(*desktopName);
    }
    if (desktopStatus) {
      res["DesktopStatus"] = boost::any(*desktopStatus);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (langType) {
      res["LangType"] = boost::any(*langType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopName") != m.end() && !m["DesktopName"].empty()) {
      desktopName = make_shared<string>(boost::any_cast<string>(m["DesktopName"]));
    }
    if (m.find("DesktopStatus") != m.end() && !m["DesktopStatus"].empty()) {
      desktopStatus = make_shared<string>(boost::any_cast<string>(m["DesktopStatus"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("LangType") != m.end() && !m["LangType"].empty()) {
      langType = make_shared<string>(boost::any_cast<string>(m["LangType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ExportDesktopListInfoRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportDesktopListInfoRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ExportDesktopListInfoRequestTag>>(expect1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ExportDesktopListInfoRequest() = default;
};
class ExportDesktopListInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  ExportDesktopListInfoResponseBody() {}

  explicit ExportDesktopListInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ExportDesktopListInfoResponseBody() = default;
};
class ExportDesktopListInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportDesktopListInfoResponseBody> body{};

  ExportDesktopListInfoResponse() {}

  explicit ExportDesktopListInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportDesktopListInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportDesktopListInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ExportDesktopListInfoResponse() = default;
};
class GetAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> cdsId{};

  GetAsyncTaskRequest() {}

  explicit GetAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
  }


  virtual ~GetAsyncTaskRequest() = default;
};
class GetAsyncTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> consumedProcess{};
  shared_ptr<long> errCode{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<long> totalProcess{};
  shared_ptr<string> url{};

  GetAsyncTaskResponseBodyData() {}

  explicit GetAsyncTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (consumedProcess) {
      res["ConsumedProcess"] = boost::any(*consumedProcess);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalProcess) {
      res["TotalProcess"] = boost::any(*totalProcess);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("ConsumedProcess") != m.end() && !m["ConsumedProcess"].empty()) {
      consumedProcess = make_shared<string>(boost::any_cast<string>(m["ConsumedProcess"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<long>(boost::any_cast<long>(m["ErrCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalProcess") != m.end() && !m["TotalProcess"].empty()) {
      totalProcess = make_shared<long>(boost::any_cast<long>(m["TotalProcess"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAsyncTaskResponseBodyData() = default;
};
class GetAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAsyncTaskResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetAsyncTaskResponseBody() {}

  explicit GetAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAsyncTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAsyncTaskResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetAsyncTaskResponseBody() = default;
};
class GetAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAsyncTaskResponseBody> body{};

  GetAsyncTaskResponse() {}

  explicit GetAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetAsyncTaskResponse() = default;
};
class GetConnectionTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandContent{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> uuid{};

  GetConnectionTicketRequest() {}

  explicit GetConnectionTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetConnectionTicketRequest() = default;
};
class GetConnectionTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskMessage{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> ticket{};

  GetConnectionTicketResponseBody() {}

  explicit GetConnectionTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskMessage) {
      res["TaskMessage"] = boost::any(*taskMessage);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (ticket) {
      res["Ticket"] = boost::any(*ticket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskMessage") != m.end() && !m["TaskMessage"].empty()) {
      taskMessage = make_shared<string>(boost::any_cast<string>(m["TaskMessage"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Ticket") != m.end() && !m["Ticket"].empty()) {
      ticket = make_shared<string>(boost::any_cast<string>(m["Ticket"]));
    }
  }


  virtual ~GetConnectionTicketResponseBody() = default;
};
class GetConnectionTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConnectionTicketResponseBody> body{};

  GetConnectionTicketResponse() {}

  explicit GetConnectionTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConnectionTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConnectionTicketResponseBody>(model1);
      }
    }
  }


  virtual ~GetConnectionTicketResponse() = default;
};
class GetCoordinateTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> coId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> userType{};

  GetCoordinateTicketRequest() {}

  explicit GetCoordinateTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coId) {
      res["CoId"] = boost::any(*coId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoId") != m.end() && !m["CoId"].empty()) {
      coId = make_shared<string>(boost::any_cast<string>(m["CoId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~GetCoordinateTicketRequest() = default;
};
class GetCoordinateTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> coId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> ticket{};

  GetCoordinateTicketResponseBody() {}

  explicit GetCoordinateTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coId) {
      res["CoId"] = boost::any(*coId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (ticket) {
      res["Ticket"] = boost::any(*ticket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoId") != m.end() && !m["CoId"].empty()) {
      coId = make_shared<string>(boost::any_cast<string>(m["CoId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Ticket") != m.end() && !m["Ticket"].empty()) {
      ticket = make_shared<string>(boost::any_cast<string>(m["Ticket"]));
    }
  }


  virtual ~GetCoordinateTicketResponseBody() = default;
};
class GetCoordinateTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCoordinateTicketResponseBody> body{};

  GetCoordinateTicketResponse() {}

  explicit GetCoordinateTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCoordinateTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCoordinateTicketResponseBody>(model1);
      }
    }
  }


  virtual ~GetCoordinateTicketResponse() = default;
};
class GetDesktopGroupDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};

  GetDesktopGroupDetailRequest() {}

  explicit GetDesktopGroupDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDesktopGroupDetailRequest() = default;
};
class GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos : public Darabonba::Model {
public:
  shared_ptr<long> buyResAmount{};
  shared_ptr<string> cron{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxResAmount{};
  shared_ptr<long> minResAmount{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<string> type{};

  GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos() {}

  explicit GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyResAmount) {
      res["BuyResAmount"] = boost::any(*buyResAmount);
    }
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxResAmount) {
      res["MaxResAmount"] = boost::any(*maxResAmount);
    }
    if (minResAmount) {
      res["MinResAmount"] = boost::any(*minResAmount);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyResAmount") != m.end() && !m["BuyResAmount"].empty()) {
      buyResAmount = make_shared<long>(boost::any_cast<long>(m["BuyResAmount"]));
    }
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxResAmount") != m.end() && !m["MaxResAmount"].empty()) {
      maxResAmount = make_shared<long>(boost::any_cast<long>(m["MaxResAmount"]));
    }
    if (m.find("MinResAmount") != m.end() && !m["MinResAmount"].empty()) {
      minResAmount = make_shared<long>(boost::any_cast<long>(m["MinResAmount"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos() = default;
};
class GetDesktopGroupDetailResponseBodyDesktopsTimerInfos : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> forced{};
  shared_ptr<long> status{};
  shared_ptr<long> timerType{};

  GetDesktopGroupDetailResponseBodyDesktopsTimerInfos() {}

  explicit GetDesktopGroupDetailResponseBodyDesktopsTimerInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (forced) {
      res["Forced"] = boost::any(*forced);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Forced") != m.end() && !m["Forced"].empty()) {
      forced = make_shared<bool>(boost::any_cast<bool>(m["Forced"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<long>(boost::any_cast<long>(m["TimerType"]));
    }
  }


  virtual ~GetDesktopGroupDetailResponseBodyDesktopsTimerInfos() = default;
};
class GetDesktopGroupDetailResponseBodyDesktops : public Darabonba::Model {
public:
  shared_ptr<long> allowAutoSetup{};
  shared_ptr<long> allowBufferCount{};
  shared_ptr<long> bindAmount{};
  shared_ptr<long> buyDesktopsCount{};
  shared_ptr<string> comments{};
  shared_ptr<long> connectDuration{};
  shared_ptr<long> cpu{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<string> dataDiskSize{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryType{};
  shared_ptr<string> expiredTime{};
  shared_ptr<double> gpuCount{};
  shared_ptr<string> gpuSpec{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxDesktopsCount{};
  shared_ptr<long> memory{};
  shared_ptr<long> minDesktopsCount{};
  shared_ptr<string> nasFileSystemID{};
  shared_ptr<string> nasFileSystemName{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteType{};
  shared_ptr<string> ownBundleId{};
  shared_ptr<string> ownBundleName{};
  shared_ptr<long> ownType{};
  shared_ptr<string> payType{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<vector<string>> policyGroupIds{};
  shared_ptr<string> policyGroupName{};
  shared_ptr<vector<string>> policyGroupNames{};
  shared_ptr<bool> profileFollowSwitch{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<long> resType{};
  shared_ptr<long> resetType{};
  shared_ptr<vector<GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos>> scaleTimerInfos{};
  shared_ptr<long> status{};
  shared_ptr<long> stopDuration{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<GetDesktopGroupDetailResponseBodyDesktopsTimerInfos>> timerInfos{};
  shared_ptr<string> timingStrategyInfo{};
  shared_ptr<long> version{};

  GetDesktopGroupDetailResponseBodyDesktops() {}

  explicit GetDesktopGroupDetailResponseBodyDesktops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowAutoSetup) {
      res["AllowAutoSetup"] = boost::any(*allowAutoSetup);
    }
    if (allowBufferCount) {
      res["AllowBufferCount"] = boost::any(*allowBufferCount);
    }
    if (bindAmount) {
      res["BindAmount"] = boost::any(*bindAmount);
    }
    if (buyDesktopsCount) {
      res["BuyDesktopsCount"] = boost::any(*buyDesktopsCount);
    }
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (connectDuration) {
      res["ConnectDuration"] = boost::any(*connectDuration);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryType) {
      res["DirectoryType"] = boost::any(*directoryType);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuSpec) {
      res["GpuSpec"] = boost::any(*gpuSpec);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxDesktopsCount) {
      res["MaxDesktopsCount"] = boost::any(*maxDesktopsCount);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minDesktopsCount) {
      res["MinDesktopsCount"] = boost::any(*minDesktopsCount);
    }
    if (nasFileSystemID) {
      res["NasFileSystemID"] = boost::any(*nasFileSystemID);
    }
    if (nasFileSystemName) {
      res["NasFileSystemName"] = boost::any(*nasFileSystemName);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteType) {
      res["OfficeSiteType"] = boost::any(*officeSiteType);
    }
    if (ownBundleId) {
      res["OwnBundleId"] = boost::any(*ownBundleId);
    }
    if (ownBundleName) {
      res["OwnBundleName"] = boost::any(*ownBundleName);
    }
    if (ownType) {
      res["OwnType"] = boost::any(*ownType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupIds) {
      res["PolicyGroupIds"] = boost::any(*policyGroupIds);
    }
    if (policyGroupName) {
      res["PolicyGroupName"] = boost::any(*policyGroupName);
    }
    if (policyGroupNames) {
      res["PolicyGroupNames"] = boost::any(*policyGroupNames);
    }
    if (profileFollowSwitch) {
      res["ProfileFollowSwitch"] = boost::any(*profileFollowSwitch);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (resType) {
      res["ResType"] = boost::any(*resType);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (scaleTimerInfos) {
      vector<boost::any> temp1;
      for(auto item1:*scaleTimerInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScaleTimerInfos"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (timerInfos) {
      vector<boost::any> temp1;
      for(auto item1:*timerInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimerInfos"] = boost::any(temp1);
    }
    if (timingStrategyInfo) {
      res["TimingStrategyInfo"] = boost::any(*timingStrategyInfo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowAutoSetup") != m.end() && !m["AllowAutoSetup"].empty()) {
      allowAutoSetup = make_shared<long>(boost::any_cast<long>(m["AllowAutoSetup"]));
    }
    if (m.find("AllowBufferCount") != m.end() && !m["AllowBufferCount"].empty()) {
      allowBufferCount = make_shared<long>(boost::any_cast<long>(m["AllowBufferCount"]));
    }
    if (m.find("BindAmount") != m.end() && !m["BindAmount"].empty()) {
      bindAmount = make_shared<long>(boost::any_cast<long>(m["BindAmount"]));
    }
    if (m.find("BuyDesktopsCount") != m.end() && !m["BuyDesktopsCount"].empty()) {
      buyDesktopsCount = make_shared<long>(boost::any_cast<long>(m["BuyDesktopsCount"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("ConnectDuration") != m.end() && !m["ConnectDuration"].empty()) {
      connectDuration = make_shared<long>(boost::any_cast<long>(m["ConnectDuration"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryType") != m.end() && !m["DirectoryType"].empty()) {
      directoryType = make_shared<string>(boost::any_cast<string>(m["DirectoryType"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<double>(boost::any_cast<double>(m["GpuCount"]));
    }
    if (m.find("GpuSpec") != m.end() && !m["GpuSpec"].empty()) {
      gpuSpec = make_shared<string>(boost::any_cast<string>(m["GpuSpec"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxDesktopsCount") != m.end() && !m["MaxDesktopsCount"].empty()) {
      maxDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MaxDesktopsCount"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MinDesktopsCount") != m.end() && !m["MinDesktopsCount"].empty()) {
      minDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MinDesktopsCount"]));
    }
    if (m.find("NasFileSystemID") != m.end() && !m["NasFileSystemID"].empty()) {
      nasFileSystemID = make_shared<string>(boost::any_cast<string>(m["NasFileSystemID"]));
    }
    if (m.find("NasFileSystemName") != m.end() && !m["NasFileSystemName"].empty()) {
      nasFileSystemName = make_shared<string>(boost::any_cast<string>(m["NasFileSystemName"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteType") != m.end() && !m["OfficeSiteType"].empty()) {
      officeSiteType = make_shared<string>(boost::any_cast<string>(m["OfficeSiteType"]));
    }
    if (m.find("OwnBundleId") != m.end() && !m["OwnBundleId"].empty()) {
      ownBundleId = make_shared<string>(boost::any_cast<string>(m["OwnBundleId"]));
    }
    if (m.find("OwnBundleName") != m.end() && !m["OwnBundleName"].empty()) {
      ownBundleName = make_shared<string>(boost::any_cast<string>(m["OwnBundleName"]));
    }
    if (m.find("OwnType") != m.end() && !m["OwnType"].empty()) {
      ownType = make_shared<long>(boost::any_cast<long>(m["OwnType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupIds") != m.end() && !m["PolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyGroupName") != m.end() && !m["PolicyGroupName"].empty()) {
      policyGroupName = make_shared<string>(boost::any_cast<string>(m["PolicyGroupName"]));
    }
    if (m.find("PolicyGroupNames") != m.end() && !m["PolicyGroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProfileFollowSwitch") != m.end() && !m["ProfileFollowSwitch"].empty()) {
      profileFollowSwitch = make_shared<bool>(boost::any_cast<bool>(m["ProfileFollowSwitch"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("ResType") != m.end() && !m["ResType"].empty()) {
      resType = make_shared<long>(boost::any_cast<long>(m["ResType"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<long>(boost::any_cast<long>(m["ResetType"]));
    }
    if (m.find("ScaleTimerInfos") != m.end() && !m["ScaleTimerInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ScaleTimerInfos"].type()) {
        vector<GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScaleTimerInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scaleTimerInfos = make_shared<vector<GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("TimerInfos") != m.end() && !m["TimerInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TimerInfos"].type()) {
        vector<GetDesktopGroupDetailResponseBodyDesktopsTimerInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimerInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDesktopGroupDetailResponseBodyDesktopsTimerInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timerInfos = make_shared<vector<GetDesktopGroupDetailResponseBodyDesktopsTimerInfos>>(expect1);
      }
    }
    if (m.find("TimingStrategyInfo") != m.end() && !m["TimingStrategyInfo"].empty()) {
      timingStrategyInfo = make_shared<string>(boost::any_cast<string>(m["TimingStrategyInfo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetDesktopGroupDetailResponseBodyDesktops() = default;
};
class GetDesktopGroupDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDesktopGroupDetailResponseBodyDesktops> desktops{};
  shared_ptr<string> requestId{};

  GetDesktopGroupDetailResponseBody() {}

  explicit GetDesktopGroupDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktops) {
      res["Desktops"] = desktops ? boost::any(desktops->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desktops") != m.end() && !m["Desktops"].empty()) {
      if (typeid(map<string, boost::any>) == m["Desktops"].type()) {
        GetDesktopGroupDetailResponseBodyDesktops model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Desktops"]));
        desktops = make_shared<GetDesktopGroupDetailResponseBodyDesktops>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDesktopGroupDetailResponseBody() = default;
};
class GetDesktopGroupDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDesktopGroupDetailResponseBody> body{};

  GetDesktopGroupDetailResponse() {}

  explicit GetDesktopGroupDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDesktopGroupDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDesktopGroupDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDesktopGroupDetailResponse() = default;
};
class GetOfficeSiteSsoStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  GetOfficeSiteSsoStatusRequest() {}

  explicit GetOfficeSiteSsoStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetOfficeSiteSsoStatusRequest() = default;
};
class GetOfficeSiteSsoStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> ssoStatus{};

  GetOfficeSiteSsoStatusResponseBody() {}

  explicit GetOfficeSiteSsoStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ssoStatus) {
      res["SsoStatus"] = boost::any(*ssoStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SsoStatus") != m.end() && !m["SsoStatus"].empty()) {
      ssoStatus = make_shared<bool>(boost::any_cast<bool>(m["SsoStatus"]));
    }
  }


  virtual ~GetOfficeSiteSsoStatusResponseBody() = default;
};
class GetOfficeSiteSsoStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOfficeSiteSsoStatusResponseBody> body{};

  GetOfficeSiteSsoStatusResponse() {}

  explicit GetOfficeSiteSsoStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOfficeSiteSsoStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOfficeSiteSsoStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetOfficeSiteSsoStatusResponse() = default;
};
class GetSpMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> directoryId{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  GetSpMetadataRequest() {}

  explicit GetSpMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSpMetadataRequest() = default;
};
class GetSpMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> spMetadata{};

  GetSpMetadataResponseBody() {}

  explicit GetSpMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spMetadata) {
      res["SpMetadata"] = boost::any(*spMetadata);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpMetadata") != m.end() && !m["SpMetadata"].empty()) {
      spMetadata = make_shared<string>(boost::any_cast<string>(m["SpMetadata"]));
    }
  }


  virtual ~GetSpMetadataResponseBody() = default;
};
class GetSpMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpMetadataResponseBody> body{};

  GetSpMetadataResponse() {}

  explicit GetSpMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpMetadataResponse() = default;
};
class HibernateDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};

  HibernateDesktopsRequest() {}

  explicit HibernateDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~HibernateDesktopsRequest() = default;
};
class HibernateDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  HibernateDesktopsResponseBody() {}

  explicit HibernateDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HibernateDesktopsResponseBody() = default;
};
class HibernateDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HibernateDesktopsResponseBody> body{};

  HibernateDesktopsResponse() {}

  explicit HibernateDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HibernateDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HibernateDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~HibernateDesktopsResponse() = default;
};
class ListCdsFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<vector<string>> fileIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderType{};
  shared_ptr<string> parentFileId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  ListCdsFilesRequest() {}

  explicit ListCdsFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (parentFileId) {
      res["ParentFileId"] = boost::any(*parentFileId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("ParentFileId") != m.end() && !m["ParentFileId"].empty()) {
      parentFileId = make_shared<string>(boost::any_cast<string>(m["ParentFileId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCdsFilesRequest() = default;
};
class ListCdsFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileIdsShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderType{};
  shared_ptr<string> parentFileId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  ListCdsFilesShrinkRequest() {}

  explicit ListCdsFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileIdsShrink) {
      res["FileIds"] = boost::any(*fileIdsShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (parentFileId) {
      res["ParentFileId"] = boost::any(*parentFileId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIdsShrink = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("ParentFileId") != m.end() && !m["ParentFileId"].empty()) {
      parentFileId = make_shared<string>(boost::any_cast<string>(m["ParentFileId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCdsFilesShrinkRequest() = default;
};
class ListCdsFilesResponseBodyFileModels : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> contentType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> fileId{};
  shared_ptr<string> filePath{};
  shared_ptr<string> fileType{};
  shared_ptr<string> md5{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> openTime{};
  shared_ptr<long> openTimeStamp{};
  shared_ptr<string> parentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sha1{};
  shared_ptr<long> size{};
  shared_ptr<string> thumbnail{};

  ListCdsFilesResponseBodyFileModels() {}

  explicit ListCdsFilesResponseBodyFileModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openTime) {
      res["OpenTime"] = boost::any(*openTime);
    }
    if (openTimeStamp) {
      res["OpenTimeStamp"] = boost::any(*openTimeStamp);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sha1) {
      res["Sha1"] = boost::any(*sha1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenTime") != m.end() && !m["OpenTime"].empty()) {
      openTime = make_shared<string>(boost::any_cast<string>(m["OpenTime"]));
    }
    if (m.find("OpenTimeStamp") != m.end() && !m["OpenTimeStamp"].empty()) {
      openTimeStamp = make_shared<long>(boost::any_cast<long>(m["OpenTimeStamp"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sha1") != m.end() && !m["Sha1"].empty()) {
      sha1 = make_shared<string>(boost::any_cast<string>(m["Sha1"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
  }


  virtual ~ListCdsFilesResponseBodyFileModels() = default;
};
class ListCdsFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<vector<ListCdsFilesResponseBodyFileModels>> fileModels{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCdsFilesResponseBody() {}

  explicit ListCdsFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (fileModels) {
      vector<boost::any> temp1;
      for(auto item1:*fileModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileModels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("FileModels") != m.end() && !m["FileModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FileModels"].type()) {
        vector<ListCdsFilesResponseBodyFileModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCdsFilesResponseBodyFileModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileModels = make_shared<vector<ListCdsFilesResponseBodyFileModels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCdsFilesResponseBody() = default;
};
class ListCdsFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCdsFilesResponseBody> body{};

  ListCdsFilesResponse() {}

  explicit ListCdsFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCdsFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCdsFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCdsFilesResponse() = default;
};
class ListDirectoryUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignedInfo{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> filter{};
  shared_ptr<bool> includeAssignedUser{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> OUPath{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sortType{};

  ListDirectoryUsersRequest() {}

  explicit ListDirectoryUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedInfo) {
      res["AssignedInfo"] = boost::any(*assignedInfo);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (includeAssignedUser) {
      res["IncludeAssignedUser"] = boost::any(*includeAssignedUser);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (OUPath) {
      res["OUPath"] = boost::any(*OUPath);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedInfo") != m.end() && !m["AssignedInfo"].empty()) {
      assignedInfo = make_shared<string>(boost::any_cast<string>(m["AssignedInfo"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("IncludeAssignedUser") != m.end() && !m["IncludeAssignedUser"].empty()) {
      includeAssignedUser = make_shared<bool>(boost::any_cast<bool>(m["IncludeAssignedUser"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OUPath") != m.end() && !m["OUPath"].empty()) {
      OUPath = make_shared<string>(boost::any_cast<string>(m["OUPath"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
  }


  virtual ~ListDirectoryUsersRequest() = default;
};
class ListDirectoryUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<long> assignedDesktopNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameNew{};
  shared_ptr<string> email{};
  shared_ptr<string> endUser{};
  shared_ptr<string> phone{};
  shared_ptr<string> userPrincipalName{};

  ListDirectoryUsersResponseBodyUsers() {}

  explicit ListDirectoryUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedDesktopNumber) {
      res["AssignedDesktopNumber"] = boost::any(*assignedDesktopNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameNew) {
      res["DisplayNameNew"] = boost::any(*displayNameNew);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (endUser) {
      res["EndUser"] = boost::any(*endUser);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (userPrincipalName) {
      res["UserPrincipalName"] = boost::any(*userPrincipalName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedDesktopNumber") != m.end() && !m["AssignedDesktopNumber"].empty()) {
      assignedDesktopNumber = make_shared<long>(boost::any_cast<long>(m["AssignedDesktopNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameNew") != m.end() && !m["DisplayNameNew"].empty()) {
      displayNameNew = make_shared<string>(boost::any_cast<string>(m["DisplayNameNew"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EndUser") != m.end() && !m["EndUser"].empty()) {
      endUser = make_shared<string>(boost::any_cast<string>(m["EndUser"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("UserPrincipalName") != m.end() && !m["UserPrincipalName"].empty()) {
      userPrincipalName = make_shared<string>(boost::any_cast<string>(m["UserPrincipalName"]));
    }
  }


  virtual ~ListDirectoryUsersResponseBodyUsers() = default;
};
class ListDirectoryUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDirectoryUsersResponseBodyUsers>> users{};

  ListDirectoryUsersResponseBody() {}

  explicit ListDirectoryUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListDirectoryUsersResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDirectoryUsersResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListDirectoryUsersResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListDirectoryUsersResponseBody() = default;
};
class ListDirectoryUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDirectoryUsersResponseBody> body{};

  ListDirectoryUsersResponse() {}

  explicit ListDirectoryUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDirectoryUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDirectoryUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListDirectoryUsersResponse() = default;
};
class ListFilePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};

  ListFilePermissionRequest() {}

  explicit ListFilePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFilePermissionRequest() = default;
};
class ListFilePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<FilePermissionMember>> filePermissions{};
  shared_ptr<string> requestId{};

  ListFilePermissionResponseBody() {}

  explicit ListFilePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePermissions) {
      vector<boost::any> temp1;
      for(auto item1:*filePermissions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilePermissions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePermissions") != m.end() && !m["FilePermissions"].empty()) {
      if (typeid(vector<boost::any>) == m["FilePermissions"].type()) {
        vector<FilePermissionMember> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilePermissions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FilePermissionMember model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filePermissions = make_shared<vector<FilePermissionMember>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFilePermissionResponseBody() = default;
};
class ListFilePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFilePermissionResponseBody> body{};

  ListFilePermissionResponse() {}

  explicit ListFilePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilePermissionResponse() = default;
};
class ListOfficeSiteOverviewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceRefresh{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> officeSiteId{};
  shared_ptr<long> queryRange{};
  shared_ptr<string> regionId{};

  ListOfficeSiteOverviewRequest() {}

  explicit ListOfficeSiteOverviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceRefresh) {
      res["ForceRefresh"] = boost::any(*forceRefresh);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (queryRange) {
      res["QueryRange"] = boost::any(*queryRange);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceRefresh") != m.end() && !m["ForceRefresh"].empty()) {
      forceRefresh = make_shared<bool>(boost::any_cast<bool>(m["ForceRefresh"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OfficeSiteId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OfficeSiteId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      officeSiteId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("QueryRange") != m.end() && !m["QueryRange"].empty()) {
      queryRange = make_shared<long>(boost::any_cast<long>(m["QueryRange"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListOfficeSiteOverviewRequest() = default;
};
class ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults : public Darabonba::Model {
public:
  shared_ptr<long> hasExpiredEdsCount{};
  shared_ptr<long> hasExpiredEdsCountForGroup{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> officeSiteStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningEdsCount{};
  shared_ptr<long> runningEdsCountForGroup{};
  shared_ptr<long> totalEdsCount{};
  shared_ptr<long> totalEdsCountForGroup{};
  shared_ptr<string> vpcType{};
  shared_ptr<long> willExpiredEdsCount{};
  shared_ptr<long> willExpiredEdsCountForGroup{};

  ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults() {}

  explicit ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasExpiredEdsCount) {
      res["HasExpiredEdsCount"] = boost::any(*hasExpiredEdsCount);
    }
    if (hasExpiredEdsCountForGroup) {
      res["HasExpiredEdsCountForGroup"] = boost::any(*hasExpiredEdsCountForGroup);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (officeSiteStatus) {
      res["OfficeSiteStatus"] = boost::any(*officeSiteStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningEdsCount) {
      res["RunningEdsCount"] = boost::any(*runningEdsCount);
    }
    if (runningEdsCountForGroup) {
      res["RunningEdsCountForGroup"] = boost::any(*runningEdsCountForGroup);
    }
    if (totalEdsCount) {
      res["TotalEdsCount"] = boost::any(*totalEdsCount);
    }
    if (totalEdsCountForGroup) {
      res["TotalEdsCountForGroup"] = boost::any(*totalEdsCountForGroup);
    }
    if (vpcType) {
      res["VpcType"] = boost::any(*vpcType);
    }
    if (willExpiredEdsCount) {
      res["WillExpiredEdsCount"] = boost::any(*willExpiredEdsCount);
    }
    if (willExpiredEdsCountForGroup) {
      res["WillExpiredEdsCountForGroup"] = boost::any(*willExpiredEdsCountForGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasExpiredEdsCount") != m.end() && !m["HasExpiredEdsCount"].empty()) {
      hasExpiredEdsCount = make_shared<long>(boost::any_cast<long>(m["HasExpiredEdsCount"]));
    }
    if (m.find("HasExpiredEdsCountForGroup") != m.end() && !m["HasExpiredEdsCountForGroup"].empty()) {
      hasExpiredEdsCountForGroup = make_shared<long>(boost::any_cast<long>(m["HasExpiredEdsCountForGroup"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("OfficeSiteStatus") != m.end() && !m["OfficeSiteStatus"].empty()) {
      officeSiteStatus = make_shared<string>(boost::any_cast<string>(m["OfficeSiteStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningEdsCount") != m.end() && !m["RunningEdsCount"].empty()) {
      runningEdsCount = make_shared<long>(boost::any_cast<long>(m["RunningEdsCount"]));
    }
    if (m.find("RunningEdsCountForGroup") != m.end() && !m["RunningEdsCountForGroup"].empty()) {
      runningEdsCountForGroup = make_shared<long>(boost::any_cast<long>(m["RunningEdsCountForGroup"]));
    }
    if (m.find("TotalEdsCount") != m.end() && !m["TotalEdsCount"].empty()) {
      totalEdsCount = make_shared<long>(boost::any_cast<long>(m["TotalEdsCount"]));
    }
    if (m.find("TotalEdsCountForGroup") != m.end() && !m["TotalEdsCountForGroup"].empty()) {
      totalEdsCountForGroup = make_shared<long>(boost::any_cast<long>(m["TotalEdsCountForGroup"]));
    }
    if (m.find("VpcType") != m.end() && !m["VpcType"].empty()) {
      vpcType = make_shared<string>(boost::any_cast<string>(m["VpcType"]));
    }
    if (m.find("WillExpiredEdsCount") != m.end() && !m["WillExpiredEdsCount"].empty()) {
      willExpiredEdsCount = make_shared<long>(boost::any_cast<long>(m["WillExpiredEdsCount"]));
    }
    if (m.find("WillExpiredEdsCountForGroup") != m.end() && !m["WillExpiredEdsCountForGroup"].empty()) {
      willExpiredEdsCountForGroup = make_shared<long>(boost::any_cast<long>(m["WillExpiredEdsCountForGroup"]));
    }
  }


  virtual ~ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults() = default;
};
class ListOfficeSiteOverviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults>> officeSiteOverviewResults{};
  shared_ptr<string> requestId{};

  ListOfficeSiteOverviewResponseBody() {}

  explicit ListOfficeSiteOverviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteOverviewResults) {
      vector<boost::any> temp1;
      for(auto item1:*officeSiteOverviewResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OfficeSiteOverviewResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteOverviewResults") != m.end() && !m["OfficeSiteOverviewResults"].empty()) {
      if (typeid(vector<boost::any>) == m["OfficeSiteOverviewResults"].type()) {
        vector<ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OfficeSiteOverviewResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        officeSiteOverviewResults = make_shared<vector<ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOfficeSiteOverviewResponseBody() = default;
};
class ListOfficeSiteOverviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOfficeSiteOverviewResponseBody> body{};

  ListOfficeSiteOverviewResponse() {}

  explicit ListOfficeSiteOverviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOfficeSiteOverviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOfficeSiteOverviewResponseBody>(model1);
      }
    }
  }


  virtual ~ListOfficeSiteOverviewResponse() = default;
};
class ListOfficeSiteUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignedInfo{};
  shared_ptr<string> filter{};
  shared_ptr<bool> includeAssignedUser{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> OUPath{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sortType{};

  ListOfficeSiteUsersRequest() {}

  explicit ListOfficeSiteUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedInfo) {
      res["AssignedInfo"] = boost::any(*assignedInfo);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (includeAssignedUser) {
      res["IncludeAssignedUser"] = boost::any(*includeAssignedUser);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (OUPath) {
      res["OUPath"] = boost::any(*OUPath);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedInfo") != m.end() && !m["AssignedInfo"].empty()) {
      assignedInfo = make_shared<string>(boost::any_cast<string>(m["AssignedInfo"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("IncludeAssignedUser") != m.end() && !m["IncludeAssignedUser"].empty()) {
      includeAssignedUser = make_shared<bool>(boost::any_cast<bool>(m["IncludeAssignedUser"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OUPath") != m.end() && !m["OUPath"].empty()) {
      OUPath = make_shared<string>(boost::any_cast<string>(m["OUPath"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
  }


  virtual ~ListOfficeSiteUsersRequest() = default;
};
class ListOfficeSiteUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<long> assignedDesktopNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameNew{};
  shared_ptr<string> email{};
  shared_ptr<string> endUser{};
  shared_ptr<string> phone{};
  shared_ptr<string> userPrincipalName{};

  ListOfficeSiteUsersResponseBodyUsers() {}

  explicit ListOfficeSiteUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedDesktopNumber) {
      res["AssignedDesktopNumber"] = boost::any(*assignedDesktopNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameNew) {
      res["DisplayNameNew"] = boost::any(*displayNameNew);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (endUser) {
      res["EndUser"] = boost::any(*endUser);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (userPrincipalName) {
      res["UserPrincipalName"] = boost::any(*userPrincipalName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedDesktopNumber") != m.end() && !m["AssignedDesktopNumber"].empty()) {
      assignedDesktopNumber = make_shared<long>(boost::any_cast<long>(m["AssignedDesktopNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameNew") != m.end() && !m["DisplayNameNew"].empty()) {
      displayNameNew = make_shared<string>(boost::any_cast<string>(m["DisplayNameNew"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EndUser") != m.end() && !m["EndUser"].empty()) {
      endUser = make_shared<string>(boost::any_cast<string>(m["EndUser"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("UserPrincipalName") != m.end() && !m["UserPrincipalName"].empty()) {
      userPrincipalName = make_shared<string>(boost::any_cast<string>(m["UserPrincipalName"]));
    }
  }


  virtual ~ListOfficeSiteUsersResponseBodyUsers() = default;
};
class ListOfficeSiteUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListOfficeSiteUsersResponseBodyUsers>> users{};

  ListOfficeSiteUsersResponseBody() {}

  explicit ListOfficeSiteUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListOfficeSiteUsersResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOfficeSiteUsersResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListOfficeSiteUsersResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListOfficeSiteUsersResponseBody() = default;
};
class ListOfficeSiteUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOfficeSiteUsersResponseBody> body{};

  ListOfficeSiteUsersResponse() {}

  explicit ListOfficeSiteUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOfficeSiteUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOfficeSiteUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListOfficeSiteUsersResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserAdOrganizationUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> filter{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ListUserAdOrganizationUnitsRequest() {}

  explicit ListUserAdOrganizationUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListUserAdOrganizationUnitsRequest() = default;
};
class ListUserAdOrganizationUnitsResponseBodyOUNames : public Darabonba::Model {
public:
  shared_ptr<string> displayOUName{};
  shared_ptr<string> OUName{};
  shared_ptr<string> officeSiteId{};

  ListUserAdOrganizationUnitsResponseBodyOUNames() {}

  explicit ListUserAdOrganizationUnitsResponseBodyOUNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayOUName) {
      res["DisplayOUName"] = boost::any(*displayOUName);
    }
    if (OUName) {
      res["OUName"] = boost::any(*OUName);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayOUName") != m.end() && !m["DisplayOUName"].empty()) {
      displayOUName = make_shared<string>(boost::any_cast<string>(m["DisplayOUName"]));
    }
    if (m.find("OUName") != m.end() && !m["OUName"].empty()) {
      OUName = make_shared<string>(boost::any_cast<string>(m["OUName"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
  }


  virtual ~ListUserAdOrganizationUnitsResponseBodyOUNames() = default;
};
class ListUserAdOrganizationUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListUserAdOrganizationUnitsResponseBodyOUNames>> OUNames{};
  shared_ptr<string> requestId{};

  ListUserAdOrganizationUnitsResponseBody() {}

  explicit ListUserAdOrganizationUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (OUNames) {
      vector<boost::any> temp1;
      for(auto item1:*OUNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OUNames"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OUNames") != m.end() && !m["OUNames"].empty()) {
      if (typeid(vector<boost::any>) == m["OUNames"].type()) {
        vector<ListUserAdOrganizationUnitsResponseBodyOUNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OUNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserAdOrganizationUnitsResponseBodyOUNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OUNames = make_shared<vector<ListUserAdOrganizationUnitsResponseBodyOUNames>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUserAdOrganizationUnitsResponseBody() = default;
};
class ListUserAdOrganizationUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserAdOrganizationUnitsResponseBody> body{};

  ListUserAdOrganizationUnitsResponse() {}

  explicit ListUserAdOrganizationUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserAdOrganizationUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserAdOrganizationUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserAdOrganizationUnitsResponse() = default;
};
class LockVirtualMFADeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumber{};

  LockVirtualMFADeviceRequest() {}

  explicit LockVirtualMFADeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~LockVirtualMFADeviceRequest() = default;
};
class LockVirtualMFADeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LockVirtualMFADeviceResponseBody() {}

  explicit LockVirtualMFADeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LockVirtualMFADeviceResponseBody() = default;
};
class LockVirtualMFADeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LockVirtualMFADeviceResponseBody> body{};

  LockVirtualMFADeviceResponse() {}

  explicit LockVirtualMFADeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LockVirtualMFADeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LockVirtualMFADeviceResponseBody>(model1);
      }
    }
  }


  virtual ~LockVirtualMFADeviceResponse() = default;
};
class MigrateDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetOfficeSiteId{};

  MigrateDesktopsRequest() {}

  explicit MigrateDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetOfficeSiteId) {
      res["TargetOfficeSiteId"] = boost::any(*targetOfficeSiteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetOfficeSiteId") != m.end() && !m["TargetOfficeSiteId"].empty()) {
      targetOfficeSiteId = make_shared<string>(boost::any_cast<string>(m["TargetOfficeSiteId"]));
    }
  }


  virtual ~MigrateDesktopsRequest() = default;
};
class MigrateDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MigrateDesktopsResponseBody() {}

  explicit MigrateDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateDesktopsResponseBody() = default;
};
class MigrateDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MigrateDesktopsResponseBody> body{};

  MigrateDesktopsResponse() {}

  explicit MigrateDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateDesktopsResponse() = default;
};
class MigrateImageProtocolRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> imageId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetProtocolType{};

  MigrateImageProtocolRequest() {}

  explicit MigrateImageProtocolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetProtocolType) {
      res["TargetProtocolType"] = boost::any(*targetProtocolType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetProtocolType") != m.end() && !m["TargetProtocolType"].empty()) {
      targetProtocolType = make_shared<string>(boost::any_cast<string>(m["TargetProtocolType"]));
    }
  }


  virtual ~MigrateImageProtocolRequest() = default;
};
class MigrateImageProtocolResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedIds{};
  shared_ptr<string> requestId{};

  MigrateImageProtocolResponseBody() {}

  explicit MigrateImageProtocolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedIds) {
      res["FailedIds"] = boost::any(*failedIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedIds") != m.end() && !m["FailedIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateImageProtocolResponseBody() = default;
};
class MigrateImageProtocolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MigrateImageProtocolResponseBody> body{};

  MigrateImageProtocolResponse() {}

  explicit MigrateImageProtocolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateImageProtocolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateImageProtocolResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateImageProtocolResponse() = default;
};
class ModifyADConnectorDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> adHostname{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> directoryName{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> OUName{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> subDomainDnsAddress{};
  shared_ptr<string> subDomainName{};

  ModifyADConnectorDirectoryRequest() {}

  explicit ModifyADConnectorDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (directoryName) {
      res["DirectoryName"] = boost::any(*directoryName);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (OUName) {
      res["OUName"] = boost::any(*OUName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subDomainDnsAddress) {
      res["SubDomainDnsAddress"] = boost::any(*subDomainDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("DirectoryName") != m.end() && !m["DirectoryName"].empty()) {
      directoryName = make_shared<string>(boost::any_cast<string>(m["DirectoryName"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("OUName") != m.end() && !m["OUName"].empty()) {
      OUName = make_shared<string>(boost::any_cast<string>(m["OUName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubDomainDnsAddress") != m.end() && !m["SubDomainDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDomainDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDomainDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDomainDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
  }


  virtual ~ModifyADConnectorDirectoryRequest() = default;
};
class ModifyADConnectorDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyADConnectorDirectoryResponseBody() {}

  explicit ModifyADConnectorDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyADConnectorDirectoryResponseBody() = default;
};
class ModifyADConnectorDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyADConnectorDirectoryResponseBody> body{};

  ModifyADConnectorDirectoryResponse() {}

  explicit ModifyADConnectorDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyADConnectorDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyADConnectorDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyADConnectorDirectoryResponse() = default;
};
class ModifyADConnectorOfficeSiteRequest : public Darabonba::Model {
public:
  shared_ptr<string> adHostname{};
  shared_ptr<string> backupDCHostname{};
  shared_ptr<string> backupDns{};
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainPassword{};
  shared_ptr<string> domainUserName{};
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> OUName{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> subDomainDnsAddress{};
  shared_ptr<string> subDomainName{};

  ModifyADConnectorOfficeSiteRequest() {}

  explicit ModifyADConnectorOfficeSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adHostname) {
      res["AdHostname"] = boost::any(*adHostname);
    }
    if (backupDCHostname) {
      res["BackupDCHostname"] = boost::any(*backupDCHostname);
    }
    if (backupDns) {
      res["BackupDns"] = boost::any(*backupDns);
    }
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainPassword) {
      res["DomainPassword"] = boost::any(*domainPassword);
    }
    if (domainUserName) {
      res["DomainUserName"] = boost::any(*domainUserName);
    }
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (OUName) {
      res["OUName"] = boost::any(*OUName);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subDomainDnsAddress) {
      res["SubDomainDnsAddress"] = boost::any(*subDomainDnsAddress);
    }
    if (subDomainName) {
      res["SubDomainName"] = boost::any(*subDomainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdHostname") != m.end() && !m["AdHostname"].empty()) {
      adHostname = make_shared<string>(boost::any_cast<string>(m["AdHostname"]));
    }
    if (m.find("BackupDCHostname") != m.end() && !m["BackupDCHostname"].empty()) {
      backupDCHostname = make_shared<string>(boost::any_cast<string>(m["BackupDCHostname"]));
    }
    if (m.find("BackupDns") != m.end() && !m["BackupDns"].empty()) {
      backupDns = make_shared<string>(boost::any_cast<string>(m["BackupDns"]));
    }
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainPassword") != m.end() && !m["DomainPassword"].empty()) {
      domainPassword = make_shared<string>(boost::any_cast<string>(m["DomainPassword"]));
    }
    if (m.find("DomainUserName") != m.end() && !m["DomainUserName"].empty()) {
      domainUserName = make_shared<string>(boost::any_cast<string>(m["DomainUserName"]));
    }
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("OUName") != m.end() && !m["OUName"].empty()) {
      OUName = make_shared<string>(boost::any_cast<string>(m["OUName"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubDomainDnsAddress") != m.end() && !m["SubDomainDnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubDomainDnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubDomainDnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subDomainDnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDomainName") != m.end() && !m["SubDomainName"].empty()) {
      subDomainName = make_shared<string>(boost::any_cast<string>(m["SubDomainName"]));
    }
  }


  virtual ~ModifyADConnectorOfficeSiteRequest() = default;
};
class ModifyADConnectorOfficeSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyADConnectorOfficeSiteResponseBody() {}

  explicit ModifyADConnectorOfficeSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyADConnectorOfficeSiteResponseBody() = default;
};
class ModifyADConnectorOfficeSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyADConnectorOfficeSiteResponseBody> body{};

  ModifyADConnectorOfficeSiteResponse() {}

  explicit ModifyADConnectorOfficeSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyADConnectorOfficeSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyADConnectorOfficeSiteResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyADConnectorOfficeSiteResponse() = default;
};
class ModifyAclEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> policy{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> sourceId{};
  shared_ptr<string> sourceType{};

  ModifyAclEntriesRequest() {}

  explicit ModifyAclEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ModifyAclEntriesRequest() = default;
};
class ModifyAclEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAclEntriesResponseBody() {}

  explicit ModifyAclEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAclEntriesResponseBody() = default;
};
class ModifyAclEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAclEntriesResponseBody> body{};

  ModifyAclEntriesResponse() {}

  explicit ModifyAclEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAclEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAclEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAclEntriesResponse() = default;
};
class ModifyAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> regionId{};
  shared_ptr<long> retentionDays{};

  ModifyAutoSnapshotPolicyRequest() {}

  explicit ModifyAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyRequest() = default;
};
class ModifyAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAutoSnapshotPolicyResponseBody() {}

  explicit ModifyAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAutoSnapshotPolicyResponseBody() = default;
};
class ModifyAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAutoSnapshotPolicyResponseBody> body{};

  ModifyAutoSnapshotPolicyResponse() {}

  explicit ModifyAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoSnapshotPolicyResponse() = default;
};
class ModifyBundleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bundleId{};
  shared_ptr<string> bundleName{};
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> language{};
  shared_ptr<string> regionId{};

  ModifyBundleRequest() {}

  explicit ModifyBundleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bundleId) {
      res["BundleId"] = boost::any(*bundleId);
    }
    if (bundleName) {
      res["BundleName"] = boost::any(*bundleName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BundleId") != m.end() && !m["BundleId"].empty()) {
      bundleId = make_shared<string>(boost::any_cast<string>(m["BundleId"]));
    }
    if (m.find("BundleName") != m.end() && !m["BundleName"].empty()) {
      bundleName = make_shared<string>(boost::any_cast<string>(m["BundleName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyBundleRequest() = default;
};
class ModifyBundleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBundleResponseBody() {}

  explicit ModifyBundleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBundleResponseBody() = default;
};
class ModifyBundleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBundleResponseBody> body{};

  ModifyBundleResponse() {}

  explicit ModifyBundleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBundleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBundleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBundleResponse() = default;
};
class ModifyCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> conflictPolicy{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};

  ModifyCdsFileRequest() {}

  explicit ModifyCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (conflictPolicy) {
      res["ConflictPolicy"] = boost::any(*conflictPolicy);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("ConflictPolicy") != m.end() && !m["ConflictPolicy"].empty()) {
      conflictPolicy = make_shared<string>(boost::any_cast<string>(m["ConflictPolicy"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyCdsFileRequest() = default;
};
class ModifyCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyCdsFileResponseBody() {}

  explicit ModifyCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyCdsFileResponseBody() = default;
};
class ModifyCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCdsFileResponseBody> body{};

  ModifyCdsFileResponse() {}

  explicit ModifyCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCdsFileResponse() = default;
};
class ModifyCdsFileShareLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableDownload{};
  shared_ptr<bool> disablePreview{};
  shared_ptr<bool> disableSave{};
  shared_ptr<long> downloadCount{};
  shared_ptr<long> downloadLimit{};
  shared_ptr<string> expiration{};
  shared_ptr<long> previewCount{};
  shared_ptr<long> previewLimit{};
  shared_ptr<long> reportCount{};
  shared_ptr<long> saveCount{};
  shared_ptr<long> saveLimit{};
  shared_ptr<string> shareId{};
  shared_ptr<string> shareName{};
  shared_ptr<string> sharePwd{};
  shared_ptr<string> status{};
  shared_ptr<long> videoPreviewCount{};

  ModifyCdsFileShareLinkRequest() {}

  explicit ModifyCdsFileShareLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableDownload) {
      res["DisableDownload"] = boost::any(*disableDownload);
    }
    if (disablePreview) {
      res["DisablePreview"] = boost::any(*disablePreview);
    }
    if (disableSave) {
      res["DisableSave"] = boost::any(*disableSave);
    }
    if (downloadCount) {
      res["DownloadCount"] = boost::any(*downloadCount);
    }
    if (downloadLimit) {
      res["DownloadLimit"] = boost::any(*downloadLimit);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (previewCount) {
      res["PreviewCount"] = boost::any(*previewCount);
    }
    if (previewLimit) {
      res["PreviewLimit"] = boost::any(*previewLimit);
    }
    if (reportCount) {
      res["ReportCount"] = boost::any(*reportCount);
    }
    if (saveCount) {
      res["SaveCount"] = boost::any(*saveCount);
    }
    if (saveLimit) {
      res["SaveLimit"] = boost::any(*saveLimit);
    }
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    if (shareName) {
      res["ShareName"] = boost::any(*shareName);
    }
    if (sharePwd) {
      res["SharePwd"] = boost::any(*sharePwd);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (videoPreviewCount) {
      res["VideoPreviewCount"] = boost::any(*videoPreviewCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableDownload") != m.end() && !m["DisableDownload"].empty()) {
      disableDownload = make_shared<bool>(boost::any_cast<bool>(m["DisableDownload"]));
    }
    if (m.find("DisablePreview") != m.end() && !m["DisablePreview"].empty()) {
      disablePreview = make_shared<bool>(boost::any_cast<bool>(m["DisablePreview"]));
    }
    if (m.find("DisableSave") != m.end() && !m["DisableSave"].empty()) {
      disableSave = make_shared<bool>(boost::any_cast<bool>(m["DisableSave"]));
    }
    if (m.find("DownloadCount") != m.end() && !m["DownloadCount"].empty()) {
      downloadCount = make_shared<long>(boost::any_cast<long>(m["DownloadCount"]));
    }
    if (m.find("DownloadLimit") != m.end() && !m["DownloadLimit"].empty()) {
      downloadLimit = make_shared<long>(boost::any_cast<long>(m["DownloadLimit"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("PreviewCount") != m.end() && !m["PreviewCount"].empty()) {
      previewCount = make_shared<long>(boost::any_cast<long>(m["PreviewCount"]));
    }
    if (m.find("PreviewLimit") != m.end() && !m["PreviewLimit"].empty()) {
      previewLimit = make_shared<long>(boost::any_cast<long>(m["PreviewLimit"]));
    }
    if (m.find("ReportCount") != m.end() && !m["ReportCount"].empty()) {
      reportCount = make_shared<long>(boost::any_cast<long>(m["ReportCount"]));
    }
    if (m.find("SaveCount") != m.end() && !m["SaveCount"].empty()) {
      saveCount = make_shared<long>(boost::any_cast<long>(m["SaveCount"]));
    }
    if (m.find("SaveLimit") != m.end() && !m["SaveLimit"].empty()) {
      saveLimit = make_shared<long>(boost::any_cast<long>(m["SaveLimit"]));
    }
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
    if (m.find("ShareName") != m.end() && !m["ShareName"].empty()) {
      shareName = make_shared<string>(boost::any_cast<string>(m["ShareName"]));
    }
    if (m.find("SharePwd") != m.end() && !m["SharePwd"].empty()) {
      sharePwd = make_shared<string>(boost::any_cast<string>(m["SharePwd"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VideoPreviewCount") != m.end() && !m["VideoPreviewCount"].empty()) {
      videoPreviewCount = make_shared<long>(boost::any_cast<long>(m["VideoPreviewCount"]));
    }
  }


  virtual ~ModifyCdsFileShareLinkRequest() = default;
};
class ModifyCdsFileShareLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CdsFileShareLinkModel> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyCdsFileShareLinkResponseBody() {}

  explicit ModifyCdsFileShareLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CdsFileShareLinkModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CdsFileShareLinkModel>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyCdsFileShareLinkResponseBody() = default;
};
class ModifyCdsFileShareLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCdsFileShareLinkResponseBody> body{};

  ModifyCdsFileShareLinkResponse() {}

  explicit ModifyCdsFileShareLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCdsFileShareLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCdsFileShareLinkResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCdsFileShareLinkResponse() = default;
};
class ModifyCenterPolicyRequestAuthorizeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  ModifyCenterPolicyRequestAuthorizeAccessPolicyRule() {}

  explicit ModifyCenterPolicyRequestAuthorizeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestAuthorizeAccessPolicyRule() = default;
};
class ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule() {}

  explicit ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule() = default;
};
class ModifyCenterPolicyRequestClientType : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  ModifyCenterPolicyRequestClientType() {}

  explicit ModifyCenterPolicyRequestClientType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestClientType() = default;
};
class ModifyCenterPolicyRequestDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  ModifyCenterPolicyRequestDeviceRedirects() {}

  explicit ModifyCenterPolicyRequestDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestDeviceRedirects() = default;
};
class ModifyCenterPolicyRequestDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  ModifyCenterPolicyRequestDeviceRules() {}

  explicit ModifyCenterPolicyRequestDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestDeviceRules() = default;
};
class ModifyCenterPolicyRequestDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  ModifyCenterPolicyRequestDomainResolveRule() {}

  explicit ModifyCenterPolicyRequestDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestDomainResolveRule() = default;
};
class ModifyCenterPolicyRequestNetRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};
  shared_ptr<string> ruleType{};

  ModifyCenterPolicyRequestNetRedirectRule() {}

  explicit ModifyCenterPolicyRequestNetRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestNetRedirectRule() = default;
};
class ModifyCenterPolicyRequestRevokeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  ModifyCenterPolicyRequestRevokeAccessPolicyRule() {}

  explicit ModifyCenterPolicyRequestRevokeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestRevokeAccessPolicyRule() = default;
};
class ModifyCenterPolicyRequestRevokeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  ModifyCenterPolicyRequestRevokeSecurityPolicyRule() {}

  explicit ModifyCenterPolicyRequestRevokeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestRevokeSecurityPolicyRule() = default;
};
class ModifyCenterPolicyRequestUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> productId{};
  shared_ptr<string> usbRedirectType{};
  shared_ptr<string> usbRuleType{};
  shared_ptr<string> vendorId{};

  ModifyCenterPolicyRequestUsbSupplyRedirectRule() {}

  explicit ModifyCenterPolicyRequestUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<string>(boost::any_cast<string>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<string>(boost::any_cast<string>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~ModifyCenterPolicyRequestUsbSupplyRedirectRule() = default;
};
class ModifyCenterPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<ModifyCenterPolicyRequestAuthorizeAccessPolicyRule>> authorizeAccessPolicyRule{};
  shared_ptr<vector<ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule>> authorizeSecurityPolicyRule{};
  shared_ptr<long> businessType{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<ModifyCenterPolicyRequestClientType>> clientType{};
  shared_ptr<string> clipboard{};
  shared_ptr<string> colorEnhancement{};
  shared_ptr<long> cpuDownGradeDuration{};
  shared_ptr<vector<string>> cpuProcessors{};
  shared_ptr<string> cpuProtectedMode{};
  shared_ptr<long> cpuRateLimit{};
  shared_ptr<long> cpuSampleDuration{};
  shared_ptr<long> cpuSingleRateLimit{};
  shared_ptr<string> deviceConnectHint{};
  shared_ptr<vector<ModifyCenterPolicyRequestDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<ModifyCenterPolicyRequestDeviceRules>> deviceRules{};
  shared_ptr<string> disconnectKeepSession{};
  shared_ptr<long> disconnectKeepSessionTime{};
  shared_ptr<string> displayMode{};
  shared_ptr<vector<ModifyCenterPolicyRequestDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<string> enableSessionRateLimiting{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> fileMigrate{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> internetPrinter{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<long> memoryDownGradeDuration{};
  shared_ptr<vector<string>> memoryProcessors{};
  shared_ptr<string> memoryProtectedMode{};
  shared_ptr<long> memoryRateLimit{};
  shared_ptr<long> memorySampleDuration{};
  shared_ptr<long> memorySingleRateLimit{};
  shared_ptr<string> mobileRestart{};
  shared_ptr<string> mobileShutdown{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<vector<ModifyCenterPolicyRequestNetRedirectRule>> netRedirectRule{};
  shared_ptr<string> noOperationDisconnect{};
  shared_ptr<long> noOperationDisconnectTime{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> printerRedirect{};
  shared_ptr<string> qualityEnhancement{};
  shared_ptr<long> recordEventDuration{};
  shared_ptr<vector<string>> recordEventFilePaths{};
  shared_ptr<vector<string>> recordEventRegisters{};
  shared_ptr<vector<string>> recordEvents{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<string> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<string> resetDesktop{};
  shared_ptr<long> resolutionHeight{};
  shared_ptr<string> resolutionModel{};
  shared_ptr<long> resolutionWidth{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ModifyCenterPolicyRequestRevokeAccessPolicyRule>> revokeAccessPolicyRule{};
  shared_ptr<vector<ModifyCenterPolicyRequestRevokeSecurityPolicyRule>> revokeSecurityPolicyRule{};
  shared_ptr<string> safeMenu{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<long> sessionMaxRateKbps{};
  shared_ptr<string> smoothEnhancement{};
  shared_ptr<string> statusMonitor{};
  shared_ptr<string> streamingMode{};
  shared_ptr<long> targetFps{};
  shared_ptr<string> taskbar{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<ModifyCenterPolicyRequestUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<long> videoEncAvgKbps{};
  shared_ptr<long> videoEncMaxQP{};
  shared_ptr<long> videoEncMinQP{};
  shared_ptr<long> videoEncPeakKbps{};
  shared_ptr<string> videoEncPolicy{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<long> watermarkColumnAmount{};
  shared_ptr<string> watermarkCustomText{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wuyingKeeper{};
  shared_ptr<string> wyAssistant{};

  ModifyCenterPolicyRequest() {}

  explicit ModifyCenterPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRule"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientType) {
      vector<boost::any> temp1;
      for(auto item1:*clientType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientType"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (colorEnhancement) {
      res["ColorEnhancement"] = boost::any(*colorEnhancement);
    }
    if (cpuDownGradeDuration) {
      res["CpuDownGradeDuration"] = boost::any(*cpuDownGradeDuration);
    }
    if (cpuProcessors) {
      res["CpuProcessors"] = boost::any(*cpuProcessors);
    }
    if (cpuProtectedMode) {
      res["CpuProtectedMode"] = boost::any(*cpuProtectedMode);
    }
    if (cpuRateLimit) {
      res["CpuRateLimit"] = boost::any(*cpuRateLimit);
    }
    if (cpuSampleDuration) {
      res["CpuSampleDuration"] = boost::any(*cpuSampleDuration);
    }
    if (cpuSingleRateLimit) {
      res["CpuSingleRateLimit"] = boost::any(*cpuSingleRateLimit);
    }
    if (deviceConnectHint) {
      res["DeviceConnectHint"] = boost::any(*deviceConnectHint);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (disconnectKeepSession) {
      res["DisconnectKeepSession"] = boost::any(*disconnectKeepSession);
    }
    if (disconnectKeepSessionTime) {
      res["DisconnectKeepSessionTime"] = boost::any(*disconnectKeepSessionTime);
    }
    if (displayMode) {
      res["DisplayMode"] = boost::any(*displayMode);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (enableSessionRateLimiting) {
      res["EnableSessionRateLimiting"] = boost::any(*enableSessionRateLimiting);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (fileMigrate) {
      res["FileMigrate"] = boost::any(*fileMigrate);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (internetPrinter) {
      res["InternetPrinter"] = boost::any(*internetPrinter);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (memoryDownGradeDuration) {
      res["MemoryDownGradeDuration"] = boost::any(*memoryDownGradeDuration);
    }
    if (memoryProcessors) {
      res["MemoryProcessors"] = boost::any(*memoryProcessors);
    }
    if (memoryProtectedMode) {
      res["MemoryProtectedMode"] = boost::any(*memoryProtectedMode);
    }
    if (memoryRateLimit) {
      res["MemoryRateLimit"] = boost::any(*memoryRateLimit);
    }
    if (memorySampleDuration) {
      res["MemorySampleDuration"] = boost::any(*memorySampleDuration);
    }
    if (memorySingleRateLimit) {
      res["MemorySingleRateLimit"] = boost::any(*memorySingleRateLimit);
    }
    if (mobileRestart) {
      res["MobileRestart"] = boost::any(*mobileRestart);
    }
    if (mobileShutdown) {
      res["MobileShutdown"] = boost::any(*mobileShutdown);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (netRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*netRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetRedirectRule"] = boost::any(temp1);
    }
    if (noOperationDisconnect) {
      res["NoOperationDisconnect"] = boost::any(*noOperationDisconnect);
    }
    if (noOperationDisconnectTime) {
      res["NoOperationDisconnectTime"] = boost::any(*noOperationDisconnectTime);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (printerRedirect) {
      res["PrinterRedirect"] = boost::any(*printerRedirect);
    }
    if (qualityEnhancement) {
      res["QualityEnhancement"] = boost::any(*qualityEnhancement);
    }
    if (recordEventDuration) {
      res["RecordEventDuration"] = boost::any(*recordEventDuration);
    }
    if (recordEventFilePaths) {
      res["RecordEventFilePaths"] = boost::any(*recordEventFilePaths);
    }
    if (recordEventRegisters) {
      res["RecordEventRegisters"] = boost::any(*recordEventRegisters);
    }
    if (recordEvents) {
      res["RecordEvents"] = boost::any(*recordEvents);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (resetDesktop) {
      res["ResetDesktop"] = boost::any(*resetDesktop);
    }
    if (resolutionHeight) {
      res["ResolutionHeight"] = boost::any(*resolutionHeight);
    }
    if (resolutionModel) {
      res["ResolutionModel"] = boost::any(*resolutionModel);
    }
    if (resolutionWidth) {
      res["ResolutionWidth"] = boost::any(*resolutionWidth);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (revokeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*revokeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokeAccessPolicyRule"] = boost::any(temp1);
    }
    if (revokeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*revokeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (safeMenu) {
      res["SafeMenu"] = boost::any(*safeMenu);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (sessionMaxRateKbps) {
      res["SessionMaxRateKbps"] = boost::any(*sessionMaxRateKbps);
    }
    if (smoothEnhancement) {
      res["SmoothEnhancement"] = boost::any(*smoothEnhancement);
    }
    if (statusMonitor) {
      res["StatusMonitor"] = boost::any(*statusMonitor);
    }
    if (streamingMode) {
      res["StreamingMode"] = boost::any(*streamingMode);
    }
    if (targetFps) {
      res["TargetFps"] = boost::any(*targetFps);
    }
    if (taskbar) {
      res["Taskbar"] = boost::any(*taskbar);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoEncAvgKbps) {
      res["VideoEncAvgKbps"] = boost::any(*videoEncAvgKbps);
    }
    if (videoEncMaxQP) {
      res["VideoEncMaxQP"] = boost::any(*videoEncMaxQP);
    }
    if (videoEncMinQP) {
      res["VideoEncMinQP"] = boost::any(*videoEncMinQP);
    }
    if (videoEncPeakKbps) {
      res["VideoEncPeakKbps"] = boost::any(*videoEncPeakKbps);
    }
    if (videoEncPolicy) {
      res["VideoEncPolicy"] = boost::any(*videoEncPolicy);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkColumnAmount) {
      res["WatermarkColumnAmount"] = boost::any(*watermarkColumnAmount);
    }
    if (watermarkCustomText) {
      res["WatermarkCustomText"] = boost::any(*watermarkCustomText);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wuyingKeeper) {
      res["WuyingKeeper"] = boost::any(*wuyingKeeper);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRule") != m.end() && !m["AuthorizeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRule"].type()) {
        vector<ModifyCenterPolicyRequestAuthorizeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestAuthorizeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRule = make_shared<vector<ModifyCenterPolicyRequestAuthorizeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRule") != m.end() && !m["AuthorizeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRule"].type()) {
        vector<ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRule = make_shared<vector<ModifyCenterPolicyRequestAuthorizeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientType"].type()) {
        vector<ModifyCenterPolicyRequestClientType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestClientType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientType = make_shared<vector<ModifyCenterPolicyRequestClientType>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("ColorEnhancement") != m.end() && !m["ColorEnhancement"].empty()) {
      colorEnhancement = make_shared<string>(boost::any_cast<string>(m["ColorEnhancement"]));
    }
    if (m.find("CpuDownGradeDuration") != m.end() && !m["CpuDownGradeDuration"].empty()) {
      cpuDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["CpuDownGradeDuration"]));
    }
    if (m.find("CpuProcessors") != m.end() && !m["CpuProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CpuProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CpuProtectedMode") != m.end() && !m["CpuProtectedMode"].empty()) {
      cpuProtectedMode = make_shared<string>(boost::any_cast<string>(m["CpuProtectedMode"]));
    }
    if (m.find("CpuRateLimit") != m.end() && !m["CpuRateLimit"].empty()) {
      cpuRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuRateLimit"]));
    }
    if (m.find("CpuSampleDuration") != m.end() && !m["CpuSampleDuration"].empty()) {
      cpuSampleDuration = make_shared<long>(boost::any_cast<long>(m["CpuSampleDuration"]));
    }
    if (m.find("CpuSingleRateLimit") != m.end() && !m["CpuSingleRateLimit"].empty()) {
      cpuSingleRateLimit = make_shared<long>(boost::any_cast<long>(m["CpuSingleRateLimit"]));
    }
    if (m.find("DeviceConnectHint") != m.end() && !m["DeviceConnectHint"].empty()) {
      deviceConnectHint = make_shared<string>(boost::any_cast<string>(m["DeviceConnectHint"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<ModifyCenterPolicyRequestDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<ModifyCenterPolicyRequestDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<ModifyCenterPolicyRequestDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<ModifyCenterPolicyRequestDeviceRules>>(expect1);
      }
    }
    if (m.find("DisconnectKeepSession") != m.end() && !m["DisconnectKeepSession"].empty()) {
      disconnectKeepSession = make_shared<string>(boost::any_cast<string>(m["DisconnectKeepSession"]));
    }
    if (m.find("DisconnectKeepSessionTime") != m.end() && !m["DisconnectKeepSessionTime"].empty()) {
      disconnectKeepSessionTime = make_shared<long>(boost::any_cast<long>(m["DisconnectKeepSessionTime"]));
    }
    if (m.find("DisplayMode") != m.end() && !m["DisplayMode"].empty()) {
      displayMode = make_shared<string>(boost::any_cast<string>(m["DisplayMode"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<ModifyCenterPolicyRequestDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<ModifyCenterPolicyRequestDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EnableSessionRateLimiting") != m.end() && !m["EnableSessionRateLimiting"].empty()) {
      enableSessionRateLimiting = make_shared<string>(boost::any_cast<string>(m["EnableSessionRateLimiting"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("FileMigrate") != m.end() && !m["FileMigrate"].empty()) {
      fileMigrate = make_shared<string>(boost::any_cast<string>(m["FileMigrate"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("InternetPrinter") != m.end() && !m["InternetPrinter"].empty()) {
      internetPrinter = make_shared<string>(boost::any_cast<string>(m["InternetPrinter"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("MemoryDownGradeDuration") != m.end() && !m["MemoryDownGradeDuration"].empty()) {
      memoryDownGradeDuration = make_shared<long>(boost::any_cast<long>(m["MemoryDownGradeDuration"]));
    }
    if (m.find("MemoryProcessors") != m.end() && !m["MemoryProcessors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemoryProcessors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemoryProcessors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memoryProcessors = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemoryProtectedMode") != m.end() && !m["MemoryProtectedMode"].empty()) {
      memoryProtectedMode = make_shared<string>(boost::any_cast<string>(m["MemoryProtectedMode"]));
    }
    if (m.find("MemoryRateLimit") != m.end() && !m["MemoryRateLimit"].empty()) {
      memoryRateLimit = make_shared<long>(boost::any_cast<long>(m["MemoryRateLimit"]));
    }
    if (m.find("MemorySampleDuration") != m.end() && !m["MemorySampleDuration"].empty()) {
      memorySampleDuration = make_shared<long>(boost::any_cast<long>(m["MemorySampleDuration"]));
    }
    if (m.find("MemorySingleRateLimit") != m.end() && !m["MemorySingleRateLimit"].empty()) {
      memorySingleRateLimit = make_shared<long>(boost::any_cast<long>(m["MemorySingleRateLimit"]));
    }
    if (m.find("MobileRestart") != m.end() && !m["MobileRestart"].empty()) {
      mobileRestart = make_shared<string>(boost::any_cast<string>(m["MobileRestart"]));
    }
    if (m.find("MobileShutdown") != m.end() && !m["MobileShutdown"].empty()) {
      mobileShutdown = make_shared<string>(boost::any_cast<string>(m["MobileShutdown"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("NetRedirectRule") != m.end() && !m["NetRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["NetRedirectRule"].type()) {
        vector<ModifyCenterPolicyRequestNetRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestNetRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        netRedirectRule = make_shared<vector<ModifyCenterPolicyRequestNetRedirectRule>>(expect1);
      }
    }
    if (m.find("NoOperationDisconnect") != m.end() && !m["NoOperationDisconnect"].empty()) {
      noOperationDisconnect = make_shared<string>(boost::any_cast<string>(m["NoOperationDisconnect"]));
    }
    if (m.find("NoOperationDisconnectTime") != m.end() && !m["NoOperationDisconnectTime"].empty()) {
      noOperationDisconnectTime = make_shared<long>(boost::any_cast<long>(m["NoOperationDisconnectTime"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PrinterRedirect") != m.end() && !m["PrinterRedirect"].empty()) {
      printerRedirect = make_shared<string>(boost::any_cast<string>(m["PrinterRedirect"]));
    }
    if (m.find("QualityEnhancement") != m.end() && !m["QualityEnhancement"].empty()) {
      qualityEnhancement = make_shared<string>(boost::any_cast<string>(m["QualityEnhancement"]));
    }
    if (m.find("RecordEventDuration") != m.end() && !m["RecordEventDuration"].empty()) {
      recordEventDuration = make_shared<long>(boost::any_cast<long>(m["RecordEventDuration"]));
    }
    if (m.find("RecordEventFilePaths") != m.end() && !m["RecordEventFilePaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventFilePaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventFilePaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventFilePaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEventRegisters") != m.end() && !m["RecordEventRegisters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEventRegisters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEventRegisters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEventRegisters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecordEvents") != m.end() && !m["RecordEvents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordEvents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordEvents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordEvents = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<string>(boost::any_cast<string>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("ResetDesktop") != m.end() && !m["ResetDesktop"].empty()) {
      resetDesktop = make_shared<string>(boost::any_cast<string>(m["ResetDesktop"]));
    }
    if (m.find("ResolutionHeight") != m.end() && !m["ResolutionHeight"].empty()) {
      resolutionHeight = make_shared<long>(boost::any_cast<long>(m["ResolutionHeight"]));
    }
    if (m.find("ResolutionModel") != m.end() && !m["ResolutionModel"].empty()) {
      resolutionModel = make_shared<string>(boost::any_cast<string>(m["ResolutionModel"]));
    }
    if (m.find("ResolutionWidth") != m.end() && !m["ResolutionWidth"].empty()) {
      resolutionWidth = make_shared<long>(boost::any_cast<long>(m["ResolutionWidth"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RevokeAccessPolicyRule") != m.end() && !m["RevokeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokeAccessPolicyRule"].type()) {
        vector<ModifyCenterPolicyRequestRevokeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestRevokeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokeAccessPolicyRule = make_shared<vector<ModifyCenterPolicyRequestRevokeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("RevokeSecurityPolicyRule") != m.end() && !m["RevokeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokeSecurityPolicyRule"].type()) {
        vector<ModifyCenterPolicyRequestRevokeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestRevokeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokeSecurityPolicyRule = make_shared<vector<ModifyCenterPolicyRequestRevokeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("SafeMenu") != m.end() && !m["SafeMenu"].empty()) {
      safeMenu = make_shared<string>(boost::any_cast<string>(m["SafeMenu"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SessionMaxRateKbps") != m.end() && !m["SessionMaxRateKbps"].empty()) {
      sessionMaxRateKbps = make_shared<long>(boost::any_cast<long>(m["SessionMaxRateKbps"]));
    }
    if (m.find("SmoothEnhancement") != m.end() && !m["SmoothEnhancement"].empty()) {
      smoothEnhancement = make_shared<string>(boost::any_cast<string>(m["SmoothEnhancement"]));
    }
    if (m.find("StatusMonitor") != m.end() && !m["StatusMonitor"].empty()) {
      statusMonitor = make_shared<string>(boost::any_cast<string>(m["StatusMonitor"]));
    }
    if (m.find("StreamingMode") != m.end() && !m["StreamingMode"].empty()) {
      streamingMode = make_shared<string>(boost::any_cast<string>(m["StreamingMode"]));
    }
    if (m.find("TargetFps") != m.end() && !m["TargetFps"].empty()) {
      targetFps = make_shared<long>(boost::any_cast<long>(m["TargetFps"]));
    }
    if (m.find("Taskbar") != m.end() && !m["Taskbar"].empty()) {
      taskbar = make_shared<string>(boost::any_cast<string>(m["Taskbar"]));
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<ModifyCenterPolicyRequestUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCenterPolicyRequestUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<ModifyCenterPolicyRequestUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoEncAvgKbps") != m.end() && !m["VideoEncAvgKbps"].empty()) {
      videoEncAvgKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncAvgKbps"]));
    }
    if (m.find("VideoEncMaxQP") != m.end() && !m["VideoEncMaxQP"].empty()) {
      videoEncMaxQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMaxQP"]));
    }
    if (m.find("VideoEncMinQP") != m.end() && !m["VideoEncMinQP"].empty()) {
      videoEncMinQP = make_shared<long>(boost::any_cast<long>(m["VideoEncMinQP"]));
    }
    if (m.find("VideoEncPeakKbps") != m.end() && !m["VideoEncPeakKbps"].empty()) {
      videoEncPeakKbps = make_shared<long>(boost::any_cast<long>(m["VideoEncPeakKbps"]));
    }
    if (m.find("VideoEncPolicy") != m.end() && !m["VideoEncPolicy"].empty()) {
      videoEncPolicy = make_shared<string>(boost::any_cast<string>(m["VideoEncPolicy"]));
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkColumnAmount") != m.end() && !m["WatermarkColumnAmount"].empty()) {
      watermarkColumnAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkColumnAmount"]));
    }
    if (m.find("WatermarkCustomText") != m.end() && !m["WatermarkCustomText"].empty()) {
      watermarkCustomText = make_shared<string>(boost::any_cast<string>(m["WatermarkCustomText"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WuyingKeeper") != m.end() && !m["WuyingKeeper"].empty()) {
      wuyingKeeper = make_shared<string>(boost::any_cast<string>(m["WuyingKeeper"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~ModifyCenterPolicyRequest() = default;
};
class ModifyCenterPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCenterPolicyResponseBody() {}

  explicit ModifyCenterPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCenterPolicyResponseBody() = default;
};
class ModifyCenterPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCenterPolicyResponseBody> body{};

  ModifyCenterPolicyResponse() {}

  explicit ModifyCenterPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCenterPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCenterPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCenterPolicyResponse() = default;
};
class ModifyCloudDriveGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> groupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<long> totalSize{};

  ModifyCloudDriveGroupsRequest() {}

  explicit ModifyCloudDriveGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ModifyCloudDriveGroupsRequest() = default;
};
class ModifyCloudDriveGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyCloudDriveGroupsResponseBody() {}

  explicit ModifyCloudDriveGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyCloudDriveGroupsResponseBody() = default;
};
class ModifyCloudDriveGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCloudDriveGroupsResponseBody> body{};

  ModifyCloudDriveGroupsResponse() {}

  explicit ModifyCloudDriveGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCloudDriveGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCloudDriveGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCloudDriveGroupsResponse() = default;
};
class ModifyCloudDrivePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> downloadEndUserIds{};
  shared_ptr<vector<string>> downloadUploadEndUserIds{};
  shared_ptr<vector<string>> noDownloadNoUploadEndUserIds{};
  shared_ptr<string> regionId{};

  ModifyCloudDrivePermissionRequest() {}

  explicit ModifyCloudDrivePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (downloadEndUserIds) {
      res["DownloadEndUserIds"] = boost::any(*downloadEndUserIds);
    }
    if (downloadUploadEndUserIds) {
      res["DownloadUploadEndUserIds"] = boost::any(*downloadUploadEndUserIds);
    }
    if (noDownloadNoUploadEndUserIds) {
      res["NoDownloadNoUploadEndUserIds"] = boost::any(*noDownloadNoUploadEndUserIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("DownloadEndUserIds") != m.end() && !m["DownloadEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DownloadEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DownloadEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      downloadEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DownloadUploadEndUserIds") != m.end() && !m["DownloadUploadEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DownloadUploadEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DownloadUploadEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      downloadUploadEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NoDownloadNoUploadEndUserIds") != m.end() && !m["NoDownloadNoUploadEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NoDownloadNoUploadEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NoDownloadNoUploadEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noDownloadNoUploadEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyCloudDrivePermissionRequest() = default;
};
class ModifyCloudDrivePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCloudDrivePermissionResponseBody() {}

  explicit ModifyCloudDrivePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCloudDrivePermissionResponseBody() = default;
};
class ModifyCloudDrivePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCloudDrivePermissionResponseBody> body{};

  ModifyCloudDrivePermissionResponse() {}

  explicit ModifyCloudDrivePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCloudDrivePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCloudDrivePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCloudDrivePermissionResponse() = default;
};
class ModifyCloudDriveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<long> userMaxSize{};

  ModifyCloudDriveUsersRequest() {}

  explicit ModifyCloudDriveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userMaxSize) {
      res["UserMaxSize"] = boost::any(*userMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserMaxSize") != m.end() && !m["UserMaxSize"].empty()) {
      userMaxSize = make_shared<long>(boost::any_cast<long>(m["UserMaxSize"]));
    }
  }


  virtual ~ModifyCloudDriveUsersRequest() = default;
};
class ModifyCloudDriveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCloudDriveUsersResponseBody() {}

  explicit ModifyCloudDriveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCloudDriveUsersResponseBody() = default;
};
class ModifyCloudDriveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCloudDriveUsersResponseBody> body{};

  ModifyCloudDriveUsersResponse() {}

  explicit ModifyCloudDriveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCloudDriveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCloudDriveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCloudDriveUsersResponse() = default;
};
class ModifyConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  ModifyConfigGroupRequest() {}

  explicit ModifyConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyConfigGroupRequest() = default;
};
class ModifyConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  ModifyConfigGroupResponseBody() {}

  explicit ModifyConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyConfigGroupResponseBody() = default;
};
class ModifyConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyConfigGroupResponseBody> body{};

  ModifyConfigGroupResponse() {}

  explicit ModifyConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyConfigGroupResponse() = default;
};
class ModifyCustomizedListHeadersRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> displayType{};
  shared_ptr<string> headerKey{};

  ModifyCustomizedListHeadersRequestHeaders() {}

  explicit ModifyCustomizedListHeadersRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayType) {
      res["DisplayType"] = boost::any(*displayType);
    }
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayType") != m.end() && !m["DisplayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["DisplayType"]));
    }
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
  }


  virtual ~ModifyCustomizedListHeadersRequestHeaders() = default;
};
class ModifyCustomizedListHeadersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyCustomizedListHeadersRequestHeaders>> headers{};
  shared_ptr<string> listType{};
  shared_ptr<string> regionId{};

  ModifyCustomizedListHeadersRequest() {}

  explicit ModifyCustomizedListHeadersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (listType) {
      res["ListType"] = boost::any(*listType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<ModifyCustomizedListHeadersRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCustomizedListHeadersRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<ModifyCustomizedListHeadersRequestHeaders>>(expect1);
      }
    }
    if (m.find("ListType") != m.end() && !m["ListType"].empty()) {
      listType = make_shared<string>(boost::any_cast<string>(m["ListType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyCustomizedListHeadersRequest() = default;
};
class ModifyCustomizedListHeadersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCustomizedListHeadersResponseBody() {}

  explicit ModifyCustomizedListHeadersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCustomizedListHeadersResponseBody() = default;
};
class ModifyCustomizedListHeadersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustomizedListHeadersResponseBody> body{};

  ModifyCustomizedListHeadersResponse() {}

  explicit ModifyCustomizedListHeadersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustomizedListHeadersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustomizedListHeadersResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustomizedListHeadersResponse() = default;
};
class ModifyDesktopChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> chargeType{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> useDuration{};

  ModifyDesktopChargeTypeRequest() {}

  explicit ModifyDesktopChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (useDuration) {
      res["UseDuration"] = boost::any(*useDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UseDuration") != m.end() && !m["UseDuration"].empty()) {
      useDuration = make_shared<long>(boost::any_cast<long>(m["UseDuration"]));
    }
  }


  virtual ~ModifyDesktopChargeTypeRequest() = default;
};
class ModifyDesktopChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyDesktopChargeTypeResponseBody() {}

  explicit ModifyDesktopChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopChargeTypeResponseBody() = default;
};
class ModifyDesktopChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopChargeTypeResponseBody> body{};

  ModifyDesktopChargeTypeResponse() {}

  explicit ModifyDesktopChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopChargeTypeResponse() = default;
};
class ModifyDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> allowAutoSetup{};
  shared_ptr<long> allowBufferCount{};
  shared_ptr<long> bindAmount{};
  shared_ptr<long> buyDesktopsCount{};
  shared_ptr<string> classify{};
  shared_ptr<string> comments{};
  shared_ptr<long> connectDuration{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> desktopGroupName{};
  shared_ptr<bool> disableSessionConfig{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxDesktopsCount{};
  shared_ptr<long> minDesktopsCount{};
  shared_ptr<string> ownBundleId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<vector<string>> policyGroupIds{};
  shared_ptr<bool> profileFollowSwitch{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resetType{};
  shared_ptr<string> scaleStrategyId{};
  shared_ptr<long> stopDuration{};

  ModifyDesktopGroupRequest() {}

  explicit ModifyDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowAutoSetup) {
      res["AllowAutoSetup"] = boost::any(*allowAutoSetup);
    }
    if (allowBufferCount) {
      res["AllowBufferCount"] = boost::any(*allowBufferCount);
    }
    if (bindAmount) {
      res["BindAmount"] = boost::any(*bindAmount);
    }
    if (buyDesktopsCount) {
      res["BuyDesktopsCount"] = boost::any(*buyDesktopsCount);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (connectDuration) {
      res["ConnectDuration"] = boost::any(*connectDuration);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupName) {
      res["DesktopGroupName"] = boost::any(*desktopGroupName);
    }
    if (disableSessionConfig) {
      res["DisableSessionConfig"] = boost::any(*disableSessionConfig);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxDesktopsCount) {
      res["MaxDesktopsCount"] = boost::any(*maxDesktopsCount);
    }
    if (minDesktopsCount) {
      res["MinDesktopsCount"] = boost::any(*minDesktopsCount);
    }
    if (ownBundleId) {
      res["OwnBundleId"] = boost::any(*ownBundleId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupIds) {
      res["PolicyGroupIds"] = boost::any(*policyGroupIds);
    }
    if (profileFollowSwitch) {
      res["ProfileFollowSwitch"] = boost::any(*profileFollowSwitch);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (scaleStrategyId) {
      res["ScaleStrategyId"] = boost::any(*scaleStrategyId);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowAutoSetup") != m.end() && !m["AllowAutoSetup"].empty()) {
      allowAutoSetup = make_shared<long>(boost::any_cast<long>(m["AllowAutoSetup"]));
    }
    if (m.find("AllowBufferCount") != m.end() && !m["AllowBufferCount"].empty()) {
      allowBufferCount = make_shared<long>(boost::any_cast<long>(m["AllowBufferCount"]));
    }
    if (m.find("BindAmount") != m.end() && !m["BindAmount"].empty()) {
      bindAmount = make_shared<long>(boost::any_cast<long>(m["BindAmount"]));
    }
    if (m.find("BuyDesktopsCount") != m.end() && !m["BuyDesktopsCount"].empty()) {
      buyDesktopsCount = make_shared<long>(boost::any_cast<long>(m["BuyDesktopsCount"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("ConnectDuration") != m.end() && !m["ConnectDuration"].empty()) {
      connectDuration = make_shared<long>(boost::any_cast<long>(m["ConnectDuration"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupName") != m.end() && !m["DesktopGroupName"].empty()) {
      desktopGroupName = make_shared<string>(boost::any_cast<string>(m["DesktopGroupName"]));
    }
    if (m.find("DisableSessionConfig") != m.end() && !m["DisableSessionConfig"].empty()) {
      disableSessionConfig = make_shared<bool>(boost::any_cast<bool>(m["DisableSessionConfig"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxDesktopsCount") != m.end() && !m["MaxDesktopsCount"].empty()) {
      maxDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MaxDesktopsCount"]));
    }
    if (m.find("MinDesktopsCount") != m.end() && !m["MinDesktopsCount"].empty()) {
      minDesktopsCount = make_shared<long>(boost::any_cast<long>(m["MinDesktopsCount"]));
    }
    if (m.find("OwnBundleId") != m.end() && !m["OwnBundleId"].empty()) {
      ownBundleId = make_shared<string>(boost::any_cast<string>(m["OwnBundleId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupIds") != m.end() && !m["PolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProfileFollowSwitch") != m.end() && !m["ProfileFollowSwitch"].empty()) {
      profileFollowSwitch = make_shared<bool>(boost::any_cast<bool>(m["ProfileFollowSwitch"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<long>(boost::any_cast<long>(m["ResetType"]));
    }
    if (m.find("ScaleStrategyId") != m.end() && !m["ScaleStrategyId"].empty()) {
      scaleStrategyId = make_shared<string>(boost::any_cast<string>(m["ScaleStrategyId"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
  }


  virtual ~ModifyDesktopGroupRequest() = default;
};
class ModifyDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDesktopGroupResponseBody() {}

  explicit ModifyDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopGroupResponseBody() = default;
};
class ModifyDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopGroupResponseBody> body{};

  ModifyDesktopGroupResponse() {}

  explicit ModifyDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopGroupResponse() = default;
};
class ModifyDesktopHostNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> newHostName{};
  shared_ptr<string> regionId{};

  ModifyDesktopHostNameRequest() {}

  explicit ModifyDesktopHostNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (newHostName) {
      res["NewHostName"] = boost::any(*newHostName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("NewHostName") != m.end() && !m["NewHostName"].empty()) {
      newHostName = make_shared<string>(boost::any_cast<string>(m["NewHostName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDesktopHostNameRequest() = default;
};
class ModifyDesktopHostNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDesktopHostNameResponseBody() {}

  explicit ModifyDesktopHostNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopHostNameResponseBody() = default;
};
class ModifyDesktopHostNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopHostNameResponseBody> body{};

  ModifyDesktopHostNameResponse() {}

  explicit ModifyDesktopHostNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopHostNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopHostNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopHostNameResponse() = default;
};
class ModifyDesktopNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<string> newDesktopName{};
  shared_ptr<string> regionId{};

  ModifyDesktopNameRequest() {}

  explicit ModifyDesktopNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (newDesktopName) {
      res["NewDesktopName"] = boost::any(*newDesktopName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("NewDesktopName") != m.end() && !m["NewDesktopName"].empty()) {
      newDesktopName = make_shared<string>(boost::any_cast<string>(m["NewDesktopName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDesktopNameRequest() = default;
};
class ModifyDesktopNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDesktopNameResponseBody() {}

  explicit ModifyDesktopNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopNameResponseBody() = default;
};
class ModifyDesktopNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopNameResponseBody> body{};

  ModifyDesktopNameResponse() {}

  explicit ModifyDesktopNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopNameResponse() = default;
};
class ModifyDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<string> description{};
  shared_ptr<long> idleDisconnectDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<long> keepDuration{};
  shared_ptr<string> name{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> oversoldUserCount{};
  shared_ptr<long> oversoldWarn{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<long> stopDuration{};

  ModifyDesktopOversoldGroupRequest() {}

  explicit ModifyDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (idleDisconnectDuration) {
      res["IdleDisconnectDuration"] = boost::any(*idleDisconnectDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    if (oversoldWarn) {
      res["OversoldWarn"] = boost::any(*oversoldWarn);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (stopDuration) {
      res["StopDuration"] = boost::any(*stopDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IdleDisconnectDuration") != m.end() && !m["IdleDisconnectDuration"].empty()) {
      idleDisconnectDuration = make_shared<long>(boost::any_cast<long>(m["IdleDisconnectDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
    if (m.find("OversoldWarn") != m.end() && !m["OversoldWarn"].empty()) {
      oversoldWarn = make_shared<long>(boost::any_cast<long>(m["OversoldWarn"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("StopDuration") != m.end() && !m["StopDuration"].empty()) {
      stopDuration = make_shared<long>(boost::any_cast<long>(m["StopDuration"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupRequest() = default;
};
class ModifyDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> oversoldGroupId{};

  ModifyDesktopOversoldGroupResponseBodyData() {}

  explicit ModifyDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupResponseBodyData() = default;
};
class ModifyDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyDesktopOversoldGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ModifyDesktopOversoldGroupResponseBody() {}

  explicit ModifyDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyDesktopOversoldGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyDesktopOversoldGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupResponseBody() = default;
};
class ModifyDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopOversoldGroupResponseBody> body{};

  ModifyDesktopOversoldGroupResponse() {}

  explicit ModifyDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopOversoldGroupResponse() = default;
};
class ModifyDesktopOversoldGroupSaleRequest : public Darabonba::Model {
public:
  shared_ptr<long> concurrenceCount{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> oversoldUserCount{};

  ModifyDesktopOversoldGroupSaleRequest() {}

  explicit ModifyDesktopOversoldGroupSaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrenceCount) {
      res["ConcurrenceCount"] = boost::any(*concurrenceCount);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (oversoldUserCount) {
      res["OversoldUserCount"] = boost::any(*oversoldUserCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrenceCount") != m.end() && !m["ConcurrenceCount"].empty()) {
      concurrenceCount = make_shared<long>(boost::any_cast<long>(m["ConcurrenceCount"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("OversoldUserCount") != m.end() && !m["OversoldUserCount"].empty()) {
      oversoldUserCount = make_shared<long>(boost::any_cast<long>(m["OversoldUserCount"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupSaleRequest() = default;
};
class ModifyDesktopOversoldGroupSaleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> oversoldGroupId{};

  ModifyDesktopOversoldGroupSaleResponseBodyData() {}

  explicit ModifyDesktopOversoldGroupSaleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupSaleResponseBodyData() = default;
};
class ModifyDesktopOversoldGroupSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyDesktopOversoldGroupSaleResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ModifyDesktopOversoldGroupSaleResponseBody() {}

  explicit ModifyDesktopOversoldGroupSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyDesktopOversoldGroupSaleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyDesktopOversoldGroupSaleResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopOversoldGroupSaleResponseBody() = default;
};
class ModifyDesktopOversoldGroupSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopOversoldGroupSaleResponseBody> body{};

  ModifyDesktopOversoldGroupSaleResponse() {}

  explicit ModifyDesktopOversoldGroupSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopOversoldGroupSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopOversoldGroupSaleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopOversoldGroupSaleResponse() = default;
};
class ModifyDesktopOversoldUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> name{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> userGroupId{};

  ModifyDesktopOversoldUserGroupRequest() {}

  explicit ModifyDesktopOversoldUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ModifyDesktopOversoldUserGroupRequest() = default;
};
class ModifyDesktopOversoldUserGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> userGroupId{};

  ModifyDesktopOversoldUserGroupResponseBodyData() {}

  explicit ModifyDesktopOversoldUserGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ModifyDesktopOversoldUserGroupResponseBodyData() = default;
};
class ModifyDesktopOversoldUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyDesktopOversoldUserGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ModifyDesktopOversoldUserGroupResponseBody() {}

  explicit ModifyDesktopOversoldUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyDesktopOversoldUserGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyDesktopOversoldUserGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopOversoldUserGroupResponseBody() = default;
};
class ModifyDesktopOversoldUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopOversoldUserGroupResponseBody> body{};

  ModifyDesktopOversoldUserGroupResponse() {}

  explicit ModifyDesktopOversoldUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopOversoldUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopOversoldUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopOversoldUserGroupResponse() = default;
};
class ModifyDesktopSpecRequestResourceSpecs : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<long> rootDiskSizeGib{};
  shared_ptr<long> userDiskSizeGib{};

  ModifyDesktopSpecRequestResourceSpecs() {}

  explicit ModifyDesktopSpecRequestResourceSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (rootDiskSizeGib) {
      res["RootDiskSizeGib"] = boost::any(*rootDiskSizeGib);
    }
    if (userDiskSizeGib) {
      res["UserDiskSizeGib"] = boost::any(*userDiskSizeGib);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("RootDiskSizeGib") != m.end() && !m["RootDiskSizeGib"].empty()) {
      rootDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["RootDiskSizeGib"]));
    }
    if (m.find("UserDiskSizeGib") != m.end() && !m["UserDiskSizeGib"].empty()) {
      userDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["UserDiskSizeGib"]));
    }
  }


  virtual ~ModifyDesktopSpecRequestResourceSpecs() = default;
};
class ModifyDesktopSpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> desktopType{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyDesktopSpecRequestResourceSpecs>> resourceSpecs{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> rootDiskSizeGib{};
  shared_ptr<string> userDiskPerformanceLevel{};
  shared_ptr<long> userDiskSizeGib{};

  ModifyDesktopSpecRequest() {}

  explicit ModifyDesktopSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopType) {
      res["DesktopType"] = boost::any(*desktopType);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceSpecs) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSpecs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSpecs"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (rootDiskSizeGib) {
      res["RootDiskSizeGib"] = boost::any(*rootDiskSizeGib);
    }
    if (userDiskPerformanceLevel) {
      res["UserDiskPerformanceLevel"] = boost::any(*userDiskPerformanceLevel);
    }
    if (userDiskSizeGib) {
      res["UserDiskSizeGib"] = boost::any(*userDiskSizeGib);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("DesktopType") != m.end() && !m["DesktopType"].empty()) {
      desktopType = make_shared<string>(boost::any_cast<string>(m["DesktopType"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceSpecs") != m.end() && !m["ResourceSpecs"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSpecs"].type()) {
        vector<ModifyDesktopSpecRequestResourceSpecs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSpecs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDesktopSpecRequestResourceSpecs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSpecs = make_shared<vector<ModifyDesktopSpecRequestResourceSpecs>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RootDiskSizeGib") != m.end() && !m["RootDiskSizeGib"].empty()) {
      rootDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["RootDiskSizeGib"]));
    }
    if (m.find("UserDiskPerformanceLevel") != m.end() && !m["UserDiskPerformanceLevel"].empty()) {
      userDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["UserDiskPerformanceLevel"]));
    }
    if (m.find("UserDiskSizeGib") != m.end() && !m["UserDiskSizeGib"].empty()) {
      userDiskSizeGib = make_shared<long>(boost::any_cast<long>(m["UserDiskSizeGib"]));
    }
  }


  virtual ~ModifyDesktopSpecRequest() = default;
};
class ModifyDesktopSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<vector<long>> orderIds{};
  shared_ptr<string> requestId{};

  ModifyDesktopSpecResponseBody() {}

  explicit ModifyDesktopSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      orderIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopSpecResponseBody() = default;
};
class ModifyDesktopSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopSpecResponseBody> body{};

  ModifyDesktopSpecResponse() {}

  explicit ModifyDesktopSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopSpecResponse() = default;
};
class ModifyDesktopTimerRequestDesktopTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<string> operationType{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};

  ModifyDesktopTimerRequestDesktopTimers() {}

  explicit ModifyDesktopTimerRequestDesktopTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
  }


  virtual ~ModifyDesktopTimerRequestDesktopTimers() = default;
};
class ModifyDesktopTimerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<vector<ModifyDesktopTimerRequestDesktopTimers>> desktopTimers{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> useDesktopTimers{};

  ModifyDesktopTimerRequest() {}

  explicit ModifyDesktopTimerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (desktopTimers) {
      vector<boost::any> temp1;
      for(auto item1:*desktopTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesktopTimers"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (useDesktopTimers) {
      res["UseDesktopTimers"] = boost::any(*useDesktopTimers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopTimers") != m.end() && !m["DesktopTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["DesktopTimers"].type()) {
        vector<ModifyDesktopTimerRequestDesktopTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesktopTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDesktopTimerRequestDesktopTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desktopTimers = make_shared<vector<ModifyDesktopTimerRequestDesktopTimers>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UseDesktopTimers") != m.end() && !m["UseDesktopTimers"].empty()) {
      useDesktopTimers = make_shared<bool>(boost::any_cast<bool>(m["UseDesktopTimers"]));
    }
  }


  virtual ~ModifyDesktopTimerRequest() = default;
};
class ModifyDesktopTimerResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopIds{};
  shared_ptr<string> requestId{};

  ModifyDesktopTimerResponseBody() {}

  explicit ModifyDesktopTimerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopIds) {
      res["DesktopIds"] = boost::any(*desktopIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopIds") != m.end() && !m["DesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopTimerResponseBody() = default;
};
class ModifyDesktopTimerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopTimerResponseBody> body{};

  ModifyDesktopTimerResponse() {}

  explicit ModifyDesktopTimerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopTimerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopTimerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopTimerResponse() = default;
};
class ModifyDesktopsPolicyGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<vector<string>> policyGroupIds{};
  shared_ptr<string> regionId{};

  ModifyDesktopsPolicyGroupRequest() {}

  explicit ModifyDesktopsPolicyGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (policyGroupIds) {
      res["PolicyGroupIds"] = boost::any(*policyGroupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PolicyGroupIds") != m.end() && !m["PolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDesktopsPolicyGroupRequest() = default;
};
class ModifyDesktopsPolicyGroupResponseBodyModifyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> message{};

  ModifyDesktopsPolicyGroupResponseBodyModifyResults() {}

  explicit ModifyDesktopsPolicyGroupResponseBodyModifyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ModifyDesktopsPolicyGroupResponseBodyModifyResults() = default;
};
class ModifyDesktopsPolicyGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyDesktopsPolicyGroupResponseBodyModifyResults>> modifyResults{};
  shared_ptr<string> requestId{};

  ModifyDesktopsPolicyGroupResponseBody() {}

  explicit ModifyDesktopsPolicyGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyResults) {
      vector<boost::any> temp1;
      for(auto item1:*modifyResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModifyResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifyResults") != m.end() && !m["ModifyResults"].empty()) {
      if (typeid(vector<boost::any>) == m["ModifyResults"].type()) {
        vector<ModifyDesktopsPolicyGroupResponseBodyModifyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModifyResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDesktopsPolicyGroupResponseBodyModifyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyResults = make_shared<vector<ModifyDesktopsPolicyGroupResponseBodyModifyResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDesktopsPolicyGroupResponseBody() = default;
};
class ModifyDesktopsPolicyGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesktopsPolicyGroupResponseBody> body{};

  ModifyDesktopsPolicyGroupResponse() {}

  explicit ModifyDesktopsPolicyGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesktopsPolicyGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesktopsPolicyGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesktopsPolicyGroupResponse() = default;
};
class ModifyDiskSpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resellerOwnerUid{};
  shared_ptr<string> rootDiskPerformanceLevel{};
  shared_ptr<string> userDiskPerformanceLevel{};

  ModifyDiskSpecRequest() {}

  explicit ModifyDiskSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resellerOwnerUid) {
      res["ResellerOwnerUid"] = boost::any(*resellerOwnerUid);
    }
    if (rootDiskPerformanceLevel) {
      res["RootDiskPerformanceLevel"] = boost::any(*rootDiskPerformanceLevel);
    }
    if (userDiskPerformanceLevel) {
      res["UserDiskPerformanceLevel"] = boost::any(*userDiskPerformanceLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResellerOwnerUid") != m.end() && !m["ResellerOwnerUid"].empty()) {
      resellerOwnerUid = make_shared<long>(boost::any_cast<long>(m["ResellerOwnerUid"]));
    }
    if (m.find("RootDiskPerformanceLevel") != m.end() && !m["RootDiskPerformanceLevel"].empty()) {
      rootDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["RootDiskPerformanceLevel"]));
    }
    if (m.find("UserDiskPerformanceLevel") != m.end() && !m["UserDiskPerformanceLevel"].empty()) {
      userDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["UserDiskPerformanceLevel"]));
    }
  }


  virtual ~ModifyDiskSpecRequest() = default;
};
class ModifyDiskSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyDiskSpecResponseBody() {}

  explicit ModifyDiskSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDiskSpecResponseBody() = default;
};
class ModifyDiskSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDiskSpecResponseBody> body{};

  ModifyDiskSpecResponse() {}

  explicit ModifyDiskSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiskSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiskSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiskSpecResponse() = default;
};
class ModifyEntitlementRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> regionId{};

  ModifyEntitlementRequest() {}

  explicit ModifyEntitlementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyEntitlementRequest() = default;
};
class ModifyEntitlementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEntitlementResponseBody() {}

  explicit ModifyEntitlementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEntitlementResponseBody() = default;
};
class ModifyEntitlementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEntitlementResponseBody> body{};

  ModifyEntitlementResponse() {}

  explicit ModifyEntitlementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEntitlementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEntitlementResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEntitlementResponse() = default;
};
class ModifyImageAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  ModifyImageAttributeRequest() {}

  explicit ModifyImageAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyImageAttributeRequest() = default;
};
class ModifyImageAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageAttributeResponseBody() {}

  explicit ModifyImageAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageAttributeResponseBody() = default;
};
class ModifyImageAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyImageAttributeResponseBody> body{};

  ModifyImageAttributeResponse() {}

  explicit ModifyImageAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageAttributeResponse() = default;
};
class ModifyImagePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> addAccount{};
  shared_ptr<string> imageId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<long>> removeAccount{};

  ModifyImagePermissionRequest() {}

  explicit ModifyImagePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addAccount) {
      res["AddAccount"] = boost::any(*addAccount);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removeAccount) {
      res["RemoveAccount"] = boost::any(*removeAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddAccount") != m.end() && !m["AddAccount"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AddAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AddAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      addAccount = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoveAccount") != m.end() && !m["RemoveAccount"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RemoveAccount"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemoveAccount"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      removeAccount = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ModifyImagePermissionRequest() = default;
};
class ModifyImagePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImagePermissionResponseBody() {}

  explicit ModifyImagePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImagePermissionResponseBody() = default;
};
class ModifyImagePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyImagePermissionResponseBody> body{};

  ModifyImagePermissionResponse() {}

  explicit ModifyImagePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImagePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImagePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImagePermissionResponse() = default;
};
class ModifyNASDefaultMountTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> regionId{};

  ModifyNASDefaultMountTargetRequest() {}

  explicit ModifyNASDefaultMountTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyNASDefaultMountTargetRequest() = default;
};
class ModifyNASDefaultMountTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNASDefaultMountTargetResponseBody() {}

  explicit ModifyNASDefaultMountTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNASDefaultMountTargetResponseBody() = default;
};
class ModifyNASDefaultMountTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNASDefaultMountTargetResponseBody> body{};

  ModifyNASDefaultMountTargetResponse() {}

  explicit ModifyNASDefaultMountTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNASDefaultMountTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNASDefaultMountTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNASDefaultMountTargetResponse() = default;
};
class ModifyNetworkPackageBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};

  ModifyNetworkPackageBandwidthRequest() {}

  explicit ModifyNetworkPackageBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyNetworkPackageBandwidthRequest() = default;
};
class ModifyNetworkPackageBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyNetworkPackageBandwidthResponseBody() {}

  explicit ModifyNetworkPackageBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkPackageBandwidthResponseBody() = default;
};
class ModifyNetworkPackageBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkPackageBandwidthResponseBody> body{};

  ModifyNetworkPackageBandwidthResponse() {}

  explicit ModifyNetworkPackageBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkPackageBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkPackageBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkPackageBandwidthResponse() = default;
};
class ModifyNetworkPackageEnabledRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> networkPackageId{};
  shared_ptr<string> regionId{};

  ModifyNetworkPackageEnabledRequest() {}

  explicit ModifyNetworkPackageEnabledRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      networkPackageId = make_shared<string>(boost::any_cast<string>(m["NetworkPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyNetworkPackageEnabledRequest() = default;
};
class ModifyNetworkPackageEnabledResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkPackageEnabledResponseBody() {}

  explicit ModifyNetworkPackageEnabledResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkPackageEnabledResponseBody() = default;
};
class ModifyNetworkPackageEnabledResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkPackageEnabledResponseBody> body{};

  ModifyNetworkPackageEnabledResponse() {}

  explicit ModifyNetworkPackageEnabledResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkPackageEnabledResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkPackageEnabledResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkPackageEnabledResponse() = default;
};
class ModifyOfficeSiteAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopAccessType{};
  shared_ptr<bool> enableAdminAccess{};
  shared_ptr<bool> needVerifyLoginRisk{};
  shared_ptr<bool> needVerifyZeroDevice{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> officeSiteName{};
  shared_ptr<string> regionId{};

  ModifyOfficeSiteAttributeRequest() {}

  explicit ModifyOfficeSiteAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopAccessType) {
      res["DesktopAccessType"] = boost::any(*desktopAccessType);
    }
    if (enableAdminAccess) {
      res["EnableAdminAccess"] = boost::any(*enableAdminAccess);
    }
    if (needVerifyLoginRisk) {
      res["NeedVerifyLoginRisk"] = boost::any(*needVerifyLoginRisk);
    }
    if (needVerifyZeroDevice) {
      res["NeedVerifyZeroDevice"] = boost::any(*needVerifyZeroDevice);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (officeSiteName) {
      res["OfficeSiteName"] = boost::any(*officeSiteName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopAccessType") != m.end() && !m["DesktopAccessType"].empty()) {
      desktopAccessType = make_shared<string>(boost::any_cast<string>(m["DesktopAccessType"]));
    }
    if (m.find("EnableAdminAccess") != m.end() && !m["EnableAdminAccess"].empty()) {
      enableAdminAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableAdminAccess"]));
    }
    if (m.find("NeedVerifyLoginRisk") != m.end() && !m["NeedVerifyLoginRisk"].empty()) {
      needVerifyLoginRisk = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyLoginRisk"]));
    }
    if (m.find("NeedVerifyZeroDevice") != m.end() && !m["NeedVerifyZeroDevice"].empty()) {
      needVerifyZeroDevice = make_shared<bool>(boost::any_cast<bool>(m["NeedVerifyZeroDevice"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("OfficeSiteName") != m.end() && !m["OfficeSiteName"].empty()) {
      officeSiteName = make_shared<string>(boost::any_cast<string>(m["OfficeSiteName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyOfficeSiteAttributeRequest() = default;
};
class ModifyOfficeSiteAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOfficeSiteAttributeResponseBody() {}

  explicit ModifyOfficeSiteAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOfficeSiteAttributeResponseBody() = default;
};
class ModifyOfficeSiteAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOfficeSiteAttributeResponseBody> body{};

  ModifyOfficeSiteAttributeResponse() {}

  explicit ModifyOfficeSiteAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOfficeSiteAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOfficeSiteAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOfficeSiteAttributeResponse() = default;
};
class ModifyOfficeSiteCrossDesktopAccessRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableCrossDesktopAccess{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ModifyOfficeSiteCrossDesktopAccessRequest() {}

  explicit ModifyOfficeSiteCrossDesktopAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCrossDesktopAccess) {
      res["EnableCrossDesktopAccess"] = boost::any(*enableCrossDesktopAccess);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCrossDesktopAccess") != m.end() && !m["EnableCrossDesktopAccess"].empty()) {
      enableCrossDesktopAccess = make_shared<bool>(boost::any_cast<bool>(m["EnableCrossDesktopAccess"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyOfficeSiteCrossDesktopAccessRequest() = default;
};
class ModifyOfficeSiteCrossDesktopAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOfficeSiteCrossDesktopAccessResponseBody() {}

  explicit ModifyOfficeSiteCrossDesktopAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOfficeSiteCrossDesktopAccessResponseBody() = default;
};
class ModifyOfficeSiteCrossDesktopAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOfficeSiteCrossDesktopAccessResponseBody> body{};

  ModifyOfficeSiteCrossDesktopAccessResponse() {}

  explicit ModifyOfficeSiteCrossDesktopAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOfficeSiteCrossDesktopAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOfficeSiteCrossDesktopAccessResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOfficeSiteCrossDesktopAccessResponse() = default;
};
class ModifyOfficeSiteDnsInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsAddress{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ModifyOfficeSiteDnsInfoRequest() {}

  explicit ModifyOfficeSiteDnsInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsAddress) {
      res["DnsAddress"] = boost::any(*dnsAddress);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsAddress") != m.end() && !m["DnsAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyOfficeSiteDnsInfoRequest() = default;
};
class ModifyOfficeSiteDnsInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOfficeSiteDnsInfoResponseBody() {}

  explicit ModifyOfficeSiteDnsInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOfficeSiteDnsInfoResponseBody() = default;
};
class ModifyOfficeSiteDnsInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOfficeSiteDnsInfoResponseBody> body{};

  ModifyOfficeSiteDnsInfoResponse() {}

  explicit ModifyOfficeSiteDnsInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOfficeSiteDnsInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOfficeSiteDnsInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOfficeSiteDnsInfoResponse() = default;
};
class ModifyOfficeSiteMfaEnabledRequest : public Darabonba::Model {
public:
  shared_ptr<bool> mfaEnabled{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  ModifyOfficeSiteMfaEnabledRequest() {}

  explicit ModifyOfficeSiteMfaEnabledRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mfaEnabled) {
      res["MfaEnabled"] = boost::any(*mfaEnabled);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MfaEnabled") != m.end() && !m["MfaEnabled"].empty()) {
      mfaEnabled = make_shared<bool>(boost::any_cast<bool>(m["MfaEnabled"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyOfficeSiteMfaEnabledRequest() = default;
};
class ModifyOfficeSiteMfaEnabledResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOfficeSiteMfaEnabledResponseBody() {}

  explicit ModifyOfficeSiteMfaEnabledResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOfficeSiteMfaEnabledResponseBody() = default;
};
class ModifyOfficeSiteMfaEnabledResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOfficeSiteMfaEnabledResponseBody> body{};

  ModifyOfficeSiteMfaEnabledResponse() {}

  explicit ModifyOfficeSiteMfaEnabledResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOfficeSiteMfaEnabledResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOfficeSiteMfaEnabledResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOfficeSiteMfaEnabledResponse() = default;
};
class ModifyPolicyGroupRequestAuthorizeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  ModifyPolicyGroupRequestAuthorizeAccessPolicyRule() {}

  explicit ModifyPolicyGroupRequestAuthorizeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestAuthorizeAccessPolicyRule() = default;
};
class ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule() {}

  explicit ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule() = default;
};
class ModifyPolicyGroupRequestClientType : public Darabonba::Model {
public:
  shared_ptr<string> clientType{};
  shared_ptr<string> status{};

  ModifyPolicyGroupRequestClientType() {}

  explicit ModifyPolicyGroupRequestClientType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<string>(boost::any_cast<string>(m["ClientType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestClientType() = default;
};
class ModifyPolicyGroupRequestDeviceRedirects : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> redirectType{};

  ModifyPolicyGroupRequestDeviceRedirects() {}

  explicit ModifyPolicyGroupRequestDeviceRedirects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestDeviceRedirects() = default;
};
class ModifyPolicyGroupRequestDeviceRules : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePid{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceVid{};
  shared_ptr<string> optCommand{};
  shared_ptr<string> platforms{};
  shared_ptr<string> redirectType{};

  ModifyPolicyGroupRequestDeviceRules() {}

  explicit ModifyPolicyGroupRequestDeviceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePid) {
      res["DevicePid"] = boost::any(*devicePid);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceVid) {
      res["DeviceVid"] = boost::any(*deviceVid);
    }
    if (optCommand) {
      res["OptCommand"] = boost::any(*optCommand);
    }
    if (platforms) {
      res["Platforms"] = boost::any(*platforms);
    }
    if (redirectType) {
      res["RedirectType"] = boost::any(*redirectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePid") != m.end() && !m["DevicePid"].empty()) {
      devicePid = make_shared<string>(boost::any_cast<string>(m["DevicePid"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceVid") != m.end() && !m["DeviceVid"].empty()) {
      deviceVid = make_shared<string>(boost::any_cast<string>(m["DeviceVid"]));
    }
    if (m.find("OptCommand") != m.end() && !m["OptCommand"].empty()) {
      optCommand = make_shared<string>(boost::any_cast<string>(m["OptCommand"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      platforms = make_shared<string>(boost::any_cast<string>(m["Platforms"]));
    }
    if (m.find("RedirectType") != m.end() && !m["RedirectType"].empty()) {
      redirectType = make_shared<string>(boost::any_cast<string>(m["RedirectType"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestDeviceRules() = default;
};
class ModifyPolicyGroupRequestDomainResolveRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};

  ModifyPolicyGroupRequestDomainResolveRule() {}

  explicit ModifyPolicyGroupRequestDomainResolveRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestDomainResolveRule() = default;
};
class ModifyPolicyGroupRequestRevokeAccessPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};

  ModifyPolicyGroupRequestRevokeAccessPolicyRule() {}

  explicit ModifyPolicyGroupRequestRevokeAccessPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestRevokeAccessPolicyRule() = default;
};
class ModifyPolicyGroupRequestRevokeSecurityPolicyRule : public Darabonba::Model {
public:
  shared_ptr<string> cidrIp{};
  shared_ptr<string> description{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  ModifyPolicyGroupRequestRevokeSecurityPolicyRule() {}

  explicit ModifyPolicyGroupRequestRevokeSecurityPolicyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestRevokeSecurityPolicyRule() = default;
};
class ModifyPolicyGroupRequestUsbSupplyRedirectRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> deviceClass{};
  shared_ptr<string> deviceSubclass{};
  shared_ptr<string> productId{};
  shared_ptr<long> usbRedirectType{};
  shared_ptr<long> usbRuleType{};
  shared_ptr<string> vendorId{};

  ModifyPolicyGroupRequestUsbSupplyRedirectRule() {}

  explicit ModifyPolicyGroupRequestUsbSupplyRedirectRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceClass) {
      res["DeviceClass"] = boost::any(*deviceClass);
    }
    if (deviceSubclass) {
      res["DeviceSubclass"] = boost::any(*deviceSubclass);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (usbRedirectType) {
      res["UsbRedirectType"] = boost::any(*usbRedirectType);
    }
    if (usbRuleType) {
      res["UsbRuleType"] = boost::any(*usbRuleType);
    }
    if (vendorId) {
      res["VendorId"] = boost::any(*vendorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceClass") != m.end() && !m["DeviceClass"].empty()) {
      deviceClass = make_shared<string>(boost::any_cast<string>(m["DeviceClass"]));
    }
    if (m.find("DeviceSubclass") != m.end() && !m["DeviceSubclass"].empty()) {
      deviceSubclass = make_shared<string>(boost::any_cast<string>(m["DeviceSubclass"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["ProductId"]));
    }
    if (m.find("UsbRedirectType") != m.end() && !m["UsbRedirectType"].empty()) {
      usbRedirectType = make_shared<long>(boost::any_cast<long>(m["UsbRedirectType"]));
    }
    if (m.find("UsbRuleType") != m.end() && !m["UsbRuleType"].empty()) {
      usbRuleType = make_shared<long>(boost::any_cast<long>(m["UsbRuleType"]));
    }
    if (m.find("VendorId") != m.end() && !m["VendorId"].empty()) {
      vendorId = make_shared<string>(boost::any_cast<string>(m["VendorId"]));
    }
  }


  virtual ~ModifyPolicyGroupRequestUsbSupplyRedirectRule() = default;
};
class ModifyPolicyGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminAccess{};
  shared_ptr<string> appContentProtection{};
  shared_ptr<vector<ModifyPolicyGroupRequestAuthorizeAccessPolicyRule>> authorizeAccessPolicyRule{};
  shared_ptr<vector<ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule>> authorizeSecurityPolicyRule{};
  shared_ptr<string> cameraRedirect{};
  shared_ptr<vector<ModifyPolicyGroupRequestClientType>> clientType{};
  shared_ptr<string> clipboard{};
  shared_ptr<vector<ModifyPolicyGroupRequestDeviceRedirects>> deviceRedirects{};
  shared_ptr<vector<ModifyPolicyGroupRequestDeviceRules>> deviceRules{};
  shared_ptr<string> domainList{};
  shared_ptr<vector<ModifyPolicyGroupRequestDomainResolveRule>> domainResolveRule{};
  shared_ptr<string> domainResolveRuleType{};
  shared_ptr<string> endUserApplyAdminCoordinate{};
  shared_ptr<string> endUserGroupCoordinate{};
  shared_ptr<string> gpuAcceleration{};
  shared_ptr<string> html5Access{};
  shared_ptr<string> html5FileTransfer{};
  shared_ptr<string> internetCommunicationProtocol{};
  shared_ptr<string> localDrive{};
  shared_ptr<long> maxReconnectTime{};
  shared_ptr<string> name{};
  shared_ptr<string> netRedirect{};
  shared_ptr<string> policyGroupId{};
  shared_ptr<string> preemptLogin{};
  shared_ptr<vector<string>> preemptLoginUser{};
  shared_ptr<string> printerRedirection{};
  shared_ptr<string> recordContent{};
  shared_ptr<long> recordContentExpires{};
  shared_ptr<string> recording{};
  shared_ptr<string> recordingAudio{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingEndTime{};
  shared_ptr<long> recordingExpires{};
  shared_ptr<long> recordingFps{};
  shared_ptr<string> recordingStartTime{};
  shared_ptr<string> recordingUserNotify{};
  shared_ptr<string> recordingUserNotifyMessage{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCoordinate{};
  shared_ptr<vector<ModifyPolicyGroupRequestRevokeAccessPolicyRule>> revokeAccessPolicyRule{};
  shared_ptr<vector<ModifyPolicyGroupRequestRevokeSecurityPolicyRule>> revokeSecurityPolicyRule{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<string> usbRedirect{};
  shared_ptr<vector<ModifyPolicyGroupRequestUsbSupplyRedirectRule>> usbSupplyRedirectRule{};
  shared_ptr<string> videoRedirect{};
  shared_ptr<string> visualQuality{};
  shared_ptr<string> watermark{};
  shared_ptr<string> watermarkAntiCam{};
  shared_ptr<long> watermarkColor{};
  shared_ptr<double> watermarkDegree{};
  shared_ptr<long> watermarkFontSize{};
  shared_ptr<string> watermarkFontStyle{};
  shared_ptr<string> watermarkPower{};
  shared_ptr<long> watermarkRowAmount{};
  shared_ptr<string> watermarkSecurity{};
  shared_ptr<string> watermarkTransparency{};
  shared_ptr<long> watermarkTransparencyValue{};
  shared_ptr<string> watermarkType{};
  shared_ptr<string> wyAssistant{};

  ModifyPolicyGroupRequest() {}

  explicit ModifyPolicyGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccess) {
      res["AdminAccess"] = boost::any(*adminAccess);
    }
    if (appContentProtection) {
      res["AppContentProtection"] = boost::any(*appContentProtection);
    }
    if (authorizeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeAccessPolicyRule"] = boost::any(temp1);
    }
    if (authorizeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*authorizeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (cameraRedirect) {
      res["CameraRedirect"] = boost::any(*cameraRedirect);
    }
    if (clientType) {
      vector<boost::any> temp1;
      for(auto item1:*clientType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientType"] = boost::any(temp1);
    }
    if (clipboard) {
      res["Clipboard"] = boost::any(*clipboard);
    }
    if (deviceRedirects) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRedirects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRedirects"] = boost::any(temp1);
    }
    if (deviceRules) {
      vector<boost::any> temp1;
      for(auto item1:*deviceRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceRules"] = boost::any(temp1);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainResolveRule) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolveRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolveRule"] = boost::any(temp1);
    }
    if (domainResolveRuleType) {
      res["DomainResolveRuleType"] = boost::any(*domainResolveRuleType);
    }
    if (endUserApplyAdminCoordinate) {
      res["EndUserApplyAdminCoordinate"] = boost::any(*endUserApplyAdminCoordinate);
    }
    if (endUserGroupCoordinate) {
      res["EndUserGroupCoordinate"] = boost::any(*endUserGroupCoordinate);
    }
    if (gpuAcceleration) {
      res["GpuAcceleration"] = boost::any(*gpuAcceleration);
    }
    if (html5Access) {
      res["Html5Access"] = boost::any(*html5Access);
    }
    if (html5FileTransfer) {
      res["Html5FileTransfer"] = boost::any(*html5FileTransfer);
    }
    if (internetCommunicationProtocol) {
      res["InternetCommunicationProtocol"] = boost::any(*internetCommunicationProtocol);
    }
    if (localDrive) {
      res["LocalDrive"] = boost::any(*localDrive);
    }
    if (maxReconnectTime) {
      res["MaxReconnectTime"] = boost::any(*maxReconnectTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netRedirect) {
      res["NetRedirect"] = boost::any(*netRedirect);
    }
    if (policyGroupId) {
      res["PolicyGroupId"] = boost::any(*policyGroupId);
    }
    if (preemptLogin) {
      res["PreemptLogin"] = boost::any(*preemptLogin);
    }
    if (preemptLoginUser) {
      res["PreemptLoginUser"] = boost::any(*preemptLoginUser);
    }
    if (printerRedirection) {
      res["PrinterRedirection"] = boost::any(*printerRedirection);
    }
    if (recordContent) {
      res["RecordContent"] = boost::any(*recordContent);
    }
    if (recordContentExpires) {
      res["RecordContentExpires"] = boost::any(*recordContentExpires);
    }
    if (recording) {
      res["Recording"] = boost::any(*recording);
    }
    if (recordingAudio) {
      res["RecordingAudio"] = boost::any(*recordingAudio);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingEndTime) {
      res["RecordingEndTime"] = boost::any(*recordingEndTime);
    }
    if (recordingExpires) {
      res["RecordingExpires"] = boost::any(*recordingExpires);
    }
    if (recordingFps) {
      res["RecordingFps"] = boost::any(*recordingFps);
    }
    if (recordingStartTime) {
      res["RecordingStartTime"] = boost::any(*recordingStartTime);
    }
    if (recordingUserNotify) {
      res["RecordingUserNotify"] = boost::any(*recordingUserNotify);
    }
    if (recordingUserNotifyMessage) {
      res["RecordingUserNotifyMessage"] = boost::any(*recordingUserNotifyMessage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCoordinate) {
      res["RemoteCoordinate"] = boost::any(*remoteCoordinate);
    }
    if (revokeAccessPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*revokeAccessPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokeAccessPolicyRule"] = boost::any(temp1);
    }
    if (revokeSecurityPolicyRule) {
      vector<boost::any> temp1;
      for(auto item1:*revokeSecurityPolicyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokeSecurityPolicyRule"] = boost::any(temp1);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (usbRedirect) {
      res["UsbRedirect"] = boost::any(*usbRedirect);
    }
    if (usbSupplyRedirectRule) {
      vector<boost::any> temp1;
      for(auto item1:*usbSupplyRedirectRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsbSupplyRedirectRule"] = boost::any(temp1);
    }
    if (videoRedirect) {
      res["VideoRedirect"] = boost::any(*videoRedirect);
    }
    if (visualQuality) {
      res["VisualQuality"] = boost::any(*visualQuality);
    }
    if (watermark) {
      res["Watermark"] = boost::any(*watermark);
    }
    if (watermarkAntiCam) {
      res["WatermarkAntiCam"] = boost::any(*watermarkAntiCam);
    }
    if (watermarkColor) {
      res["WatermarkColor"] = boost::any(*watermarkColor);
    }
    if (watermarkDegree) {
      res["WatermarkDegree"] = boost::any(*watermarkDegree);
    }
    if (watermarkFontSize) {
      res["WatermarkFontSize"] = boost::any(*watermarkFontSize);
    }
    if (watermarkFontStyle) {
      res["WatermarkFontStyle"] = boost::any(*watermarkFontStyle);
    }
    if (watermarkPower) {
      res["WatermarkPower"] = boost::any(*watermarkPower);
    }
    if (watermarkRowAmount) {
      res["WatermarkRowAmount"] = boost::any(*watermarkRowAmount);
    }
    if (watermarkSecurity) {
      res["WatermarkSecurity"] = boost::any(*watermarkSecurity);
    }
    if (watermarkTransparency) {
      res["WatermarkTransparency"] = boost::any(*watermarkTransparency);
    }
    if (watermarkTransparencyValue) {
      res["WatermarkTransparencyValue"] = boost::any(*watermarkTransparencyValue);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    if (wyAssistant) {
      res["WyAssistant"] = boost::any(*wyAssistant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccess") != m.end() && !m["AdminAccess"].empty()) {
      adminAccess = make_shared<string>(boost::any_cast<string>(m["AdminAccess"]));
    }
    if (m.find("AppContentProtection") != m.end() && !m["AppContentProtection"].empty()) {
      appContentProtection = make_shared<string>(boost::any_cast<string>(m["AppContentProtection"]));
    }
    if (m.find("AuthorizeAccessPolicyRule") != m.end() && !m["AuthorizeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeAccessPolicyRule"].type()) {
        vector<ModifyPolicyGroupRequestAuthorizeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestAuthorizeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeAccessPolicyRule = make_shared<vector<ModifyPolicyGroupRequestAuthorizeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("AuthorizeSecurityPolicyRule") != m.end() && !m["AuthorizeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizeSecurityPolicyRule"].type()) {
        vector<ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizeSecurityPolicyRule = make_shared<vector<ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("CameraRedirect") != m.end() && !m["CameraRedirect"].empty()) {
      cameraRedirect = make_shared<string>(boost::any_cast<string>(m["CameraRedirect"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientType"].type()) {
        vector<ModifyPolicyGroupRequestClientType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestClientType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientType = make_shared<vector<ModifyPolicyGroupRequestClientType>>(expect1);
      }
    }
    if (m.find("Clipboard") != m.end() && !m["Clipboard"].empty()) {
      clipboard = make_shared<string>(boost::any_cast<string>(m["Clipboard"]));
    }
    if (m.find("DeviceRedirects") != m.end() && !m["DeviceRedirects"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRedirects"].type()) {
        vector<ModifyPolicyGroupRequestDeviceRedirects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRedirects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestDeviceRedirects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRedirects = make_shared<vector<ModifyPolicyGroupRequestDeviceRedirects>>(expect1);
      }
    }
    if (m.find("DeviceRules") != m.end() && !m["DeviceRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceRules"].type()) {
        vector<ModifyPolicyGroupRequestDeviceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestDeviceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceRules = make_shared<vector<ModifyPolicyGroupRequestDeviceRules>>(expect1);
      }
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainResolveRule") != m.end() && !m["DomainResolveRule"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolveRule"].type()) {
        vector<ModifyPolicyGroupRequestDomainResolveRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolveRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestDomainResolveRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolveRule = make_shared<vector<ModifyPolicyGroupRequestDomainResolveRule>>(expect1);
      }
    }
    if (m.find("DomainResolveRuleType") != m.end() && !m["DomainResolveRuleType"].empty()) {
      domainResolveRuleType = make_shared<string>(boost::any_cast<string>(m["DomainResolveRuleType"]));
    }
    if (m.find("EndUserApplyAdminCoordinate") != m.end() && !m["EndUserApplyAdminCoordinate"].empty()) {
      endUserApplyAdminCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserApplyAdminCoordinate"]));
    }
    if (m.find("EndUserGroupCoordinate") != m.end() && !m["EndUserGroupCoordinate"].empty()) {
      endUserGroupCoordinate = make_shared<string>(boost::any_cast<string>(m["EndUserGroupCoordinate"]));
    }
    if (m.find("GpuAcceleration") != m.end() && !m["GpuAcceleration"].empty()) {
      gpuAcceleration = make_shared<string>(boost::any_cast<string>(m["GpuAcceleration"]));
    }
    if (m.find("Html5Access") != m.end() && !m["Html5Access"].empty()) {
      html5Access = make_shared<string>(boost::any_cast<string>(m["Html5Access"]));
    }
    if (m.find("Html5FileTransfer") != m.end() && !m["Html5FileTransfer"].empty()) {
      html5FileTransfer = make_shared<string>(boost::any_cast<string>(m["Html5FileTransfer"]));
    }
    if (m.find("InternetCommunicationProtocol") != m.end() && !m["InternetCommunicationProtocol"].empty()) {
      internetCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["InternetCommunicationProtocol"]));
    }
    if (m.find("LocalDrive") != m.end() && !m["LocalDrive"].empty()) {
      localDrive = make_shared<string>(boost::any_cast<string>(m["LocalDrive"]));
    }
    if (m.find("MaxReconnectTime") != m.end() && !m["MaxReconnectTime"].empty()) {
      maxReconnectTime = make_shared<long>(boost::any_cast<long>(m["MaxReconnectTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetRedirect") != m.end() && !m["NetRedirect"].empty()) {
      netRedirect = make_shared<string>(boost::any_cast<string>(m["NetRedirect"]));
    }
    if (m.find("PolicyGroupId") != m.end() && !m["PolicyGroupId"].empty()) {
      policyGroupId = make_shared<string>(boost::any_cast<string>(m["PolicyGroupId"]));
    }
    if (m.find("PreemptLogin") != m.end() && !m["PreemptLogin"].empty()) {
      preemptLogin = make_shared<string>(boost::any_cast<string>(m["PreemptLogin"]));
    }
    if (m.find("PreemptLoginUser") != m.end() && !m["PreemptLoginUser"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PreemptLoginUser"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreemptLoginUser"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      preemptLoginUser = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrinterRedirection") != m.end() && !m["PrinterRedirection"].empty()) {
      printerRedirection = make_shared<string>(boost::any_cast<string>(m["PrinterRedirection"]));
    }
    if (m.find("RecordContent") != m.end() && !m["RecordContent"].empty()) {
      recordContent = make_shared<string>(boost::any_cast<string>(m["RecordContent"]));
    }
    if (m.find("RecordContentExpires") != m.end() && !m["RecordContentExpires"].empty()) {
      recordContentExpires = make_shared<long>(boost::any_cast<long>(m["RecordContentExpires"]));
    }
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      recording = make_shared<string>(boost::any_cast<string>(m["Recording"]));
    }
    if (m.find("RecordingAudio") != m.end() && !m["RecordingAudio"].empty()) {
      recordingAudio = make_shared<string>(boost::any_cast<string>(m["RecordingAudio"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingEndTime") != m.end() && !m["RecordingEndTime"].empty()) {
      recordingEndTime = make_shared<string>(boost::any_cast<string>(m["RecordingEndTime"]));
    }
    if (m.find("RecordingExpires") != m.end() && !m["RecordingExpires"].empty()) {
      recordingExpires = make_shared<long>(boost::any_cast<long>(m["RecordingExpires"]));
    }
    if (m.find("RecordingFps") != m.end() && !m["RecordingFps"].empty()) {
      recordingFps = make_shared<long>(boost::any_cast<long>(m["RecordingFps"]));
    }
    if (m.find("RecordingStartTime") != m.end() && !m["RecordingStartTime"].empty()) {
      recordingStartTime = make_shared<string>(boost::any_cast<string>(m["RecordingStartTime"]));
    }
    if (m.find("RecordingUserNotify") != m.end() && !m["RecordingUserNotify"].empty()) {
      recordingUserNotify = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotify"]));
    }
    if (m.find("RecordingUserNotifyMessage") != m.end() && !m["RecordingUserNotifyMessage"].empty()) {
      recordingUserNotifyMessage = make_shared<string>(boost::any_cast<string>(m["RecordingUserNotifyMessage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCoordinate") != m.end() && !m["RemoteCoordinate"].empty()) {
      remoteCoordinate = make_shared<string>(boost::any_cast<string>(m["RemoteCoordinate"]));
    }
    if (m.find("RevokeAccessPolicyRule") != m.end() && !m["RevokeAccessPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokeAccessPolicyRule"].type()) {
        vector<ModifyPolicyGroupRequestRevokeAccessPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokeAccessPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestRevokeAccessPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokeAccessPolicyRule = make_shared<vector<ModifyPolicyGroupRequestRevokeAccessPolicyRule>>(expect1);
      }
    }
    if (m.find("RevokeSecurityPolicyRule") != m.end() && !m["RevokeSecurityPolicyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokeSecurityPolicyRule"].type()) {
        vector<ModifyPolicyGroupRequestRevokeSecurityPolicyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokeSecurityPolicyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestRevokeSecurityPolicyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokeSecurityPolicyRule = make_shared<vector<ModifyPolicyGroupRequestRevokeSecurityPolicyRule>>(expect1);
      }
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UsbRedirect") != m.end() && !m["UsbRedirect"].empty()) {
      usbRedirect = make_shared<string>(boost::any_cast<string>(m["UsbRedirect"]));
    }
    if (m.find("UsbSupplyRedirectRule") != m.end() && !m["UsbSupplyRedirectRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UsbSupplyRedirectRule"].type()) {
        vector<ModifyPolicyGroupRequestUsbSupplyRedirectRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsbSupplyRedirectRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPolicyGroupRequestUsbSupplyRedirectRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usbSupplyRedirectRule = make_shared<vector<ModifyPolicyGroupRequestUsbSupplyRedirectRule>>(expect1);
      }
    }
    if (m.find("VideoRedirect") != m.end() && !m["VideoRedirect"].empty()) {
      videoRedirect = make_shared<string>(boost::any_cast<string>(m["VideoRedirect"]));
    }
    if (m.find("VisualQuality") != m.end() && !m["VisualQuality"].empty()) {
      visualQuality = make_shared<string>(boost::any_cast<string>(m["VisualQuality"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermark = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
    if (m.find("WatermarkAntiCam") != m.end() && !m["WatermarkAntiCam"].empty()) {
      watermarkAntiCam = make_shared<string>(boost::any_cast<string>(m["WatermarkAntiCam"]));
    }
    if (m.find("WatermarkColor") != m.end() && !m["WatermarkColor"].empty()) {
      watermarkColor = make_shared<long>(boost::any_cast<long>(m["WatermarkColor"]));
    }
    if (m.find("WatermarkDegree") != m.end() && !m["WatermarkDegree"].empty()) {
      watermarkDegree = make_shared<double>(boost::any_cast<double>(m["WatermarkDegree"]));
    }
    if (m.find("WatermarkFontSize") != m.end() && !m["WatermarkFontSize"].empty()) {
      watermarkFontSize = make_shared<long>(boost::any_cast<long>(m["WatermarkFontSize"]));
    }
    if (m.find("WatermarkFontStyle") != m.end() && !m["WatermarkFontStyle"].empty()) {
      watermarkFontStyle = make_shared<string>(boost::any_cast<string>(m["WatermarkFontStyle"]));
    }
    if (m.find("WatermarkPower") != m.end() && !m["WatermarkPower"].empty()) {
      watermarkPower = make_shared<string>(boost::any_cast<string>(m["WatermarkPower"]));
    }
    if (m.find("WatermarkRowAmount") != m.end() && !m["WatermarkRowAmount"].empty()) {
      watermarkRowAmount = make_shared<long>(boost::any_cast<long>(m["WatermarkRowAmount"]));
    }
    if (m.find("WatermarkSecurity") != m.end() && !m["WatermarkSecurity"].empty()) {
      watermarkSecurity = make_shared<string>(boost::any_cast<string>(m["WatermarkSecurity"]));
    }
    if (m.find("WatermarkTransparency") != m.end() && !m["WatermarkTransparency"].empty()) {
      watermarkTransparency = make_shared<string>(boost::any_cast<string>(m["WatermarkTransparency"]));
    }
    if (m.find("WatermarkTransparencyValue") != m.end() && !m["WatermarkTransparencyValue"].empty()) {
      watermarkTransparencyValue = make_shared<long>(boost::any_cast<long>(m["WatermarkTransparencyValue"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
    if (m.find("WyAssistant") != m.end() && !m["WyAssistant"].empty()) {
      wyAssistant = make_shared<string>(boost::any_cast<string>(m["WyAssistant"]));
    }
  }


  virtual ~ModifyPolicyGroupRequest() = default;
};
class ModifyPolicyGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPolicyGroupResponseBody() {}

  explicit ModifyPolicyGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPolicyGroupResponseBody() = default;
};
class ModifyPolicyGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPolicyGroupResponseBody> body{};

  ModifyPolicyGroupResponse() {}

  explicit ModifyPolicyGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPolicyGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPolicyGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPolicyGroupResponse() = default;
};
class ModifyResourceCenterPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> policyGroupIds{};
  shared_ptr<string> policyGroupType{};
  shared_ptr<string> productType{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};

  ModifyResourceCenterPolicyRequest() {}

  explicit ModifyResourceCenterPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyGroupIds) {
      res["PolicyGroupIds"] = boost::any(*policyGroupIds);
    }
    if (policyGroupType) {
      res["PolicyGroupType"] = boost::any(*policyGroupType);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyGroupIds") != m.end() && !m["PolicyGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyGroupType") != m.end() && !m["PolicyGroupType"].empty()) {
      policyGroupType = make_shared<string>(boost::any_cast<string>(m["PolicyGroupType"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ModifyResourceCenterPolicyRequest() = default;
};
class ModifyResourceCenterPolicyResponseBodyModifyResults : public Darabonba::Model {
public:
  shared_ptr<bool> checkResult{};
  shared_ptr<string> resourceId{};

  ModifyResourceCenterPolicyResponseBodyModifyResults() {}

  explicit ModifyResourceCenterPolicyResponseBodyModifyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<bool>(boost::any_cast<bool>(m["CheckResult"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ModifyResourceCenterPolicyResponseBodyModifyResults() = default;
};
class ModifyResourceCenterPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyResourceCenterPolicyResponseBodyModifyResults>> modifyResults{};
  shared_ptr<string> requestId{};

  ModifyResourceCenterPolicyResponseBody() {}

  explicit ModifyResourceCenterPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyResults) {
      vector<boost::any> temp1;
      for(auto item1:*modifyResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModifyResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifyResults") != m.end() && !m["ModifyResults"].empty()) {
      if (typeid(vector<boost::any>) == m["ModifyResults"].type()) {
        vector<ModifyResourceCenterPolicyResponseBodyModifyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModifyResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyResourceCenterPolicyResponseBodyModifyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyResults = make_shared<vector<ModifyResourceCenterPolicyResponseBodyModifyResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourceCenterPolicyResponseBody() = default;
};
class ModifyResourceCenterPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourceCenterPolicyResponseBody> body{};

  ModifyResourceCenterPolicyResponse() {}

  explicit ModifyResourceCenterPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceCenterPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceCenterPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceCenterPolicyResponse() = default;
};
class ModifyTimerGroupRequestConfigTimers : public Darabonba::Model {
public:
  shared_ptr<bool> allowClientSetting{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> enforce{};
  shared_ptr<long> interval{};
  shared_ptr<long> notificationTime{};
  shared_ptr<string> operationType{};
  shared_ptr<vector<string>> processWhitelist{};
  shared_ptr<string> resetType{};
  shared_ptr<string> timerType{};
  shared_ptr<string> triggerType{};

  ModifyTimerGroupRequestConfigTimers() {}

  explicit ModifyTimerGroupRequestConfigTimers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowClientSetting) {
      res["AllowClientSetting"] = boost::any(*allowClientSetting);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (enforce) {
      res["Enforce"] = boost::any(*enforce);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (notificationTime) {
      res["NotificationTime"] = boost::any(*notificationTime);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (processWhitelist) {
      res["ProcessWhitelist"] = boost::any(*processWhitelist);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowClientSetting") != m.end() && !m["AllowClientSetting"].empty()) {
      allowClientSetting = make_shared<bool>(boost::any_cast<bool>(m["AllowClientSetting"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("Enforce") != m.end() && !m["Enforce"].empty()) {
      enforce = make_shared<bool>(boost::any_cast<bool>(m["Enforce"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("NotificationTime") != m.end() && !m["NotificationTime"].empty()) {
      notificationTime = make_shared<long>(boost::any_cast<long>(m["NotificationTime"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("ProcessWhitelist") != m.end() && !m["ProcessWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<string>(boost::any_cast<string>(m["TimerType"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ModifyTimerGroupRequestConfigTimers() = default;
};
class ModifyTimerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyTimerGroupRequestConfigTimers>> configTimers{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  ModifyTimerGroupRequest() {}

  explicit ModifyTimerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configTimers) {
      vector<boost::any> temp1;
      for(auto item1:*configTimers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTimers"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigTimers") != m.end() && !m["ConfigTimers"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTimers"].type()) {
        vector<ModifyTimerGroupRequestConfigTimers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTimers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyTimerGroupRequestConfigTimers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTimers = make_shared<vector<ModifyTimerGroupRequestConfigTimers>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyTimerGroupRequest() = default;
};
class ModifyTimerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  ModifyTimerGroupResponseBody() {}

  explicit ModifyTimerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTimerGroupResponseBody() = default;
};
class ModifyTimerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTimerGroupResponseBody> body{};

  ModifyTimerGroupResponse() {}

  explicit ModifyTimerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTimerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTimerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTimerGroupResponse() = default;
};
class ModifyUserEntitlementRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> authorizeDesktopId{};
  shared_ptr<vector<string>> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> revokeDesktopId{};

  ModifyUserEntitlementRequest() {}

  explicit ModifyUserEntitlementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeDesktopId) {
      res["AuthorizeDesktopId"] = boost::any(*authorizeDesktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (revokeDesktopId) {
      res["RevokeDesktopId"] = boost::any(*revokeDesktopId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeDesktopId") != m.end() && !m["AuthorizeDesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthorizeDesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthorizeDesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authorizeDesktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RevokeDesktopId") != m.end() && !m["RevokeDesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RevokeDesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RevokeDesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      revokeDesktopId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyUserEntitlementRequest() = default;
};
class ModifyUserEntitlementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserEntitlementResponseBody() {}

  explicit ModifyUserEntitlementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserEntitlementResponseBody() = default;
};
class ModifyUserEntitlementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserEntitlementResponseBody> body{};

  ModifyUserEntitlementResponse() {}

  explicit ModifyUserEntitlementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserEntitlementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserEntitlementResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserEntitlementResponse() = default;
};
class ModifyUserToDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> newEndUserIds{};
  shared_ptr<vector<string>> oldEndUserIds{};
  shared_ptr<string> regionId{};

  ModifyUserToDesktopGroupRequest() {}

  explicit ModifyUserToDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (newEndUserIds) {
      res["NewEndUserIds"] = boost::any(*newEndUserIds);
    }
    if (oldEndUserIds) {
      res["OldEndUserIds"] = boost::any(*oldEndUserIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("NewEndUserIds") != m.end() && !m["NewEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NewEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NewEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      newEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OldEndUserIds") != m.end() && !m["OldEndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OldEndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OldEndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      oldEndUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyUserToDesktopGroupRequest() = default;
};
class ModifyUserToDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserToDesktopGroupResponseBody() {}

  explicit ModifyUserToDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserToDesktopGroupResponseBody() = default;
};
class ModifyUserToDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserToDesktopGroupResponseBody> body{};

  ModifyUserToDesktopGroupResponse() {}

  explicit ModifyUserToDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserToDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserToDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserToDesktopGroupResponse() = default;
};
class MoveCdsFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> conflictPolicy{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> parentFolderId{};
  shared_ptr<string> regionId{};

  MoveCdsFileRequest() {}

  explicit MoveCdsFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (conflictPolicy) {
      res["ConflictPolicy"] = boost::any(*conflictPolicy);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (parentFolderId) {
      res["ParentFolderId"] = boost::any(*parentFolderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("ConflictPolicy") != m.end() && !m["ConflictPolicy"].empty()) {
      conflictPolicy = make_shared<string>(boost::any_cast<string>(m["ConflictPolicy"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ParentFolderId") != m.end() && !m["ParentFolderId"].empty()) {
      parentFolderId = make_shared<string>(boost::any_cast<string>(m["ParentFolderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~MoveCdsFileRequest() = default;
};
class MoveCdsFileResponseBodyMoveCdsFileModel : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<bool> exist{};
  shared_ptr<string> fileId{};

  MoveCdsFileResponseBodyMoveCdsFileModel() {}

  explicit MoveCdsFileResponseBodyMoveCdsFileModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (exist) {
      res["Exist"] = boost::any(*exist);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("Exist") != m.end() && !m["Exist"].empty()) {
      exist = make_shared<bool>(boost::any_cast<bool>(m["Exist"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~MoveCdsFileResponseBodyMoveCdsFileModel() = default;
};
class MoveCdsFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<MoveCdsFileResponseBodyMoveCdsFileModel> moveCdsFileModel{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveCdsFileResponseBody() {}

  explicit MoveCdsFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (moveCdsFileModel) {
      res["MoveCdsFileModel"] = moveCdsFileModel ? boost::any(moveCdsFileModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MoveCdsFileModel") != m.end() && !m["MoveCdsFileModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoveCdsFileModel"].type()) {
        MoveCdsFileResponseBodyMoveCdsFileModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoveCdsFileModel"]));
        moveCdsFileModel = make_shared<MoveCdsFileResponseBodyMoveCdsFileModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveCdsFileResponseBody() = default;
};
class MoveCdsFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveCdsFileResponseBody> body{};

  MoveCdsFileResponse() {}

  explicit MoveCdsFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveCdsFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveCdsFileResponseBody>(model1);
      }
    }
  }


  virtual ~MoveCdsFileResponse() = default;
};
class RebootDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<bool> osUpdate{};
  shared_ptr<string> regionId{};

  RebootDesktopsRequest() {}

  explicit RebootDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (osUpdate) {
      res["OsUpdate"] = boost::any(*osUpdate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OsUpdate") != m.end() && !m["OsUpdate"].empty()) {
      osUpdate = make_shared<bool>(boost::any_cast<bool>(m["OsUpdate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RebootDesktopsRequest() = default;
};
class RebootDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootDesktopsResponseBody() {}

  explicit RebootDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootDesktopsResponseBody() = default;
};
class RebootDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootDesktopsResponseBody> body{};

  RebootDesktopsResponse() {}

  explicit RebootDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~RebootDesktopsResponse() = default;
};
class RebuildDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<string> afterStatus{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> language{};
  shared_ptr<string> operateType{};
  shared_ptr<string> regionId{};

  RebuildDesktopsRequest() {}

  explicit RebuildDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterStatus) {
      res["AfterStatus"] = boost::any(*afterStatus);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterStatus") != m.end() && !m["AfterStatus"].empty()) {
      afterStatus = make_shared<string>(boost::any_cast<string>(m["AfterStatus"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RebuildDesktopsRequest() = default;
};
class RebuildDesktopsResponseBodyRebuildResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> desktopId{};
  shared_ptr<string> message{};

  RebuildDesktopsResponseBodyRebuildResults() {}

  explicit RebuildDesktopsResponseBodyRebuildResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      desktopId = make_shared<string>(boost::any_cast<string>(m["DesktopId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~RebuildDesktopsResponseBodyRebuildResults() = default;
};
class RebuildDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<RebuildDesktopsResponseBodyRebuildResults>> rebuildResults{};
  shared_ptr<string> requestId{};

  RebuildDesktopsResponseBody() {}

  explicit RebuildDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rebuildResults) {
      vector<boost::any> temp1;
      for(auto item1:*rebuildResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RebuildResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RebuildResults") != m.end() && !m["RebuildResults"].empty()) {
      if (typeid(vector<boost::any>) == m["RebuildResults"].type()) {
        vector<RebuildDesktopsResponseBodyRebuildResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RebuildResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RebuildDesktopsResponseBodyRebuildResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rebuildResults = make_shared<vector<RebuildDesktopsResponseBodyRebuildResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebuildDesktopsResponseBody() = default;
};
class RebuildDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebuildDesktopsResponseBody> body{};

  RebuildDesktopsResponse() {}

  explicit RebuildDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebuildDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebuildDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~RebuildDesktopsResponse() = default;
};
class RemoveFilePermissionRequestMemberListCdsIdentity : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  RemoveFilePermissionRequestMemberListCdsIdentity() {}

  explicit RemoveFilePermissionRequestMemberListCdsIdentity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RemoveFilePermissionRequestMemberListCdsIdentity() = default;
};
class RemoveFilePermissionRequestMemberList : public Darabonba::Model {
public:
  shared_ptr<RemoveFilePermissionRequestMemberListCdsIdentity> cdsIdentity{};
  shared_ptr<string> roleId{};

  RemoveFilePermissionRequestMemberList() {}

  explicit RemoveFilePermissionRequestMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsIdentity) {
      res["CdsIdentity"] = cdsIdentity ? boost::any(cdsIdentity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsIdentity") != m.end() && !m["CdsIdentity"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdsIdentity"].type()) {
        RemoveFilePermissionRequestMemberListCdsIdentity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdsIdentity"]));
        cdsIdentity = make_shared<RemoveFilePermissionRequestMemberListCdsIdentity>(model1);
      }
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~RemoveFilePermissionRequestMemberList() = default;
};
class RemoveFilePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<RemoveFilePermissionRequestMemberList>> memberList{};
  shared_ptr<string> regionId{};

  RemoveFilePermissionRequest() {}

  explicit RemoveFilePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (memberList) {
      vector<boost::any> temp1;
      for(auto item1:*memberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MemberList"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["MemberList"].type()) {
        vector<RemoveFilePermissionRequestMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveFilePermissionRequestMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberList = make_shared<vector<RemoveFilePermissionRequestMemberList>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveFilePermissionRequest() = default;
};
class RemoveFilePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdsId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> fileId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> memberListShrink{};
  shared_ptr<string> regionId{};

  RemoveFilePermissionShrinkRequest() {}

  explicit RemoveFilePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdsId) {
      res["CdsId"] = boost::any(*cdsId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (memberListShrink) {
      res["MemberList"] = boost::any(*memberListShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdsId") != m.end() && !m["CdsId"].empty()) {
      cdsId = make_shared<string>(boost::any_cast<string>(m["CdsId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      memberListShrink = make_shared<string>(boost::any_cast<string>(m["MemberList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveFilePermissionShrinkRequest() = default;
};
class RemoveFilePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveFilePermissionResponseBody() {}

  explicit RemoveFilePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveFilePermissionResponseBody() = default;
};
class RemoveFilePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveFilePermissionResponseBody> body{};

  RemoveFilePermissionResponse() {}

  explicit RemoveFilePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveFilePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveFilePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveFilePermissionResponse() = default;
};
class RemoveUserFromDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopGroupIds{};
  shared_ptr<vector<string>> endUserIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userOuPath{};

  RemoveUserFromDesktopGroupRequest() {}

  explicit RemoveUserFromDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupIds) {
      res["DesktopGroupIds"] = boost::any(*desktopGroupIds);
    }
    if (endUserIds) {
      res["EndUserIds"] = boost::any(*endUserIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userOuPath) {
      res["UserOuPath"] = boost::any(*userOuPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupIds") != m.end() && !m["DesktopGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserIds") != m.end() && !m["EndUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserOuPath") != m.end() && !m["UserOuPath"].empty()) {
      userOuPath = make_shared<string>(boost::any_cast<string>(m["UserOuPath"]));
    }
  }


  virtual ~RemoveUserFromDesktopGroupRequest() = default;
};
class RemoveUserFromDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveUserFromDesktopGroupResponseBody() {}

  explicit RemoveUserFromDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUserFromDesktopGroupResponseBody() = default;
};
class RemoveUserFromDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUserFromDesktopGroupResponseBody> body{};

  RemoveUserFromDesktopGroupResponse() {}

  explicit RemoveUserFromDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUserFromDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUserFromDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUserFromDesktopGroupResponse() = default;
};
class RemoveUserFromDesktopOversoldUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> endUserId{};
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<string> userDesktopId{};
  shared_ptr<string> userGroupId{};

  RemoveUserFromDesktopOversoldUserGroupRequest() {}

  explicit RemoveUserFromDesktopOversoldUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (userDesktopId) {
      res["UserDesktopId"] = boost::any(*userDesktopId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("UserDesktopId") != m.end() && !m["UserDesktopId"].empty()) {
      userDesktopId = make_shared<string>(boost::any_cast<string>(m["UserDesktopId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~RemoveUserFromDesktopOversoldUserGroupRequest() = default;
};
class RemoveUserFromDesktopOversoldUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveUserFromDesktopOversoldUserGroupResponseBody() {}

  explicit RemoveUserFromDesktopOversoldUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUserFromDesktopOversoldUserGroupResponseBody() = default;
};
class RemoveUserFromDesktopOversoldUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUserFromDesktopOversoldUserGroupResponseBody> body{};

  RemoveUserFromDesktopOversoldUserGroupResponse() {}

  explicit RemoveUserFromDesktopOversoldUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUserFromDesktopOversoldUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUserFromDesktopOversoldUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUserFromDesktopOversoldUserGroupResponse() = default;
};
class RenewDesktopGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};

  RenewDesktopGroupRequest() {}

  explicit RenewDesktopGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RenewDesktopGroupRequest() = default;
};
class RenewDesktopGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderId{};
  shared_ptr<string> requestId{};

  RenewDesktopGroupResponseBody() {}

  explicit RenewDesktopGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewDesktopGroupResponseBody() = default;
};
class RenewDesktopGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewDesktopGroupResponseBody> body{};

  RenewDesktopGroupResponse() {}

  explicit RenewDesktopGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewDesktopGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewDesktopGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RenewDesktopGroupResponse() = default;
};
class RenewDesktopOversoldGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> oversoldGroupId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};

  RenewDesktopOversoldGroupRequest() {}

  explicit RenewDesktopOversoldGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~RenewDesktopOversoldGroupRequest() = default;
};
class RenewDesktopOversoldGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> oversoldGroupId{};

  RenewDesktopOversoldGroupResponseBodyData() {}

  explicit RenewDesktopOversoldGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (oversoldGroupId) {
      res["OversoldGroupId"] = boost::any(*oversoldGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OversoldGroupId") != m.end() && !m["OversoldGroupId"].empty()) {
      oversoldGroupId = make_shared<string>(boost::any_cast<string>(m["OversoldGroupId"]));
    }
  }


  virtual ~RenewDesktopOversoldGroupResponseBodyData() = default;
};
class RenewDesktopOversoldGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<RenewDesktopOversoldGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  RenewDesktopOversoldGroupResponseBody() {}

  explicit RenewDesktopOversoldGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RenewDesktopOversoldGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RenewDesktopOversoldGroupResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewDesktopOversoldGroupResponseBody() = default;
};
class RenewDesktopOversoldGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewDesktopOversoldGroupResponseBody> body{};

  RenewDesktopOversoldGroupResponse() {}

  explicit RenewDesktopOversoldGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewDesktopOversoldGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewDesktopOversoldGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RenewDesktopOversoldGroupResponse() = default;
};
class RenewDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  RenewDesktopsRequest() {}

  explicit RenewDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~RenewDesktopsRequest() = default;
};
class RenewDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RenewDesktopsResponseBody() {}

  explicit RenewDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewDesktopsResponseBody() = default;
};
class RenewDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewDesktopsResponseBody> body{};

  RenewDesktopsResponse() {}

  explicit RenewDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~RenewDesktopsResponse() = default;
};
class RenewNetworkPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<vector<string>> networkPackageId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> regionId{};

  RenewNetworkPackagesRequest() {}

  explicit RenewNetworkPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (networkPackageId) {
      res["NetworkPackageId"] = boost::any(*networkPackageId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("NetworkPackageId") != m.end() && !m["NetworkPackageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkPackageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkPackageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkPackageId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RenewNetworkPackagesRequest() = default;
};
class RenewNetworkPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RenewNetworkPackagesResponseBody() {}

  explicit RenewNetworkPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewNetworkPackagesResponseBody() = default;
};
class RenewNetworkPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewNetworkPackagesResponseBody> body{};

  RenewNetworkPackagesResponse() {}

  explicit RenewNetworkPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewNetworkPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewNetworkPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~RenewNetworkPackagesResponse() = default;
};
class ResetDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopGroupIds{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resetScope{};
  shared_ptr<string> resetType{};

  ResetDesktopsRequest() {}

  explicit ResetDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopGroupIds) {
      res["DesktopGroupIds"] = boost::any(*desktopGroupIds);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resetScope) {
      res["ResetScope"] = boost::any(*resetScope);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopGroupIds") != m.end() && !m["DesktopGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResetScope") != m.end() && !m["ResetScope"].empty()) {
      resetScope = make_shared<string>(boost::any_cast<string>(m["ResetScope"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<string>(boost::any_cast<string>(m["ResetType"]));
    }
  }


  virtual ~ResetDesktopsRequest() = default;
};
class ResetDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetDesktopsResponseBody() {}

  explicit ResetDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetDesktopsResponseBody() = default;
};
class ResetDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetDesktopsResponseBody> body{};

  ResetDesktopsResponse() {}

  explicit ResetDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDesktopsResponse() = default;
};
class ResetNASDefaultMountTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> regionId{};

  ResetNASDefaultMountTargetRequest() {}

  explicit ResetNASDefaultMountTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ResetNASDefaultMountTargetRequest() = default;
};
class ResetNASDefaultMountTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetNASDefaultMountTargetResponseBody() {}

  explicit ResetNASDefaultMountTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetNASDefaultMountTargetResponseBody() = default;
};
class ResetNASDefaultMountTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetNASDefaultMountTargetResponseBody> body{};

  ResetNASDefaultMountTargetResponse() {}

  explicit ResetNASDefaultMountTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetNASDefaultMountTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetNASDefaultMountTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ResetNASDefaultMountTargetResponse() = default;
};
class ResetSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};

  ResetSnapshotRequest() {}

  explicit ResetSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~ResetSnapshotRequest() = default;
};
class ResetSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetSnapshotResponseBody() {}

  explicit ResetSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetSnapshotResponseBody() = default;
};
class ResetSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetSnapshotResponseBody> body{};

  ResetSnapshotResponse() {}

  explicit ResetSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~ResetSnapshotResponse() = default;
};
class RevokeCoordinatePrivilegeRequest : public Darabonba::Model {
public:
  shared_ptr<string> coId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userType{};
  shared_ptr<string> uuid{};

  RevokeCoordinatePrivilegeRequest() {}

  explicit RevokeCoordinatePrivilegeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coId) {
      res["CoId"] = boost::any(*coId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoId") != m.end() && !m["CoId"].empty()) {
      coId = make_shared<string>(boost::any_cast<string>(m["CoId"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~RevokeCoordinatePrivilegeRequest() = default;
};
class RevokeCoordinatePrivilegeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeCoordinatePrivilegeResponseBody() {}

  explicit RevokeCoordinatePrivilegeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeCoordinatePrivilegeResponseBody() = default;
};
class RevokeCoordinatePrivilegeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeCoordinatePrivilegeResponseBody> body{};

  RevokeCoordinatePrivilegeResponse() {}

  explicit RevokeCoordinatePrivilegeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeCoordinatePrivilegeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeCoordinatePrivilegeResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeCoordinatePrivilegeResponse() = default;
};
class RunCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandContent{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> endUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};

  RunCommandRequest() {}

  explicit RunCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandContent) {
      res["CommandContent"] = boost::any(*commandContent);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandContent") != m.end() && !m["CommandContent"].empty()) {
      commandContent = make_shared<string>(boost::any_cast<string>(m["CommandContent"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RunCommandRequest() = default;
};
class RunCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> invokeId{};
  shared_ptr<string> requestId{};

  RunCommandResponseBody() {}

  explicit RunCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunCommandResponseBody() = default;
};
class RunCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunCommandResponseBody> body{};

  RunCommandResponse() {}

  explicit RunCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RunCommandResponse() = default;
};
class SendVerifyCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> extraInfo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> verifyCodeAction{};

  SendVerifyCodeRequest() {}

  explicit SendVerifyCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (verifyCodeAction) {
      res["VerifyCodeAction"] = boost::any(*verifyCodeAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VerifyCodeAction") != m.end() && !m["VerifyCodeAction"].empty()) {
      verifyCodeAction = make_shared<string>(boost::any_cast<string>(m["VerifyCodeAction"]));
    }
  }


  virtual ~SendVerifyCodeRequest() = default;
};
class SendVerifyCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendVerifyCodeResponseBody() {}

  explicit SendVerifyCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendVerifyCodeResponseBody() = default;
};
class SendVerifyCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendVerifyCodeResponseBody> body{};

  SendVerifyCodeResponse() {}

  explicit SendVerifyCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendVerifyCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendVerifyCodeResponseBody>(model1);
      }
    }
  }


  virtual ~SendVerifyCodeResponse() = default;
};
class SetDesktopGroupScaleTimerRequestScaleTimerInfos : public Darabonba::Model {
public:
  shared_ptr<long> buyResAmount{};
  shared_ptr<string> cron{};
  shared_ptr<long> keepDuration{};
  shared_ptr<long> loadPolicy{};
  shared_ptr<long> maxResAmount{};
  shared_ptr<long> minResAmount{};
  shared_ptr<double> ratioThreshold{};
  shared_ptr<string> type{};

  SetDesktopGroupScaleTimerRequestScaleTimerInfos() {}

  explicit SetDesktopGroupScaleTimerRequestScaleTimerInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyResAmount) {
      res["BuyResAmount"] = boost::any(*buyResAmount);
    }
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (keepDuration) {
      res["KeepDuration"] = boost::any(*keepDuration);
    }
    if (loadPolicy) {
      res["LoadPolicy"] = boost::any(*loadPolicy);
    }
    if (maxResAmount) {
      res["MaxResAmount"] = boost::any(*maxResAmount);
    }
    if (minResAmount) {
      res["MinResAmount"] = boost::any(*minResAmount);
    }
    if (ratioThreshold) {
      res["RatioThreshold"] = boost::any(*ratioThreshold);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyResAmount") != m.end() && !m["BuyResAmount"].empty()) {
      buyResAmount = make_shared<long>(boost::any_cast<long>(m["BuyResAmount"]));
    }
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<string>(boost::any_cast<string>(m["Cron"]));
    }
    if (m.find("KeepDuration") != m.end() && !m["KeepDuration"].empty()) {
      keepDuration = make_shared<long>(boost::any_cast<long>(m["KeepDuration"]));
    }
    if (m.find("LoadPolicy") != m.end() && !m["LoadPolicy"].empty()) {
      loadPolicy = make_shared<long>(boost::any_cast<long>(m["LoadPolicy"]));
    }
    if (m.find("MaxResAmount") != m.end() && !m["MaxResAmount"].empty()) {
      maxResAmount = make_shared<long>(boost::any_cast<long>(m["MaxResAmount"]));
    }
    if (m.find("MinResAmount") != m.end() && !m["MinResAmount"].empty()) {
      minResAmount = make_shared<long>(boost::any_cast<long>(m["MinResAmount"]));
    }
    if (m.find("RatioThreshold") != m.end() && !m["RatioThreshold"].empty()) {
      ratioThreshold = make_shared<double>(boost::any_cast<double>(m["RatioThreshold"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SetDesktopGroupScaleTimerRequestScaleTimerInfos() = default;
};
class SetDesktopGroupScaleTimerRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<SetDesktopGroupScaleTimerRequestScaleTimerInfos>> scaleTimerInfos{};

  SetDesktopGroupScaleTimerRequest() {}

  explicit SetDesktopGroupScaleTimerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scaleTimerInfos) {
      vector<boost::any> temp1;
      for(auto item1:*scaleTimerInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScaleTimerInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScaleTimerInfos") != m.end() && !m["ScaleTimerInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ScaleTimerInfos"].type()) {
        vector<SetDesktopGroupScaleTimerRequestScaleTimerInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScaleTimerInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetDesktopGroupScaleTimerRequestScaleTimerInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scaleTimerInfos = make_shared<vector<SetDesktopGroupScaleTimerRequestScaleTimerInfos>>(expect1);
      }
    }
  }


  virtual ~SetDesktopGroupScaleTimerRequest() = default;
};
class SetDesktopGroupScaleTimerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDesktopGroupScaleTimerResponseBody() {}

  explicit SetDesktopGroupScaleTimerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDesktopGroupScaleTimerResponseBody() = default;
};
class SetDesktopGroupScaleTimerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDesktopGroupScaleTimerResponseBody> body{};

  SetDesktopGroupScaleTimerResponse() {}

  explicit SetDesktopGroupScaleTimerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDesktopGroupScaleTimerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDesktopGroupScaleTimerResponseBody>(model1);
      }
    }
  }


  virtual ~SetDesktopGroupScaleTimerResponse() = default;
};
class SetDesktopGroupTimerRequest : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<bool> force{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resetType{};
  shared_ptr<long> timerType{};

  SetDesktopGroupTimerRequest() {}

  explicit SetDesktopGroupTimerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resetType) {
      res["ResetType"] = boost::any(*resetType);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResetType") != m.end() && !m["ResetType"].empty()) {
      resetType = make_shared<long>(boost::any_cast<long>(m["ResetType"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<long>(boost::any_cast<long>(m["TimerType"]));
    }
  }


  virtual ~SetDesktopGroupTimerRequest() = default;
};
class SetDesktopGroupTimerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDesktopGroupTimerResponseBody() {}

  explicit SetDesktopGroupTimerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDesktopGroupTimerResponseBody() = default;
};
class SetDesktopGroupTimerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDesktopGroupTimerResponseBody> body{};

  SetDesktopGroupTimerResponse() {}

  explicit SetDesktopGroupTimerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDesktopGroupTimerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDesktopGroupTimerResponseBody>(model1);
      }
    }
  }


  virtual ~SetDesktopGroupTimerResponse() = default;
};
class SetDesktopGroupTimerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<long> timerType{};

  SetDesktopGroupTimerStatusRequest() {}

  explicit SetDesktopGroupTimerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timerType) {
      res["TimerType"] = boost::any(*timerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TimerType") != m.end() && !m["TimerType"].empty()) {
      timerType = make_shared<long>(boost::any_cast<long>(m["TimerType"]));
    }
  }


  virtual ~SetDesktopGroupTimerStatusRequest() = default;
};
class SetDesktopGroupTimerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDesktopGroupTimerStatusResponseBody() {}

  explicit SetDesktopGroupTimerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDesktopGroupTimerStatusResponseBody() = default;
};
class SetDesktopGroupTimerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDesktopGroupTimerStatusResponseBody> body{};

  SetDesktopGroupTimerStatusResponse() {}

  explicit SetDesktopGroupTimerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDesktopGroupTimerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDesktopGroupTimerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDesktopGroupTimerStatusResponse() = default;
};
class SetDesktopMaintenanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopIds{};
  shared_ptr<string> mode{};
  shared_ptr<string> regionId{};

  SetDesktopMaintenanceRequest() {}

  explicit SetDesktopMaintenanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopIds) {
      res["DesktopIds"] = boost::any(*desktopIds);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopIds") != m.end() && !m["DesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetDesktopMaintenanceRequest() = default;
};
class SetDesktopMaintenanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDesktopMaintenanceResponseBody() {}

  explicit SetDesktopMaintenanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDesktopMaintenanceResponseBody() = default;
};
class SetDesktopMaintenanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDesktopMaintenanceResponseBody> body{};

  SetDesktopMaintenanceResponse() {}

  explicit SetDesktopMaintenanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDesktopMaintenanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDesktopMaintenanceResponseBody>(model1);
      }
    }
  }


  virtual ~SetDesktopMaintenanceResponse() = default;
};
class SetDirectorySsoStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> directoryId{};
  shared_ptr<bool> enableSso{};
  shared_ptr<string> regionId{};

  SetDirectorySsoStatusRequest() {}

  explicit SetDirectorySsoStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (enableSso) {
      res["EnableSso"] = boost::any(*enableSso);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("EnableSso") != m.end() && !m["EnableSso"].empty()) {
      enableSso = make_shared<bool>(boost::any_cast<bool>(m["EnableSso"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetDirectorySsoStatusRequest() = default;
};
class SetDirectorySsoStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDirectorySsoStatusResponseBody() {}

  explicit SetDirectorySsoStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDirectorySsoStatusResponseBody() = default;
};
class SetDirectorySsoStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDirectorySsoStatusResponseBody> body{};

  SetDirectorySsoStatusResponse() {}

  explicit SetDirectorySsoStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDirectorySsoStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDirectorySsoStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDirectorySsoStatusResponse() = default;
};
class SetIdpMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> directoryId{};
  shared_ptr<string> idpMetadata{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  SetIdpMetadataRequest() {}

  explicit SetIdpMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (idpMetadata) {
      res["IdpMetadata"] = boost::any(*idpMetadata);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("IdpMetadata") != m.end() && !m["IdpMetadata"].empty()) {
      idpMetadata = make_shared<string>(boost::any_cast<string>(m["IdpMetadata"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetIdpMetadataRequest() = default;
};
class SetIdpMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> idpEntityId{};
  shared_ptr<string> requestId{};

  SetIdpMetadataResponseBody() {}

  explicit SetIdpMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idpEntityId) {
      res["IdpEntityId"] = boost::any(*idpEntityId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdpEntityId") != m.end() && !m["IdpEntityId"].empty()) {
      idpEntityId = make_shared<string>(boost::any_cast<string>(m["IdpEntityId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetIdpMetadataResponseBody() = default;
};
class SetIdpMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetIdpMetadataResponseBody> body{};

  SetIdpMetadataResponse() {}

  explicit SetIdpMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetIdpMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetIdpMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~SetIdpMetadataResponse() = default;
};
class SetOfficeSiteSsoStatusRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableSso{};
  shared_ptr<string> officeSiteId{};
  shared_ptr<string> regionId{};

  SetOfficeSiteSsoStatusRequest() {}

  explicit SetOfficeSiteSsoStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableSso) {
      res["EnableSso"] = boost::any(*enableSso);
    }
    if (officeSiteId) {
      res["OfficeSiteId"] = boost::any(*officeSiteId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableSso") != m.end() && !m["EnableSso"].empty()) {
      enableSso = make_shared<bool>(boost::any_cast<bool>(m["EnableSso"]));
    }
    if (m.find("OfficeSiteId") != m.end() && !m["OfficeSiteId"].empty()) {
      officeSiteId = make_shared<string>(boost::any_cast<string>(m["OfficeSiteId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetOfficeSiteSsoStatusRequest() = default;
};
class SetOfficeSiteSsoStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetOfficeSiteSsoStatusResponseBody() {}

  explicit SetOfficeSiteSsoStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetOfficeSiteSsoStatusResponseBody() = default;
};
class SetOfficeSiteSsoStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetOfficeSiteSsoStatusResponseBody> body{};

  SetOfficeSiteSsoStatusResponse() {}

  explicit SetOfficeSiteSsoStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetOfficeSiteSsoStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetOfficeSiteSsoStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetOfficeSiteSsoStatusResponse() = default;
};
class SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath() {}

  explicit SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath() = default;
};
class SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths() {}

  explicit SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths() = default;
};
class SetUserProfilePathRulesRequestUserProfilePathRule : public Darabonba::Model {
public:
  shared_ptr<SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath> blackPath{};
  shared_ptr<vector<SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths>> whitePaths{};

  SetUserProfilePathRulesRequestUserProfilePathRule() {}

  explicit SetUserProfilePathRulesRequestUserProfilePathRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackPath) {
      res["BlackPath"] = blackPath ? boost::any(blackPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (whitePaths) {
      vector<boost::any> temp1;
      for(auto item1:*whitePaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WhitePaths"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackPath") != m.end() && !m["BlackPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlackPath"].type()) {
        SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlackPath"]));
        blackPath = make_shared<SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath>(model1);
      }
    }
    if (m.find("WhitePaths") != m.end() && !m["WhitePaths"].empty()) {
      if (typeid(vector<boost::any>) == m["WhitePaths"].type()) {
        vector<SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhitePaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whitePaths = make_shared<vector<SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths>>(expect1);
      }
    }
  }


  virtual ~SetUserProfilePathRulesRequestUserProfilePathRule() = default;
};
class SetUserProfilePathRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<SetUserProfilePathRulesRequestUserProfilePathRule>> userProfilePathRule{};
  shared_ptr<string> userProfileRuleType{};

  SetUserProfilePathRulesRequest() {}

  explicit SetUserProfilePathRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userProfilePathRule) {
      vector<boost::any> temp1;
      for(auto item1:*userProfilePathRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserProfilePathRule"] = boost::any(temp1);
    }
    if (userProfileRuleType) {
      res["UserProfileRuleType"] = boost::any(*userProfileRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserProfilePathRule") != m.end() && !m["UserProfilePathRule"].empty()) {
      if (typeid(vector<boost::any>) == m["UserProfilePathRule"].type()) {
        vector<SetUserProfilePathRulesRequestUserProfilePathRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserProfilePathRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetUserProfilePathRulesRequestUserProfilePathRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userProfilePathRule = make_shared<vector<SetUserProfilePathRulesRequestUserProfilePathRule>>(expect1);
      }
    }
    if (m.find("UserProfileRuleType") != m.end() && !m["UserProfileRuleType"].empty()) {
      userProfileRuleType = make_shared<string>(boost::any_cast<string>(m["UserProfileRuleType"]));
    }
  }


  virtual ~SetUserProfilePathRulesRequest() = default;
};
class SetUserProfilePathRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> desktopGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userProfilePathRuleShrink{};
  shared_ptr<string> userProfileRuleType{};

  SetUserProfilePathRulesShrinkRequest() {}

  explicit SetUserProfilePathRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userProfilePathRuleShrink) {
      res["UserProfilePathRule"] = boost::any(*userProfilePathRuleShrink);
    }
    if (userProfileRuleType) {
      res["UserProfileRuleType"] = boost::any(*userProfileRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserProfilePathRule") != m.end() && !m["UserProfilePathRule"].empty()) {
      userProfilePathRuleShrink = make_shared<string>(boost::any_cast<string>(m["UserProfilePathRule"]));
    }
    if (m.find("UserProfileRuleType") != m.end() && !m["UserProfileRuleType"].empty()) {
      userProfileRuleType = make_shared<string>(boost::any_cast<string>(m["UserProfileRuleType"]));
    }
  }


  virtual ~SetUserProfilePathRulesShrinkRequest() = default;
};
class SetUserProfilePathRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetUserProfilePathRulesResponseBody() {}

  explicit SetUserProfilePathRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetUserProfilePathRulesResponseBody() = default;
};
class SetUserProfilePathRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetUserProfilePathRulesResponseBody> body{};

  SetUserProfilePathRulesResponse() {}

  explicit SetUserProfilePathRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetUserProfilePathRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetUserProfilePathRulesResponseBody>(model1);
      }
    }
  }


  virtual ~SetUserProfilePathRulesResponse() = default;
};
class StartDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};

  StartDesktopsRequest() {}

  explicit StartDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartDesktopsRequest() = default;
};
class StartDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDesktopsResponseBody() {}

  explicit StartDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDesktopsResponseBody() = default;
};
class StartDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDesktopsResponseBody> body{};

  StartDesktopsResponse() {}

  explicit StartDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~StartDesktopsResponse() = default;
};
class StopDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<bool> osUpdate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stoppedMode{};

  StopDesktopsRequest() {}

  explicit StopDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (osUpdate) {
      res["OsUpdate"] = boost::any(*osUpdate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stoppedMode) {
      res["StoppedMode"] = boost::any(*stoppedMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OsUpdate") != m.end() && !m["OsUpdate"].empty()) {
      osUpdate = make_shared<bool>(boost::any_cast<bool>(m["OsUpdate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StoppedMode") != m.end() && !m["StoppedMode"].empty()) {
      stoppedMode = make_shared<string>(boost::any_cast<string>(m["StoppedMode"]));
    }
  }


  virtual ~StopDesktopsRequest() = default;
};
class StopDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDesktopsResponseBody() {}

  explicit StopDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDesktopsResponseBody() = default;
};
class StopDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDesktopsResponseBody> body{};

  StopDesktopsResponse() {}

  explicit StopDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~StopDesktopsResponse() = default;
};
class StopInvocationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> invokeId{};
  shared_ptr<string> regionId{};

  StopInvocationRequest() {}

  explicit StopInvocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (invokeId) {
      res["InvokeId"] = boost::any(*invokeId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvokeId") != m.end() && !m["InvokeId"].empty()) {
      invokeId = make_shared<string>(boost::any_cast<string>(m["InvokeId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopInvocationRequest() = default;
};
class StopInvocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopInvocationResponseBody() {}

  explicit StopInvocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInvocationResponseBody() = default;
};
class StopInvocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopInvocationResponseBody> body{};

  StopInvocationResponse() {}

  explicit StopInvocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInvocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInvocationResponseBody>(model1);
      }
    }
  }


  virtual ~StopInvocationResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnbindConfigGroupRequestResourceInfos : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceType{};

  UnbindConfigGroupRequestResourceInfos() {}

  explicit UnbindConfigGroupRequestResourceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UnbindConfigGroupRequestResourceInfos() = default;
};
class UnbindConfigGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<UnbindConfigGroupRequestResourceInfos>> resourceInfos{};
  shared_ptr<string> type{};

  UnbindConfigGroupRequest() {}

  explicit UnbindConfigGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInfos"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInfos") != m.end() && !m["ResourceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInfos"].type()) {
        vector<UnbindConfigGroupRequestResourceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnbindConfigGroupRequestResourceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInfos = make_shared<vector<UnbindConfigGroupRequestResourceInfos>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UnbindConfigGroupRequest() = default;
};
class UnbindConfigGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> requestId{};

  UnbindConfigGroupResponseBody() {}

  explicit UnbindConfigGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindConfigGroupResponseBody() = default;
};
class UnbindConfigGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindConfigGroupResponseBody> body{};

  UnbindConfigGroupResponse() {}

  explicit UnbindConfigGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindConfigGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindConfigGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindConfigGroupResponse() = default;
};
class UnbindUserDesktopRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopAgentIds{};
  shared_ptr<string> desktopGroupId{};
  shared_ptr<vector<string>> desktopIds{};
  shared_ptr<bool> force{};
  shared_ptr<string> reason{};
  shared_ptr<vector<string>> userDesktopIds{};

  UnbindUserDesktopRequest() {}

  explicit UnbindUserDesktopRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopAgentIds) {
      res["DesktopAgentIds"] = boost::any(*desktopAgentIds);
    }
    if (desktopGroupId) {
      res["DesktopGroupId"] = boost::any(*desktopGroupId);
    }
    if (desktopIds) {
      res["DesktopIds"] = boost::any(*desktopIds);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (userDesktopIds) {
      res["UserDesktopIds"] = boost::any(*userDesktopIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopAgentIds") != m.end() && !m["DesktopAgentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopAgentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopAgentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopAgentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DesktopGroupId") != m.end() && !m["DesktopGroupId"].empty()) {
      desktopGroupId = make_shared<string>(boost::any_cast<string>(m["DesktopGroupId"]));
    }
    if (m.find("DesktopIds") != m.end() && !m["DesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("UserDesktopIds") != m.end() && !m["UserDesktopIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserDesktopIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserDesktopIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userDesktopIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UnbindUserDesktopRequest() = default;
};
class UnbindUserDesktopResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindUserDesktopResponseBody() {}

  explicit UnbindUserDesktopResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindUserDesktopResponseBody() = default;
};
class UnbindUserDesktopResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindUserDesktopResponseBody> body{};

  UnbindUserDesktopResponse() {}

  explicit UnbindUserDesktopResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindUserDesktopResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindUserDesktopResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindUserDesktopResponse() = default;
};
class UnlockVirtualMFADeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumber{};

  UnlockVirtualMFADeviceRequest() {}

  explicit UnlockVirtualMFADeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~UnlockVirtualMFADeviceRequest() = default;
};
class UnlockVirtualMFADeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnlockVirtualMFADeviceResponseBody() {}

  explicit UnlockVirtualMFADeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnlockVirtualMFADeviceResponseBody() = default;
};
class UnlockVirtualMFADeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnlockVirtualMFADeviceResponseBody> body{};

  UnlockVirtualMFADeviceResponse() {}

  explicit UnlockVirtualMFADeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockVirtualMFADeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockVirtualMFADeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockVirtualMFADeviceResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateFotaTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskUid{};
  shared_ptr<string> userStatus{};

  UpdateFotaTaskRequest() {}

  explicit UpdateFotaTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskUid) {
      res["TaskUid"] = boost::any(*taskUid);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskUid") != m.end() && !m["TaskUid"].empty()) {
      taskUid = make_shared<string>(boost::any_cast<string>(m["TaskUid"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~UpdateFotaTaskRequest() = default;
};
class UpdateFotaTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFotaTaskResponseBody() {}

  explicit UpdateFotaTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFotaTaskResponseBody() = default;
};
class UpdateFotaTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFotaTaskResponseBody> body{};

  UpdateFotaTaskResponse() {}

  explicit UpdateFotaTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFotaTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFotaTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFotaTaskResponse() = default;
};
class UploadImageRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableSecurityCheck{};
  shared_ptr<bool> gpuCategory{};
  shared_ptr<string> gpuDriverType{};
  shared_ptr<string> imageName{};
  shared_ptr<string> licenseType{};
  shared_ptr<string> osType{};
  shared_ptr<string> ossObjectPath{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> systemDiskSize{};

  UploadImageRequest() {}

  explicit UploadImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableSecurityCheck) {
      res["EnableSecurityCheck"] = boost::any(*enableSecurityCheck);
    }
    if (gpuCategory) {
      res["GpuCategory"] = boost::any(*gpuCategory);
    }
    if (gpuDriverType) {
      res["GpuDriverType"] = boost::any(*gpuDriverType);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (licenseType) {
      res["LicenseType"] = boost::any(*licenseType);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (ossObjectPath) {
      res["OssObjectPath"] = boost::any(*ossObjectPath);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableSecurityCheck") != m.end() && !m["EnableSecurityCheck"].empty()) {
      enableSecurityCheck = make_shared<bool>(boost::any_cast<bool>(m["EnableSecurityCheck"]));
    }
    if (m.find("GpuCategory") != m.end() && !m["GpuCategory"].empty()) {
      gpuCategory = make_shared<bool>(boost::any_cast<bool>(m["GpuCategory"]));
    }
    if (m.find("GpuDriverType") != m.end() && !m["GpuDriverType"].empty()) {
      gpuDriverType = make_shared<string>(boost::any_cast<string>(m["GpuDriverType"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("LicenseType") != m.end() && !m["LicenseType"].empty()) {
      licenseType = make_shared<string>(boost::any_cast<string>(m["LicenseType"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("OssObjectPath") != m.end() && !m["OssObjectPath"].empty()) {
      ossObjectPath = make_shared<string>(boost::any_cast<string>(m["OssObjectPath"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<string>(boost::any_cast<string>(m["SystemDiskSize"]));
    }
  }


  virtual ~UploadImageRequest() = default;
};
class UploadImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  UploadImageResponseBody() {}

  explicit UploadImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadImageResponseBody() = default;
};
class UploadImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadImageResponseBody> body{};

  UploadImageResponse() {}

  explicit UploadImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadImageResponseBody>(model1);
      }
    }
  }


  virtual ~UploadImageResponse() = default;
};
class VerifyCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> regionId{};
  shared_ptr<string> verifyCode{};

  VerifyCenRequest() {}

  explicit VerifyCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
  }


  virtual ~VerifyCenRequest() = default;
};
class VerifyCenResponseBodyRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  VerifyCenResponseBodyRouteEntries() {}

  explicit VerifyCenResponseBodyRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopInstanceId) {
      res["NextHopInstanceId"] = boost::any(*nextHopInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopInstanceId") != m.end() && !m["NextHopInstanceId"].empty()) {
      nextHopInstanceId = make_shared<string>(boost::any_cast<string>(m["NextHopInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~VerifyCenResponseBodyRouteEntries() = default;
};
class VerifyCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cidrBlocks{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<VerifyCenResponseBodyRouteEntries>> routeEntries{};
  shared_ptr<string> status{};

  VerifyCenResponseBody() {}

  explicit VerifyCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlocks) {
      res["CidrBlocks"] = boost::any(*cidrBlocks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntries) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntries"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlocks") != m.end() && !m["CidrBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CidrBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CidrBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cidrBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntries") != m.end() && !m["RouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntries"].type()) {
        vector<VerifyCenResponseBodyRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VerifyCenResponseBodyRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntries = make_shared<vector<VerifyCenResponseBodyRouteEntries>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~VerifyCenResponseBody() = default;
};
class VerifyCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyCenResponseBody> body{};

  VerifyCenResponse() {}

  explicit VerifyCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyCenResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyCenResponse() = default;
};
class WakeupDesktopsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> desktopId{};
  shared_ptr<string> regionId{};

  WakeupDesktopsRequest() {}

  explicit WakeupDesktopsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desktopId) {
      res["DesktopId"] = boost::any(*desktopId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesktopId") != m.end() && !m["DesktopId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DesktopId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DesktopId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      desktopId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~WakeupDesktopsRequest() = default;
};
class WakeupDesktopsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  WakeupDesktopsResponseBody() {}

  explicit WakeupDesktopsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~WakeupDesktopsResponseBody() = default;
};
class WakeupDesktopsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WakeupDesktopsResponseBody> body{};

  WakeupDesktopsResponse() {}

  explicit WakeupDesktopsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WakeupDesktopsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WakeupDesktopsResponseBody>(model1);
      }
    }
  }


  virtual ~WakeupDesktopsResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateOfficeSiteResponse activateOfficeSiteWithOptions(shared_ptr<ActivateOfficeSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateOfficeSiteResponse activateOfficeSite(shared_ptr<ActivateOfficeSiteRequest> request);
  AddDesktopOversoldUserGroupResponse addDesktopOversoldUserGroupWithOptions(shared_ptr<AddDesktopOversoldUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDesktopOversoldUserGroupResponse addDesktopOversoldUserGroup(shared_ptr<AddDesktopOversoldUserGroupRequest> request);
  AddDevicesResponse addDevicesWithOptions(shared_ptr<AddDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDevicesResponse addDevices(shared_ptr<AddDevicesRequest> request);
  AddFilePermissionResponse addFilePermissionWithOptions(shared_ptr<AddFilePermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFilePermissionResponse addFilePermission(shared_ptr<AddFilePermissionRequest> request);
  AddUserToDesktopGroupResponse addUserToDesktopGroupWithOptions(shared_ptr<AddUserToDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUserToDesktopGroupResponse addUserToDesktopGroup(shared_ptr<AddUserToDesktopGroupRequest> request);
  AddUserToDesktopOversoldUserGroupResponse addUserToDesktopOversoldUserGroupWithOptions(shared_ptr<AddUserToDesktopOversoldUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUserToDesktopOversoldUserGroupResponse addUserToDesktopOversoldUserGroup(shared_ptr<AddUserToDesktopOversoldUserGroupRequest> request);
  ApplyAutoSnapshotPolicyResponse applyAutoSnapshotPolicyWithOptions(shared_ptr<ApplyAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAutoSnapshotPolicyResponse applyAutoSnapshotPolicy(shared_ptr<ApplyAutoSnapshotPolicyRequest> request);
  ApplyCoordinatePrivilegeResponse applyCoordinatePrivilegeWithOptions(shared_ptr<ApplyCoordinatePrivilegeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyCoordinatePrivilegeResponse applyCoordinatePrivilege(shared_ptr<ApplyCoordinatePrivilegeRequest> request);
  ApplyCoordinationForMonitoringResponse applyCoordinationForMonitoringWithOptions(shared_ptr<ApplyCoordinationForMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyCoordinationForMonitoringResponse applyCoordinationForMonitoring(shared_ptr<ApplyCoordinationForMonitoringRequest> request);
  ApproveFotaUpdateResponse approveFotaUpdateWithOptions(shared_ptr<ApproveFotaUpdateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApproveFotaUpdateResponse approveFotaUpdate(shared_ptr<ApproveFotaUpdateRequest> request);
  AssociateNetworkPackageResponse associateNetworkPackageWithOptions(shared_ptr<AssociateNetworkPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateNetworkPackageResponse associateNetworkPackage(shared_ptr<AssociateNetworkPackageRequest> request);
  AttachCenResponse attachCenWithOptions(shared_ptr<AttachCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachCenResponse attachCen(shared_ptr<AttachCenRequest> request);
  AttachEndUserResponse attachEndUserWithOptions(shared_ptr<AttachEndUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachEndUserResponse attachEndUser(shared_ptr<AttachEndUserRequest> request);
  BindConfigGroupResponse bindConfigGroupWithOptions(shared_ptr<BindConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindConfigGroupResponse bindConfigGroup(shared_ptr<BindConfigGroupRequest> request);
  CancelAutoSnapshotPolicyResponse cancelAutoSnapshotPolicyWithOptions(shared_ptr<CancelAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelAutoSnapshotPolicyResponse cancelAutoSnapshotPolicy(shared_ptr<CancelAutoSnapshotPolicyRequest> request);
  CancelCdsFileShareLinkResponse cancelCdsFileShareLinkWithOptions(shared_ptr<CancelCdsFileShareLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelCdsFileShareLinkResponse cancelCdsFileShareLink(shared_ptr<CancelCdsFileShareLinkRequest> request);
  CancelCoordinationForMonitoringResponse cancelCoordinationForMonitoringWithOptions(shared_ptr<CancelCoordinationForMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelCoordinationForMonitoringResponse cancelCoordinationForMonitoring(shared_ptr<CancelCoordinationForMonitoringRequest> request);
  CancelCopyImageResponse cancelCopyImageWithOptions(shared_ptr<CancelCopyImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelCopyImageResponse cancelCopyImage(shared_ptr<CancelCopyImageRequest> request);
  CloneCenterPolicyResponse cloneCenterPolicyWithOptions(shared_ptr<CloneCenterPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneCenterPolicyResponse cloneCenterPolicy(shared_ptr<CloneCenterPolicyRequest> request);
  ClonePolicyGroupResponse clonePolicyGroupWithOptions(shared_ptr<ClonePolicyGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClonePolicyGroupResponse clonePolicyGroup(shared_ptr<ClonePolicyGroupRequest> request);
  CompleteCdsFileResponse completeCdsFileWithOptions(shared_ptr<CompleteCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompleteCdsFileResponse completeCdsFile(shared_ptr<CompleteCdsFileRequest> request);
  ConfigADConnectorTrustResponse configADConnectorTrustWithOptions(shared_ptr<ConfigADConnectorTrustRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigADConnectorTrustResponse configADConnectorTrust(shared_ptr<ConfigADConnectorTrustRequest> request);
  ConfigADConnectorUserResponse configADConnectorUserWithOptions(shared_ptr<ConfigADConnectorUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigADConnectorUserResponse configADConnectorUser(shared_ptr<ConfigADConnectorUserRequest> request);
  CopyCdsFileResponse copyCdsFileWithOptions(shared_ptr<CopyCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCdsFileResponse copyCdsFile(shared_ptr<CopyCdsFileRequest> request);
  CopyImageResponse copyImageWithOptions(shared_ptr<CopyImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyImageResponse copyImage(shared_ptr<CopyImageRequest> request);
  CreateADConnectorDirectoryResponse createADConnectorDirectoryWithOptions(shared_ptr<CreateADConnectorDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateADConnectorDirectoryResponse createADConnectorDirectory(shared_ptr<CreateADConnectorDirectoryRequest> request);
  CreateADConnectorOfficeSiteResponse createADConnectorOfficeSiteWithOptions(shared_ptr<CreateADConnectorOfficeSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateADConnectorOfficeSiteResponse createADConnectorOfficeSite(shared_ptr<CreateADConnectorOfficeSiteRequest> request);
  CreateAndBindNasFileSystemResponse createAndBindNasFileSystemWithOptions(shared_ptr<CreateAndBindNasFileSystemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAndBindNasFileSystemResponse createAndBindNasFileSystem(shared_ptr<CreateAndBindNasFileSystemRequest> request);
  CreateAutoSnapshotPolicyResponse createAutoSnapshotPolicyWithOptions(shared_ptr<CreateAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAutoSnapshotPolicyResponse createAutoSnapshotPolicy(shared_ptr<CreateAutoSnapshotPolicyRequest> request);
  CreateBandwidthResourcePackagesResponse createBandwidthResourcePackagesWithOptions(shared_ptr<CreateBandwidthResourcePackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBandwidthResourcePackagesResponse createBandwidthResourcePackages(shared_ptr<CreateBandwidthResourcePackagesRequest> request);
  CreateBundleResponse createBundleWithOptions(shared_ptr<CreateBundleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBundleResponse createBundle(shared_ptr<CreateBundleRequest> request);
  CreateCdsFileResponse createCdsFileWithOptions(shared_ptr<CreateCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCdsFileResponse createCdsFile(shared_ptr<CreateCdsFileRequest> request);
  CreateCdsFileShareLinkResponse createCdsFileShareLinkWithOptions(shared_ptr<CreateCdsFileShareLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCdsFileShareLinkResponse createCdsFileShareLink(shared_ptr<CreateCdsFileShareLinkRequest> request);
  CreateCenterPolicyResponse createCenterPolicyWithOptions(shared_ptr<CreateCenterPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCenterPolicyResponse createCenterPolicy(shared_ptr<CreateCenterPolicyRequest> request);
  CreateCloudDriveServiceResponse createCloudDriveServiceWithOptions(shared_ptr<CreateCloudDriveServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudDriveServiceResponse createCloudDriveService(shared_ptr<CreateCloudDriveServiceRequest> request);
  CreateCloudDriveUsersResponse createCloudDriveUsersWithOptions(shared_ptr<CreateCloudDriveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudDriveUsersResponse createCloudDriveUsers(shared_ptr<CreateCloudDriveUsersRequest> request);
  CreateConfigGroupResponse createConfigGroupWithOptions(shared_ptr<CreateConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigGroupResponse createConfigGroup(shared_ptr<CreateConfigGroupRequest> request);
  CreateDesktopGroupResponse createDesktopGroupWithOptions(shared_ptr<CreateDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDesktopGroupResponse createDesktopGroup(shared_ptr<CreateDesktopGroupRequest> request);
  CreateDesktopOversoldGroupResponse createDesktopOversoldGroupWithOptions(shared_ptr<CreateDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDesktopOversoldGroupResponse createDesktopOversoldGroup(shared_ptr<CreateDesktopOversoldGroupRequest> request);
  CreateDesktopsResponse createDesktopsWithOptions(shared_ptr<CreateDesktopsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDesktopsResponse createDesktops(shared_ptr<CreateDesktopsRequest> request);
  CreateDiskEncryptionServiceResponse createDiskEncryptionServiceWithOptions(shared_ptr<CreateDiskEncryptionServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskEncryptionServiceResponse createDiskEncryptionService(shared_ptr<CreateDiskEncryptionServiceRequest> request);
  CreateImageResponse createImageWithOptions(shared_ptr<CreateImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageResponse createImage(shared_ptr<CreateImageRequest> request);
  CreateNASFileSystemResponse createNASFileSystemWithOptions(shared_ptr<CreateNASFileSystemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNASFileSystemResponse createNASFileSystem(shared_ptr<CreateNASFileSystemRequest> request);
  CreateNetworkPackageResponse createNetworkPackageWithOptions(shared_ptr<CreateNetworkPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkPackageResponse createNetworkPackage(shared_ptr<CreateNetworkPackageRequest> request);
  CreatePolicyGroupResponse createPolicyGroupWithOptions(shared_ptr<CreatePolicyGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePolicyGroupResponse createPolicyGroup(shared_ptr<CreatePolicyGroupRequest> request);
  CreateRAMDirectoryResponse createRAMDirectoryWithOptions(shared_ptr<CreateRAMDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRAMDirectoryResponse createRAMDirectory(shared_ptr<CreateRAMDirectoryRequest> request);
  CreateSimpleOfficeSiteResponse createSimpleOfficeSiteWithOptions(shared_ptr<CreateSimpleOfficeSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimpleOfficeSiteResponse createSimpleOfficeSite(shared_ptr<CreateSimpleOfficeSiteRequest> request);
  CreateSnapshotResponse createSnapshotWithOptions(shared_ptr<CreateSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnapshotResponse createSnapshot(shared_ptr<CreateSnapshotRequest> request);
  DeleteAutoSnapshotPolicyResponse deleteAutoSnapshotPolicyWithOptions(shared_ptr<DeleteAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAutoSnapshotPolicyResponse deleteAutoSnapshotPolicy(shared_ptr<DeleteAutoSnapshotPolicyRequest> request);
  DeleteBundlesResponse deleteBundlesWithOptions(shared_ptr<DeleteBundlesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBundlesResponse deleteBundles(shared_ptr<DeleteBundlesRequest> request);
  DeleteCdsFileResponse deleteCdsFileWithOptions(shared_ptr<DeleteCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCdsFileResponse deleteCdsFile(shared_ptr<DeleteCdsFileRequest> request);
  DeleteCenterPolicyResponse deleteCenterPolicyWithOptions(shared_ptr<DeleteCenterPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCenterPolicyResponse deleteCenterPolicy(shared_ptr<DeleteCenterPolicyRequest> request);
  DeleteCloudDriveGroupsResponse deleteCloudDriveGroupsWithOptions(shared_ptr<DeleteCloudDriveGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudDriveGroupsResponse deleteCloudDriveGroups(shared_ptr<DeleteCloudDriveGroupsRequest> request);
  DeleteCloudDriveUsersResponse deleteCloudDriveUsersWithOptions(shared_ptr<DeleteCloudDriveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudDriveUsersResponse deleteCloudDriveUsers(shared_ptr<DeleteCloudDriveUsersRequest> request);
  DeleteConfigGroupResponse deleteConfigGroupWithOptions(shared_ptr<DeleteConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigGroupResponse deleteConfigGroup(shared_ptr<DeleteConfigGroupRequest> request);
  DeleteDesktopGroupResponse deleteDesktopGroupWithOptions(shared_ptr<DeleteDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDesktopGroupResponse deleteDesktopGroup(shared_ptr<DeleteDesktopGroupRequest> request);
  DeleteDesktopsResponse deleteDesktopsWithOptions(shared_ptr<DeleteDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDesktopsResponse deleteDesktops(shared_ptr<DeleteDesktopsRequest> request);
  DeleteDevicesResponse deleteDevicesWithOptions(shared_ptr<DeleteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicesResponse deleteDevices(shared_ptr<DeleteDevicesRequest> request);
  DeleteDirectoriesResponse deleteDirectoriesWithOptions(shared_ptr<DeleteDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDirectoriesResponse deleteDirectories(shared_ptr<DeleteDirectoriesRequest> request);
  DeleteEduRoomResponse deleteEduRoomWithOptions(shared_ptr<DeleteEduRoomRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEduRoomResponse deleteEduRoom(shared_ptr<DeleteEduRoomRequest> request);
  DeleteImagesResponse deleteImagesWithOptions(shared_ptr<DeleteImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImagesResponse deleteImages(shared_ptr<DeleteImagesRequest> request);
  DeleteNASFileSystemsResponse deleteNASFileSystemsWithOptions(shared_ptr<DeleteNASFileSystemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNASFileSystemsResponse deleteNASFileSystems(shared_ptr<DeleteNASFileSystemsRequest> request);
  DeleteNetworkPackagesResponse deleteNetworkPackagesWithOptions(shared_ptr<DeleteNetworkPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkPackagesResponse deleteNetworkPackages(shared_ptr<DeleteNetworkPackagesRequest> request);
  DeleteOfficeSitesResponse deleteOfficeSitesWithOptions(shared_ptr<DeleteOfficeSitesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOfficeSitesResponse deleteOfficeSites(shared_ptr<DeleteOfficeSitesRequest> request);
  DeletePolicyGroupsResponse deletePolicyGroupsWithOptions(shared_ptr<DeletePolicyGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePolicyGroupsResponse deletePolicyGroups(shared_ptr<DeletePolicyGroupsRequest> request);
  DeleteSnapshotResponse deleteSnapshotWithOptions(shared_ptr<DeleteSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotResponse deleteSnapshot(shared_ptr<DeleteSnapshotRequest> request);
  DeleteVirtualMFADeviceResponse deleteVirtualMFADeviceWithOptions(shared_ptr<DeleteVirtualMFADeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVirtualMFADeviceResponse deleteVirtualMFADevice(shared_ptr<DeleteVirtualMFADeviceRequest> request);
  DescribeAclEntriesResponse describeAclEntriesWithOptions(shared_ptr<DescribeAclEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAclEntriesResponse describeAclEntries(shared_ptr<DescribeAclEntriesRequest> request);
  DescribeAutoSnapshotPolicyResponse describeAutoSnapshotPolicyWithOptions(shared_ptr<DescribeAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoSnapshotPolicyResponse describeAutoSnapshotPolicy(shared_ptr<DescribeAutoSnapshotPolicyRequest> request);
  DescribeBundlesResponse describeBundlesWithOptions(shared_ptr<DescribeBundlesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBundlesResponse describeBundles(shared_ptr<DescribeBundlesRequest> request);
  DescribeCdsFileShareLinksResponse describeCdsFileShareLinksWithOptions(shared_ptr<DescribeCdsFileShareLinksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdsFileShareLinksResponse describeCdsFileShareLinks(shared_ptr<DescribeCdsFileShareLinksRequest> request);
  DescribeCensResponse describeCensWithOptions(shared_ptr<DescribeCensRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCensResponse describeCens(shared_ptr<DescribeCensRequest> request);
  DescribeCenterPolicyListResponse describeCenterPolicyListWithOptions(shared_ptr<DescribeCenterPolicyListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCenterPolicyListResponse describeCenterPolicyList(shared_ptr<DescribeCenterPolicyListRequest> request);
  DescribeClientEventsResponse describeClientEventsWithOptions(shared_ptr<DescribeClientEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClientEventsResponse describeClientEvents(shared_ptr<DescribeClientEventsRequest> request);
  DescribeCloudDriveGroupsResponse describeCloudDriveGroupsWithOptions(shared_ptr<DescribeCloudDriveGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDriveGroupsResponse describeCloudDriveGroups(shared_ptr<DescribeCloudDriveGroupsRequest> request);
  DescribeCloudDrivePermissionsResponse describeCloudDrivePermissionsWithOptions(shared_ptr<DescribeCloudDrivePermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDrivePermissionsResponse describeCloudDrivePermissions(shared_ptr<DescribeCloudDrivePermissionsRequest> request);
  DescribeCloudDriveUsersResponse describeCloudDriveUsersWithOptions(shared_ptr<DescribeCloudDriveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDriveUsersResponse describeCloudDriveUsers(shared_ptr<DescribeCloudDriveUsersRequest> request);
  DescribeConfigGroupResponse describeConfigGroupWithOptions(shared_ptr<DescribeConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConfigGroupResponse describeConfigGroup(shared_ptr<DescribeConfigGroupRequest> request);
  DescribeCustomizedListHeadersResponse describeCustomizedListHeadersWithOptions(shared_ptr<DescribeCustomizedListHeadersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomizedListHeadersResponse describeCustomizedListHeaders(shared_ptr<DescribeCustomizedListHeadersRequest> request);
  DescribeDesktopGroupSessionsResponse describeDesktopGroupSessionsWithOptions(shared_ptr<DescribeDesktopGroupSessionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopGroupSessionsResponse describeDesktopGroupSessions(shared_ptr<DescribeDesktopGroupSessionsRequest> request);
  DescribeDesktopGroupsResponse describeDesktopGroupsWithOptions(shared_ptr<DescribeDesktopGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopGroupsResponse describeDesktopGroups(shared_ptr<DescribeDesktopGroupsRequest> request);
  DescribeDesktopInfoResponse describeDesktopInfoWithOptions(shared_ptr<DescribeDesktopInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopInfoResponse describeDesktopInfo(shared_ptr<DescribeDesktopInfoRequest> request);
  DescribeDesktopOversoldGroupResponse describeDesktopOversoldGroupWithOptions(shared_ptr<DescribeDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopOversoldGroupResponse describeDesktopOversoldGroup(shared_ptr<DescribeDesktopOversoldGroupRequest> request);
  DescribeDesktopOversoldUserResponse describeDesktopOversoldUserWithOptions(shared_ptr<DescribeDesktopOversoldUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopOversoldUserResponse describeDesktopOversoldUser(shared_ptr<DescribeDesktopOversoldUserRequest> request);
  DescribeDesktopOversoldUserGroupResponse describeDesktopOversoldUserGroupWithOptions(shared_ptr<DescribeDesktopOversoldUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopOversoldUserGroupResponse describeDesktopOversoldUserGroup(shared_ptr<DescribeDesktopOversoldUserGroupRequest> request);
  DescribeDesktopSessionsResponse describeDesktopSessionsWithOptions(shared_ptr<DescribeDesktopSessionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopSessionsResponse describeDesktopSessions(shared_ptr<DescribeDesktopSessionsRequest> request);
  DescribeDesktopTypesResponse describeDesktopTypesWithOptions(shared_ptr<DescribeDesktopTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopTypesResponse describeDesktopTypes(shared_ptr<DescribeDesktopTypesRequest> request);
  DescribeDesktopsResponse describeDesktopsWithOptions(shared_ptr<DescribeDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopsResponse describeDesktops(shared_ptr<DescribeDesktopsRequest> request);
  DescribeDesktopsInGroupResponse describeDesktopsInGroupWithOptions(shared_ptr<DescribeDesktopsInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDesktopsInGroupResponse describeDesktopsInGroup(shared_ptr<DescribeDesktopsInGroupRequest> request);
  DescribeDevicesResponse describeDevicesWithOptions(shared_ptr<DescribeDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDevicesResponse describeDevices(shared_ptr<DescribeDevicesRequest> request);
  DescribeDirectoriesResponse describeDirectoriesWithOptions(shared_ptr<DescribeDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDirectoriesResponse describeDirectories(shared_ptr<DescribeDirectoriesRequest> request);
  DescribeFlowMetricResponse describeFlowMetricWithOptions(shared_ptr<DescribeFlowMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowMetricResponse describeFlowMetric(shared_ptr<DescribeFlowMetricRequest> request);
  DescribeFlowStatisticResponse describeFlowStatisticWithOptions(shared_ptr<DescribeFlowStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowStatisticResponse describeFlowStatistic(shared_ptr<DescribeFlowStatisticRequest> request);
  DescribeFotaPendingDesktopsResponse describeFotaPendingDesktopsWithOptions(shared_ptr<DescribeFotaPendingDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFotaPendingDesktopsResponse describeFotaPendingDesktops(shared_ptr<DescribeFotaPendingDesktopsRequest> request);
  DescribeFotaTasksResponse describeFotaTasksWithOptions(shared_ptr<DescribeFotaTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFotaTasksResponse describeFotaTasks(shared_ptr<DescribeFotaTasksRequest> request);
  DescribeGuestApplicationsResponse describeGuestApplicationsWithOptions(shared_ptr<DescribeGuestApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGuestApplicationsResponse describeGuestApplications(shared_ptr<DescribeGuestApplicationsRequest> request);
  DescribeImageModifiedRecordsResponse describeImageModifiedRecordsWithOptions(shared_ptr<DescribeImageModifiedRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageModifiedRecordsResponse describeImageModifiedRecords(shared_ptr<DescribeImageModifiedRecordsRequest> request);
  DescribeImagePermissionResponse describeImagePermissionWithOptions(shared_ptr<DescribeImagePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagePermissionResponse describeImagePermission(shared_ptr<DescribeImagePermissionRequest> request);
  DescribeImagesResponse describeImagesWithOptions(shared_ptr<DescribeImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagesResponse describeImages(shared_ptr<DescribeImagesRequest> request);
  DescribeInvocationsResponse describeInvocationsWithOptions(shared_ptr<DescribeInvocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInvocationsResponse describeInvocations(shared_ptr<DescribeInvocationsRequest> request);
  DescribeKmsKeysResponse describeKmsKeysWithOptions(shared_ptr<DescribeKmsKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKmsKeysResponse describeKmsKeys(shared_ptr<DescribeKmsKeysRequest> request);
  DescribeModificationPriceResponse describeModificationPriceWithOptions(shared_ptr<DescribeModificationPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModificationPriceResponse describeModificationPrice(shared_ptr<DescribeModificationPriceRequest> request);
  DescribeNASFileSystemsResponse describeNASFileSystemsWithOptions(shared_ptr<DescribeNASFileSystemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNASFileSystemsResponse describeNASFileSystems(shared_ptr<DescribeNASFileSystemsRequest> request);
  DescribeNetworkPackagesResponse describeNetworkPackagesWithOptions(shared_ptr<DescribeNetworkPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkPackagesResponse describeNetworkPackages(shared_ptr<DescribeNetworkPackagesRequest> request);
  DescribeOfficeSitesResponse describeOfficeSitesWithOptions(shared_ptr<DescribeOfficeSitesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOfficeSitesResponse describeOfficeSites(shared_ptr<DescribeOfficeSitesRequest> request);
  DescribePolicyGroupsResponse describePolicyGroupsWithOptions(shared_ptr<DescribePolicyGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePolicyGroupsResponse describePolicyGroups(shared_ptr<DescribePolicyGroupsRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribePriceForCreateDesktopOversoldGroupResponse describePriceForCreateDesktopOversoldGroupWithOptions(shared_ptr<DescribePriceForCreateDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceForCreateDesktopOversoldGroupResponse describePriceForCreateDesktopOversoldGroup(shared_ptr<DescribePriceForCreateDesktopOversoldGroupRequest> request);
  DescribePriceForModifyDesktopOversoldGroupSaleResponse describePriceForModifyDesktopOversoldGroupSaleWithOptions(shared_ptr<DescribePriceForModifyDesktopOversoldGroupSaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceForModifyDesktopOversoldGroupSaleResponse describePriceForModifyDesktopOversoldGroupSale(shared_ptr<DescribePriceForModifyDesktopOversoldGroupSaleRequest> request);
  DescribePriceForRenewDesktopOversoldGroupResponse describePriceForRenewDesktopOversoldGroupWithOptions(shared_ptr<DescribePriceForRenewDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceForRenewDesktopOversoldGroupResponse describePriceForRenewDesktopOversoldGroup(shared_ptr<DescribePriceForRenewDesktopOversoldGroupRequest> request);
  DescribeRecordingsResponse describeRecordingsWithOptions(shared_ptr<DescribeRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordingsResponse describeRecordings(shared_ptr<DescribeRecordingsRequest> request);
  DescribeRefundPriceResponse describeRefundPriceWithOptions(shared_ptr<DescribeRefundPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRefundPriceResponse describeRefundPrice(shared_ptr<DescribeRefundPriceRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRenewalPriceResponse describeRenewalPriceWithOptions(shared_ptr<DescribeRenewalPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenewalPriceResponse describeRenewalPrice(shared_ptr<DescribeRenewalPriceRequest> request);
  DescribeResourceByCenterPolicyIdResponse describeResourceByCenterPolicyIdWithOptions(shared_ptr<DescribeResourceByCenterPolicyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceByCenterPolicyIdResponse describeResourceByCenterPolicyId(shared_ptr<DescribeResourceByCenterPolicyIdRequest> request);
  DescribeSessionStatisticResponse describeSessionStatisticWithOptions(shared_ptr<DescribeSessionStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSessionStatisticResponse describeSessionStatistic(shared_ptr<DescribeSessionStatisticRequest> request);
  DescribeSnapshotsResponse describeSnapshotsWithOptions(shared_ptr<DescribeSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsResponse describeSnapshots(shared_ptr<DescribeSnapshotsRequest> request);
  DescribeTimerGroupResponse describeTimerGroupWithOptions(shared_ptr<DescribeTimerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTimerGroupResponse describeTimerGroup(shared_ptr<DescribeTimerGroupRequest> request);
  DescribeUserConnectTimeResponse describeUserConnectTimeWithOptions(shared_ptr<DescribeUserConnectTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserConnectTimeResponse describeUserConnectTime(shared_ptr<DescribeUserConnectTimeRequest> request);
  DescribeUserConnectionRecordsResponse describeUserConnectionRecordsWithOptions(shared_ptr<DescribeUserConnectionRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserConnectionRecordsResponse describeUserConnectionRecords(shared_ptr<DescribeUserConnectionRecordsRequest> request);
  DescribeUserProfilePathRulesResponse describeUserProfilePathRulesWithOptions(shared_ptr<DescribeUserProfilePathRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserProfilePathRulesResponse describeUserProfilePathRules(shared_ptr<DescribeUserProfilePathRulesRequest> request);
  DescribeUsersInGroupResponse describeUsersInGroupWithOptions(shared_ptr<DescribeUsersInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUsersInGroupResponse describeUsersInGroup(shared_ptr<DescribeUsersInGroupRequest> request);
  DescribeUsersPasswordResponse describeUsersPasswordWithOptions(shared_ptr<DescribeUsersPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUsersPasswordResponse describeUsersPassword(shared_ptr<DescribeUsersPasswordRequest> request);
  DescribeVirtualMFADevicesResponse describeVirtualMFADevicesWithOptions(shared_ptr<DescribeVirtualMFADevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVirtualMFADevicesResponse describeVirtualMFADevices(shared_ptr<DescribeVirtualMFADevicesRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  DetachCenResponse detachCenWithOptions(shared_ptr<DetachCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachCenResponse detachCen(shared_ptr<DetachCenRequest> request);
  DetachEndUserResponse detachEndUserWithOptions(shared_ptr<DetachEndUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachEndUserResponse detachEndUser(shared_ptr<DetachEndUserRequest> request);
  DisableDesktopsInGroupResponse disableDesktopsInGroupWithOptions(shared_ptr<DisableDesktopsInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDesktopsInGroupResponse disableDesktopsInGroup(shared_ptr<DisableDesktopsInGroupRequest> request);
  DisconnectDesktopSessionsResponse disconnectDesktopSessionsWithOptions(shared_ptr<DisconnectDesktopSessionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisconnectDesktopSessionsResponse disconnectDesktopSessions(shared_ptr<DisconnectDesktopSessionsRequest> request);
  DissociateNetworkPackageResponse dissociateNetworkPackageWithOptions(shared_ptr<DissociateNetworkPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateNetworkPackageResponse dissociateNetworkPackage(shared_ptr<DissociateNetworkPackageRequest> request);
  DownloadCdsFileResponse downloadCdsFileWithOptions(shared_ptr<DownloadCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadCdsFileResponse downloadCdsFile(shared_ptr<DownloadCdsFileRequest> request);
  ExportClientEventsResponse exportClientEventsWithOptions(shared_ptr<ExportClientEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportClientEventsResponse exportClientEvents(shared_ptr<ExportClientEventsRequest> request);
  ExportDesktopGroupInfoResponse exportDesktopGroupInfoWithOptions(shared_ptr<ExportDesktopGroupInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDesktopGroupInfoResponse exportDesktopGroupInfo(shared_ptr<ExportDesktopGroupInfoRequest> request);
  ExportDesktopListInfoResponse exportDesktopListInfoWithOptions(shared_ptr<ExportDesktopListInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDesktopListInfoResponse exportDesktopListInfo(shared_ptr<ExportDesktopListInfoRequest> request);
  GetAsyncTaskResponse getAsyncTaskWithOptions(shared_ptr<GetAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAsyncTaskResponse getAsyncTask(shared_ptr<GetAsyncTaskRequest> request);
  GetConnectionTicketResponse getConnectionTicketWithOptions(shared_ptr<GetConnectionTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConnectionTicketResponse getConnectionTicket(shared_ptr<GetConnectionTicketRequest> request);
  GetCoordinateTicketResponse getCoordinateTicketWithOptions(shared_ptr<GetCoordinateTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCoordinateTicketResponse getCoordinateTicket(shared_ptr<GetCoordinateTicketRequest> request);
  GetDesktopGroupDetailResponse getDesktopGroupDetailWithOptions(shared_ptr<GetDesktopGroupDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDesktopGroupDetailResponse getDesktopGroupDetail(shared_ptr<GetDesktopGroupDetailRequest> request);
  GetOfficeSiteSsoStatusResponse getOfficeSiteSsoStatusWithOptions(shared_ptr<GetOfficeSiteSsoStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOfficeSiteSsoStatusResponse getOfficeSiteSsoStatus(shared_ptr<GetOfficeSiteSsoStatusRequest> request);
  GetSpMetadataResponse getSpMetadataWithOptions(shared_ptr<GetSpMetadataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpMetadataResponse getSpMetadata(shared_ptr<GetSpMetadataRequest> request);
  HibernateDesktopsResponse hibernateDesktopsWithOptions(shared_ptr<HibernateDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HibernateDesktopsResponse hibernateDesktops(shared_ptr<HibernateDesktopsRequest> request);
  ListCdsFilesResponse listCdsFilesWithOptions(shared_ptr<ListCdsFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCdsFilesResponse listCdsFiles(shared_ptr<ListCdsFilesRequest> request);
  ListDirectoryUsersResponse listDirectoryUsersWithOptions(shared_ptr<ListDirectoryUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDirectoryUsersResponse listDirectoryUsers(shared_ptr<ListDirectoryUsersRequest> request);
  ListFilePermissionResponse listFilePermissionWithOptions(shared_ptr<ListFilePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilePermissionResponse listFilePermission(shared_ptr<ListFilePermissionRequest> request);
  ListOfficeSiteOverviewResponse listOfficeSiteOverviewWithOptions(shared_ptr<ListOfficeSiteOverviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOfficeSiteOverviewResponse listOfficeSiteOverview(shared_ptr<ListOfficeSiteOverviewRequest> request);
  ListOfficeSiteUsersResponse listOfficeSiteUsersWithOptions(shared_ptr<ListOfficeSiteUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOfficeSiteUsersResponse listOfficeSiteUsers(shared_ptr<ListOfficeSiteUsersRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserAdOrganizationUnitsResponse listUserAdOrganizationUnitsWithOptions(shared_ptr<ListUserAdOrganizationUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserAdOrganizationUnitsResponse listUserAdOrganizationUnits(shared_ptr<ListUserAdOrganizationUnitsRequest> request);
  LockVirtualMFADeviceResponse lockVirtualMFADeviceWithOptions(shared_ptr<LockVirtualMFADeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LockVirtualMFADeviceResponse lockVirtualMFADevice(shared_ptr<LockVirtualMFADeviceRequest> request);
  MigrateDesktopsResponse migrateDesktopsWithOptions(shared_ptr<MigrateDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateDesktopsResponse migrateDesktops(shared_ptr<MigrateDesktopsRequest> request);
  MigrateImageProtocolResponse migrateImageProtocolWithOptions(shared_ptr<MigrateImageProtocolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateImageProtocolResponse migrateImageProtocol(shared_ptr<MigrateImageProtocolRequest> request);
  ModifyADConnectorDirectoryResponse modifyADConnectorDirectoryWithOptions(shared_ptr<ModifyADConnectorDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyADConnectorDirectoryResponse modifyADConnectorDirectory(shared_ptr<ModifyADConnectorDirectoryRequest> request);
  ModifyADConnectorOfficeSiteResponse modifyADConnectorOfficeSiteWithOptions(shared_ptr<ModifyADConnectorOfficeSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyADConnectorOfficeSiteResponse modifyADConnectorOfficeSite(shared_ptr<ModifyADConnectorOfficeSiteRequest> request);
  ModifyAclEntriesResponse modifyAclEntriesWithOptions(shared_ptr<ModifyAclEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAclEntriesResponse modifyAclEntries(shared_ptr<ModifyAclEntriesRequest> request);
  ModifyAutoSnapshotPolicyResponse modifyAutoSnapshotPolicyWithOptions(shared_ptr<ModifyAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoSnapshotPolicyResponse modifyAutoSnapshotPolicy(shared_ptr<ModifyAutoSnapshotPolicyRequest> request);
  ModifyBundleResponse modifyBundleWithOptions(shared_ptr<ModifyBundleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBundleResponse modifyBundle(shared_ptr<ModifyBundleRequest> request);
  ModifyCdsFileResponse modifyCdsFileWithOptions(shared_ptr<ModifyCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCdsFileResponse modifyCdsFile(shared_ptr<ModifyCdsFileRequest> request);
  ModifyCdsFileShareLinkResponse modifyCdsFileShareLinkWithOptions(shared_ptr<ModifyCdsFileShareLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCdsFileShareLinkResponse modifyCdsFileShareLink(shared_ptr<ModifyCdsFileShareLinkRequest> request);
  ModifyCenterPolicyResponse modifyCenterPolicyWithOptions(shared_ptr<ModifyCenterPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCenterPolicyResponse modifyCenterPolicy(shared_ptr<ModifyCenterPolicyRequest> request);
  ModifyCloudDriveGroupsResponse modifyCloudDriveGroupsWithOptions(shared_ptr<ModifyCloudDriveGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCloudDriveGroupsResponse modifyCloudDriveGroups(shared_ptr<ModifyCloudDriveGroupsRequest> request);
  ModifyCloudDrivePermissionResponse modifyCloudDrivePermissionWithOptions(shared_ptr<ModifyCloudDrivePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCloudDrivePermissionResponse modifyCloudDrivePermission(shared_ptr<ModifyCloudDrivePermissionRequest> request);
  ModifyCloudDriveUsersResponse modifyCloudDriveUsersWithOptions(shared_ptr<ModifyCloudDriveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCloudDriveUsersResponse modifyCloudDriveUsers(shared_ptr<ModifyCloudDriveUsersRequest> request);
  ModifyConfigGroupResponse modifyConfigGroupWithOptions(shared_ptr<ModifyConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyConfigGroupResponse modifyConfigGroup(shared_ptr<ModifyConfigGroupRequest> request);
  ModifyCustomizedListHeadersResponse modifyCustomizedListHeadersWithOptions(shared_ptr<ModifyCustomizedListHeadersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustomizedListHeadersResponse modifyCustomizedListHeaders(shared_ptr<ModifyCustomizedListHeadersRequest> request);
  ModifyDesktopChargeTypeResponse modifyDesktopChargeTypeWithOptions(shared_ptr<ModifyDesktopChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopChargeTypeResponse modifyDesktopChargeType(shared_ptr<ModifyDesktopChargeTypeRequest> request);
  ModifyDesktopGroupResponse modifyDesktopGroupWithOptions(shared_ptr<ModifyDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopGroupResponse modifyDesktopGroup(shared_ptr<ModifyDesktopGroupRequest> request);
  ModifyDesktopHostNameResponse modifyDesktopHostNameWithOptions(shared_ptr<ModifyDesktopHostNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopHostNameResponse modifyDesktopHostName(shared_ptr<ModifyDesktopHostNameRequest> request);
  ModifyDesktopNameResponse modifyDesktopNameWithOptions(shared_ptr<ModifyDesktopNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopNameResponse modifyDesktopName(shared_ptr<ModifyDesktopNameRequest> request);
  ModifyDesktopOversoldGroupResponse modifyDesktopOversoldGroupWithOptions(shared_ptr<ModifyDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopOversoldGroupResponse modifyDesktopOversoldGroup(shared_ptr<ModifyDesktopOversoldGroupRequest> request);
  ModifyDesktopOversoldGroupSaleResponse modifyDesktopOversoldGroupSaleWithOptions(shared_ptr<ModifyDesktopOversoldGroupSaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopOversoldGroupSaleResponse modifyDesktopOversoldGroupSale(shared_ptr<ModifyDesktopOversoldGroupSaleRequest> request);
  ModifyDesktopOversoldUserGroupResponse modifyDesktopOversoldUserGroupWithOptions(shared_ptr<ModifyDesktopOversoldUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopOversoldUserGroupResponse modifyDesktopOversoldUserGroup(shared_ptr<ModifyDesktopOversoldUserGroupRequest> request);
  ModifyDesktopSpecResponse modifyDesktopSpecWithOptions(shared_ptr<ModifyDesktopSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopSpecResponse modifyDesktopSpec(shared_ptr<ModifyDesktopSpecRequest> request);
  ModifyDesktopTimerResponse modifyDesktopTimerWithOptions(shared_ptr<ModifyDesktopTimerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopTimerResponse modifyDesktopTimer(shared_ptr<ModifyDesktopTimerRequest> request);
  ModifyDesktopsPolicyGroupResponse modifyDesktopsPolicyGroupWithOptions(shared_ptr<ModifyDesktopsPolicyGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesktopsPolicyGroupResponse modifyDesktopsPolicyGroup(shared_ptr<ModifyDesktopsPolicyGroupRequest> request);
  ModifyDiskSpecResponse modifyDiskSpecWithOptions(shared_ptr<ModifyDiskSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiskSpecResponse modifyDiskSpec(shared_ptr<ModifyDiskSpecRequest> request);
  ModifyEntitlementResponse modifyEntitlementWithOptions(shared_ptr<ModifyEntitlementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEntitlementResponse modifyEntitlement(shared_ptr<ModifyEntitlementRequest> request);
  ModifyImageAttributeResponse modifyImageAttributeWithOptions(shared_ptr<ModifyImageAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageAttributeResponse modifyImageAttribute(shared_ptr<ModifyImageAttributeRequest> request);
  ModifyImagePermissionResponse modifyImagePermissionWithOptions(shared_ptr<ModifyImagePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImagePermissionResponse modifyImagePermission(shared_ptr<ModifyImagePermissionRequest> request);
  ModifyNASDefaultMountTargetResponse modifyNASDefaultMountTargetWithOptions(shared_ptr<ModifyNASDefaultMountTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNASDefaultMountTargetResponse modifyNASDefaultMountTarget(shared_ptr<ModifyNASDefaultMountTargetRequest> request);
  ModifyNetworkPackageBandwidthResponse modifyNetworkPackageBandwidthWithOptions(shared_ptr<ModifyNetworkPackageBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkPackageBandwidthResponse modifyNetworkPackageBandwidth(shared_ptr<ModifyNetworkPackageBandwidthRequest> request);
  ModifyNetworkPackageEnabledResponse modifyNetworkPackageEnabledWithOptions(shared_ptr<ModifyNetworkPackageEnabledRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkPackageEnabledResponse modifyNetworkPackageEnabled(shared_ptr<ModifyNetworkPackageEnabledRequest> request);
  ModifyOfficeSiteAttributeResponse modifyOfficeSiteAttributeWithOptions(shared_ptr<ModifyOfficeSiteAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOfficeSiteAttributeResponse modifyOfficeSiteAttribute(shared_ptr<ModifyOfficeSiteAttributeRequest> request);
  ModifyOfficeSiteCrossDesktopAccessResponse modifyOfficeSiteCrossDesktopAccessWithOptions(shared_ptr<ModifyOfficeSiteCrossDesktopAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOfficeSiteCrossDesktopAccessResponse modifyOfficeSiteCrossDesktopAccess(shared_ptr<ModifyOfficeSiteCrossDesktopAccessRequest> request);
  ModifyOfficeSiteDnsInfoResponse modifyOfficeSiteDnsInfoWithOptions(shared_ptr<ModifyOfficeSiteDnsInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOfficeSiteDnsInfoResponse modifyOfficeSiteDnsInfo(shared_ptr<ModifyOfficeSiteDnsInfoRequest> request);
  ModifyOfficeSiteMfaEnabledResponse modifyOfficeSiteMfaEnabledWithOptions(shared_ptr<ModifyOfficeSiteMfaEnabledRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOfficeSiteMfaEnabledResponse modifyOfficeSiteMfaEnabled(shared_ptr<ModifyOfficeSiteMfaEnabledRequest> request);
  ModifyPolicyGroupResponse modifyPolicyGroupWithOptions(shared_ptr<ModifyPolicyGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPolicyGroupResponse modifyPolicyGroup(shared_ptr<ModifyPolicyGroupRequest> request);
  ModifyResourceCenterPolicyResponse modifyResourceCenterPolicyWithOptions(shared_ptr<ModifyResourceCenterPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceCenterPolicyResponse modifyResourceCenterPolicy(shared_ptr<ModifyResourceCenterPolicyRequest> request);
  ModifyTimerGroupResponse modifyTimerGroupWithOptions(shared_ptr<ModifyTimerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTimerGroupResponse modifyTimerGroup(shared_ptr<ModifyTimerGroupRequest> request);
  ModifyUserEntitlementResponse modifyUserEntitlementWithOptions(shared_ptr<ModifyUserEntitlementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserEntitlementResponse modifyUserEntitlement(shared_ptr<ModifyUserEntitlementRequest> request);
  ModifyUserToDesktopGroupResponse modifyUserToDesktopGroupWithOptions(shared_ptr<ModifyUserToDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserToDesktopGroupResponse modifyUserToDesktopGroup(shared_ptr<ModifyUserToDesktopGroupRequest> request);
  MoveCdsFileResponse moveCdsFileWithOptions(shared_ptr<MoveCdsFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveCdsFileResponse moveCdsFile(shared_ptr<MoveCdsFileRequest> request);
  RebootDesktopsResponse rebootDesktopsWithOptions(shared_ptr<RebootDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootDesktopsResponse rebootDesktops(shared_ptr<RebootDesktopsRequest> request);
  RebuildDesktopsResponse rebuildDesktopsWithOptions(shared_ptr<RebuildDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebuildDesktopsResponse rebuildDesktops(shared_ptr<RebuildDesktopsRequest> request);
  RemoveFilePermissionResponse removeFilePermissionWithOptions(shared_ptr<RemoveFilePermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveFilePermissionResponse removeFilePermission(shared_ptr<RemoveFilePermissionRequest> request);
  RemoveUserFromDesktopGroupResponse removeUserFromDesktopGroupWithOptions(shared_ptr<RemoveUserFromDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUserFromDesktopGroupResponse removeUserFromDesktopGroup(shared_ptr<RemoveUserFromDesktopGroupRequest> request);
  RemoveUserFromDesktopOversoldUserGroupResponse removeUserFromDesktopOversoldUserGroupWithOptions(shared_ptr<RemoveUserFromDesktopOversoldUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUserFromDesktopOversoldUserGroupResponse removeUserFromDesktopOversoldUserGroup(shared_ptr<RemoveUserFromDesktopOversoldUserGroupRequest> request);
  RenewDesktopGroupResponse renewDesktopGroupWithOptions(shared_ptr<RenewDesktopGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewDesktopGroupResponse renewDesktopGroup(shared_ptr<RenewDesktopGroupRequest> request);
  RenewDesktopOversoldGroupResponse renewDesktopOversoldGroupWithOptions(shared_ptr<RenewDesktopOversoldGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewDesktopOversoldGroupResponse renewDesktopOversoldGroup(shared_ptr<RenewDesktopOversoldGroupRequest> request);
  RenewDesktopsResponse renewDesktopsWithOptions(shared_ptr<RenewDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewDesktopsResponse renewDesktops(shared_ptr<RenewDesktopsRequest> request);
  RenewNetworkPackagesResponse renewNetworkPackagesWithOptions(shared_ptr<RenewNetworkPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewNetworkPackagesResponse renewNetworkPackages(shared_ptr<RenewNetworkPackagesRequest> request);
  ResetDesktopsResponse resetDesktopsWithOptions(shared_ptr<ResetDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDesktopsResponse resetDesktops(shared_ptr<ResetDesktopsRequest> request);
  ResetNASDefaultMountTargetResponse resetNASDefaultMountTargetWithOptions(shared_ptr<ResetNASDefaultMountTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetNASDefaultMountTargetResponse resetNASDefaultMountTarget(shared_ptr<ResetNASDefaultMountTargetRequest> request);
  ResetSnapshotResponse resetSnapshotWithOptions(shared_ptr<ResetSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetSnapshotResponse resetSnapshot(shared_ptr<ResetSnapshotRequest> request);
  RevokeCoordinatePrivilegeResponse revokeCoordinatePrivilegeWithOptions(shared_ptr<RevokeCoordinatePrivilegeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeCoordinatePrivilegeResponse revokeCoordinatePrivilege(shared_ptr<RevokeCoordinatePrivilegeRequest> request);
  RunCommandResponse runCommandWithOptions(shared_ptr<RunCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCommandResponse runCommand(shared_ptr<RunCommandRequest> request);
  SendVerifyCodeResponse sendVerifyCodeWithOptions(shared_ptr<SendVerifyCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendVerifyCodeResponse sendVerifyCode(shared_ptr<SendVerifyCodeRequest> request);
  SetDesktopGroupScaleTimerResponse setDesktopGroupScaleTimerWithOptions(shared_ptr<SetDesktopGroupScaleTimerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDesktopGroupScaleTimerResponse setDesktopGroupScaleTimer(shared_ptr<SetDesktopGroupScaleTimerRequest> request);
  SetDesktopGroupTimerResponse setDesktopGroupTimerWithOptions(shared_ptr<SetDesktopGroupTimerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDesktopGroupTimerResponse setDesktopGroupTimer(shared_ptr<SetDesktopGroupTimerRequest> request);
  SetDesktopGroupTimerStatusResponse setDesktopGroupTimerStatusWithOptions(shared_ptr<SetDesktopGroupTimerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDesktopGroupTimerStatusResponse setDesktopGroupTimerStatus(shared_ptr<SetDesktopGroupTimerStatusRequest> request);
  SetDesktopMaintenanceResponse setDesktopMaintenanceWithOptions(shared_ptr<SetDesktopMaintenanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDesktopMaintenanceResponse setDesktopMaintenance(shared_ptr<SetDesktopMaintenanceRequest> request);
  SetDirectorySsoStatusResponse setDirectorySsoStatusWithOptions(shared_ptr<SetDirectorySsoStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDirectorySsoStatusResponse setDirectorySsoStatus(shared_ptr<SetDirectorySsoStatusRequest> request);
  SetIdpMetadataResponse setIdpMetadataWithOptions(shared_ptr<SetIdpMetadataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetIdpMetadataResponse setIdpMetadata(shared_ptr<SetIdpMetadataRequest> request);
  SetOfficeSiteSsoStatusResponse setOfficeSiteSsoStatusWithOptions(shared_ptr<SetOfficeSiteSsoStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetOfficeSiteSsoStatusResponse setOfficeSiteSsoStatus(shared_ptr<SetOfficeSiteSsoStatusRequest> request);
  SetUserProfilePathRulesResponse setUserProfilePathRulesWithOptions(shared_ptr<SetUserProfilePathRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetUserProfilePathRulesResponse setUserProfilePathRules(shared_ptr<SetUserProfilePathRulesRequest> request);
  StartDesktopsResponse startDesktopsWithOptions(shared_ptr<StartDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDesktopsResponse startDesktops(shared_ptr<StartDesktopsRequest> request);
  StopDesktopsResponse stopDesktopsWithOptions(shared_ptr<StopDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDesktopsResponse stopDesktops(shared_ptr<StopDesktopsRequest> request);
  StopInvocationResponse stopInvocationWithOptions(shared_ptr<StopInvocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInvocationResponse stopInvocation(shared_ptr<StopInvocationRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnbindConfigGroupResponse unbindConfigGroupWithOptions(shared_ptr<UnbindConfigGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindConfigGroupResponse unbindConfigGroup(shared_ptr<UnbindConfigGroupRequest> request);
  UnbindUserDesktopResponse unbindUserDesktopWithOptions(shared_ptr<UnbindUserDesktopRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindUserDesktopResponse unbindUserDesktop(shared_ptr<UnbindUserDesktopRequest> request);
  UnlockVirtualMFADeviceResponse unlockVirtualMFADeviceWithOptions(shared_ptr<UnlockVirtualMFADeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockVirtualMFADeviceResponse unlockVirtualMFADevice(shared_ptr<UnlockVirtualMFADeviceRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateFotaTaskResponse updateFotaTaskWithOptions(shared_ptr<UpdateFotaTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFotaTaskResponse updateFotaTask(shared_ptr<UpdateFotaTaskRequest> request);
  UploadImageResponse uploadImageWithOptions(shared_ptr<UploadImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadImageResponse uploadImage(shared_ptr<UploadImageRequest> request);
  VerifyCenResponse verifyCenWithOptions(shared_ptr<VerifyCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyCenResponse verifyCen(shared_ptr<VerifyCenRequest> request);
  WakeupDesktopsResponse wakeupDesktopsWithOptions(shared_ptr<WakeupDesktopsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WakeupDesktopsResponse wakeupDesktops(shared_ptr<WakeupDesktopsRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ecd20200930

#endif
